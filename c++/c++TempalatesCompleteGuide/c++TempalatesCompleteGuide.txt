Part I: The Basics

	 Function parameters are the names listed in the function's definition. Function arguments are the real values passed to the function. Parameters are initialized to the values of the arguments supplied

1 Function Templates

1.1    A First Look at Function Templates
	Its family of function. Some elements of function are left to be undetermined.

	1.1.1 Defining the Template

	template<typename T>
	T max(T a, T b)
	{
		// stepanov notes : http://stepanovpapers.com/notes.pdf#page=62
		return b < a ? a : b;
	}

	template function has two types of parameters
	1. template parameter  T 
			- this is "type" template parameter in this case
			- which is most common type of template paramter
			- others are "value", "none type" template parameter
	2. calling parameters a and b.

	You can use keyword "class" for template paramters are it was the only way 
	before c++98 for template type parameters. It may misleads you that it can not be 
	simple intergral types.	But you can not use "struct" instead of typename

	1.1.2 Using the Template
		calling template function with actual arguments "instantiate" function. 
		An instance of function will be generated for every different concrete type. 

	1.1.3 Two-Phase Translation
		If all operations in template function are not supported by the type
		template instantiation will fail for that concrete type

		It is actually two steps process
			1.	Definition Time:
				at template "definition" time template code is checked for language
				syntax, unknown type and function names, static assertions independant
				of template parameters. 
				Basically checks only part that can be determined
			2.	Instantiation Time
				Check if all code is valid 
		
	1.1.4 Compile And Linking
		Normal functions just needs declaration of function signature. 
		Actual function is checked if avaialbe and linked later at link time.
		Template function definition is needed at compile time for instantiation
		i.e checking template code validity for concreate types.


1.2    Template Argument Deduction
	
	template parameters are determined by calling arguments if not explicitely defined
	at call.

	1.2.1 Type Conversions During Type Deduction
		Two rules
		1. for call paramters declared as reference trivial conversions do not apply
		during the type deduction
		2. For call parameters by value, trivial conversion that decay are supported
			a. const, volatile is stripped off
			b. reference type is converted to type it referenced to
			c. arrays and functions are converted to pointers
		3. For two call parameters/call-arguments declared with the same template
			paratmer T, decayed type must match
			i.e. in case of ::max above, ::max(4, 5.3) => must be converted/decayed
			to same type either double or int, otherwise its compile time error
		
			::max(4, 7.2); // error, T can be either int or double
			::max("maths", std::string("maths")); // error, T can be either string or 
										// const char [5]
				
	1.2.2 Fixing Type conversion 
		1. cast calling arguments to match
			::max(static_cast<double>(4), 7.2);
		2. explicitely specify template argument to prevent template type deduction
			by compiler
			::max<double>(4, 7.2)
		3. modify template definition to accept different types as template parameter
			template<typename T1, typename T2> 

	1.2.3 Type deduction for default call arguments

		template<typename T>
		void f(T = "");

		f(1); // Fine
		f(); // compiler cant deduce type for default call argument

		So Specify the default template parameter type for template types on which i
		call arguments with default values are depends.

		template<typename T=std::string>
		void f(T = "");



1.3    Multiple Template Parameters
	If you pass different types call arguments to the ::max function, while returning it will have to convert one of the two arguments to return type
	
	This has three solutions
		1.3.1 Template Parameters for Return Types
		1.3.2 Deducing the Return Type
		1.3.3 Return Type as Common Type

	1.3.1 Template Parameters for Return Types
		Pass return type RT as template parameter. Call with explicitely specifying
		RT as return types can not be deduced. Any template type which does not have
		connection with the calling parameter can not be deduced and must be
		explicitely specified.

	1.3.2 Deducing the Return Type
		Specify auto as return type so compiler will deduce it.

		"auto" with (-> after calling parameters) in C++11
		just "auto" in C++14,
		
		will return the type returned by tertiary opeartor "?:". Tertiary operator 
		returns the most common or intituative type

		c++11: auto max(T1 a, T2 b)->  std::decay<decltype(true?a:b)>::type 
		c++14: auto max(T1 a, T2 b)

		remember "auto" type decays everytime it is used, even in case of return type

	1.3.3 Return Type as Common Type
		you can use c++ construct std::common_type_t<T1, T2> which behaves as 
		decltype(true ?T1 : T2) but also decays automatically.

		ternary operator returns a "more common type" among T1 and T2, but does not
		decay automatically. Ternary oprator is an expression and it does not have
		return type but returns value, common type among T1 and T2.

1.4    Default Template Arguments
		you can have default template arguments
		Third parameter RT could be specified as default value

		template<typename T1, typename T2,
		         typename RT = std::decay_t<decltype(true ? T1() : T2())>>
		RT max(T1, T2);

		template<typename T1, typename T2, typename RT = std::commont_type_t<T1, T2>>
		RT max(T1, T2);

		but, to override default template type, you must specify T1 and T2
		::max<int, int, float>(5,6);

		template<typename RT = std::commont_type_t<T1, T2>, typename T1, typename T2>
		RT max(T1, T2);
		::max<float>(5,6);

		All the type arguments after last type argument with default value must be deducible 
	

1.5    Overloading Function Templates


	
	int max(int a, int b);

	template<typename T>
	T max(T a, T b);

	::max(7, 42);                // calls the nontemplate for two ints 
	::max(7.0, 42.0);            // calls max<double> (by argument deduction)
	::max(’a’, ’b’);              //calls max<char> (by argument deduction)
	::max<>(7, 42);              // calls max<int> (by argument deduction)
	::max<double>(7, 42);        // calls max<double> (no argument deduction)

	automatic type conversion is not considered for the template type deduction
	so nontemplate version
	::max(’a’, 42.7);             //calls the nontemplate for two ints


	Specify return type 
		template<typename T1, typename T2>
		auto max(T1 a, T2 b);

		template<typename RT, typename T1, typename T2>
		RT max(T1 a, T2 b);

		auto a = ::max(4, 7.2);                     // uses first template

		# long double is different than  double
		auto b = ::max<long double>(7.2, 4);        // uses second template
	
		// ERROR: both function templates match
		// ensure only one among overloads matches 
		auto c = ::max<int>(4, 7.2); 



	Dont return references from templates. They might point to dangling reference
	which could be reference to temporary objects

	All versions of the template overloads must be been "declared" before calling 
	template function, otherwise only seen overload is considered for the resolution
	at that point.
	
		template<typename T>
		T max (T a, T b);

		template<typename T>
		T max (T a, T b, T c) { return max(max(a,b), c);} 

		int max (int a, int b);

		 ::max(47,11,33);        // OOPS: uses max<T>() instead of max(int,int)
		

1.6    But, Shouldn’t We …?

	1.6.1 Pass by Value or by Reference?
		Try to avoid references in templates
		The syntax is simple.
		Compilers optimize better.
		Move semantics often makes copies cheap.
		And sometimes there is no copy or move at all.

		 A template might be used for both simple and complex types, so choosing the approach for complex types might be counter-productive for simple types.
		 As a caller you can often still decide to pass arguments by reference, using std::ref() and std::cref() (see Section 7.3 on page 112).

	1.6.2 Why Not inline?
		you may. you define inline and template functions usually in header files. 
		inline means multiple copies of function replaced locally at call location
		inline is hint. compiler are intelligent to make functions inline but 
		specifying inline is taken into consideration for this decision.

	1.6.3 Why Not constexpr?
		template<typename T1, typename T2>
		constexpr auto max (T1 a, T2 b)

1.7    Summary


2. Class Templates

	2.1    Implementation of Class Template Stack

	2.1.1 Declaration of Class Templates
		Like function templates class templates accepts type parmeter. In Stack<T>,
		the template parameter T is required wherever it can not be deduced. Inside
		template class definition, after initial two lines of class declaration,
		Stack represents Stack<T>. But for member function definitions outside class
		you must specify Stack<T>.
			template<typename T>
			void Stack<T>::operator ==(const Stack<T>& other) {}

		Unlike normal classes you can not define templates inside function or block.
		You can define them only at global/namespace level or within other class

	2.1.2 Implementation of Member Functions
		you must specify full class 

	2.2    Use of Class Template Stack
		Code is instantiated only for functions that are called.
		If class has static members then those are instantiated once for each type template
		is instantiated with. You may use const, volatile with instantiated templates. you 
		may use template type in typedef or "using".

				using IntStack = Stack <int>;

		Template types could be of any type, ie pointers, (references?)


	2.3    Partial Usage of Class Templates
		Template only expects operations on the type parameter to be supported,
		which are used in the used or instancetiated functions.

	2.3.1 Concepts
		Concepts are constrains on the template types that are required to instantiate
		successfully. 
		1. Otherwise compilation errors during the member function isntantiation
			are complex, not clear.
		2. Otherway to detect these errors earlier is class level static_asserts which
			will pin point from where Class definition is instantiating.

	2.4    Friends
		You may have friend functions declared/defined inside template class. Defining
		them inside template class is simple. But declaring them inside and defining outside
		is trickier.

		1. Normal friend declaration as non-template function
			template <typename T>
			struct Stack
			{
				friend std::cout operator << (std::cout stream, const Stack<T>& );
			};
	
			You must define the function outside for per instance of template type T i.e. Stack<T>
			created.

		2. Approach 2 : Declare generic template friend function
				1. Using type parameter U : this does not shadows original parameter
				2. you must use Stack<U> as function calling parameter to refer stack

			template <typename T>
			struct Stack
			{
				template<typename U>
				friend std::cout operator << (std::cout stream, const Stack<U>& );
			};

			template<typename T>
			std::cout operator << (std::cout stream, const Stack<T>& ) {}

		3. Approach 3: Forward declare friend template function, but instantiated within class.

			template <typename T>
			struct Stack;
			template <typename T>
			std::cout operator << (std::cout stream, const Stack<T>& );

			template <typename T>
			struct Stack
			{
				// See how it is instantiated for type T
				friend std::cout operator << <T>(std::cout stream, const Stack& );
			};


	2.5    Specializations of Class Templates 

			Specilizing individual member functions
				It is possible to specialize single member function for a particular type parameter to 
				template class.	This will cause template class instantition for that type.

				But once you specialize single member function outside of template class declaration for a type
				parameter to template class, then you can not fully specialize template class for that type.

			Full Specializing whole template class
				template <>
				struct Stack<std::string> {};
	
			Specilization full or partial might provide slight different interface and implementation

	2.6    Partial Specialization
			1. You can specilize stack for the pointer type.

				template <typename T>
				struct Stack<T*> {};
			
			2. Partial specializing with multiple type parameter
				
				template <typename T1, typename T2>
				struct MyClass{};
				
				template <typename T>
				struct MyClass<T, T>{};

				template <typename T>
				struct MyClass<T, int>{};

				template <typename T1, typename T2>
				struct MyClass<T1*, T2*>{};

				MyClass<int, float> mif; // MyClass<T1, T2>
				MyClass<float, float> mff; // MyClass<T, T>
				MyClass<float, int> mfi; // MyClass<T, int>
				MyClass<int*, Float*> mif; // MyClass<T1*, T2*>

				MyClass<int, int> mii; // Error, Ambibuity MyClass<T,T> or MyClass<T, int>
				MyClass<int*, int*> mii; // Error, Ambibuity MyClass<T,T> or MyClass<T1*, T2*>

				To resolve this provide additional partial specialization for exact match

				// full specialization
				template <>
				struct MyClass<int, int>{};

				template <typename T>
				struct MyClass<T*, T*>{};
			
	2.7    Default Class Template Arguments
			Class can accept the default template type parameter
			template<typename T, typename Container=std::vector<T>>
			class Stack	{};

			template<typename T, typename Container>
			void Stack<T,Container>::top (T const&)  {}

	2.8    Type Aliases
			There are two ways to declare type aliases
			1> typedef
				typedef Stack<int, std::vector<int>> IntStack;
			2> using 
				using IntStack = Stack<int, std::vector<int>>;

			But you can declar  

	2.9    Class Template Argument Deduction
			Until c++17 you always had to specify the template parameters. Now it is relaxed in
			c++17. Template parameters could be deduced automatically from
			1> Copy assignment constructor
				Stack<int> i1;
				Stack i2 = i1; // since c++17 ok, i2 is Stack<int>				

			2> Argument deduction from constructor arguments 
				template<typename T>
				Stack<T>::Stack(const T& element) {}

				Stack i1 = 1; // Stack<int> deduced since c++17

			3> Class Template Arguments Deduction with String Literals
				a.	if constructor accepts argument by reference, no decay happens
					and T is deduced as const char[7] rather than as const char*
					Stack stringStack = "bottom";  // T is const char[7]
				b.	But if you pass T as value to constructor then decay happens
					Stack stringStack = "bottom";  // T is const char*

			4> Deduction Guide:
			
				Stack stringStack{"bottom"};  // Stack<const char[7]> deduced
				
				But below is not valid, because, when using one argument constructor to copy
				initialize(initialize using = at variable definition time), you can not pass
				const char[7] where constructor expects std::string

					Stack stringStack = "bottom";  // Stack<std::string> deduced, but still not valid

				Also dealing with raw c strings pointers is dangerous. We can force to
				deduce the raw c string pointers to deduce std::string as template type
				parameter by using "deduction guide" which works more like trailing/auto
				return types

					Stack( char const*) -> Stack<std::string>;

				If you specify this at the end of Stack template definition, in the same
				namespace as of stack, then  

				Stack stringStack{"bottom"};  // Stack<std::string> deduced

				Using copy constructor to intialize the template class copies the template type
				deductions i.e its exactly same type that is of source object
		
	2.10   Templatized Aggregates
				It could be that template aggregate classes/structs (no custom/inherited const
				, private/protected static data, no virt func, no virt, private/protected class)
				can be template.
				
				template<typename T>
				struct ValueWithComment
				{
					T value;
					std::string comment;
				};

				ValueWithComment< int> vc; // valid
				[vc.val, vc.comment] = [42, "initial value"]

				You may define type deduction guide for the aggregate types since c++17
				ValueWithComment vc{"hello", "initial value" }; // valid

	2.11   Summary


3 Nontype Template Parameters
		type and non-type parameters remain open until class is not instantiated or function is not used
		or called.

3.1    Nontype Class Template Parameters
		It could be int or another integral, pointer to object, member, function or lamda could be 
		parameter to template class.

3.2    Nontype Function Template Parameters
		Simialar to class function templates accept value as template parameter. Could be used to pass 
		function as parameter. Below, addValue parameter types are deduced when used. Function template
		deduction works only for immidiate calls. There is no such thing that only half of the parameters
		are deduced and remaining will be deduced as they fit at the time of call

		std::transform(s.begin(), s.end(), d.begin(), addValue<5, int>)


3.3    Restrictions for Nontype Template Parameters
		Floting point or class type objects cant be template parameter
		When passing pointer or references you can not pass string literals, temporories or data members
		or other sub-objects

		template<double VAT>         // ERROR: floating-point values are not
		double process (double v)    //        allowed as template parameters

		template<std::string name>   // ERROR: class-type objects are not
		class MyClass {              //        allowed as template parameters

		MyClass<"hello"> x;  //ERROR: string literal "hello" not allowed

		Template argyment expression could be constexpr.
		
		template<int I, bool B>
		class C;
		C<sizeof(int) + 4, sizeof(int)==4> c;

		If you want to use > anywhere in the template argumend, put it inside parenthesis, so compiler does
		not complain about syntax ambiguity

		C<42, sizeof(int) > 4> c;    // ERROR: first > ends the template argument list
		C<42, (sizeof(int) > 4)> c;  // OK

3.4    Template Parameter Type auto
		With c++17, you can define non type template parameter to generally accept any types value argument
		that is allowed forthe non type parameter.

		template<typename T, auto Maxsize>
		Stack
		{
			using sizetype = decltype(Maxsize);
			sizetype numElements;

			auto size()
			{
				return numElements;
			}
		};

		auto s1 = Stack<int, 20u>().size();
		auto s2 = Stack<int, 20>().size();
		
		assert(std::is_same_v(decltype(s1), decltype(s2))); // Fails, usigned int == int

		Remember that constrains on what could be non-type parameter/argument remains applicable
		Stack<int,3.14> sd;        // ERROR: Floating-point nontype argument

		Note that, template<decltype(auto) N> is possible, which does instantiation of N as reference


		template<decltype(auto) N>
		class C {};
		int i;
		C<(i)> x; // N is int&


3.5    Summary



Part I: The Basics

	 Function parameters are the names listed in the function's definition. Function arguments are the real values passed to the function. Parameters are initialized to the values of the arguments supplied

1 Function Templates

1.1    A First Look at Function Templates
	Its family of function. Some elements of function are left to be undetermined.

	1.1.1 Defining the Template

	template<typename T>
	T max(T a, T b)
	{
		// stepanov notes : http://stepanovpapers.com/notes.pdf#page=62
		return b < a ? a : b;
	}

	template function has two types of parameters
	1. template parameter  T 
			- this is "type" template parameter in this case
			- which is most common type of template paramter
			- others are "value", "none type" template parameter
	2. calling parameters a and b.

	You can use keyword "class" for template paramters are it was the only way 
	before c++98 for template type parameters. It may misleads you that it can not be 
	simple intergral types.	But you can not use "struct" instead of typename

	1.1.2 Using the Template
		calling template function with actual arguments "instantiate" function. 
		An instance of function will be generated for every different concrete type. 

	1.1.3 Two-Phase Translation
		If all operations in template function are not supported by the type
		template instantiation will fail for that concrete type

		It is actually two steps process
			1.	Definition Time:
				at template "definition" time template code is checked for language
				syntax, unknown type and function names, static assertions independant
				of template parameters. 
				Basically checks only part that can be determined
			2.	Instantiation Time
				Check if all code is valid 
		
	1.1.4 Compile And Linking
		Normal functions just needs declaration of function signature. 
		Actual function is checked if avaialbe and linked later at link time.
		Template function definition is needed at compile time for instantiation
		i.e checking template code validity for concreate types.


1.2    Template Argument Deduction
	
	template parameters are determined by calling arguments if not explicitely defined
	at call.

	1.2.1 Type Conversions During Type Deduction
		Two rules
		1. for call paramters declared as reference trivial conversions do not apply
		during the type deduction
		2. For call parameters by value, trivial conversion that decay are supported
			a. const, volatile is stripped off
			b. reference type is converted to type it referenced to
			c. arrays and functions are converted to pointers
		3. For two call parameters/call-arguments declared with the same template
			paratmer T, decayed type must match
			i.e. in case of ::max above, ::max(4, 5.3) => must be converted/decayed
			to same type either double or int, otherwise its compile time error
		
			::max(4, 7.2); // error, T can be either int or double
			::max("maths", std::string("maths")); // error, T can be either string or 
										// const char [5]
				
	1.2.2 Fixing Type conversion 
		1. cast calling arguments to match
			::max(static_cast<double>(4), 7.2);
		2. explicitely specify template argument to prevent template type deduction
			by compiler
			::max<double>(4, 7.2)
		3. modify template definition to accept different types as template parameter
			template<typename T1, typename T2> 

	1.2.3 Type deduction for default call arguments

		template<typename T>
		void f(T = "");

		f(1); // Fine
		f(); // compiler cant deduce type for default call argument

		So Specify the default template parameter type for template types on which i
		call arguments with default values are depends.

		template<typename T=std::string>
		void f(T = "");



1.3    Multiple Template Parameters
	If you pass different types call arguments to the ::max function, while returning it will have to convert one of the two arguments to return type
	
	This has three solutions
		1.3.1 Template Parameters for Return Types
		1.3.2 Deducing the Return Type
		1.3.3 Return Type as Common Type

	1.3.1 Template Parameters for Return Types
		Pass return type RT as template parameter. Call with explicitely specifying
		RT as return types can not be deduced. Any template type which does not have
		connection with the calling parameter can not be deduced and must be
		explicitely specified.

	1.3.2 Deducing the Return Type
		Specify auto as return type so compiler will deduce it.

		"auto" with (-> after calling parameters) in C++11
		just "auto" in C++14,
		
		will return the type returned by tertiary opeartor "?:". Tertiary operator 
		returns the most common or intituative type

		c++11: auto max(T1 a, T2 b)->  std::decay<decltype(true?a:b)>::type 
		c++14: auto max(T1 a, T2 b)

		remember "auto" type decays everytime it is used, even in case of return type

	1.3.3 Return Type as Common Type
		you can use c++ construct std::common_type_t<T1, T2> which behaves as 
		decltype(true ?T1 : T2) but also decays automatically.

		ternary operator returns a "more common type" among T1 and T2, but does not
		decay automatically. Ternary oprator is an expression and it does not have
		return type but returns value.

1.4    Default Template Arguments

1.5    Overloading Function Templates

1.6    But, Shouldn’t We …?

	1.6.1 Pass by Value or by Reference?

	1.6.2 Why Not inline?

	1.6.3 Why Not constexpr?

1.7    Summary



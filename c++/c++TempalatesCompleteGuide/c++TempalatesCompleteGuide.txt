Part I: The Basics

	 Function parameters are the names listed in the function's definition. Function arguments are the real values passed to the function. Parameters are initialized to the values of the arguments supplied

1 Function Templates

1.1    A First Look at Function Templates
	Its family of function. Some elements of function are left to be undetermined.

	1.1.1 Defining the Template

	template<typename T>
	T max(T a, T b)
	{
		// stepanov notes : http://stepanovpapers.com/notes.pdf#page=62
		return b < a ? a : b;
	}

	template function has two types of parameters
	1. template parameter  T 
			- this is "type" template parameter in this case
			- which is most common type of template paramter
			- others are "value", "none type" template parameter
	2. calling parameters a and b.

	You can use keyword "class" for template paramters are it was the only way 
	before c++98 for template type parameters. It may misleads you that it can not be 
	simple intergral types.	But you can not use "struct" instead of typename

	1.1.2 Using the Template
		calling template function with actual arguments "instantiate" function. 
		An instance of function will be generated for every different concrete type. 

	1.1.3 Two-Phase Translation
		If all operations in template function are not supported by the type
		template instantiation will fail for that concrete type

		It is actually two steps process
			1.	Definition Time:
				at template "definition" time template code is checked for language
				syntax, unknown type and function names, static assertions independant
				of template parameters. 
				Basically checks only part that can be determined
			2.	Instantiation Time
				Check if all code is valid 
		
	1.1.4 Compile And Linking
		Normal functions just needs declaration of function signature. 
		Actual function is checked if avaialbe and linked later at link time.
		Template function definition is needed at compile time for instantiation
		i.e checking template code validity for concreate types.


1.2    Template Argument Deduction
	
	template parameters are determined by calling arguments if not explicitely defined
	at call.

	1.2.1 Type Conversions During Type Deduction
		Two rules
		1. for call paramters declared as reference trivial conversions do not apply
		during the type deduction
		2. For call parameters by value, trivial conversion that decay are supported
			a. const, volatile is stripped off
			b. reference type is converted to type it referenced to
			c. arrays and functions are converted to pointers
		3. For two call parameters/call-arguments declared with the same template
			paratmer T, decayed type must match
			i.e. in case of ::max above, ::max(4, 5.3) => must be converted/decayed
			to same type either double or int, otherwise its compile time error
		
			::max(4, 7.2); // error, T can be either int or double
			::max("maths", std::string("maths")); // error, T can be either string or 
										// const char [5]
				
	1.2.2 Fixing Type conversion 
		1. cast calling arguments to match
			::max(static_cast<double>(4), 7.2);
		2. explicitely specify template argument to prevent template type deduction
			by compiler
			::max<double>(4, 7.2)
		3. modify template definition to accept different types as template parameter
			template<typename T1, typename T2> 

	1.2.3 Type deduction for default call arguments

		template<typename T>
		void f(T = "");

		f(1); // Fine
		f(); // compiler cant deduce type for default call argument

		So Specify the default template parameter type for template types on which i
		call arguments with default values are depends.

		template<typename T=std::string>
		void f(T = "");



1.3    Multiple Template Parameters
	If you pass different types call arguments to the ::max function, while returning it will have to convert one of the two arguments to return type
	
	This has three solutions
		1.3.1 Template Parameters for Return Types
		1.3.2 Deducing the Return Type
		1.3.3 Return Type as Common Type

	1.3.1 Template Parameters for Return Types
		Pass return type RT as template parameter. Call with explicitely specifying
		RT as return types can not be deduced. Any template type which does not have
		connection with the calling parameter can not be deduced and must be
		explicitely specified.

	1.3.2 Deducing the Return Type
		Specify auto as return type so compiler will deduce it.

		"auto" with (-> after calling parameters) in C++11
		just "auto" in C++14,
		
		will return the type returned by tertiary opeartor "?:". Tertiary operator 
		returns the most common or intituative type

		c++11: auto max(T1 a, T2 b)->  std::decay<decltype(true?a:b)>::type 
		c++14: auto max(T1 a, T2 b)

		remember "auto" type decays everytime it is used, even in case of return type

	1.3.3 Return Type as Common Type
		you can use c++ construct std::common_type_t<T1, T2> which behaves as 
		decltype(true ?T1 : T2) but also decays automatically.

		ternary operator returns a "more common type" among T1 and T2, but does not
		decay automatically. Ternary oprator is an expression and it does not have
		return type but returns value, common type among T1 and T2.

1.4    Default Template Arguments
		you can have default template arguments
		Third parameter RT could be specified as default value

		template<typename T1, typename T2,
		         typename RT = std::decay_t<decltype(true ? T1() : T2())>>
		RT max(T1, T2);

		template<typename T1, typename T2, typename RT = std::commont_type_t<T1, T2>>
		RT max(T1, T2);

		but, to override default template type, you must specify T1 and T2
		::max<int, int, float>(5,6);

		template<typename RT = std::commont_type_t<T1, T2>, typename T1, typename T2>
		RT max(T1, T2);
		::max<float>(5,6);

		All the type arguments after last type argument with default value must be deducible 
	

1.5    Overloading Function Templates


	
	int max(int a, int b);

	template<typename T>
	T max(T a, T b);

	::max(7, 42);                // calls the nontemplate for two ints 
	::max(7.0, 42.0);            // calls max<double> (by argument deduction)
	::max(’a’, ’b’);              //calls max<char> (by argument deduction)
	::max<>(7, 42);              // calls max<int> (by argument deduction)
	::max<double>(7, 42);        // calls max<double> (no argument deduction)

	automatic type conversion is not considered for the template type deduction
	so nontemplate version
	::max(’a’, 42.7);             //calls the nontemplate for two ints


	Specify return type 
		template<typename T1, typename T2>
		auto max(T1 a, T2 b);

		template<typename RT, typename T1, typename T2>
		RT max(T1 a, T2 b);

		auto a = ::max(4, 7.2);                     // uses first template

		# long double is different than  double
		auto b = ::max<long double>(7.2, 4);        // uses second template
	
		// ERROR: both function templates match
		// ensure only one among overloads matches 
		auto c = ::max<int>(4, 7.2); 



	Dont return references from templates. They might point to dangling reference
	which could be reference to temporary objects

	All versions of the template overloads must be been "declared" before calling 
	template function, otherwise only seen overload is considered for the resolution
	at that point.
	
		template<typename T>
		T max (T a, T b);

		template<typename T>
		T max (T a, T b, T c) { return max(max(a,b), c);} 

		int max (int a, int b);

		 ::max(47,11,33);        // OOPS: uses max<T>() instead of max(int,int)
		

1.6    But, Shouldn’t We …?

	1.6.1 Pass by Value or by Reference?
		Try to avoid references in templates
		The syntax is simple.
		Compilers optimize better.
		Move semantics often makes copies cheap.
		And sometimes there is no copy or move at all.

		 A template might be used for both simple and complex types, so choosing the approach for complex types might be counter-productive for simple types.
		 As a caller you can often still decide to pass arguments by reference, using std::ref() and std::cref() (see Section 7.3 on page 112).

	1.6.2 Why Not inline?
		you may. you define inline and template functions usually in header files. 
		inline means multiple copies of function replaced locally at call location
		inline is hint. compiler are intelligent to make functions inline but 
		specifying inline is taken into consideration for this decision.

	1.6.3 Why Not constexpr?
		template<typename T1, typename T2>
		constexpr auto max (T1 a, T2 b)

1.7    Summary


2. Class Templates

	2.1    Implementation of Class Template Stack

	2.1.1 Declaration of Class Templates
		Like function templates class templates accepts type parmeter. In Stack<T>,
		the template parameter T is required wherever it can not be deduced. Inside
		template class definition, after initial two lines of class declaration,
		Stack represents Stack<T>. But for member function definitions outside class
		you must specify Stack<T>.
			template<typename T>
			void Stack<T>::operator ==(const Stack<T>& other) {}

		Unlike normal classes you can not define templates inside function or block.
		You can define them only at global/namespace level or within other class

	2.1.2 Implementation of Member Functions
		you must specify full class 

	2.2    Use of Class Template Stack
		Code is instantiated only for functions that are called.
		If class has static members then those are instantiated once for each type template
		is instantiated with. You may use const, volatile with instantiated templates. you 
		may use template type in typedef or "using".

				using IntStack = Stack <int>;

		Template types could be of any type, ie pointers, (references?)


	2.3    Partial Usage of Class Templates
		Template only expects operations on the type parameter to be supported,
		which are used in the used or instancetiated functions.

	2.3.1 Concepts
		Concepts are constrains on the template types that are required to instantiate
		successfully. 
		1. Otherwise compilation errors during the member function isntantiation
			are complex, not clear.
		2. Otherway to detect these errors earlier is class level static_asserts which
			will pin point from where Class definition is instantiating.

	2.4    Friends
		You may have friend functions declared/defined inside template class. Defining
		them inside template class is simple. But declaring them inside and defining outside
		is trickier.

		1. Normal friend declaration as non-template function
			template <typename T>
			struct Stack
			{
				friend std::cout operator << (std::cout stream, const Stack<T>& );
			};
	
			You must define the function outside for per instance of template type T i.e. Stack<T>
			created.

		2. Approach 2 : Declare generic template friend function
				1. Using type parameter U : this does not shadows original parameter
				2. you must use Stack<U> as function calling parameter to refer stack

			template <typename T>
			struct Stack
			{
				template<typename U>
				friend std::cout operator << (std::cout stream, const Stack<U>& );
			};

			template<typename T>
			std::cout operator << (std::cout stream, const Stack<T>& ) {}

		3. Approach 3: Forward declare friend template function, but instantiated within class.

			template <typename T>
			struct Stack;
			template <typename T>
			std::cout operator << (std::cout stream, const Stack<T>& );

			template <typename T>
			struct Stack
			{
				// See how it is instantiated for type T
				friend std::cout operator << <T>(std::cout stream, const Stack& );
			};


	2.5    Specializations of Class Templates 

			Specilizing individual member functions
				It is possible to specialize single member function for a particular type parameter to 
				template class.	This will cause template class instantition for that type.

				But once you specialize single member function outside of template class declaration for a type
				parameter to template class, then you can not fully specialize template class for that type.

			Full Specializing whole template class
				template <>
				struct Stack<std::string> {};
	
			Specilization full or partial might provide slight different interface and implementation

	2.6    Partial Specialization
			1. You can specilize stack for the pointer type.

				template <typename T>
				struct Stack<T*> {};
			
			2. Partial specializing with multiple type parameter
				
				template <typename T1, typename T2>
				struct MyClass{};
				
				template <typename T>
				struct MyClass<T, T>{};

				template <typename T>
				struct MyClass<T, int>{};

				template <typename T1, typename T2>
				struct MyClass<T1*, T2*>{};

				MyClass<int, float> mif; // MyClass<T1, T2>
				MyClass<float, float> mff; // MyClass<T, T>
				MyClass<float, int> mfi; // MyClass<T, int>
				MyClass<int*, Float*> mif; // MyClass<T1*, T2*>

				MyClass<int, int> mii; // Error, Ambibuity MyClass<T,T> or MyClass<T, int>
				MyClass<int*, int*> mii; // Error, Ambibuity MyClass<T,T> or MyClass<T1*, T2*>

				To resolve this provide additional partial specialization for exact match

				// full specialization
				template <>
				struct MyClass<int, int>{};

				template <typename T>
				struct MyClass<T*, T*>{};
			
	2.7    Default Class Template Arguments
			Class can accept the default template type parameter
			template<typename T, typename Container=std::vector<T>>
			class Stack	{};

			template<typename T, typename Container>
			void Stack<T,Container>::top (T const&)  {}

	2.8    Type Aliases
			There are two ways to declare type aliases
			1> typedef
				typedef Stack<int, std::vector<int>> IntStack;
			2> using 
				using IntStack = Stack<int, std::vector<int>>;

			But you can declar  

	2.9    Class Template Argument Deduction
			Until c++17 you always had to specify the template parameters. Now it is relaxed in
			c++17. Template parameters could be deduced automatically from
			1> Copy assignment constructor
				Stack<int> i1;
				Stack i2 = i1; // since c++17 ok, i2 is Stack<int>				

			2> Argument deduction from constructor arguments 
				template<typename T>
				Stack<T>::Stack(const T& element) {}

				Stack i1 = 1; // Stack<int> deduced since c++17

			3> Class Template Arguments Deduction with String Literals
				a.	if constructor accepts argument by reference, no decay happens
					and T is deduced as const char[7] rather than as const char*
					Stack stringStack = "bottom";  // T is const char[7]
				b.	But if you pass T as value to constructor then decay happens
					Stack stringStack = "bottom";  // T is const char*

			4> Deduction Guide:
			
				Stack stringStack{"bottom"};  // Stack<const char[7]> deduced
				
				But below is not valid, because, when using one argument constructor to copy
				initialize(initialize using = at variable definition time), you can not pass
				const char[7] where constructor expects std::string

					Stack stringStack = "bottom";  // Stack<std::string> deduced, but still not valid

				Also dealing with raw c strings pointers is dangerous. We can force to
				deduce the raw c string pointers to deduce std::string as template type
				parameter by using "deduction guide" which works more like trailing/auto
				return types

					Stack( char const*) -> Stack<std::string>;

				If you specify this at the end of Stack template definition, in the same
				namespace as of stack, then  

				Stack stringStack{"bottom"};  // Stack<std::string> deduced

				Using copy constructor to intialize the template class copies the template type
				deductions i.e its exactly same type that is of source object
		
	2.10   Templatized Aggregates
				It could be that template aggregate classes/structs (no custom/inherited const
				, private/protected static data, no virt func, no virt, private/protected class)
				can be template.
				
				template<typename T>
				struct ValueWithComment
				{
					T value;
					std::string comment;
				};

				ValueWithComment< int> vc; // valid
				[vc.val, vc.comment] = [42, "initial value"]

				You may define type deduction guide for the aggregate types since c++17
				ValueWithComment vc{"hello", "initial value" }; // valid

	2.11   Summary


3 Nontype Template Parameters
		type and non-type parameters remain open until class is not instantiated or function is not used
		or called.

3.1    Nontype Class Template Parameters
		It could be int or another integral, pointer to object, member, function or lamda could be 
		parameter to template class.

3.2    Nontype Function Template Parameters
		Simialar to class function templates accept value as template parameter. Could be used to pass 
		function as parameter. Below, addValue parameter types are deduced when used. Function template
		deduction works only for immidiate calls. There is no such thing that only half of the parameters
		are deduced and remaining will be deduced as they fit at the time of call

		std::transform(s.begin(), s.end(), d.begin(), addValue<5, int>)


3.3    Restrictions for Nontype Template Parameters
		Floting point or class type objects cant be template parameter
		When passing pointer or references you can not pass string literals, temporories or data members
		or other sub-objects

		template<double VAT>         // ERROR: floating-point values are not
		double process (double v)    //        allowed as template parameters

		template<std::string name>   // ERROR: class-type objects are not
		class MyClass {              //        allowed as template parameters

		MyClass<"hello"> x;  //ERROR: string literal "hello" not allowed

		Template argyment expression could be constexpr.
		
		template<int I, bool B>
		class C;
		C<sizeof(int) + 4, sizeof(int)==4> c;

		If you want to use > anywhere in the template argumend, put it inside parenthesis, so compiler does
		not complain about syntax ambiguity

		C<42, sizeof(int) > 4> c;    // ERROR: first > ends the template argument list
		C<42, (sizeof(int) > 4)> c;  // OK

3.4    Template Parameter Type auto
		With c++17, you can define non type template parameter to generally accept any types value argument
		that is allowed forthe non type parameter.

		template<typename T, auto Maxsize>
		Stack
		{
			using sizetype = decltype(Maxsize);
			sizetype numElements;

			auto size()
			{
				return numElements;
			}
		};

		auto s1 = Stack<int, 20u>().size();
		auto s2 = Stack<int, 20>().size();
		
		assert(std::is_same_v(decltype(s1), decltype(s2))); // Fails, usigned int == int

		Remember that constrains on what could be non-type parameter/argument remains applicable
		Stack<int,3.14> sd;        // ERROR: Floating-point nontype argument

		Note that, template<decltype(auto) N> is possible, which does instantiation of N as reference


		template<decltype(auto) N>
		class C {};
		int i;
		C<(i)> x; // N is int&


3.5    Summary

5 Tricky Basics

5.1    Keyword typename
		In ambigous example 
		T::SubType* ptr;
		If it is to be compiled as multiplication of static member T::SubType and ptr, where does ptr
		could be declared is not specified

5.2    Zero Initialization

5.3    Using this->
		Not mentioning if base class is not dependant on T, then does inherited member 'x' could be 
		simply referred as 'x' or have to have use 'this->x' ?

5.4    Templates for Raw Arrays and String Literals

5.5    Member Templates
		class template might have member function as template function
		such as operator= which helps to copy the elements from another Stack<T2> into Stack<T1>.

		remember Stack<T2> and Stack<T1> are different types so none of them can access private
		members such as container used to store stack.

		So operator= must use only public inteface of stack to copy the elements

		template<typename T>
		class Stack
		{
			...
			public:
			...

			template<typename T2>
			Stack operator=(Stack<T2> const&);
		}

		template<T>
			template<T2>
		Stack<T> Stack<T>::opeartor=(Stack<T2> const& )
		{
			...
		}

		To access private members of the Stack<T2> you can declare all stack instances to be friend
		of each other

		template<typename T>
		class Stack
		{
			template<typename> 
			friend class Stack;
		}

		You can also templatize the container as parameter to stack

		template<typename T, typename C=std::deque<T>>
		class Stack
		{
			template<typename T2, typename C2>
			Stack operator=(Stack<T2, C2> const&);

			template<typename, typename> 
			friend class Stack;
		}
	
		But remember template class member functions are only instantiated if they are used. So if any
		method/operation on the particular deduced type T, C, T2, C2 is used in member function but
		if that member function itself is not called then it does not instantiate and no compiler error
		is reported

			
5.4.1 Specialization of Member Function Templates
		We can fully specialize the member templates. But all the template definitions are in the header files so
		that they could be instantiated.

		Full specialization of the template class does not need declaration not tou can declare if function
		template has a any full specialization.

		So in order to define the full specilization of member function template and which could be used by
		the all translation units, define them in the header files.

		But each translation unit might create its own copy of the full specialized template. This will cause
		linker error. To avoid this you can declare full specialization of the template as inline

		class BoolString
		{
			std::string v;
			public:
			template<typename T>
			T get() {return v;}
		}

		template<>
		T BoolString::get<bool>() {return v == "1" || v== "true" || v == "on";}

5.4.2 Special Member Function Templates
		Class provides default member functions copy,move construtors, assigment operators. You may define them
		as template member function accepting different template class instance of similar type.
		ie. 
		
		template<typename T2>
		Stack(Stack<T2> const&); // Copy constructor for Stack<T1> accepting Stack<T2>

		However remember, these template special members are not really special member functions and default
		provided special member functions are still there for Stack<T1>.

		1. It might happen that these overloaded template might be better fit than the compiler provided special
		member funcitons
		2. its difficult to write template move,copy constructors with constraints on its existences


5.5.1 The .template Construct
		in order to explicitely call specefic instance of the member template function, you will have to 
		use .template construct, otherwise template parameter pack starting '<' could be confused by 
		compiler with 'less than < operator'

		instance.template doSomething<int, float>(4, 7.2);

5.5.2 Generic Lambdas and Member Templates
		generic lamda in C++14 are shortcuts for member templates
	
		[] (x, y) { return x+y;}

		class GenLamCompilerSpecName {
			GenLamCompilerSpecName(); // only callable by compiler

			template<typename T1, typename T2>
			auto operator()(T1 x, T2 y) const {return x+y;}
		}


5.6    Variable Templates
		With C++17 you can declare variable templates, at same scope of template classes
		ie. not in block nor at function scope
		
		template<typename T = float>
		constexpr T pi = {3.142723232};

		And can use like below in diff translational units, which refers to same global variable
		instance. You may have default template parameter types.

		std::cout << pi<double> << std::endl;
		std::cout << pi<long double> << std::endl;
		std::cout << pi << std::endl; // ERROR

		So if you have an std::array variable in diff translation unit, it will refer to same global
		variable even if you initialize it multiple times.

		you may have non type template parameters ie. int for size,
		template<int N>
		std::array<int, N> arr{}; // Value Zero initialization

		template<auto N> // auto type depends upon what has been passed
		constexpr decltype(N) dval = N;

		std::cout << dval<'c'> << std::endl;


	5.6.1 variable Types as data members

		template<typename T>
		struct MyClass
		{
			static constexpr T veryLongName = 10000;
		};

		template<typename T>	
		T shortName = MyClass<T>::veryLongName;
		
		template<typename T> class numeric_limits		
		{
			auto is_signed = false;
		};

		template<typename T>
		constexpr bool isSigned = numeric_limits<T>::is_signed;

	5.6.2 type traits suffic_v
		
		template<typename T>
		constexpr bool is_const_v = is_const<T>::value;

5.7    Template Template Parameters TTP
		
		you might want to pass the another template class(without actual template parameter types pack)
		as stand alone type to new template.


		Befor C++17, you could use only keyword 'class' for template template parameter
		as well, TTP must match all of its parameter pack including default types
		
		//Elem is optional and could be just given for documentation purpose
		// template<typename T, template<typename Elem, typename Alloc> class Container = std::deque> // Pre-C++17
		// template<typename T, template<typename Elem, typename Alloc = std::allocator<Elem>> class Container = std::deque> // Pre-C++17
		template<typename T, template<typename Elem> typename Container = std::deque> // C++17
		class Stack
		{
			Container<T> data;
		}

		After c++11 we can substiute the TTP with template alias names as well.

		Now the operator= looks like below
		template<typename T, typename<typename, typename> typename C>
			template<typename T2, typename<typename, typename> typename C2>
		Stack<T, C>& Stack<T,C>::opeartor=(const Stack<T2, C2>& s2){}




5.8    Summary

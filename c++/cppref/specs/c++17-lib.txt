std::variant
	can have same types,
	can provide same type with diff cv qualification

	default contr of 1st element

	all types are allocated within std::variant
	no dynamic allocation

	better than union can tell you which type is stored

	index
	std::get<int or index> : throws error if type or index is not stored
	std::get_if<int>  : returns pointer

	std::variant_size
	std::holds_alternative<T>(v); 
	std::variant_alternative

std::optional
	default contr of 1st element

	all types are allocated within std::optional
	no dynamic allocation

	throws bad optional access if optional is not set
	*x 
	x.value()
	if (x) // is bool(x) or x.has_value()

std::any
	std::any x;
	x = 5;
	x = 5.5;
	x.has_value()
	std::any_cast<std::string>(&x)
	x.emplace()
	make_any(4);
	int x = std::any_cast<int>(x);

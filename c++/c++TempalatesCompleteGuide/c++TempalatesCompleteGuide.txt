Part I: The Basics

	 Function parameters are the names listed in the function's definition. Function arguments are the real values passed to the function. Parameters are initialized to the values of the arguments supplied

1 Function Templates

1.1    A First Look at Function Templates
	Its family of function. Some elements of function are left to be undetermined.

	1.1.1 Defining the Template

	template<typename T>
	T max(T a, T b)
	{
		// stepanov notes : http://stepanovpapers.com/notes.pdf#page=62
		return b < a ? a : b;
	}

	template function has two types of parameters
	1. template parameter  T 
			- this is "type" template parameter in this case
			- which is most common type of template paramter
			- others are "value", "none type" template parameter
	2. calling parameters a and b.

	You can use keyword "class" for template paramters are it was the only way 
	before c++98 for template type parameters. It may misleads you that it can not be 
	simple intergral types.	But you can not use "struct" instead of typename

	1.1.2 Using the Template
		calling template function with actual arguments "instantiate" function. 
		An instance of function will be generated for every different concrete type. 

	1.1.3 Two-Phase Translation
		If all operations in template function are not supported by the type
		template instantiation will fail for that concrete type

		It is actually two steps process
			1.	Definition Time:
				at template "definition" time template code is checked for language
				syntax, unknown type and function names, static assertions independant
				of template parameters. 
				Basically checks only part that can be determined
			2.	Instantiation Time
				Check if all code is valid 
		
	1.1.4 Compile And Linking
		Normal functions just needs declaration of function signature. 
		Actual function is checked if avaialbe and linked later at link time.
		Template function definition is needed at compile time for instantiation
		i.e checking template code validity for concreate types.


1.2    Template Argument Deduction
	
	template parameters are determined by calling arguments if not explicitely defined
	at call.

	1.2.1 Type Conversions During Type Deduction
		Two rules
		1. for call paramters declared as reference trivial conversions do not apply
		during the type deduction
		2. For call parameters by value, trivial conversion that decay are supported
			a. const, volatile is stripped off
			b. reference type is converted to type it referenced to
			c. arrays and functions are converted to pointers
		3. For two call parameters/call-arguments declared with the same template
			paratmer T, decayed type must match
			i.e. in case of ::max above, ::max(4, 5.3) => must be converted/decayed
			to same type either double or int, otherwise its compile time error
		
			::max(4, 7.2); // error, T can be either int or double
			::max("maths", std::string("maths")); // error, T can be either string or 
										// const char [5]
				
	1.2.2 Fixing Type conversion 
		1. cast calling arguments to match
			::max(static_cast<double>(4), 7.2);
		2. explicitely specify template argument to prevent template type deduction
			by compiler
			::max<double>(4, 7.2)
		3. modify template definition to accept different types as template parameter
			template<typename T1, typename T2> 

	1.2.3 Type deduction for default call arguments

		template<typename T>
		void f(T = "");

		f(1); // Fine
		f(); // compiler cant deduce type for default call argument

		So Specify the default template parameter type for template types on which i
		call arguments with default values are depends.

		template<typename T=std::string>
		void f(T = "");



1.3    Multiple Template Parameters
	If you pass different types call arguments to the ::max function, while returning it will have to convert one of the two arguments to return type
	
	This has three solutions
		1.3.1 Template Parameters for Return Types
		1.3.2 Deducing the Return Type
		1.3.3 Return Type as Common Type

	1.3.1 Template Parameters for Return Types
		Pass return type RT as template parameter. Call with explicitely specifying
		RT as return types can not be deduced. Any template type which does not have
		connection with the calling parameter can not be deduced and must be
		explicitely specified.

	1.3.2 Deducing the Return Type
		Specify auto as return type so compiler will deduce it.

		"auto" with (-> after calling parameters) in C++11
		just "auto" in C++14,
		
		will return the type returned by tertiary opeartor "?:". Tertiary operator 
		returns the most common or intituative type

		c++11: auto max(T1 a, T2 b)->  std::decay<decltype(true?a:b)>::type 
		c++14: auto max(T1 a, T2 b)

		remember "auto" type decays everytime it is used, even in case of return type

	1.3.3 Return Type as Common Type
		you can use c++ construct std::common_type_t<T1, T2> which behaves as 
		decltype(true ?T1 : T2) but also decays automatically.

		ternary operator returns a "more common type" among T1 and T2, but does not
		decay automatically. Ternary oprator is an expression and it does not have
		return type but returns value, common type among T1 and T2.

1.4    Default Template Arguments
		you can have default template arguments
		Third parameter RT could be specified as default value

		template<typename T1, typename T2,
		         typename RT = std::decay_t<decltype(true ? T1() : T2())>>
		RT max(T1, T2);

		template<typename T1, typename T2, typename RT = std::commont_type_t<T1, T2>>
		RT max(T1, T2);

		but, to override default template type, you must specify T1 and T2
		::max<int, int, float>(5,6);

		template<typename RT = std::commont_type_t<T1, T2>, typename T1, typename T2>
		RT max(T1, T2);
		::max<float>(5,6);

		All the type arguments after last type argument with default value must be deducible 
	

1.5    Overloading Function Templates


	
	int max(int a, int b);

	template<typename T>
	T max(T a, T b);

	::max(7, 42);                // calls the nontemplate for two ints 
	::max(7.0, 42.0);            // calls max<double> (by argument deduction)
	::max(’a’, ’b’);              //calls max<char> (by argument deduction)
	::max<>(7, 42);              // calls max<int> (by argument deduction)
	::max<double>(7, 42);        // calls max<double> (no argument deduction)

	automatic type conversion is not considered for the template type deduction
	so nontemplate version
	::max(’a’, 42.7);             //calls the nontemplate for two ints


	Specify return type 
		template<typename T1, typename T2>
		auto max(T1 a, T2 b);

		template<typename RT, typename T1, typename T2>
		RT max(T1 a, T2 b);

		auto a = ::max(4, 7.2);                     // uses first template

		# long double is different than  double
		auto b = ::max<long double>(7.2, 4);        // uses second template
	
		// ERROR: both function templates match
		// ensure only one among overloads matches 
		auto c = ::max<int>(4, 7.2); 



	Dont return references from templates. They might point to dangling reference
	which could be reference to temporary objects

	All versions of the template overloads must be been "declared" before calling 
	template function, otherwise only seen overload is considered for the resolution
	at that point.
	
		template<typename T>
		T max (T a, T b);

		template<typename T>
		T max (T a, T b, T c) { return max(max(a,b), c);} 

		int max (int a, int b);

		 ::max(47,11,33);        // OOPS: uses max<T>() instead of max(int,int)
		

1.6    But, Shouldn’t We …?

	1.6.1 Pass by Value or by Reference?
		Try to avoid references in templates
		The syntax is simple.
		Compilers optimize better.
		Move semantics often makes copies cheap.
		And sometimes there is no copy or move at all.

		 A template might be used for both simple and complex types, so choosing the approach for complex types might be counter-productive for simple types.
		 As a caller you can often still decide to pass arguments by reference, using std::ref() and std::cref() (see Section 7.3 on page 112).

	1.6.2 Why Not inline?
		you may. you define inline and template functions usually in header files. 
		inline means multiple copies of function replaced locally at call location
		inline is hint. compiler are intelligent to make functions inline but 
		specifying inline is taken into consideration for this decision.

	1.6.3 Why Not constexpr?
		template<typename T1, typename T2>
		constexpr auto max (T1 a, T2 b)

1.7    Summary


2. Class Templates

	2.1    Implementation of Class Template Stack

	2.1.1 Declaration of Class Templates
		Like function templates class templates accepts type parmeter. In Stack<T>,
		the template parameter T is required wherever it can not be deduced. Inside
		template class definition, after initial two lines of class declaration,
		Stack represents Stack<T>. But for member function definitions outside class
		you must specify Stack<T>.
			template<typename T>
			void Stack<T>::operator ==(const Stack<T>& other) {}

		Unlike normal classes you can not define templates inside function or block.
		You can define them only at global/namespace level or within other class

	2.1.2 Implementation of Member Functions
		you must specify full class 

	2.2    Use of Class Template Stack
		Code is instantiated only for functions that are called.
		If class has static members then those are instantiated once for each type template
		is instantiated with. You may use const, volatile with instantiated templates. you 
		may use template type in typedef or "using".

				using IntStack = Stack <int>;

		Template types could be of any type, ie pointers, (references?)


	2.3    Partial Usage of Class Templates
		Template only expects operations on the type parameter to be supported,
		which are used in the used or instancetiated functions.

	2.3.1 Concepts
		Concepts are constrains on the template types that are required to instantiate
		successfully. 
		1. Otherwise compilation errors during the member function isntantiation
			are complex, not clear.
		2. Otherway to detect these errors earlier is class level static_asserts which
			will pin point from where Class definition is instantiating.

	2.4    Friends
		You may have friend functions declared/defined inside template class. Defining
		them inside template class is simple. But declaring them inside and defining outside
		is trickier.

		1. Normal friend declaration as non-template function
			template <typename T>
			struct Stack
			{
				friend std::cout operator << (std::cout stream, const Stack<T>& );
			};
	
			You must define the function outside for per instance of template type T i.e. Stack<T>
			created.

		2. Approach 2 : Declare generic template friend function
				1. Using type parameter U : this does not shadows original parameter
				2. you must use Stack<U> as function calling parameter to refer stack

			template <typename T>
			struct Stack
			{
				template<typename U>
				friend std::cout operator << (std::cout stream, const Stack<U>& );
			};

			template<typename T>
			std::cout operator << (std::cout stream, const Stack<T>& ) {}

		3. Approach 3: Forward declare friend template function, but instantiated within class.

			template <typename T>
			struct Stack;
			template <typename T>
			std::cout operator << (std::cout stream, const Stack<T>& );

			template <typename T>
			struct Stack
			{
				// See how it is instantiated for type T
				friend std::cout operator << <T>(std::cout stream, const Stack& );
			};


	2.5    Specializations of Class Templates 

			Specilizing individual member functions
				It is possible to specialize single member function for a particular type parameter to 
				template class.	This will cause template class instantition for that type.

				But once you specialize single member function outside of template class declaration for a type
				parameter to template class, then you can not fully specialize template class for that type.

			Full Specializing whole template class
				template <>
				struct Stack<std::string> {};
	
			Specilization full or partial might provide slight different interface and implementation

	2.6    Partial Specialization
			1. You can specilize stack for the pointer type.

				template <typename T>
				struct Stack<T*> {};
			
			2. Partial specializing with multiple type parameter
				
				template <typename T1, typename T2>
				struct MyClass{};
				
				template <typename T>
				struct MyClass<T, T>{};

				template <typename T>
				struct MyClass<T, int>{};

				template <typename T1, typename T2>
				struct MyClass<T1*, T2*>{};

				MyClass<int, float> mif; // MyClass<T1, T2>
				MyClass<float, float> mff; // MyClass<T, T>
				MyClass<float, int> mfi; // MyClass<T, int>
				MyClass<int*, Float*> mif; // MyClass<T1*, T2*>

				MyClass<int, int> mii; // Error, Ambibuity MyClass<T,T> or MyClass<T, int>
				MyClass<int*, int*> mii; // Error, Ambibuity MyClass<T,T> or MyClass<T1*, T2*>

				To resolve this provide additional partial specialization for exact match

				// full specialization
				template <>
				struct MyClass<int, int>{};

				template <typename T>
				struct MyClass<T*, T*>{};
			
	2.7    Default Class Template Arguments
			Class can accept the default template type parameter
			template<typename T, typename Container=std::vector<T>>
			class Stack	{};

			template<typename T, typename Container>
			void Stack<T,Container>::top (T const&)  {}

	2.8    Type Aliases

	2.9    Class Template Argument Deduction

	2.10   Templatized Aggregates

	2.11   Summary



**************FILE************ .
**************FILE************ ./tools
**************FILE************ ./tools/checkPatch.py
#!/usr/bin/python3

from sys import argv 
from os.path import exists  
from subprocess import PIPE
import subprocess


""" 
	Script to check if all files are indented properly before checkin.
"""
program = argv[0]

# List only changed files.
cmdString="svn diff --summarize"
proc = subprocess.Popen(cmdString, stdout=subprocess.PIPE)
filesChanged = proc.stdout.read()

print("filesChanged = %s", filesChanged)




**************FILE************ ./tools/astyle.rc
--style=allman 
--indent=spaces=4 
--convert-tabs 
--indent-classes 
--indent-switches 
--indent-namespaces 
--indent-labels 
--indent-col1-comments 
--min-conditional-indent=0 
--pad-oper 
--pad-header 
--unpad-paren 
--align-pointer=name 
--lineend=linux 
--suffix=none 
-n

**************FILE************ ./developement-docs
**************FILE************ ./.log
**************FILE************ ./source
**************FILE************ ./source/0.9.0.0
**************FILE************ ./source/0.9.0.0/test
**************FILE************ ./source/0.9.0.0/test/MDApp.h
#ifndef __MD_H__
#define __MD_H__

#include "base/API.h"

class MDApp: public FeedAPI
{
	std::string _config;
	std::vector<std::string> _symbols;
	std::vector<std::string> _symbolFiles;
	FILE *_output;
	base::MarketDataApplication* _marketDataApp;
	bool _print;
	uint32_t _printLevels; // printLevels in the book
	bool _printOrders; // printOrders in the levels

	public:

		//FeedAPI
		void onFeedStarted(const FeedHandler *feedHandler);
		void onFeedStopped(const FeedHandler *feedHandler);
		void onLineGroupStarted(const LineGroup *lineGroup);
		void onLineGroupStopped(const LineGroup *lineGroup);
		void onLineStarted(const Line *pLine);
		void onLineStopped(const Line *pLine);
		void onPacketStart(const Line *pLine);
		void onPacketEnd(const Line *pLine);

		void printBase(char *buf, const Base *);
		void printProductInfo(const ProductInfo *);
		void printLevels(const Book *book, char *buf, uint32_t &wrote);
		void printOrder(const Order *);
		void printQuote(const Quote *);
		void printBook(const Book *book);
		void printTrade(const Trade *);
		void printStatus(const Status *);

		//SubscriptionAPI
		void onOrder(const Order *);
		void onBook(const Book *);
		void onQuote(const Quote *);
		void onTrade(const Trade *, const Order *);
		void onStatus(const Status *);
		void onCustom(const Custom *);
		void onProductInfo(const ProductInfo *);

		MDApp();
		~MDApp();
		void parseCmdLine(int argc, char *argv[]);
		void init();
		void subscribe();
		void start();
		void stop();

		atomic<bool> _shutdownApp;
};

#endif //__MD_H__
**************FILE************ ./source/0.9.0.0/test/omxnordic.xml
<?xml version="1.0" encoding="utf-8"?>

<config>
<Logger name="logger" file="omxnordic-clarice.log" level="INFO" logger-queue-size="2000" max-size-in-mb="1000" cpu="6"/>

<ApplicationManager name="MarketDataUS" bind-threads="manually" first-cpu="4" cpu=""/>

<NetworkReaders>
    <NetworkReader name="NetReader1" cpu="4" />
</NetworkReaders>

<FeedHandlers>
    <FeedOtherType/>    

    <FeedHandler name="omxnordic" feed="omxnordic" playback-mode="file" libarary="" callback-thread-pool="" playback-files="omxnordic-18.cl.gz" re-record="false" xrecord="true" callbacks="QUOTE,CUSTOM,TRADE,STATUS" maintain-orders="${MAINTAIN_ORDER}">
        <LineGroups>
        <LineGroup name="LG1" xprocessor="EProcessor" network-reader="NetReader1" cpu="5" callback-thread-pool="">
            <Lines>
            <Line name="omx" primary-mc-line="233.74.125.41:31041" secondary-mc-line="233.74.125.141:31141"/>
            </Lines>
        </LineGroup>
        </LineGroups>
    </FeedHandler>
</FeedHandlers>
</config>
**************FILE************ ./source/0.9.0.0/test/MDApp.cpp
#include <stdio.h>
#include <iostream>
#include <signal.h>
#include <errno.h>
#include <assert.h>
#include <string.h> 
#include "infra/utils/StringUtils.h"
#include "base/MarketDataApplication.h"
#include "base/FeedHandler.h"
#include "base/LineGroup.h"
#include "base/Line.h"
#include "base/Packet.h"
#include "base/Subscription.h"
#include "base/Base.h"
#include "base/LineGroup.h"
#include "base/Line.h"
#include "base/Order.h"
#include "base/Book.h"
#include "base/Quote.h"
#include "base/PriceLevel.h"
#include "base/Quote.h"
#include "base/Trade.h"
#include "base/Status.h"
#include "base/Custom.h"
#include "base/ProductInfo.h"
#include "MDApp.h"

using namespace base;

#define FPRINTF fprintf 

base::FeedAPI feedAPI;
MDApp *app = nullptr;

// typedef for signals
typedef void (*SignalHandler)(int, siginfo_t *, void *);

void register_signals(int signal, SignalHandler sig_func);

// register the signalhandler for siginfo 
void signal_handler(int signum, siginfo_t *siginfo, void *data)
{
	fprintf(stderr, "Recieved signal %d\n", signum);	
	app->_shutdownApp = true;
	register_signals(signum, nullptr);
}

//register the signalhandler for siginfo 
void register_signals(int signal, SignalHandler sig_func)
{
	struct sigaction act;	
	struct sigaction oldact;	
	memset(&act, 0, sizeof(act));
	act.sa_handler = nullptr;
	act.sa_sigaction = sig_func;
	act.sa_flags =  SA_SIGINFO;

	int result = sigaction(signal, &act, &oldact);
	if(result)
	{
		perror("Could not register signal SIGINT");
		exit(-1);
	}
}

void MDApp::onFeedStarted(const FeedHandler *feedHandler)
{
	fprintf(stdout, "update onFeedStarted, feed %s\n", feedHandler->_name);
}

void MDApp::onFeedStopped(const FeedHandler *feedHandler)
{
	fprintf(stdout, "update onFeedStopped, feed %s\n", feedHandler->_name);
}

void MDApp::onLineGroupStarted(const LineGroup *lineGroup)
{
	fprintf(stdout, "update onLineGroupStarted, feed %s, lineGroup %s\n", lineGroup->_feedHandler->_name, lineGroup->_name);
}

void MDApp::onLineGroupStopped(const LineGroup *lineGroup)
{
	fprintf(stdout, "update onLineGroupStarted, feed %s, lineGroup %s\n", lineGroup->_feedHandler->_name, lineGroup->_name);
}

void MDApp::onLineStarted(const Line *pLine)
{
	fprintf(stdout, "update onLineStarted, feed %s, lineGroup %s, line: %s\n", pLine->_lineGroup->_feedHandler->_name, pLine->_lineGroup->_name, pLine->_name);
}

void MDApp::onLineStopped(const Line *pLine)
{
	fprintf(stdout, "update onLineStopped, feed %s, lineGroup %s, line: %s\n", pLine->_lineGroup->_feedHandler->_name, pLine->_lineGroup->_name, pLine->_name);
}

void MDApp::onPacketStart(const Line *pLine)
{
//	fprintf(stdout, "sq %lu, update onPacketStart, endsq %lu, nmsg %lu, %s\n", pLine->_headerSeqNo, pLine->_endSeqNo, pLine->_endSeqNo - pLine->_headerSeqNo+1, pLine->_packet->_packetAddress->toString().c_str());
}

void MDApp::onPacketEnd(const Line *pLine)
{
//	fprintf(stdout, "sq %lu, update onPacketEnd, endsq %lu, nmsg %lu, %s\n", pLine->_headerSeqNo, pLine->_endSeqNo, pLine->_endSeqNo - pLine->_headerSeqNo+1, pLine->_packet->_packetAddress->toString().c_str());
}

/**
 * Checks if ID has valid type and valid value
 */
void assertID(const ID &id)
{
	// Either it is numeric or alphanum
	ASSERT(id.type() == NUMERIC || id.type() == ALPHANUM, "Wrong Order ID type");

	// if numeric should not be 0, if alphanum should not be equal to "" 
 	ASSERT(	id.type() == NUMERIC ? id.numeric() != 0 : strcmp(id.alphanum(), ""), "Order ID is not initialized");
}

void assertBase(const Base *base)
{
	ASSERT(base != nullptr, "Base is nullptr");
	ASSERT(base->_sub->_symbolID != 0, "SymbolID is 0");
	ASSERT(base->_sub->_prodInfo != nullptr, "ProductInfo is nullptr");
	ASSERT(base->_seqNum != 0, "Seq num is 0");
	ASSERT(base->_xt.tv_sec != 0, "Exchange Time is 0");
	ASSERT(base->_type != UNKNOWN_UPDATE, "Object type unknown");
}



/**
 * Assert if all the order fields have valid values 
 */
void assertOrder(const Order *order)
{
	assertBase(order);
	// orderType is either NORMAL_ORDER or MARKET_ORDER
	ASSERT(order->_orderType == NORMAL_ORDER || 
			order->_orderType == MARKET_ORDER, "Invalid Order type");

	// order side is BUY or SELL
	ASSERT(order->_side == BUY || order->_side == SELL, "Invalid Order Side");

	//Check if orderID is  not empty 
	//assertID()

	// if not MARKET_ORDER then price should not be zero
	if(order->_orderType != MARKET_ORDER && (order->_action == ADDED || order->_action == MODIFIED))
	{
		ASSERT(order->_px != 0.0, "Order Price is 0.0");
	}

	// if modified or added, size should not be zero 
	ASSERT(order->_action == ADDED ||
			order->_action == MODIFIED ||
			order->_action == DELETED ||
			order->_action == EXECUTED, "Invalid Order Action");

	// if modified or added, size should not be zero 
	if(order->_action == ADDED || order->_action == MODIFIED)
	{
		ASSERT(order->_size != 0, "Order size is 0 at the time of add/modify");
	}
}

/**
 * Assert if all the quote fields have valid values 
 */
void assertQuote(const Quote *quote)
{
	assertBase(quote);
	
	ASSERT(_sub->_buys.empty() ||  _buy == _sub->_buys.begin()->second, "quote->_buy != TOB");
	ASSERT(_sub->_sells.empty() ||  _sell == _sub->_sells.begin()->second, "quote->_sell != TOB");
}

/**
 * Assert if all the trade fields have valid values 
 */
void assertTrade(const Trade *trade)
{
	assertBase(trade);
	// trade side is BUY or SELL
	//ASSERT(trade->_side == BUY || 
	//		trade->_side == SELL || trade->_side == SIDE_UNKNOWN);
	ASSERT(trade->_px != 0.0, "Traded price is 0.0");
}

void calcLatency(const Base *base)
{
	LineGroup *lineGroup = base->_line->_lineGroup;
#ifdef __MSG_LATENCY__
	getLatency(lineGroup->_ml, lineGroup->_mt);
#endif

#ifdef __PACKET_LATENCY__
	getLatency(lineGroup->_rl, base->_line->_packet->_rt);
#endif 
}

void MDApp::printBase(char *buf, const Base *base)
{
	timespec ct = globalClock();

	timespec mt = base->_line->_lineGroup->_mt;

	timespec rt = base->_line->_packet->_rt;

	//FPRINTF(_output, "pt %s, line %s, instrID %lu, sq %lu, msg %u, recordTime %ld.%.09ld, xt %ld.%.09ld, rt %ld.%.09ld, mt %ld.%.09ld, ct %ld.%.09ld, ut %c, ", base->_line->_lineGroup->_name, base->_line->_name, base->_sub->_symbolID, base->_seqNum, base->_msgType, base->_line->_packet->_recordTime.tv_sec, base->_line->_packet->_recordTime.tv_nsec, base->_xt.tv_sec, base->_xt.tv_nsec, rt.tv_sec, rt.tv_nsec, mt.tv_sec, mt.tv_nsec, ct.tv_sec, ct.tv_nsec, base->_type);
	sprintf(buf, "pt %s, line %s, instrID %lu, sq %lu, msg %u, recordTime %ld.%.09ld, xt %ld.%.09ld, ut %c", base->_line->_lineGroup->_name, base->_line->_name, base->_sub->_symbolID, base->_seqNum, base->_msgType, base->_line->_packet->_recordTime.tv_sec, base->_line->_packet->_recordTime.tv_nsec, base->_xt.tv_sec, base->_xt.tv_nsec, base->_type);
}

void MDApp::printProductInfo(const ProductInfo *product)
{
	if(_print)
	{
		char buf[512];
		printBase(buf, product);
		FPRINTF(_output, "%s, update onProductInfo, symbol %s, isin %.12s\n", buf, product->_symbol, product->_isin);
	}
}

void MDApp::onProductInfo(const ProductInfo *product)
{
	printProductInfo(product);
}

void MDApp::printLevels(const Book *book, char *buf, uint32_t &wrote)
{
	{
		PriceLevelMap::const_iterator itr = book->_buys.begin();
		PriceLevelMap::const_iterator itrEnd = book->_buys.end();
		int i = 1;
		wrote += snprintf(buf + wrote, sizeof(buf) - wrote, "	Bid Levels : size %lu\n", book->_buyQuantity);
		for(; itr != itrEnd && i <= _printLevels; itr++, i++)
		{
			wrote += snprintf(buf + wrote, sizeof(buf) - wrote, "	%d] px %f, size %lu, num %lu\n", i, itr->second->_px, itr->second->_size, itr->second->_numOrders);
			if(_printOrders)
			{
				Order *order = itr->second->_orders;
				while(order)
				{
					wrote += snprintf(buf + wrote, sizeof(buf) - wrote, "		|__ px %f, size %u, orderID %s\n", order->_px, order->_size, order->_orderID.to_string().c_str());
					order = order->_next;
				}
			}
		}
	}
	{
		PriceLevelMap::const_iterator itr = book->_sells.begin();
		PriceLevelMap::const_iterator itrEnd = book->_sells.end();
		int i = 1;
		wrote += snprintf(buf + wrote, sizeof(buf) - wrote, "	Ask Levels : size %lu\n", book->_sellQuantity);
		for(; itr != itrEnd && i <= _printLevels; itr++, i++)
		{
			wrote += snprintf(buf + wrote, sizeof(buf) - wrote, "	%d] px %f, size %lu, num %lu\n", i, itr->second->_px, itr->second->_size, itr->second->_numOrders);
			if(_printOrders)
			{
				Order *order = itr->second->_orders;
				while(order)
				{
					wrote += snprintf(buf + wrote, sizeof(buf) - wrote, "		|__ px %f, size %u, orderID %s\n", order->_px, order->_size, order->_orderID.to_string().c_str());
					order = order->_next;
				}
			}
		}
	}
}

void MDApp::printOrder(const Order *order)
{
	assertOrder(order);
	if(_print)
	{
		char buf1[512];
		char buf[65536 * 10];
		printBase(buf1, order);
		uint32_t wrote = snprintf(buf, sizeof(buf), "%s, px %f, size %u, side %c, action %c, orderID %s\n", buf1, order->_px, order->_size, order->_side, order->_action, order->_orderID.to_string().c_str());
		fwrite(buf, 1, wrote, _output);
	}
}

void MDApp::onOrder(const Order *order)
{
	calcLatency(order);
	printOrder(order);
}

void MDApp::printBook(const Book *book)
{
	//assertOrder(book);
	if(_print)
	{
		char buf1[512];
		char buf[65536 * 10];
		printBase(buf1, book);

		uint32_t wrote = snprintf(buf, sizeof(buf), "%s", buf1);

		if(!book->_buys.empty())
		{
			wrote += snprintf(buf + wrote , sizeof(buf) - wrote, ", bp %f, bs %lu, bnum %lu, blevels %lu, cbs %lu", book->_buys.begin()->second->_px, book->_buys.begin()->second->_size, book->_buys.begin()->second->_numOrders, book->_buys.size(), book->_buyQuantity);
		}
	
		if(!book->_sells.empty())
		{
			wrote += snprintf(buf + wrote , sizeof(buf) - wrote, ", ap %f, as %lu, snum %lu, alevels %lu, cas %lu \n", book->_sells.begin()->second->_px, book->_sells.begin()->second->_size, book->_sells.begin()->second->_numOrders, book->_sells.size(), book->_sellQuantity);
		}

		if(_printLevels)
		{
			printLevels(book, buf, wrote);
		}
		fwrite(buf, 1, wrote, _output);
	}
}

void MDApp::onBook(const Book *book)
{
	calcLatency(book);
	printBook(book);
}

void MDApp::printQuote(const Quote *quote)
{
	assertQuote(quote);
	if(_print)
	{
		char buf1[512];
		char buf[512];
		printBase(buf1, quote);
		uint32_t wrote = snprintf(buf, sizeof(buf), "%s", buf1);
		if(quote->_buy)
		{
			wrote += snprintf(buf + wrote, sizeof(buf) - wrote, ", bp %f, bs %lu, bnum %lu", quote->_buy->_px, quote->_buy->_size, quote->_buy->_numOrders);
		}

		if(quote->_sell)
		{
			wrote += snprintf(buf + wrote, sizeof(buf) - wrote, ", ap %f, as %lu, anum %lu", quote->_sell->_px, quote->_sell->_size, quote->_sell->_numOrders);
		}
		wrote += snprintf(buf + wrote, sizeof(buf) - wrote, "\n");
		fwrite(buf, 1, wrote, _output);
	}
}


void MDApp::onQuote(const Quote *quote)
{
	calcLatency(quote);
	printQuote(quote);
}

void MDApp::printTrade(const Trade *trade)
{
	if(_print)
	{
		char buf[512];
		printBase(buf, trade);
		FPRINTF(_output, "%s, px %f, size %u, side %c, tradeID %s\n", buf, trade->_px, trade->_size, trade->_side, trade->_tradeID.to_string().c_str());
	}
}

void MDApp::onTrade(const Trade *trade, const Order *order)
{
	calcLatency(trade);
	assertTrade(trade);
	printTrade(trade);
	if(order)
	{
		printOrder(order);
	}
}

void MDApp::printStatus(const Status *status)
{
	if(_print)
	{
		char buf[512];
		printBase(buf, status);
		FPRINTF(_output, "%s, st %s, prev %s\n", buf, Status::StateToCStr(status->_state), Status::StateToCStr(status->_prevState));
	}
}

void MDApp::onStatus(const Status *status)
{
	calcLatency(status);
	printStatus(status);
}

void MDApp::onCustom(const Custom *custom)
{
}

MDApp::MDApp()
	: FeedAPI(static_cast<OnFeedStarted>(&MDApp::onFeedStarted)
	, static_cast<OnFeedStopped>(&MDApp::onFeedStopped)
	, static_cast<OnLineGroupStarted>(&MDApp::onLineGroupStarted)
	, static_cast<OnLineGroupStopped>(&MDApp::onLineGroupStopped)
	, static_cast<OnLineStarted>(&MDApp::onLineStarted)
	, static_cast<OnLineStopped>(&MDApp::onLineStopped)
	, static_cast<OnPacketStart>(&MDApp::onPacketStart)
	, static_cast<OnPacketEnd>(&MDApp::onPacketEnd)
	, static_cast<OnOrder>(&MDApp::onOrder)
	, static_cast<OnBook>(&MDApp::onBook)
	, static_cast<OnQuote>(&MDApp::onQuote)
	, static_cast<OnTrade>(&MDApp::onTrade)
	, static_cast<OnStatus>(&MDApp::onStatus)
	, static_cast<OnCustom>(&MDApp::onCustom)
	, static_cast<OnProductInfo>(&MDApp::onProductInfo))
	, _config("")
	, _output(stdout)
	, _symbols()
	, _symbolFiles()
	, _marketDataApp(nullptr)
	, _print(false)
	, _printLevels(0)
	, _printOrders(false)
	, _shutdownApp(false)
{
}

MDApp::~MDApp()
{
	/**
	 * Will now release all the resources held.
	 * Destructs in exactly reverse order of the create base::MarketDataApplication
	 */	

	delete _marketDataApp;	
}

void MDApp::parseCmdLine(int argc, char *argv[])
{
	int opt;
	while((opt = getopt(argc, argv, "oc:s:S:f:p:")) != -1) 
	{
		switch (opt) 
		{
			case 'c':
				_config = optarg;
				break;

			case 's':
				_symbols = tokenize(optarg, ",");
				break;

			case 'S':
				_symbolFiles = tokenize(optarg, ",");
				break;

			case 'p':
				if(optarg)
					_printLevels = atoi(optarg);
				else
					_printLevels = 100000;
				break;

			case 'o':
				_printOrders = true;
				break;

			case 'f':
				if(!strcmp(optarg, "-"))
				{
					_output = stdout;
					_print = true;
				}
				else
				{
					_output = fopen(optarg, "w");
					_print = true;
					//@TODO: check return value and give exception
				}
				break;
			
			default: /* '?' */
				break;
		}
	}

	if(_config.empty())
	{
		fprintf(stderr, "Please provide config file with option -c \n");
		exit(-1);
	}
}

void MDApp::init()
{
	_marketDataApp = new base::MarketDataApplication(_config, this);	
}

void MDApp::subscribe()
{
	/*
	 * @TODO: Subscribe to the _marketDataApp.
	 * _marketDataApp->subscribe(SYMBOL, feed-name, CALLBACKS, *subscriptionInterface);	
	 */
	Subscription *ppSub;

	std::vector<string>::const_iterator	itr = _symbols.begin();
	for(; itr != _symbols.end(); itr++)
	{
		uint32_t ret = _marketDataApp->subscribe("millenium", (*itr).c_str(), &ppSub);
		if(ret < 0)
		{
			fprintf(stderr, "Could not create subscription symbols %s\n", (*itr).c_str());
		}
		else
		{
			fprintf(stderr, "Subscribed to %s\n", (*itr).c_str());
		}
	}
}

void MDApp::start()
{
	_marketDataApp->start();

	while(!_shutdownApp.load(std::memory_order_acquire))
	{
	}
}

void MDApp::stop()
{
	/** 
	 * Stop the managers, connections and flush all logs in logger at the end. We have not freed _thread yet.
	 */
	std::cerr << "Shutting down the application !!!" << endl;	
	_marketDataApp->stop();

}

int main(int argc, char *argv[])
{
	register_signals(SIGINT, signal_handler);
	register_signals(15, signal_handler);
	char buff[16 * 1024];
	//Set the stdout buffer
	setvbuf(stdout, buff, _IOFBF, sizeof(buff));
	fprintf(stderr, "Standard Market Data application: Clarice Feeds !!!\n");

	try	
	{
		app= new MDApp();
		app->parseCmdLine(argc, argv);
		app->init();
		app->subscribe();
		app->start();
		app->stop();
		usleep(5 * 1000000);
		delete  app;
	}
	catch(std::exception& e)
	{
		std::cerr << "exception caught: " << e.what() << '\n';
		app->stop();
		delete  app;
		exit(-1);
	}
	catch(...)
	{
		fprintf(stderr, "EXECPTION: Standard Market Data application: Clarice Feeds !!!\n");
		app->stop();
		delete  app;
		exit(-1);
	}
	return 0;
}
**************FILE************ ./source/0.9.0.0/test/sample.xml
<?xml version="1.0" encoding="utf-8"?>

<config>
<Logger name="logger" file="clarice.log" level="INFO" logger-queue-size="2000" max-size-in-mb="1000" cpu="5"/>

<ApplicationManager name="MarketDataUS" bind-threads="manually" first-cpu="4" cpu="4"/>

<NetworkReaders>
	<NetworkReader name="NetReader1" cpu="7" />
	<NetworkReader name="NetReader2" cpu="9" />
	<NetworkReader name="NetReader3" cpu="11" />
</NetworkReaders>

<FeedHandlers>
	<FeedOtherType/>			

	<FeedHandler name="millenium" feed="millenium" playback-mode="file" libarary="" callback-thread-pool="" playback-files="oslo.cl.gz" xre-record="true" xrecord="true" callbacks="BOOK,TRADE,STATUS,CUSTOM" maintain-orders="true">			
		<Recovery snapshot-username="" snapshot-password="" global-primary-tcp-snapshot="" global-secondary-tcp-snapshot="" global-primary-tcp-retranse="" global-secondary-tcp-retrans=""
				retranse-username="" retranse-password="" global-primary-udp-snapshot="" global-secondary-udp-snapshot="" global-primary-udp-retranse="" global-secondary-udp-retrans=""/>
		<LineGroups>
		<LineGroup name="LG1" xprocessor="EProcessor" network-reader="NetReader1" cpu="6" callback-thread-pool="">
			<Lines>
			<Line name="DOB-EQ" type="" data-type="" callback-thread-pool="" dormant-secondarr=""
					username="" password="" retrans-username="" retrans-password="" snapshot-username="" snapshot-password=""
					primary-mc-line="224.4.2.224:60300" secondary-mc-line="224.4.3.224:60300"  primary-mc-snapshot=""  secondary-mc-snapshot=""  primary-mc-retrans=""   secondary-mc-retrans=""
					primary-tcp-line=""	secondary-tcp-line="" primary-tcp-snapshot="" secondary-tcp-snapshot="" primary-tcp-retranse="" secondary-tcp-retrans=""
					udp-primary-snapshot="" udp-secondary-snapshot="" udp-primary-retranse="" udp-secondary-retrans=""/>
			</Lines>
		</LineGroup>
		<LineGroup name="LG2" xprocessor="BProcessor" network-reader="NetReader2" cpu="8" callback-thread-pool="">
			<Lines>
			<Line name="DOB-WAR" type="" data-type="" callback-thread-pool="" dormant-secondarr=""
					username="" password="" retrans-username="" retrans-password="" snapshot-username="" snapshot-password=""
					primary-mc-line="224.4.2.226:60300" 	secondary-mc-line="224.4.3.226:60300"  primary-mc-snapshot=""  secondary-mc-snapshot=""  primary-mc-retrans=""   secondary-mc-retrans=""
					primary-tcp-line=""	secondary-tcp-line="" primary-tcp-snapshot="" secondary-tcp-snapshot="" primary-tcp-retranse="" secondary-tcp-retrans=""
					udp-primary-snapshot="" udp-secondary-snapshot="" udp-primary-retranse="" udp-secondary-retrans=""/>
			</Lines>
		</LineGroup>
		<LineGroup name="LG3" xprocessor="WProcessor" network-reader="NetReader3" cpu="10" callback-thread-pool="">
			<Lines>
			<Line name="WARRANT" type="" data-type="" callback-thread-pool="" dormant-secondarr=""
					username="" password="" retrans-username="" retrans-password="" snapshot-username="" snapshot-password=""
					primary-mc-line="224.4.2.228:60300" 	secondary-mc-line="224.4.3.228:60300" primary-mc-snapshot=""  secondary-mc-snapshot=""  primary-mc-retrans=""   secondary-mc-retrans=""
					primary-tcp-line=""	secondary-tcp-line="" primary-tcp-snapshot="" secondary-tcp-snapshot="" primary-tcp-retranse="" secondary-tcp-retrans=""
					udp-primary-snapshot="" udp-secondary-snapshot="" udp-primary-retranse="" udp-secondary-retrans=""/>
			</Lines>
		</LineGroup>
		</LineGroups>
	</FeedHandler>
</FeedHandlers>
</config>

**************FILE************ ./source/0.9.0.0/test/main_config.xml
<?xml version="1.0" encoding="utf-8"?>

<config>
<Logger file="log/clariec.log"	logger-queue-size="2048" max-size-in-mb="1000" />

<ApplicationManager name="MarketDataUS" cpu="2"/>
<SessionManagers>
	<CallBackThreadPool name="global-raiser">
		<CallbackThread name="" cpu="" range="0-9a-m"/>
		<CallbackThread name="" cpu="" range="n-z" />
	</CallBackThreadPool>
	<SessionManager name="" libarary="" callback-thread-pool="">			
		<Recovery snapshot-username="" snapshot-password="" global-primary-tcp-snapshot="" global-secondary-tcp-snapshot="" global-primary-tcp-retranse="" global-secondary-tcp-retrans=""
				retranse-username="" retranse-password="" global-primary-udp-snapshot="" global-secondary-udp-snapshot="" global-primary-udp-retranse="" global-secondary-udp-retrans=""/>
		<CallBackThreadPool name="feed-raiser"/>
		<Connection name="" callback-thread-pool="">
			<CallBackThreadPool name="connection1-raiser1"/>
			<CallBackThreadPool name="connection1-raiser2"/>
			<Linehandler name="" type="" data-type="" thread="" callback-thread-pool="" dormant-secondarr=""
					username="" password="" primary-mc-line="" 	secondary-mc-line=""  primary-mc-snapshot=""  secondary-mc-snapshot=""  primary-mc-retrans=""   secondary-mc-retrans=""
					snapshot-username="" snapshot-password="" primary-tcp-line=""	secondary-tcp-line="" primary-tcp-snapshot="" secondary-tcp-snapshot="" primary-tcp-retranse="" secondary-tcp-retrans=""
					retranse-username="" retranse-password="" primary-mc-snapshot="" secondary-mc-snapshot="" primary-mc-retranse="" secondary-mc-retrans=""/>
		</Connection>
		<Connection cpu="" callback-thread-pool="">
			<CallBackThreadPool name="connection2-raiser1"/>
			<CallBackThreadPool name="connection2-raiser2"/>
			<Linehandler name="" type="" data-type="" callback-thread-pool=""
					primary-mc-line="" 	secondary-mc-line=""  primary-mc-snapshot=""  secondary-mc-snapshot=""  primary-mc-retrans=""   secondary-mc-retrans=""
					primary-tcp-line=""	secondary-tcp-line="" primary-tcp-snapshot="" secondary-tcp-snapshot="" primary-tcp-retranse="" secondary-tcp-retrans=""
					udp-primary-snapshot="" udp-secondary-snapshot="" udp-primary-retranse="" udp-secondary-retrans=""/>
		</Connection>
	</SessionManager>
</SessionManagers>
</config>
**************FILE************ ./source/0.9.0.0/.MarketDataUS-clariec.log.swo
**************FILE************ ./source/0.9.0.0/main.mk
DEBUG_OBJ_DIR=obj/debug/${HOSTBITS}
RELEASE_OBJ_DIR=obj/release/${HOSTBITS}

CD_INCLUDE=${CD_HOME}/include

CD_BOOST_HOME=${CD_INCLUDE}/boost
CD_INC_BOOST=${CD_BOOST_HOME}

CD_LIBXML_HOME=${CD_INCLUDE}/libxml2
CD_INC_LIBXML=${CD_LIBXML_HOME}/libxml2

CD_BIN_DIR =${CD_HOME}/bin/${HOSTBITS}

CD_LIB_DIR =${CD_HOME}/libs/${HOSTBITS}
CD_CORE_LIBS= -lcd-base -lcd-infra

CD_STD_LIBS=-lrt -lpthread -lnsl -lstdc++ -latomic -lm -ldl -lxml2 -lz
CD_BOOST_LIBS=-lboost_system
CD_FEED_LIBS=-lcd-millenium

CD_INC_DIR =-I${CD_HOME} -I${CD_INCLUDE} -I${CD_INC_BOOST} -I${CD_INC_LIBXML}

CORE_C_FLAGS= -c -fPIC -std=c++11 
CORE_C_RELEASE_FLAGS= -O3 -minline-all-stringops -finline-limit=3006 
CORE_C_DEBUG_FLAGS= -g

#CORE_USER_FLAGS= -DASSERT_ENABLED -D__LATENCY__ -D__QWRITEREAD_LATENCY__ -D__NEXTREAD_LATENCY__ -D__MSG_LATENCY__ -D__PACKET_LATENCY__ -D__SUBMAP_LATENCY__ -D__ORDERMAP_LATENCY__ -D__ORDERPOOL_LATENCY__
CORE_USER_FLAGS= -D__LATENCY__ -D__MSG_LATENCY__

CFLAGS = ${CORE_C_FLAGS}
CC = gcc 
**************FILE************ ./source/0.9.0.0/feeds
**************FILE************ ./source/0.9.0.0/feeds/euronext
**************FILE************ ./source/0.9.0.0/feeds/euronext/EuronextCommon.h
#ifndef __EURONEXT_COMMON_H__
#define __EURONEXT_COMMON_H__
namespace euronext
{
	class EuronextFeedHandler;
	class EuronextLineGroup;
	class EuronextLine;
};
#endif //__EURONEXT_COMMON_H__
**************FILE************ ./source/0.9.0.0/feeds/euronext/EuronextLine.h
#ifndef __EURONEXTLINEHANDLER_H__
#define __EURONEXTLINEHANDLER_H__

#include "base/Line.h"
#include "base/Subscription.h"
#include "feeds/euronext/EuronextCommon.h"
#include "feeds/euronext/EuronextMessages.h"

#include "base/Base.h"

using namespace base;

namespace euronext
{
	class EuronextLine : public Line
	{
		public:
			//@TODO: This should be static and should be called when lib gets loaded;
			void initializeParseFunctions();

			static Line* _EuronextLine(const MarketDataApplication *, FeedHandler *, LineGroup *, Thread *, const pugi::xml_node &, LineAPI *);
			EuronextLine(const MarketDataApplication *, EuronextFeedHandler *, EuronextLineGroup *, Thread *, const pugi::xml_node &, LineAPI *);

			static void _start(Line *pLine);
			void start();

			static void _getPacketStats(Line *pLine);
			void getPacketStats();

			static void _getPacketStatsSnap(Line *pLine);
			void getPacketStatsSnap();

			static bool _reRequestMissedPackets(Line *pLine, uint64_t first, uint64_t last);
			bool reRequestMissedPackets(uint64_t first, uint64_t last);

			void processPacket();
			void processMsg_rev();

			// System Messages
			void loginRequest();
			void loginResponse();
			void logoutRequest();
			void replayRequest();
			void replayResponse();
			void snapshotRequest();
			void snapshotResponse();
			void snapshotComplete();

			// Application messages
			void exchangeTime();
			void systemEvent();
			void symDir();
			void symStatus();
			void addOrder();
			void orderDeleted();
			void orderModified();
			void orderBookClear();
			void orderExec();
			void orderExecPxSize();
			void trade();
			void offBookTrade();
			void tradeBreak();
			void auctionInfo();
			void statistics();
			void enhancedTrade();
			void recoveryTrade();
	};
}

#endif //__EURONEXTLINEHANDLER_H__
**************FILE************ ./source/0.9.0.0/feeds/euronext/EuronextMessages.h
#ifndef __EURONEXT_MESSEGES_H__
#define __EURONEXT_MESSEGES_H__

#include <stdint.h>

#define PACKED __attribute__((packed))

enum MessageType
{
	// System Messages
	
	// Application messages
};

enum PacketType
{
	DATA_PACKET = 501,
	SEQ_RESET = 1,
	HB_PACKET = 2,
	RETRANSE_RESPONSE	= 10,
	RETRANSE_REQUEST	= 20,
	SNAPSHOT_REQUEST	= 22, // REFRESH_REQUST
	SNAPSHOT_RESPONSE	= 23, // REFRESH_RESPONSE
	HB_RESPONSE			= 24
}

enum MessageType
{
	REFRESH_START = 580,
	REFRESH_END	  = 581,
}

struct PACKED EnxtPacketHeader 
{
	uint16_t length;
	uint16_t packetType;
	uint32_t seqNum;
	uint32_t sendTime;
	uint16_t serviceID;
	uint8_t	 deliveryFlag; // 0 - Real Time Uncompressed, 1 - Retransmission uncompressed, 17 - refresh zlib compresed
	uint8_t	 numOfMsgs;		// 0 in case of HB packet
};	//16

struct PACKED EnxtSeqReset // day one packet, with seq 1
{
	uint32_t nextSeqNum;	// this must be 2
}; //4

struct PACKED EnxtHBResBody
{
	char	sourceID[20]; // source	(client) requesting retransmission
};

struct PACKED EnxtRetrReq
{
	uint16_t length;	 // 44 = 16 header + 24 
	uint16_t packetType; // set to 20
	uint32_t seqNum;	 // Optional
	uint32_t sendTime;	 // Optional
	uint16_t serviceID;	 // Service ID of the broadcast stream/MC Line 
	uint8_t	 deliveryFlag;  // always 0
	uint8_t	 numOfMsgs;		// 1 message  
}; // 16

struct PACKED EnxtRetrReqBody
{
	uint32_t beginSeqNum;
	uint32_t endSeqNum;
	char	sourceID[20]; // source	(client) requesting retransmission
}; // 28

enum EnxtRejectReason
{
	ACCEPTED = 0,
	PERMISSION = 1,	// the ServiceID is not granted for the SourceID or an incorrect Source ID has been used
	INVALID_SEQ   = 2, // Rejected due to invalid sequence range
	MAX_SEQ_RANGE = 3, // Rejected due to max sequence range reached (> thresholds)
	MAX_REQ		  = 4, // Rejected due to max request reached in a day (> thresholds)
	NOT_AVAILABLE = 5, // Requested packets are no longer available
	INVALID_REQ	  = 6, // Retransmission request incorrectly formatted
	INV_SERV_ID	  = 7  // Rejected – Due to incorrect ServiceID
}

struct PACKED EnxtRetrResBody
{
	uint32_t sourceSeqNum; // Requested packet seq num
	char    sourceID[20]; // source (client) requesting retransmission
	uint8_t	status;	// A = Accepted, R = Rejected
	uint8_t rejectReason;
	uint8_t filler[2]; // reserved 
}; // 28

struct PACKED EnxtRefreshReqBody
{
	char	sourceID[20]; // source	(client) requesting retransmission
}; // 20

enum EnxtResponseRejectReason
{
	REFRESH_ACCEPTED = 0,
	REFRESH_PERMISSION = 1, // the ServiceID is not granted for the SourceID or an incorrect Source ID has been used
	REFRESH_INV_SERV_ID  = 2,  // Rejected – Due to incorrect ServiceID
	REFRESH_INVALID_REQ = 3, // Refresh request incorrectly formatted
	REFRESH_INVALID_SEQ   = 4, // Rejected due to incorrect packet type sent
	REFRESH_MAX_REQ = 5, // Rejected due to max request reached in a day (> thresholds)
	REFRESH_MAX_SEQ_RANGE = 6, // Rejected due unavailibility of refresh data 
	REFRESH_NOT_AVAILABLE = 7 // Refresh request rejected as sent to incorrect server (secondary instead of primary)
}

struct PACKED EnxtRefreshResBody
{
	uint32_t sourceSeqNum; // Requested packet seq num
	char    sourceID[20]; // source (client) requesting retransmission
	uint8_t	status;	// A = Accepted, R = Rejected
	uint8_t rejectReason;
	uint8_t filler[2]; // reserved 
}; // 28

struct PACKED EnxtMsgHeader 
{
	uint16_t msgSize;
	uint16_t msgType;
};

struct PACKED EnxtStartRefresh
{
	EnxtMsgHeader header;
	uint32_t lastSeqNum; // lastSeqNum + 1 = next expected packet on MC line
}; // 8

struct PACKED EnxtRefreshEnd
{
	EnxtMsgHeader header;
	uint32_t lastSeqNum; // lastSeqNum + 1 = next expected packet on MC line
}; // 8

enum EnxtInstrState
{
	NA	= 0,
	AUCTION = 'A',
	HALTED = 'H',
	NULL_STATE = ' '
}

enum EnxtTradingState
{
	NA	= 0,
	SUSPENDED = 'S', // Suspended, Calculation suspended for indices 
	CALC_RESUMED = 'R' // For indices 
}

enum EnxtHaltReason
{
	NA	= 0,
	HALTED = 'R', // No Liquidity provider
	COLLAR = 'C', // Opening/trading price is outside of dynamic collars
	MANUAL_HALT = 'M', // By Market operations
	NULL_STATE = ' ' // No Info avaialable 
}

enum EnxtActAffectingState
{
	NA	= 0,
	TRADING = 'C',
	CANCLED_PROGRAM_OPENING = 'D',
	MANUAL_HALT = 'M',
	INIT_STAGE = 'N',
	OPENED = 'O',
	DEFFERED_PROGRAM_OPENING = 'P',
	AUTO_HALT = 'R',
	ONE_SIDE_PERIOD = 'Y',
	END_ONE_SIDE = 'Z'
	ORDER_ENTRY_CHANGE = ' '
}

struct PACKED EnxtStockStateChange
{
	EnxtMsgHeader header;
	uint32_t symbol;
	uint32_t sourceSeq; // assinged by system
	uint32_t seconds; // sourceTime since midgnight
	uint32_t symtemId; // Exchange/System ID
	uint16_t useconds; 
	uint8_t reserved[2];
	char	startDate[8]; // YYYYMMDD
	char	startTime[6]; // HHMMSS
	char	preOpenTime[6]; // HHMMSS
	char	orderEntryRejection; // 0 : N/A, N: Allowed, Y: Forbidden, Nulli ' '- Not provided
	char	instrState;
	char	tradingState;
	char	haltReason;
	char	actAffectState;
	char	instrStateTCS;
	char	periodSide;
	char	reserved1;
}; //52

enum EnxtSession
{
	EARLY_SESSION  = 'E',
	CLOSE_SESSION = 'C',
	LATE_SESSION  = 'L'
}

enum EnxtClassState
{
	EAMO = 1, //	
}

struct PACKED EnxtClassStateChange
{
	EnxtMsgHeader header
	uint32_t sourceSeq; // assinged by system
	uint32_t seconds; // sourceTime since midgnight
	uint32_t symtemId; // Exchange/System ID
	uint16_t useconds; 
	char	 instrGroupCode[3];
	char	 reserved;
	char	 session;
	char	 reserved1;
	uint32_t classState;
	char	startDate[8]; // YYYYMMDD
	char	startTime[6]; // HHMMSS
	char	preOpenTime[6]; // HHMMSS
	char	orderEntryRejection; // 0 : N/A, N: Allowed, Y: Forbidden, Nulli ' '- Not provided
	char	instrState;
	char	tradingState;
	char	haltReason;
	char	actAffectState;
	char	instrStateTCS;
	char	periodSide;
	char	reserved1;
}; 

struct PACKED EnxtMatchPrice // Speculative Open price
{
	EnxtMsgHeader header
	uint32_t symbol;
	uint32_t sourceSeq; // assinged by system
	uint32_t seconds; // sourceTime since midgnight
	uint32_t imPrice; // calculated with the PriceScaleCode
	uint32_t variation; // calculated with the VariationScaleCode
	uint32_t symtemId; // Exchange/System ID
	uint16_t useconds;
	uint8_t  priceScale;
	uint8_t  variationScale;
	uint32_t imvolume; // Volume that would	be exchanged if Auction occurred at this moment
};

struct PACKED EnxtTCSStateChange
{
	EnxtMsgHeader header
	uint32_t sourceSeq; // assinged by system
	uint32_t seconds; // sourceTime since midgnight
	uint32_t symtemId; // Exchange/System ID
	uint16_t useconds;
	char	 instrGroupCode[3];
	char	 changeTradingCycle;
	char	 reserved[2];
};

struct PACKED EnxtCollar
{
	EnxtMsgHeader header
	uint32_t symbol;
	uint32_t sourceSeq; // assinged by system
	uint32_t seconds; // sourceTime since midgnight
	uint32_t highCollar; // higher bound
	uint32_t lowCollar; // higher bound
	uint32_t symtemId; // Exchange/System ID
	uint16_t useconds;
	uint8_t	 highScaleCode;	
	uint8_t	 lowScaleCode;	
}; //32

struct PACKED EnxtTimeTable
{
	EnxtMsgHeader header
	uint32_t sourceSeq; // assinged by system
	uint32_t seconds; // sourceTime since midgnight
	uint32_t symtemId; // Exchange/System ID
	uint16_t useconds;
	char	 instrGroupCode[3];
	char	 session;
	char	 timePreOpen1[6];
	char	 timeOpen1[6];
	char	 timeClose1[6];
	char	 timePreOpen2[6];
	char	 timeOpen2[6];
	char	 timeClose2[6];
	char	 timePreOpen3[6];
	char	 timeOpen3[6];
	char	 timeClose3[6];
	char	 eod[6];
	char	 reserved[2];
}; // 84

// Each time Reference Data messages (553) are sent, prior to the first 553 message
// There is a 550 message per multicast group containing 553 messages

struct PACKED EnxtStartRefData
{
	EnxtMsgHeader header
	char	 indicator; // This field indicates the start of the Instrument	characteristic flow. Always takes the value 'S'.
	char	 filler[3];
};

struct PACKED EnxtEndRefData
{
	EnxtMsgHeader header
	char	 indicator; // This field indicates the end of the Instrument	characteristic flow. Always takes the value 'E'.
	char	 filler[3];
}

struct PACKED EnxtRefData
{
	EnxtMsgHeader header
	uint32_t symbol;
	uint32_t sourceSeq; // assinged by system
	uint32_t seconds; // sourceTime since midgnight
	uint32_t prevClosePrice;
	uint32_t systemID;
	uint32_t prevTradinVol; // on last trade date
	uint32_t tickSize; // only for tradable instruments
	uint16_t useconds;
	uint16_t exchangeCode;
	uint16_t instrType;
	char	 eventDate[8];
	char	 instrName;
	char	 periodIndicator; // M morning : effective today, E evening: effective next trading day
	char	 typeOfMarket;
	char	 countryCode; // Country code of location for the corporate headquarters of the company that issued the instrument.
	char	 currency[3];
	char	 instrGroupCode[3];
	char	 instrCategory;
	char	 isin[12];
	char	 lastTradingDay;
	char	 undIsin[12];
	char	 expiryDate[8];
	char	 firstSettlementDate[8];
	char	 typeOfDerivatives;
	char	 BICDepository[11];
	char	 ICB[4];
	char	 mic[4];
	char	 undWarrantIsin[12];
	char	 depositoryList[25];
	char	 mainDepository[5];
	char	 typeOfCarporateEvent[2];
	char	 timeLagEuronextUTC[5]; //Effective difference time between CET (Euronext time) and UTC.
	char	 timeLagMiFIDRegUTC[5]; //Effective time difference between	MiFID regulators and UTC
	char	 CFI[6];
	char	 quantityNotation[4]; // Specifies the nature of the amount expression used for negotiating the	instrument on the market.
	char	 indexSetOfVarPriceTick; // Tick size based on the price of instrument.
	char	 marketFeedCode[2];
	char	 MICList[24];
	char	 industryCode[4];
	char	 reserved[4];
	char	 finMktCode[3];
	char	 USindicator[7];
	char	 reserved1[2];
	uint64_t prevDayCapTraded;
	uint64_t nomMktPrice;
	uint64_t lotSize;
	uint64_t numInstrCirc;
	uint64_t sharesOut;
	uint64_t authShares;
	char	 reserved2[3];
	char	 repoIndiactor;
	uint8_t  lastAdjPriceScaleCode;
	uint8_t  typeOfUnitExp;
	uint8_t  marketIndicator;
	uint8_t  prevDayCapScaleCode;
	uint8_t  taxcode;
	uint8_t  nomMktPriceScaleCode;
	uint8_t  lotSizeScaleCode;
	uint8_t  fixPriceTickScaleCode;
	char	 menmonic[5];
	char	 tradingCode[12];
	char	 reserved3[3];
	uint32_t strikePrice;
	char	 strikeCur[3];
	uint8_t  strikeScaleCode;
	uint32_t currencyCoef;
	uint8_t  currencyCoefScaleCode;
	uint8_t  tradingCurIndicator;
	uint8_t  strikeCurIndicator;
	char	 reserved4;
};

struct PACKED EnxtSettlementice
{
	EnxtMsgHeader header
	uint32_t symbol;
	uint32_t seconds; // sourceTime since midgnight
	uint32_t sourceSeq; // assinged by system
	uint32_t price;
	uint32_t systemID;
	uint16_t useconds;
	uint8_t priceScale;
	char	reserved;
};

struct PACKED EnxtAuctionSummery
{
	EnxtMsgHeader header
	uint32_t symbol;
	uint32_t seconds; // sourceTime since midgnight
	uint32_t sourceSeq; // assinged by system
	uint32_t firstPrice;
	uint32_t lastPrice;
	uint32_t highestPrice;
	uint32_t lowestPrice;
	uint32_t cumQuantity;
	uint32_t variation;
	uint32_t systemID;
	uint16_t useconds;
	uint16_t lastPriceType;
	char	 tickDirection;
	char	 instrValPrice;
	uint8_t priceScale;
	uint8_t variationScale;
};

struct PACKED EnxtQuote
{
	EnxtMsgHeader header
	uint32_t symbol;
	uint32_t sourceSeq; // assinged by system
	uint32_t seconds; // sourceTime since midgnight
	uint32_t quoteLinkIDl;
	uint32_t askPrice;
	uint32_t askSize;
	uint32_t bidPrice;
	uint32_t bidSize;
	uint32_t systemID;
	uint16_t askOrders;
	uint16_t bidOrders;
	uint16_t useconds;
	uint8_t  askMktOrder;
	uint8_t  bidMktOrder;
	char	 quoteCond;
	uint8_t  quoteNumber;
	uint32_t priceScale;
	char	 reserved;
};

struct PACKED EnxtWeightedAvgSpread
{
	EnxtMsgHeader header
	uint32_t symbol;
	uint32_t sourceSeq; // assinged by system
	uint32_t seconds; // sourceTime since midgnight
	uint32_t buyPrice;
	uint32_t sellPrice;
	uint32_t moneyAmount;
	uint32_t systemID;
	uint16_t useconds;
	uint8_t  priceScale;
	uint8_t  moneyScale;
};

struct PACKED EnxtOrderUpdate
{
	EnxtMsgHeader header
	uint32_t symbol;
	uint32_t seconds; // sourceTime since midgnight
	uint32_t sourceSeq; // assinged by system
	uint32_t price;
	uint32_t aggrVol;
	uint32_t volume;
	uint32_t linkId;
	uint32_t orderID;
	uint32_t systemID;
	uint16_t useconds;
	uint16_t numOfOrders;
	char	 side;
	char	 OrderType;
	char	 action;
	char	 priceScale;
	uint32_t orderDate;
	uint32_t orderPrioDate;
	uint32_t orderPrioTime;
	uint16_t useconds;
	uint16_t reserved;
};

struct PACKED EnxtOrderRetransmission
{
	EnxtMsgHeader header	
	uint32_t seconds; // sourceTime since midgnight
	uint32_t sourceSeq; // assinged by system
	uint16_t tradingEngineID;
	uint8_t  instanceID;
	char	 retranseIndicator;
} // 16

struct PACKED EnxtRTindex
{
	EnxtMsgHeader header
	uint32_t symbol; 
	uint32_t seconds; // sourceTime since midgnight
	uint32_t indexLevel;
	uint32_t foreRunner;
	uint32_t sessionHigh;
	uint32_t sessionLow;
	uint32_t perctCapital;
	uint32_t varFromPrevDay;
	uint32_t systemID;
	uint16_t useconds;
	uint16_t numOfSecs;
	char	 indexCode;
	char	 typeOfLevel;
	uint8_t  indexScale;
	uint8_t  perctScale;
	uint8_t  varScale;
	uint8_t  rebroadcastInd;
	char	 reserved[2];
};

struct PACKED EnxtIndexSummery
{
	EnxtMsgHeader header
	uint32_t symbol; 
	uint32_t seconds; // sourceTime since midgnight
	uint32_t prelOpeningLevel;
	uint32_t prelOpeningTime;
	uint32_t openingLevel;
	uint32_t openingTime;
	uint32_t confirmRefLevel;
	uint32_t confirmRefTime;
	uint32_t percentVarPrevClose;
	uint32_t highLevel;
	uint32_t highTime;
	uint32_t lowLevel;
	uint32_t lowTime;
	uint32_t clearingLevel;
	uint32_t clearingTime;
	uint32_t liqTime;
	uint32_t systemID;
	uint16_t useconds;
	char	 typeOfLevel;
	uint8_t  levelScale;
	uint8_t  varScale;
	char 	 reserved[3];
};

struct PACKED EnxtIndexComp
{
	EnxtMsgHeader header
	uint32_t symbol; 
	uint32_t seconds; // sourceTime since midgnight
	uint32_t instrWeight;
	uint32_t instrFactor;
	uint32_t prevClose;
	uint32_t systemID;
	uint16_t useconds;
	uint16_t numOfComp;
	char	 isin[12];
	char	 mnemo[5];
	char	 indexFreq;
	uint8_t	 priceScale;
	uint8_t	 levelScale;
};
#endif //__EURONEXT_MESSEGES_H__
**************FILE************ ./source/0.9.0.0/feeds/euronext/EuronextLineGroup.h
#ifndef __EURONEXT_CONNECTION_H__
#define __EURONEXT_CONNECTION_H__

#include "base/BaseCommon.h"
#include "base/LineGroup.h"

#include "feeds/euronext/EuronextCommon.h"

using namespace base;

namespace euronext
{
class EuronextLineGroup : public LineGroup
{
	public:
		static LineGroup* _EuronextLineGroup(const MarketDataApplication *app, FeedHandler *feedHandler, const pugi::xml_node& lineGroupNode, LineGroupAPI *lineGroupAPI);
		EuronextLineGroup(const MarketDataApplication *app, EuronextFeedHandler *pEuronextFeedHandler, const pugi::xml_node& lineGroupNode, LineGroupAPI *lineGroupAPI);
};
}
 #endif //__EURONEXT_CONNECTION_H__
**************FILE************ ./source/0.9.0.0/feeds/euronext/EuronextFeedHandler.cpp

#include "base/MarketDataApplication.h"
#include "base/FeedHandler.h"
#include "feeds/euronext/EuronextFeedHandler.h"
#include "feeds/euronext/EuronextLineGroup.h"

using namespace euronext;
using namespace base;

//MarketDataApplication::feedHandlerConstructors[static_cast<int>(FeedID::EURONEXT)]=EuronextFeedHandler::createEuronextFeedHandler;
bool EuronextFeedHandler::_loaded = MarketDataApplication::registerFeedConstructors(FeedID::EURONEXT, _EuronextFeedHandler); 

FeedHandler* EuronextFeedHandler:: _EuronextFeedHandler(MarketDataApplication *app, const pugi::xml_node& feedHandlerNode, FeedAPI *feedAPI)
{
	return new EuronextFeedHandler(app, feedHandlerNode, feedAPI);
}

EuronextFeedHandler::EuronextFeedHandler(const MarketDataApplication *app, const pugi::xml_node & feedHandlerNode, FeedAPI *feedAPI)
	: FeedHandler(app, feedHandlerNode, FeedID::EURONEXT, EuronextLineGroup::_EuronextLineGroup, feedAPI)
{

}

**************FILE************ ./source/0.9.0.0/feeds/euronext/EuronextLineGroup.cpp

#include "feeds/euronext/EuronextFeedHandler.h"
#include "feeds/euronext/EuronextLineGroup.h"
#include "feeds/euronext/EuronextLine.h"

using namespace euronext;
using namespace base;

LineGroup* EuronextLineGroup::_EuronextLineGroup(const MarketDataApplication *app, FeedHandler *feedHandler, const pugi::xml_node& lineGroupNode, LineGroupAPI *lineGroupAPI)
{
	return new euronext::EuronextLineGroup(app, reinterpret_cast<euronext::EuronextFeedHandler *>(feedHandler), lineGroupNode, lineGroupAPI);
}

EuronextLineGroup:: EuronextLineGroup(const MarketDataApplication *app, EuronextFeedHandler *pEuronextFeedHandler, const pugi::xml_node & lineGroupNode, LineGroupAPI *lineGroupAPI)
	: LineGroup(app, pEuronextFeedHandler, lineGroupNode, EuronextLine::_EuronextLine, lineGroupAPI)
{
}

**************FILE************ ./source/0.9.0.0/feeds/euronext/EuronextFeedHandler.h
#ifndef __EURONEXT_FEEDMANAGER_H__
#define __EURONEXT_FEEDMANAGER_H__

#include "base/BaseCommon.h"
#include "base/FeedHandler.h"

using namespace base;

namespace euronext
{
	class EuronextFeedHandler: public FeedHandler
	{
		public:
			static bool _loaded;
			static FeedHandler* _EuronextFeedHandler(MarketDataApplication *app, const pugi::xml_node& feedHandlerNode, FeedAPI *feedAPI);

			EuronextFeedHandler(const MarketDataApplication *app, const pugi::xml_node & feedHandlerNode, FeedAPI *feedAPI);
	};
}
#endif //__EURONEXT_FEEDMANAGER_H__
**************FILE************ ./source/0.9.0.0/feeds/euronext/EuronextLine.cpp
#include <netinet/in.h>
#include <stdint.h>

#include "infra/logger/Logger.h"
#include "infra/thread/Thread.h"

#include "base/MarketDataApplication.h"
#include "base/ProductInfo.h"
#include "base/Packet.h"
#include "base/Order.h"
#include "base/API.h"

#include "feeds/euronext/EuronextFeedHandler.h"
#include "feeds/euronext/EuronextLineGroup.h"
#include "feeds/euronext/EuronextLine.h"
#include "feeds/euronext/EuronextMessages.h"


using namespace base;
using namespace euronext;

void EuronextLine::initializeParseFunctions()
{
	// System Messages
	parseFuncMap[uint8_t(MessageType::LoginRequest)/*0x01*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::loginRequest), false, 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::LoginResponse)/*0x02*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::loginResponse), false, 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::LogoutRequest)/*0x05*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::logoutRequest), false, 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::ReplayRequest)/*0x03*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::replayRequest), false, 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::ReplayResponse)/*0x04*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::replayResponse), false, 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SnapshotRequest)/*0x81*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::snapshotRequest), true, offsetof(struct MillSnapshotRequest, instrID), ALL_CALLBACKS);
	parseFuncMap[uint8_t(MessageType::SnapshotResponse)/*0x82*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::snapshotResponse), false, 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SnapshotComplete)/*0x83*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::snapshotComplete), false, 0, NO_CALLBACK);

	// Application messages
	parseFuncMap[uint8_t(MessageType::Time)/*0x54*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::exchangeTime), false, 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SystemEvent)/*0x53*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::systemEvent), false, 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SymDir)/*0x52*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::symDir), false, offsetof(struct MillSymDir, instrID), NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SymStatus)/*0x48*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::symStatus), true, offsetof(struct MillSymStatus, instrID), STATUS);
	parseFuncMap[uint8_t(MessageType::AddOrder)/*0x41*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::addOrder), true, offsetof(struct MillAddOrder, instrID), QUOTE|TRADE);
	parseFuncMap[uint8_t(MessageType::OrderDeleted)/*0x44*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::orderDeleted), true, offsetof(struct MillOrderDeleted, instrID), QUOTE|TRADE);
	parseFuncMap[uint8_t(MessageType::OrderModified)/*0x55*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::orderModified), true, offsetof(struct MillOrderModified, instrID), QUOTE|TRADE);
	parseFuncMap[uint8_t(MessageType::OrderBookClear)/*0x79*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::orderBookClear), true, offsetof(struct MillOrderBookClear, instrID), QUOTE);
	parseFuncMap[uint8_t(MessageType::OrderExec)/*0x45*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::orderExec), true, offsetof(struct MillOrderExec, instrID), QUOTE|TRADE);
	parseFuncMap[uint8_t(MessageType::OrderExecPxSize)/*0x43*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::orderExecPxSize), true, offsetof(struct MillOrderExecPxSize, instrID), QUOTE|TRADE);
	parseFuncMap[uint8_t(MessageType::Trade)/*0x50*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::trade), true, offsetof(struct MillTrade, instrID), TRADE);
	parseFuncMap[uint8_t(MessageType::OffBookTrade)/*0x78*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::offBookTrade), true, offsetof(struct MillOffBookTrade, instrID), TRADE);
	parseFuncMap[uint8_t(MessageType::TradeBreak)/*0x42*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::tradeBreak), true, offsetof(struct MillTradeBreak, instrID), TRADE);
	parseFuncMap[uint8_t(MessageType::AuctionInfo)/*0x49*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::auctionInfo), true, offsetof(struct MillAuctionInfo, instrID), CUSTOM);
	parseFuncMap[uint8_t(MessageType::Statistics)/*0x77*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::statistics), true, offsetof(struct MillStatistics, instrID), CUSTOM);
	parseFuncMap[uint8_t(MessageType::EnhancedTrade)/*0x90*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::enhancedTrade), true, offsetof(struct MillEnhancedTrade, instrID), TRADE);
	parseFuncMap[uint8_t(MessageType::RecoveryTrade)/*0x76*/] = MessageFunc(static_cast<NativFunc>(&EuronextLine::recoveryTrade), true, offsetof(struct MillRecoveryTrade, instrID), TRADE);
}

// System Messages
void EuronextLine::loginRequest()
{
}

void EuronextLine::loginResponse()
{
}

void EuronextLine::logoutRequest()
{
}

void EuronextLine::replayRequest()
{
}

void EuronextLine::replayResponse()
{
}

void EuronextLine::snapshotRequest()
{
}

void EuronextLine::snapshotResponse()
{
}

void EuronextLine::snapshotComplete()
{
}


// Application messages
void EuronextLine::exchangeTime()
{
	_xtSecs = reinterpret_cast<const MillTime*>(_currentMsg)->seconds; 
}

void EuronextLine::systemEvent()
{
	// Do nothing
}

void EuronextLine::symDir()
{
	const MillSymDir *symDirMsg = reinterpret_cast<const MillSymDir *>(_currentMsg);

		// routine must not be here via _processor thread
		char isin[13];
		strncpy(isin, symDirMsg->isin, sizeof(isin));
		isin[12] = '\0';

		ProductInfo *prodInfo = _feedHandler->getProductInfo(this
				, MessageType::SymDir 
				, symDirMsg->instrID
				, ""
				, isin 
				, _lastSeqNo
				, _xtSecs
				, symDirMsg->nanoSecs);

		//sub->_isActive is skipped to raise prodInfo for all symbols
		Subscription *sub = const_cast<Subscription *>(prodInfo->_sub);
	
	//Raise the callback
	sub->_prodInfo->update(this, MessageType::SymDir, _lastSeqNo, _xtSecs, symDirMsg->nanoSecs);
	(_lineAPI->*(_lineAPI->_onProductInfo))(sub->_prodInfo);

	if(hasInterest(STATUS))
	{
		if(sub)
		{
			InstrState state = InstrState::UNKNOWN;
			
			switch(symDirMsg->status)
			{
				case SymStatusEnum::ACTIVE:
					state = InstrState::OPEN;
					break;

				case SymStatusEnum::HALTED:
					state = InstrState::HALTED;
					break;

				case SymStatusEnum::SUSPENDED:
					state = InstrState::SUSPENDED;
					break;

				case SymStatusEnum::INACTIVE:
					state = InstrState::CLOSED;
					break;
			}

			sub->_status.update(this
				, sub
				, SymDir
				, _lastSeqNo
				, _xtSecs
				, symDirMsg->nanoSecs
				, state);

			//_isActive is not checked in process_rev above
			// Othrewise no other sub callback needs this check
		}
	}
}

void EuronextLine::symStatus()
{
		const MillSymStatus *symStatusMsg = reinterpret_cast<const MillSymStatus *>(_currentMsg);

		InstrState state = InstrState::UNKNOWN;
		switch(symStatusMsg->trdStatus)
		{
			case TradingStatusEnum::HALTED:
				state = InstrState::HALTED;
				break;

			case TradingStatusEnum::TRADING:
				state = InstrState::OPEN;
				break;

			case TradingStatusEnum::AUCTION_OPEN:
				state = InstrState::AUCTION_OPEN;
				break;

			case TradingStatusEnum::POSTCLOSE:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::CLOSED:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::AUCTION_CLOSE:
				state = InstrState::AUCTION_CLOSE;
				break;

			case TradingStatusEnum::AUCTION_REOPEN:
				state = InstrState::AUCTION_INTRA;
				break;

			case TradingStatusEnum::END_OF_TRADE_REPORTING:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::NO_ACTIVE_SESSION:
				state = InstrState::SUSPENDED;
				break;

			case TradingStatusEnum::END_OF_POST_CLOSE:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::PRETRADING:
				state = InstrState::PREOPEN;
				break;

			case TradingStatusEnum::CLOSING_PRICE_PUBL:
				state = InstrState::CLOSED;
				break;
		}

		_sub->_status.update(this
			, _sub
			, MessageType::SymStatus
			, _lastSeqNo
			, _xtSecs
			, symStatusMsg->nanoSecs
			, state);
}

void EuronextLine::addOrder()
{
	const MillAddOrder *addOrderMsg = reinterpret_cast<const MillAddOrder*>(_currentMsg);
	Order::Add(this
		, _sub
		, MessageType::AddOrder
		, _lastSeqNo
		, _xtSecs
		, addOrderMsg->nanoSecs
		, (addOrderMsg->px8)/100000000.0
		, addOrderMsg->quantity
		, static_cast<Side>(addOrderMsg->side)
		, addOrderMsg->orderID);
}

void EuronextLine::orderDeleted()
{

	const MillOrderDeleted *delOrderMsg = reinterpret_cast<const MillOrderDeleted *>(_currentMsg);
	
	Order::Delete(this, _sub, MessageType::OrderDeleted, _lastSeqNo, _xtSecs, delOrderMsg->nanoSecs, delOrderMsg->orderID);
}

void EuronextLine::orderModified()
{
	const MillOrderModified *modOrderMsg = reinterpret_cast<const MillOrderModified *>(_currentMsg);
	Order::ModifyPxSize(this
		, _sub
		, MessageType::OrderModified
		, _lastSeqNo
		, _xtSecs
		, modOrderMsg->nanoSecs
		, modOrderMsg->orderID
		, modOrderMsg->newPrice8 / 100000000.0
		, modOrderMsg->newQuantity);
}

void EuronextLine::orderBookClear()
{
}

void EuronextLine::orderExec()
{
	const MillOrderExec *execOrderMsg = reinterpret_cast<const MillOrderExec *>(_currentMsg);
	Order::Execute(this
			, _sub
			, MessageType::OrderExec
			, _lastSeqNo
			, _xtSecs
			, execOrderMsg->nanoSecs
			, execOrderMsg->orderID);
}

void EuronextLine::orderExecPxSize()
{

	const MillOrderExecPxSize *execPxSizeMsg = reinterpret_cast<const MillOrderExecPxSize *>(_currentMsg);
		Order::ExecutePxSize(this
			, _sub
			, MessageType::OrderExecPxSize
			, _lastSeqNo
			, _xtSecs
			, execPxSizeMsg->nanoSecs
			, execPxSizeMsg->orderID
			, execPxSizeMsg->px8/100000000.0
			, execPxSizeMsg->execQuantity
			, execPxSizeMsg->dispQuantity); 
}

void EuronextLine::trade()
{
	const MillTrade *tradeMsg = reinterpret_cast<const MillTrade*>(_currentMsg);
	_sub->_trade.update(this
			, MessageType::Trade
			, _lastSeqNo
			, _xtSecs
			, tradeMsg->nanoSecs
			, tradeMsg->px8/100000000.0
			, tradeMsg->execQuantity
			, SIDE_UNKNOWN 
			, tradeMsg->tradeID);
}

void EuronextLine::offBookTrade()
{
	//OFF book trades are not contained within the subscription object
	// Raise the local trade object
	const MillTrade *tradeMsg = reinterpret_cast<const MillTrade*>(_currentMsg);
	base::Trade trade(this
		, _sub
		, MessageType::OffBookTrade
		, _lastSeqNo
		, _xtSecs
		, tradeMsg->nanoSecs
		, (tradeMsg->px8)/100000000.0
		, tradeMsg->execQuantity
		, SIDE_UNKNOWN
		, tradeMsg->tradeID);
}

void EuronextLine::tradeBreak()
{
}

void EuronextLine::auctionInfo()
{
}

void EuronextLine::statistics()
{
}

void EuronextLine::enhancedTrade()
{
}

void EuronextLine::recoveryTrade()
{
}

Line* EuronextLine::_EuronextLine(const MarketDataApplication *app, FeedHandler *feedHandler, LineGroup *lineGroup, Thread *thread, const pugi::xml_node& lineNode, LineAPI *pLineAPI)
{
	return new EuronextLine(app, reinterpret_cast<EuronextFeedHandler *>(feedHandler), reinterpret_cast<EuronextLineGroup *>(lineGroup), thread, lineNode, pLineAPI); 
}

EuronextLine::EuronextLine(const MarketDataApplication *app, EuronextFeedHandler *euronextFeedHander, EuronextLineGroup *pEuronextLineGroup, Thread *thread, const pugi::xml_node & lineNode, LineAPI *pLineAPI)
	: Line(app, euronextFeedHander, pEuronextLineGroup, thread, lineNode, pLineAPI,static_cast<Start>(&EuronextLine::start), static_cast<ProcessPacket>(&EuronextLine::processPacket),static_cast<GetPackStats>(&EuronextLine::getPacketStats),static_cast<GetPackStatsSnap>(&EuronextLine::getPacketStatsSnap),static_cast<ReRequestMissedPackets>(&EuronextLine::reRequestMissedPackets))
{
}

void EuronextLine::_start(Line *pLine)
{
	return reinterpret_cast<EuronextLine *>(pLine)->start();
}

void EuronextLine::start()
{
	logConsole(DEBUG, "Starting the Line %s", _name);
	initializeParseFunctions();
}

//void EuronextLine::getPacketStats(ContentType& _contentType, uint64_t& _headerSeqNo, uint64_t& _endSeqNo, const char*& _firstMsg)
void EuronextLine::_getPacketStats(Line *pLine)
{
	return reinterpret_cast<EuronextLine *>(pLine)->getPacketStats();
}

void EuronextLine::getPacketStats()
{
	MillPacketHeader *pHeader = (MillPacketHeader *) _packet->packetData();
	_headerSeqNo = pHeader->seqNum;
	_endSeqNo 	 = _headerSeqNo + pHeader->messageCount - 1;
	_currentMsg  = (char *)pHeader + sizeof(MillPacketHeader);

	if(!pHeader->messageCount)
	{
		_contentType = ContentType::HB;
	}
	else
	{
		_contentType = ContentType::DATA_PACKET;
	}
}

void EuronextLine::_getPacketStatsSnap(Line *pLine)
{
	return reinterpret_cast<EuronextLine *>(pLine)->getPacketStatsSnap();
}

void EuronextLine::getPacketStatsSnap()
{
	getPacketStats();

	_isSnapStarted = false;
	_lastSeqNo = _headerSeqNo - 1;
}

bool EuronextLine::_reRequestMissedPackets(Line *pLine, uint64_t first, uint64_t last)
{
	return reinterpret_cast<EuronextLine *>(pLine)->reRequestMissedPackets(first, last);
}

bool EuronextLine::reRequestMissedPackets(uint64_t first, uint64_t last)
{
}

/**
 * Process each message within the packet
 * this function here ensures that _processPacket above is called only once per packet.
 */
void EuronextLine::processPacket()
{
	//PacketHeader has been already processed
	uint64_t i = _headerSeqNo;

	for(; i <= _lastSeqNo; i++)
	{
		//Skip the message
		_currentMsg += ((MillMessageHeader *)_currentMsg)->length;
	}

	for(; i <= _endSeqNo; i++)
	{
		_lastSeqNo++;
		uint64_t len = ((MillMessageHeader *)_currentMsg)->length;
		processMsg_rev();
		// increment the message pointer correctly including length of message header
		_currentMsg += len;	
	}

	//@TODO: assert the below check
	if(_currentMsg != _packet->packetData() + _packet->packetDataLen())
	{
		logMessage(EXCEPTION, "Wrong Packet Processing _currentMsg %p != %p [packet Start:%p + Packet Len %u]", _currentMsg, _packet->packetData()+_packet->packetDataLen(), _packet->packetData(), _packet->packetDataLen());	
	}
}



void EuronextLine::processMsg_rev()
{
	uint8_t type = (uint8_t) ((MillMessageHeader *)_currentMsg)->type;
	
	// There is _processorQueue and this message could be assigned to
	// designated thread to process
	logMessage(TRACE, "Processing Message %lu : %lu.%lu",_lastSeqNo, _packet->_recordTime.tv_sec, _packet->_recordTime.tv_nsec);
	
	if(parseFuncMap[type]._couldAssign)
	{
		if(hasInterest(parseFuncMap[type]._callbacks))
		{
			_lineGroup->_mt = _appInstance->globalClock();
			_sub = getIdSub32(parseFuncMap[type]._idOffset);
			getLatency(_lineGroup, _lineGroup->_sf);

			if(_sub)
			{	
				NativFunc func = parseFuncMap[type]._nativFunc;
				(this->*func)();
			}
		}
	}
	else // process the message locally, line/feed specefic message or for group of symbols 
	{
		_sub = nullptr;
		NativFunc func = parseFuncMap[type]._nativFunc;
		_lineGroup->_mt = _appInstance->globalClock();
		(this->*func)();
	}
}

**************FILE************ ./source/0.9.0.0/feeds/millenium
**************FILE************ ./source/0.9.0.0/feeds/millenium/MilleniumCommon.h
#ifndef __MILLENIUM_COMMON_H__
#define __MILLENIUM_COMMON_H__
namespace millenium
{
	class MilleniumFeedHandler;
	class MilleniumLineGroup;
	class MilleniumLine;
};
#endif //__MILLENIUM_COMMON_H__
**************FILE************ ./source/0.9.0.0/feeds/millenium/MilleniumLine.h
#ifndef __MILLENIUMLINEHANDLER_H__
#define __MILLENIUMLINEHANDLER_H__

#include "base/Line.h"
#include "base/Subscription.h"
#include "feeds/millenium/MilleniumCommon.h"
#include "feeds/millenium/MilleniumMessages.h"

#include "base/Base.h"

using namespace base;

namespace millenium
{
	class MilleniumLine : public Line
	{
		public:
			//@TODO: This should be static and should be called when lib gets loaded;
			void initializeParseFunctions();

			static Line* _MilleniumLine(const MarketDataApplication *, FeedHandler *, LineGroup *, Thread *, const pugi::xml_node &, LineAPI *);
			MilleniumLine(const MarketDataApplication *, MilleniumFeedHandler *, MilleniumLineGroup *, Thread *, const pugi::xml_node &, LineAPI *);

			static void _start(Line *pLine);
			void start();

			static void _getPacketStats(Line *pLine);
			void getPacketStats();

			static void _getPacketStatsSnap(Line *pLine);
			void getPacketStatsSnap();

			static bool _reRequestMissedPackets(Line *pLine, uint64_t first, uint64_t last);
			bool reRequestMissedPackets(uint64_t first, uint64_t last);

			void processPacket();
			void processMsg_rev();

			// System Messages
			void loginRequest();
			void loginResponse();
			void logoutRequest();
			void replayRequest();
			void replayResponse();
			void snapshotRequest();
			void snapshotResponse();
			void snapshotComplete();

			// Application messages
			void exchangeTime();
			void systemEvent();
			void symDir();
			void symStatus();
			void addOrder();
			void orderDeleted();
			void orderModified();
			void orderBookClear();
			void orderExec();
			void orderExecPxSize();
			void trade();
			void offBookTrade();
			void tradeBreak();
			void auctionInfo();
			void statistics();
			void enhancedTrade();
			void recoveryTrade();
	};
}

#endif //__MILLENIUMLINEHANDLER_H__
**************FILE************ ./source/0.9.0.0/feeds/millenium/MilleniumLine.cpp
#include <netinet/in.h>
#include <stdint.h>

#include "infra/logger/Logger.h"
#include "infra/thread/Thread.h"

#include "base/MarketDataApplication.h"
#include "base/ProductInfo.h"
#include "base/Packet.h"
#include "base/Order.h"
#include "base/API.h"

#include "feeds/millenium/MilleniumFeedHandler.h"
#include "feeds/millenium/MilleniumLineGroup.h"
#include "feeds/millenium/MilleniumLine.h"
#include "feeds/millenium/MilleniumMessages.h"


using namespace base;
using namespace millenium;

void MilleniumLine::initializeParseFunctions()
{
	// System Messages
	parseFuncMap[uint8_t(MessageType::LoginRequest)/*0x01*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::loginRequest), false, sizeof(MillLoginRequest), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::LoginResponse)/*0x02*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::loginResponse), false, sizeof(MillLoginResponse), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::LogoutRequest)/*0x05*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::logoutRequest), false, sizeof(MillLogoutRequest), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::ReplayRequest)/*0x03*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::replayRequest), false, sizeof(MillReplayRequest), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::ReplayResponse)/*0x04*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::replayResponse), false, sizeof(MillReplayResponse), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SnapshotRequest)/*0x81*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::snapshotRequest), true, sizeof(MillSnapshotRequest), offsetof(struct MillSnapshotRequest, instrID), ALL_CALLBACKS);
	parseFuncMap[uint8_t(MessageType::SnapshotResponse)/*0x82*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::snapshotResponse), false, sizeof(MillSnapshotResponse), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SnapshotComplete)/*0x83*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::snapshotComplete), false, sizeof(MillSnapshotComplete), 0, NO_CALLBACK);

	// Application messages
	parseFuncMap[uint8_t(MessageType::Time)/*0x54*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::exchangeTime), false, sizeof(MillTime), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SystemEvent)/*0x53*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::systemEvent), false, sizeof(MillSystemEvent), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SymDir)/*0x52*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::symDir), false, sizeof(MillSymDir), offsetof(struct MillSymDir, instrID), NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SymStatus)/*0x48*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::symStatus), true, sizeof(MillSymStatus), offsetof(struct MillSymStatus, instrID), STATUS);
	parseFuncMap[uint8_t(MessageType::AddOrder)/*0x41*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::addOrder), true, sizeof(MillAddOrder), offsetof(struct MillAddOrder, instrID), QUOTE|TRADE);
	parseFuncMap[uint8_t(MessageType::OrderDeleted)/*0x44*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::orderDeleted), true, sizeof(MillOrderDeleted), offsetof(struct MillOrderDeleted, instrID), QUOTE|TRADE);
	parseFuncMap[uint8_t(MessageType::OrderModified)/*0x55*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::orderModified), true, sizeof(MillOrderModified), offsetof(struct MillOrderModified, instrID), QUOTE|TRADE);
	parseFuncMap[uint8_t(MessageType::OrderBookClear)/*0x79*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::orderBookClear), true, sizeof(MillOrderBookClear), offsetof(struct MillOrderBookClear, instrID), QUOTE);
	parseFuncMap[uint8_t(MessageType::OrderExec)/*0x45*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::orderExec), true, sizeof(MillOrderExec), offsetof(struct MillOrderExec, instrID), QUOTE|TRADE);
	parseFuncMap[uint8_t(MessageType::OrderExecPxSize)/*0x43*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::orderExecPxSize), true, sizeof(MillOrderExecPxSize), offsetof(struct MillOrderExecPxSize, instrID), QUOTE|TRADE);
	parseFuncMap[uint8_t(MessageType::Trade)/*0x50*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::trade), true, sizeof(MillTrade), offsetof(struct MillTrade, instrID), TRADE);
	parseFuncMap[uint8_t(MessageType::OffBookTrade)/*0x78*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::offBookTrade), true, sizeof(MillOffBookTrade), offsetof(struct MillOffBookTrade, instrID), TRADE);
	parseFuncMap[uint8_t(MessageType::TradeBreak)/*0x42*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::tradeBreak), true, sizeof(MillTradeBreak), offsetof(struct MillTradeBreak, instrID), TRADE);
	parseFuncMap[uint8_t(MessageType::AuctionInfo)/*0x49*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::auctionInfo), true, sizeof(MillAuctionInfo), offsetof(struct MillAuctionInfo, instrID), CUSTOM);
	parseFuncMap[uint8_t(MessageType::Statistics)/*0x77*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::statistics), true, sizeof(MillStatistics), offsetof(struct MillStatistics, instrID), CUSTOM);
	parseFuncMap[uint8_t(MessageType::EnhancedTrade)/*0x90*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::enhancedTrade), true, sizeof(MillEnhancedTrade), offsetof(struct MillEnhancedTrade, instrID), TRADE);
	parseFuncMap[uint8_t(MessageType::RecoveryTrade)/*0x76*/] = MessageFunc(static_cast<NativFunc>(&MilleniumLine::recoveryTrade), true, sizeof(MillRecoveryTrade), offsetof(struct MillRecoveryTrade, instrID), TRADE);
}

// System Messages
void MilleniumLine::loginRequest()
{
}

void MilleniumLine::loginResponse()
{
}

void MilleniumLine::logoutRequest()
{
}

void MilleniumLine::replayRequest()
{
}

void MilleniumLine::replayResponse()
{
}

void MilleniumLine::snapshotRequest()
{
}

void MilleniumLine::snapshotResponse()
{
}

void MilleniumLine::snapshotComplete()
{
}


// Application messages
void MilleniumLine::exchangeTime()
{
	_xtSecs = reinterpret_cast<const MillTime*>(_currentMsg)->seconds; 
}

void MilleniumLine::systemEvent()
{
	// Do nothing
}

void MilleniumLine::symDir()
{
	const MillSymDir *symDirMsg = reinterpret_cast<const MillSymDir *>(_currentMsg);

		// routine must not be here via _processor thread
		char isin[13];
		strncpy(isin, symDirMsg->isin, sizeof(isin));
		isin[12] = '\0';

		ProductInfo *prodInfo = _feedHandler->getProductInfo(this
				, MessageType::SymDir 
				, symDirMsg->instrID
				, ""
				, isin 
				, _lastSeqNo
				, _xtSecs
				, symDirMsg->nanoSecs);

		//sub->_isActive is skipped to raise prodInfo for all symbols
		Subscription *sub = const_cast<Subscription *>(prodInfo->_sub);
	
	//Raise the callback
	sub->_prodInfo->update(this, MessageType::SymDir, _lastSeqNo, _xtSecs, symDirMsg->nanoSecs);
	(_lineAPI->*(_lineAPI->_onProductInfo))(sub->_prodInfo);

	if(hasInterest(STATUS))
	{
		if(sub)
		{
			InstrState state = InstrState::UNKNOWN;
			
			switch(symDirMsg->status)
			{
				case SymStatusEnum::ACTIVE:
					state = InstrState::OPEN;
					break;

				case SymStatusEnum::HALTED:
					state = InstrState::HALTED;
					break;

				case SymStatusEnum::SUSPENDED:
					state = InstrState::SUSPENDED;
					break;

				case SymStatusEnum::INACTIVE:
					state = InstrState::CLOSED;
					break;
			}

			sub->_status.update(this
				, sub
				, SymDir
				, _lastSeqNo
				, _xtSecs
				, symDirMsg->nanoSecs
				, state);

			//_isActive is not checked in process_rev above
			// Othrewise no other sub callback needs this check
		}
	}
}

void MilleniumLine::symStatus()
{
		const MillSymStatus *symStatusMsg = reinterpret_cast<const MillSymStatus *>(_currentMsg);

		InstrState state = InstrState::UNKNOWN;
		switch(symStatusMsg->trdStatus)
		{
			case TradingStatusEnum::HALTED:
				state = InstrState::HALTED;
				break;

			case TradingStatusEnum::TRADING:
				state = InstrState::OPEN;
				break;

			case TradingStatusEnum::AUCTION_OPEN:
				state = InstrState::AUCTION_OPEN;
				break;

			case TradingStatusEnum::POSTCLOSE:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::CLOSED:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::AUCTION_CLOSE:
				state = InstrState::AUCTION_CLOSE;
				break;

			case TradingStatusEnum::AUCTION_REOPEN:
				state = InstrState::AUCTION_INTRA;
				break;

			case TradingStatusEnum::END_OF_TRADE_REPORTING:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::NO_ACTIVE_SESSION:
				state = InstrState::SUSPENDED;
				break;

			case TradingStatusEnum::END_OF_POST_CLOSE:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::PRETRADING:
				state = InstrState::PREOPEN;
				break;

			case TradingStatusEnum::CLOSING_PRICE_PUBL:
				state = InstrState::CLOSED;
				break;
		}

		_sub->_status.update(this
			, _sub
			, MessageType::SymStatus
			, _lastSeqNo
			, _xtSecs
			, symStatusMsg->nanoSecs
			, state);
}

void MilleniumLine::addOrder()
{
	const MillAddOrder *addOrderMsg = reinterpret_cast<const MillAddOrder*>(_currentMsg);
	Order::Add(this
		, _sub
		, MessageType::AddOrder
		, _lastSeqNo
		, _xtSecs
		, addOrderMsg->nanoSecs
		, (addOrderMsg->px8)/100000000.0
		, addOrderMsg->quantity
		, static_cast<Side>(addOrderMsg->side)
		, addOrderMsg->orderID);
}

void MilleniumLine::orderDeleted()
{

	const MillOrderDeleted *delOrderMsg = reinterpret_cast<const MillOrderDeleted *>(_currentMsg);
	
	Order::Delete(this, MessageType::OrderDeleted, _lastSeqNo, _xtSecs, delOrderMsg->nanoSecs, delOrderMsg->orderID);
}

void MilleniumLine::orderModified()
{
	const MillOrderModified *modOrderMsg = reinterpret_cast<const MillOrderModified *>(_currentMsg);
	Order::ModifyPxSize(this
		, MessageType::OrderModified
		, _lastSeqNo
		, _xtSecs
		, modOrderMsg->nanoSecs
		, modOrderMsg->orderID
		, modOrderMsg->newPrice8 / 100000000.0
		, modOrderMsg->newQuantity);
}

void MilleniumLine::orderBookClear()
{
}

void MilleniumLine::orderExec()
{
	const MillOrderExec *execOrderMsg = reinterpret_cast<const MillOrderExec *>(_currentMsg);
	Order::Execute(this
			, MessageType::OrderExec
			, _lastSeqNo
			, _xtSecs
			, execOrderMsg->nanoSecs
			, execOrderMsg->orderID);
}

void MilleniumLine::orderExecPxSize()
{

	const MillOrderExecPxSize *execPxSizeMsg = reinterpret_cast<const MillOrderExecPxSize *>(_currentMsg);
		Order::ExecutePxSize(this
			, MessageType::OrderExecPxSize
			, _lastSeqNo
			, _xtSecs
			, execPxSizeMsg->nanoSecs
			, execPxSizeMsg->orderID
			, execPxSizeMsg->px8/100000000.0
			, execPxSizeMsg->execQuantity
			, execPxSizeMsg->dispQuantity); 
}

void MilleniumLine::trade()
{
	const MillTrade *tradeMsg = reinterpret_cast<const MillTrade*>(_currentMsg);
	_sub->_trade.update(this
			, MessageType::Trade
			, _lastSeqNo
			, _xtSecs
			, tradeMsg->nanoSecs
			, tradeMsg->px8/100000000.0
			, tradeMsg->execQuantity
			, SIDE_UNKNOWN 
			, tradeMsg->tradeID);
}

void MilleniumLine::offBookTrade()
{
	//OFF book trades are not contained within the subscription object
	// Raise the local trade object
	const MillTrade *tradeMsg = reinterpret_cast<const MillTrade*>(_currentMsg);
	base::Trade trade(this
		, _sub
		, MessageType::OffBookTrade
		, _lastSeqNo
		, _xtSecs
		, tradeMsg->nanoSecs
		, (tradeMsg->px8)/100000000.0
		, tradeMsg->execQuantity
		, SIDE_UNKNOWN
		, tradeMsg->tradeID);
}

void MilleniumLine::tradeBreak()
{
}

void MilleniumLine::auctionInfo()
{
}

void MilleniumLine::statistics()
{
}

void MilleniumLine::enhancedTrade()
{
}

void MilleniumLine::recoveryTrade()
{
}

Line* MilleniumLine::_MilleniumLine(const MarketDataApplication *app, FeedHandler *feedHandler, LineGroup *lineGroup, Thread *thread, const pugi::xml_node& lineNode, LineAPI *pLineAPI)
{
	return new MilleniumLine(app, reinterpret_cast<MilleniumFeedHandler *>(feedHandler), reinterpret_cast<MilleniumLineGroup *>(lineGroup), thread, lineNode, pLineAPI); 
}

MilleniumLine::MilleniumLine(const MarketDataApplication *app, MilleniumFeedHandler *milleniumFeedHander, MilleniumLineGroup *pMilleniumLineGroup, Thread *thread, const pugi::xml_node & lineNode, LineAPI *pLineAPI)
	: Line(app, milleniumFeedHander, pMilleniumLineGroup, thread, lineNode, pLineAPI,static_cast<Start>(&MilleniumLine::start), static_cast<ProcessPacket>(&MilleniumLine::processPacket),static_cast<GetPackStats>(&MilleniumLine::getPacketStats),static_cast<GetPackStatsSnap>(&MilleniumLine::getPacketStatsSnap),static_cast<ReRequestMissedPackets>(&MilleniumLine::reRequestMissedPackets))
{
}

void MilleniumLine::_start(Line *pLine)
{
	return reinterpret_cast<MilleniumLine *>(pLine)->start();
}

void MilleniumLine::start()
{
	logConsole(DEBUG, "Starting the Line %s", _name);
	initializeParseFunctions();
}

//void MilleniumLine::getPacketStats(ContentType& _contentType, uint64_t& _headerSeqNo, uint64_t& _endSeqNo, const char*& _firstMsg)
void MilleniumLine::_getPacketStats(Line *pLine)
{
	return reinterpret_cast<MilleniumLine *>(pLine)->getPacketStats();
}

void MilleniumLine::getPacketStats()
{
	MillPacketHeader *pHeader = (MillPacketHeader *) _packet->packetData();
	_headerSeqNo = pHeader->seqNum;
	_endSeqNo 	 = _headerSeqNo + pHeader->messageCount - 1;
	_currentMsg  = (char *)pHeader + sizeof(MillPacketHeader);

	if(!pHeader->messageCount)
	{
		_contentType = ContentType::HB;
	}
	else
	{
		_contentType = ContentType::DATA_PACKET;
	}
}

void MilleniumLine::_getPacketStatsSnap(Line *pLine)
{
	return reinterpret_cast<MilleniumLine *>(pLine)->getPacketStatsSnap();
}

void MilleniumLine::getPacketStatsSnap()
{
	getPacketStats();

	_isSnapStarted = false;
	_lastSeqNo = _headerSeqNo - 1;
}

bool MilleniumLine::_reRequestMissedPackets(Line *pLine, uint64_t first, uint64_t last)
{
	return reinterpret_cast<MilleniumLine *>(pLine)->reRequestMissedPackets(first, last);
}

bool MilleniumLine::reRequestMissedPackets(uint64_t first, uint64_t last)
{
}

/**
 * Process each message within the packet
 * this function here ensures that _processPacket above is called only once per packet.
 */
void MilleniumLine::processPacket()
{
	//PacketHeader has been already processed
	uint64_t i = _headerSeqNo;

	for(; i <= _lastSeqNo; i++)
	{
		//Skip the message
		_currentMsg += ((MillMessageHeader *)_currentMsg)->length;
	}

	for(; i <= _endSeqNo; i++)
	{
		_lastSeqNo++;
		uint64_t len = ((MillMessageHeader *)_currentMsg)->length;
		processMsg_rev();
		// increment the message pointer correctly including length of message header
		_currentMsg += len;	
	}

	//@TODO: assert the below check
	if(_currentMsg != _packet->packetData() + _packet->packetDataLen())
	{
		logMessage(EXCEPTION, "Wrong Packet Processing _currentMsg %p != %p [packet Start:%p + Packet Len %u]", _currentMsg, _packet->packetData()+_packet->packetDataLen(), _packet->packetData(), _packet->packetDataLen());	
	}
}

void MilleniumLine::processMsg_rev()
{
	uint8_t type = (uint8_t) ((MillMessageHeader *)_currentMsg)->type;
	
	// There is _processorQueue and this message could be assigned to
	// designated thread to process
	logMessage(TRACE, "Processing Message %lu : %lu.%lu",_lastSeqNo, _packet->_recordTime.tv_sec, _packet->_recordTime.tv_nsec);
	
	if(parseFuncMap[type]._couldAssign)
	{
		if(hasInterest(parseFuncMap[type]._callbacks))
		{
			_lineGroup->_mt = globalClock();
#ifdef __SUBMAP_LATENCTY__
			_sub = getIdSub32(parseFuncMap[type]._idOffset);
			getLatency(_lineGroup, _lineGroup->_sf, _lineGroup->_mt);
#else
			_sub = getIdSub32(parseFuncMap[type]._idOffset);
#endif
			if(_sub)
			{	
				NativFunc func = parseFuncMap[type]._nativFunc;
				(this->*func)();
			}
		}
	}
	else // process the message locally, line/feed specefic message or for group of symbols 
	{
		_sub = nullptr;
		NativFunc func = parseFuncMap[type]._nativFunc;
		_lineGroup->_mt = globalClock();
		(this->*func)();
	}
}

**************FILE************ ./source/0.9.0.0/feeds/millenium/MilleniumFeedHandler.cpp

#include "base/MarketDataApplication.h"
#include "base/FeedHandler.h"
#include "feeds/millenium/MilleniumFeedHandler.h"
#include "feeds/millenium/MilleniumLineGroup.h"

using namespace millenium;
using namespace base;

//MarketDataApplication::feedHandlerConstructors[static_cast<int>(FeedID::MILLENIUM)]=MilleniumFeedHandler::createMilleniumFeedHandler;
bool MilleniumFeedHandler::_loaded = MarketDataApplication::registerFeedConstructors(FeedID::MILLENIUM, _MilleniumFeedHandler); 

FeedHandler* MilleniumFeedHandler:: _MilleniumFeedHandler(MarketDataApplication *app, const pugi::xml_node& feedHandlerNode, FeedAPI *feedAPI)
{
	return new MilleniumFeedHandler(app, feedHandlerNode, feedAPI);
}

MilleniumFeedHandler::MilleniumFeedHandler(const MarketDataApplication *app, const pugi::xml_node & feedHandlerNode, FeedAPI *feedAPI)
	: FeedHandler(app, feedHandlerNode, FeedID::MILLENIUM, MilleniumLineGroup::_MilleniumLineGroup, feedAPI)
{

}

**************FILE************ ./source/0.9.0.0/feeds/millenium/MilleniumMessages.h
#ifndef __MILLENIUM_MESSEGES_H__
#define __MILLENIUM_MESSEGES_H__

#include <stdint.h>

#define PACKED __attribute__((packed))

enum MessageType
{
	// System Messages
	LoginRequest = 0x01,
	LoginResponse = 0x02,
	LogoutRequest = 0x05,
	ReplayRequest = 0x03,
	ReplayResponse = 0x04,
	SnapshotRequest = 0x81,
	SnapshotResponse = 0x82,
	SnapshotComplete = 0x83,
	
	// Application messages
	Time = 0x54,
	SystemEvent = 0x53,
	SymDir = 0x52,
	SymStatus = 0x48,
	AddOrder = 0x41,
	OrderDeleted = 0x44,
	OrderModified = 0x55,
	OrderBookClear = 0x79,
	OrderExec = 0x45,
	OrderExecPxSize = 0x43,
	Trade = 0x50,
	OffBookTrade = 0x78,
	TradeBreak = 0x42,
	AuctionInfo = 0x49,
	Statistics = 0x77,
	EnhancedTrade = 0x90,
	RecoveryTrade = 0x76,
};

struct PACKED MillPacketHeader 
{
	uint16_t	length;
	uint8_t		messageCount;
	char		marketDataGroup;
	uint32_t	seqNum;
};

struct PACKED MillMessageHeader
{
	uint8_t length;
	uint8_t type; // MessageType
};

struct PACKED MillLoginRequest
{
	MillMessageHeader header;
	char username[6];
	char passowrd[10];
};

enum class LoginResponseType : char
{
	LOGIN_ACCEPTED	= 'A',
	COMPID_INACTIVE_LOCKED = 'a',
	LOGIN_LIMIT_REACHED = 'b',
	SERVICE_UNAVAILABLE = 'c',
	CONCURRENT_LIMIT_REACHED = 'd',
	FAILED_OTHER = 'e'
};

struct PACKED MillLoginResponse
{
	MillMessageHeader header;
	LoginResponseType status;
};

struct PACKED MillLogoutRequest
{
	MillMessageHeader header;
	//empty struct
};

struct PACKED MillReplayRequest
{
	MillMessageHeader header;
	char		marketDataGroup;
	uint32_t	firstMessage;
	uint16_t	count;
};

enum class ReplayResponseType: char
{
	REQUEST_ACCEPTED = 'A',
	REQUEST_LIMIT_REACHED = 'D',
	INVALID_MARKET_DATA_GROUP = 'I',
	OUT_OF_RANGE = 'O',
	REPLAY_UNAVAILABLE = 'U',
	CONCURRENT_LIMIT_REACHED = 'c',
	UNSUPPORTED_MESSAGE_TYPE = 'd',
	FAILED_OTHER = 'e'
};

struct PACKED MillReplayResponse
{
	MillMessageHeader header;
	char		marketDataGroup;
	uint32_t	firstMessage;
	uint16_t	count;
	ReplayResponseType status;
};

enum class SnapTypeEnum : uint8_t
{
	ORDER_BOOK = 0,
	SYMBOL_STATUS = 1,
	INSTRUMENT = 2,
	TRADES = 3,
	STATISTICS = 4,
	AUCTION_INFO = 6
};

struct PACKED MillSnapshotRequest
{
	MillMessageHeader header;
	uint32_t seqNum;
	char	 segment[6];
	uint32_t instrID;
	char 	 subBook;
	SnapTypeEnum snapType;
	uint64_t recFromTime;
	uint32_t reqID;
};

enum class SnapshotResponseStatus : uint8_t
{
	REQUEST_ACCEPTED = 'A',
	OUT_OF_RANGE = 'O',
	SNAPSHOT_UNAVAILABLE = 'U',
	INVALID_SYMBOL_SEGMENT = 'a',
	REQUEST_LIMIT_REACHED = 'b',
	CONCURRENT_LIMIT_REACHED = 'c',
	UNSUPPORTED_MESSAGE_TYPE = 'd',
	FAILED_OTHER = 'e'
};

struct PACKED MillSnapshotResponse
{
	MillMessageHeader header;
	uint32_t seqNum;
	uint32_t ordCount;
	SnapshotResponseStatus status;
	SnapTypeEnum snapType;
	uint32_t reqID;
};

enum TradingStatusEnum : char 
{
	HALTED = 'H',
	TRADING = 'T',
	AUCTION_OPEN = 'a',
	POSTCLOSE = 'b',
	CLOSED	= 'c',
	AUCTION_CLOSE = 'd',
	AUCTION_REOPEN = 'e',
	END_OF_TRADE_REPORTING = 'v',
	NO_ACTIVE_SESSION = 'w',
	END_OF_POST_CLOSE = 'x',
	PRETRADING = 'y',
	CLOSING_PRICE_PUBL = 'z'
};

struct PACKED MillSnapshotComplete
{
	MillMessageHeader header;
	uint32_t seqNum;
	char	 segment[6];
	uint32_t instrID;
	uint8_t	 reserved;
	uint8_t	 subBook;
	TradingStatusEnum trdStatus;
	SnapTypeEnum snapType;
	uint32_t reqID;
};

/*
 * Number of seconds since midnight. Midnight is defined in terms of the
 * local time for the server
 */
struct PACKED MillTime
{
	MillMessageHeader header;
	uint32_t seconds;
};

enum class EventCodeEnum : char
{
	END_OF_DAY = 'C',
	START_OF_DAY = 'O',
};

struct PACKED MillSystemEvent
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	char	eventCode;
};

enum class SymStatusEnum : char 
{
	ACTIVE = ' ', // It is going to trade
	HALTED = 'H', // It is halted as of now
	SUSPENDED = 'S', // It is suspended state
	INACTIVE = 'a' // Not going to trade
};

struct PACKED MillSymDir
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint32_t instrID;
	uint8_t reserved[2];
	SymStatusEnum status;
	char 	isin[12];
	uint32_t pxBandTol4;
	uint32_t dynCirctBrkrTol4;
	uint32_t stCirctBrkrTol4;
	char	segment[6];
	char	reserved2[6];
	char	currency[3];
	char	reserved3[40];
};

enum class HaltReasonEnum : uint32_t
{
	PRICE_MOVEMENT = '1',
	RECEIVED_ANNOUNCEMENT = '2',
	ANTICIPATION_OF_ANNCMNT = '3',
	SYSTEM_PROBLEMS = '4',
	OTHER = '5',
	REFERENCE_DATA_UPDATE = '6',
	INSTRUMENT_CRCT_BRKR_TRIPPED = 0x00310031, // 101
	MATCHING_PARTITION_SUSPENDED = 0x39393938, // 9998
	SYSTEM_SUSPENDED			 = 0x39393939, // 9999
	REASON_NOT_AVAILABLE		 = ' ', //space
};

enum class SessionChangeReasonEnum : uint8_t
{
	SCHEDULED_TRANSITION = 0,
	EXTND_BY_MKT_SURVEILLANCE = 1,
	SHORTENED_BY_MKT_SURVEILLANCE = 2,
	MKT_ORDER_IMBALANCE = 3,
	PRICE_OUTSIDE_RANGE = 4,
	CIRCUIT_BREAKER_TRIPPED = 5,
	UNAVAILABLE = 9
};

enum class SubBookEnum : uint8_t
{
	REGULAR = 1,
	OFF_BOOK = 2
};

struct PACKED MillSymStatus
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint32_t instrID;
	char	 reserved[2];
	TradingStatusEnum trdStatus; 
	uint8_t  reserved1;
	HaltReasonEnum haltReason;
	SessionChangeReasonEnum sessionChgReason;
	SubBookEnum subBook;
};

enum SideEnum
{
	BUY = 'B',
	SELL = 'S'
};

struct PACKED MillAddOrder
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t orderID;
	char	 side;
	uint64_t quantity;
	uint32_t instrID;
	char	 reserved[2];
	uint64_t px8;
	uint8_t	 flags;
	char	 reserved2[8];
};

struct PACKED MillOrderDeleted 
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t orderID;
	char	 reserved;
	uint32_t instrID;
};

struct PACKED MillOrderModified
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t orderID;
	uint64_t newQuantity;
	uint64_t newPrice8;
	uint8_t	 flags;	
	uint32_t instrID;
	char	 reserved[8];
};

struct PACKED MillOrderBookClear
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint32_t instrID;
	char	 reserved[3];
};

struct PACKED MillOrderExec
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t orderID;
	uint64_t execQuantity;
	uint64_t tradeID;
	uint32_t instrID;
};

struct PACKED MillOrderExecPxSize
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t orderID;
	uint64_t execQuantity;
	uint64_t dispQuantity;
	uint64_t tradeID;
	char	 printable;
	uint64_t px8;
	uint32_t instrID;
	char	 reserved[8];
};

struct PACKED MillTrade
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t execQuantity;
	uint32_t instrID;
	char	 reserved[2];
	uint64_t px8;
	uint64_t tradeID;
	char	 reserved1[30];
};

struct PACKED MillOffBookTrade 
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t execQuantity;
	uint32_t instrID;
	char	 reserved[2];
	uint64_t px8;
	uint64_t tradeID;
	char	 tradeType[4];
	char 	 tradeTime[8]; // MMDDYYYY
	char	 tradeDate[8]; // HH:MM:SS
	char	 tradedCurrency[4];
	uint64_t originalPrice8;
	char	 execVenue[5];
	char	 flag;
	char	 isin[12];
	char	 reserved1[13];
};

enum class TradeTypeEnum : char
{
	ONBOOK_TRADE = 'T',
	OFFBOOK_TRADE = 'N'
};

struct PACKED MillTradeBreak 
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t tradeID;
	TradeTypeEnum tradeType;
	uint32_t instrID;
	char	 isin[12];
};

enum class AuctionType : char
{
	AUCTION_REOPEN = 'A',
	AUCTION_CLOSE = 'C',
	AUCTION_OPEN = 'O',
};

struct PACKED MillAuctionInfo
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t pairedQuantity;
	char	 reserved[9];
	uint32_t instrID;
	char	 reserved1[2];
	uint64_t px8;
	char	 auctionType;
};

enum class StatisticsTypeEnum : char
{
	OPEN_PRICE = 'O',
	CLOSE_PRICE = 'C',
	PREV_CLOSE_PRICE = 'P'
};

enum class PriceIndEnum : char
{
	AUCTION_TRADE = 'A',
	REGULAR_TRADE = 'B',
	MID_OF_BBO	  = 'C',
	LAST_REGULAR_TRADE = 'D',
	LAST_AUCTION_TRADE = 'E',
	MANUAL = 'F',
	PREV_CLOSE =  'I',
	BEST_BID = 'U',
	BEST_OFFER = 'V',
	NONE = 'W', //used when publishing previous close px
	PRICE_UNAVAILABLE = 'Z' //used when a value is cleared manually by market surveillance
};

struct PACKED MillStatistics 
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint32_t instrID;
	char	 reserved[2];
	StatisticsTypeEnum statistics;
	uint64_t px8;
	char	 openCloseIndicator;
	char	 reserved1;
};

enum class ActionTypeEnum : char
{
	CANCELLED_TRADE = 'C',
	TRADE = 'N'
};

struct PACKED MillEnhancedTrade 
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t execQuantity;
	uint32_t instrID;
	char	 reserved[2];
	uint64_t px8;
	char	 reserved1[8];
	char	 auctionType;
	char	 offBookTradeType[4];
	uint64_t tradeID;
	char 	 tradeTime[8]; // MMDDYYYY
	char	 tradeDate[8]; // HH:MM:SS
	ActionTypeEnum actionType;
	char	 tradedCurrency[4];
	uint64_t originalPrice8;
	char	 execVenue[5];
	char	 flag;
	char	 reserved2[29];
	char	 buyerID[11];
	char	 sellerID[11];
};

struct PACKED MillRecoveryTrade 
{
	MillMessageHeader header;
	uint32_t nanoSecs;
	uint64_t execQuantity;
	uint32_t instrID;
	char	 reserved[2];
	uint64_t px8;
	uint64_t tradeID;
	char	 auctionType;
	char	 offBookTradeType[4];
	char 	 tradeTime[8]; // MMDDYYYY
	char	 tradeDate[8]; // HH:MM:SS
	char	 actionType;
	char	 tradedCurrency[4];
	uint64_t originalPrice8;
	char	 execVenue[5];
	char	 flag;
	char	 reserved1[29];
	char	 buyerID[11];
	char	 sellerID[11];
};
#endif //__MILLENIUM_MESSEGES_H__
**************FILE************ ./source/0.9.0.0/feeds/millenium/MilleniumFeedHandler.h
#ifndef __MILLENIUM_FEEDMANAGER_H__
#define __MILLENIUM_FEEDMANAGER_H__

#include "base/BaseCommon.h"
#include "base/FeedHandler.h"

using namespace base;

namespace millenium
{
	class MilleniumFeedHandler: public FeedHandler
	{
		public:
			static bool _loaded;
			static FeedHandler* _MilleniumFeedHandler(MarketDataApplication *app, const pugi::xml_node& feedHandlerNode, FeedAPI *feedAPI);

			MilleniumFeedHandler(const MarketDataApplication *app, const pugi::xml_node & feedHandlerNode, FeedAPI *feedAPI);
	};
}
#endif //__MILLENIUM_FEEDMANAGER_H__
**************FILE************ ./source/0.9.0.0/feeds/millenium/MilleniumLineGroup.h
#ifndef __MILLENIUM_CONNECTION_H__
#define __MILLENIUM_CONNECTION_H__

#include "base/BaseCommon.h"
#include "base/LineGroup.h"

#include "feeds/millenium/MilleniumCommon.h"

using namespace base;

namespace millenium
{
class MilleniumLineGroup : public LineGroup
{
	public:
		static LineGroup* _MilleniumLineGroup(const MarketDataApplication *app, FeedHandler *feedHandler, const pugi::xml_node& lineGroupNode, LineGroupAPI *lineGroupAPI);
		MilleniumLineGroup(const MarketDataApplication *app, MilleniumFeedHandler *pMilleniumFeedHandler, const pugi::xml_node& lineGroupNode, LineGroupAPI *lineGroupAPI);
};
}
 #endif //__MILLENIUM_CONNECTION_H__
**************FILE************ ./source/0.9.0.0/feeds/millenium/MilleniumLineGroup.cpp

#include "feeds/millenium/MilleniumFeedHandler.h"
#include "feeds/millenium/MilleniumLineGroup.h"
#include "feeds/millenium/MilleniumLine.h"

using namespace millenium;
using namespace base;

LineGroup* MilleniumLineGroup::_MilleniumLineGroup(const MarketDataApplication *app, FeedHandler *feedHandler, const pugi::xml_node& lineGroupNode, LineGroupAPI *lineGroupAPI)
{
	return new millenium::MilleniumLineGroup(app, reinterpret_cast<millenium::MilleniumFeedHandler *>(feedHandler), lineGroupNode, lineGroupAPI);
}

MilleniumLineGroup:: MilleniumLineGroup(const MarketDataApplication *app, MilleniumFeedHandler *pMilleniumFeedHandler, const pugi::xml_node & lineGroupNode, LineGroupAPI *lineGroupAPI)
	: LineGroup(app, pMilleniumFeedHandler, lineGroupNode, MilleniumLine::_MilleniumLine, lineGroupAPI)
{
}

**************FILE************ ./source/0.9.0.0/feeds/omxnordic
**************FILE************ ./source/0.9.0.0/feeds/omxnordic/OMXNordicFeedHandler.cpp

#include "base/MarketDataApplication.h"
#include "base/FeedHandler.h"
#include "feeds/omxnordic/OMXNordicFeedHandler.h"
#include "feeds/omxnordic/OMXNordicLineGroup.h"

using namespace omxnordic;
using namespace base;

//MarketDataApplication::feedHandlerConstructors[static_cast<int>(FeedID::OMXNORDIC)]=OMXNordicFeedHandler::createOMXNordicFeedHandler;
bool OMXNordicFeedHandler::_loaded = MarketDataApplication::registerFeedConstructors(FeedID::OMXNORDIC, _OMXNordicFeedHandler); 

FeedHandler* OMXNordicFeedHandler:: _OMXNordicFeedHandler(MarketDataApplication *app, const pugi::xml_node& feedHandlerNode, FeedAPI *feedAPI)
{
	return new OMXNordicFeedHandler(app, feedHandlerNode, feedAPI);
}

OMXNordicFeedHandler::OMXNordicFeedHandler(const MarketDataApplication *app, const pugi::xml_node & feedHandlerNode, FeedAPI *feedAPI)
	: FeedHandler(app, feedHandlerNode, FeedID::OMXNORDIC, OMXNordicLineGroup::_OMXNordicLineGroup, feedAPI)
{

}

**************FILE************ ./source/0.9.0.0/feeds/omxnordic/OMXNordicLine.h
#ifndef __OMXNORDICLINEHANDLER_H__
#define __OMXNORDICLINEHANDLER_H__

#include "base/Line.h"
#include "base/Subscription.h"
#include "feeds/omxnordic/OMXNordicCommon.h"
#include "feeds/omxnordic/OMXNordicMessages.h"

#include "base/Base.h"

using namespace base;

namespace omxnordic
{
	class OMXNordicLine : public Line
	{
		public:
			//@TODO: This should be static and should be called when lib gets loaded;
			void initializeParseFunctions();

			static Line* _OMXNordicLine(const MarketDataApplication *, FeedHandler *, LineGroup *, Thread *, const pugi::xml_node &, LineAPI *);
			OMXNordicLine(const MarketDataApplication *, OMXNordicFeedHandler *, OMXNordicLineGroup *, Thread *, const pugi::xml_node &, LineAPI *);

			static void _start(Line *pLine);
			void start();

			static void _getPacketStats(Line *pLine);
			void getPacketStats();

			static void _getPacketStatsSnap(Line *pLine);
			void getPacketStatsSnap();

			static bool _reRequestMissedPackets(Line *pLine, uint64_t first, uint64_t last);
			bool reRequestMissedPackets(uint64_t first, uint64_t last);

			void processPacket();
			void processMsg_rev();

			// Application messages
			void exchangeTime();
			void exchangeMSeconds();
			void systemEvent();
			void stateMessage();
			void refData();
			void tradingState();

			void addOrder();
			void addOrderMPID();
			void orderExec();
			void orderExecPx();
			void orderCancel();
			void orderDelete();
			void trade();
			void crossTrade();
			void brokenTrade();
			void imbalance();
	};
}

#endif //__OMXNORDICLINEHANDLER_H__
**************FILE************ ./source/0.9.0.0/feeds/omxnordic/OMXNordicLineGroup.h
#ifndef __OMXNORDIC_CONNECTION_H__
#define __OMXNORDIC_CONNECTION_H__

#include "base/BaseCommon.h"
#include "base/LineGroup.h"

#include "feeds/omxnordic/OMXNordicCommon.h"

using namespace base;

namespace omxnordic
{
class OMXNordicLineGroup : public LineGroup
{
	public:
		static LineGroup* _OMXNordicLineGroup(const MarketDataApplication *app, FeedHandler *feedHandler, const pugi::xml_node& lineGroupNode, LineGroupAPI *lineGroupAPI);
		OMXNordicLineGroup(const MarketDataApplication *app, OMXNordicFeedHandler *pOMXNordicFeedHandler, const pugi::xml_node& lineGroupNode, LineGroupAPI *lineGroupAPI);
};
}
 #endif //__OMXNORDIC_CONNECTION_H__
**************FILE************ ./source/0.9.0.0/feeds/omxnordic/OMXNordicLine.cpp
#include <netinet/in.h>
#include <stdint.h>

#include "infra/logger/Logger.h"
#include "infra/thread/Thread.h"

#include "base/MarketDataApplication.h"
#include "base/ProductInfo.h"
#include "base/Packet.h"
#include "base/Order.h"
#include "base/API.h"

#include "feeds/omxnordic/OMXNordicFeedHandler.h"
#include "feeds/omxnordic/OMXNordicLineGroup.h"
#include "feeds/omxnordic/OMXNordicLine.h"
#include "feeds/omxnordic/OMXNordicMessages.h"
#include "feeds/omxnordic/OMXNordicUtils.h"


using namespace base;
using namespace omxnordic;

void OMXNordicLine::initializeParseFunctions()
{
	// Application messages
	parseFuncMap[uint8_t(MessageType::Time)/*T*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::exchangeTime), false, sizeof(OMXNordicTime), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::MSeconds)/*T*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::exchangeMSeconds), false, sizeof(OMXNordicMSeconds), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::SystemEvent)/*S*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::systemEvent), false, sizeof(OMXNordicSystemEvent), 0, NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::StateMessage)/*O*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::stateMessage), false, sizeof(OMXNordicStateMessage), 0, STATUS);
	parseFuncMap[uint8_t(MessageType::TradingState)/*O*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::tradingState), true, sizeof(OMXNordicTradingState), offsetof(struct OMXNordicTradingState, symbolID), STATUS);
	parseFuncMap[uint8_t(MessageType::RefData)/*R*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::refData), true, sizeof(OMXNordicRefData), offsetof(struct OMXNordicRefData, symbolID), NO_CALLBACK);
//	parseFuncMap[uint8_t(MessageType::CombRefData)/*R*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::combRefData), false, sizeof(OMXNordicCombRefData), offsetof(struct OMXNordicCombRefData, symbolID), NO_CALLBACK);
//	parseFuncMap[uint8_t(MessageType::TickData)/*L*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::tickData), false, sizeof(OMXNordicTickData), offsetof(struct OMXNordicTickData, symbolID), NO_CALLBACK);
	parseFuncMap[uint8_t(MessageType::AddOrder)/*A*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::addOrder), true, sizeof(OMXNordicAddOrder), offsetof(struct OMXNordicAddOrder, symbolID), ORDER);
	parseFuncMap[uint8_t(MessageType::AddOrderMPID)/*A*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::addOrderMPID), true, sizeof(OMXNordicAddOrderMPID), offsetof(struct OMXNordicAddOrderMPID, symbolID), ORDER);
	parseFuncMap[uint8_t(MessageType::OrderExec)/*A*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::orderExec), false, sizeof(OMXNordicOrderExec), 0, ORDER);
	parseFuncMap[uint8_t(MessageType::OrderExecPx)/*A*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::orderExecPx), false, sizeof(OMXNordicOrderExecPx), 0, ORDER);
	parseFuncMap[uint8_t(MessageType::OrderCancel)/*A*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::orderCancel), false, sizeof(OMXNordicOrderCancel), 0, ORDER);
	parseFuncMap[uint8_t(MessageType::OrderDelete)/*A*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::orderDelete), false, sizeof(OMXNordicOrderDelete), 0, ORDER);
	parseFuncMap[uint8_t(MessageType::Trade)/*A*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::trade), true, sizeof(OMXNordicTrade), offsetof(struct OMXNordicTrade, symbolID), TRADE);
	parseFuncMap[uint8_t(MessageType::CrossTrade)/*A*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::crossTrade), true, sizeof(OMXNordicCrossTrade), offsetof(struct OMXNordicCrossTrade, symbolID), TRADE);
	parseFuncMap[uint8_t(MessageType::BrokenTrade)/*A*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::brokenTrade), false, sizeof(OMXNordicTrade), 0, TRADE);
	parseFuncMap[uint8_t(MessageType::Imbalance)/*A*/] = MessageFunc(static_cast<NativFunc>(&OMXNordicLine::imbalance), true, sizeof(OMXNordicImbalance), offsetof(struct OMXNordicImbalance, symbolID), TRADE);
}

// Application messages
void OMXNordicLine::exchangeTime()
{
	_xtSecs = reinterpret_cast<const OMXNordicTime*>(_currentMsg)->seconds; 
}

void OMXNordicLine::exchangeMSeconds()
{
	_xtNanoSecs = reinterpret_cast<const OMXNordicTime*>(_currentMsg)->seconds * 1000; 
}

void OMXNordicLine::refData()
{
	const OMXNordicRefData *refDataMsg = reinterpret_cast<const OMXNordicRefData *>(_currentMsg);

	char isin[13];
	strncpy(isin, refDataMsg->isin, sizeof(isin));
	isin[12] = '\0';

	ProductInfo *prodInfo = _feedHandler->getProductInfo(this
			, MessageType::RefData
			, getUint64(refDataMsg->symbolID, sizeof(refDataMsg->symbolID))
			, ""
			, isin 
			, _lastSeqNo
			, _xtSecs
			, _xtNanoSecs);

	//sub->_isActive is skipped to raise prodInfo for all symbols
	Subscription *sub = const_cast<Subscription *>(prodInfo->_sub);

	//Raise the callback
	sub->_prodInfo->update(this, MessageType::RefData, _lastSeqNo, _xtSecs, _xtNanoSecs);
	(_lineAPI->*(_lineAPI->_onProductInfo))(sub->_prodInfo);

}

void OMXNordicLine::systemEvent()
{
}

void OMXNordicLine::stateMessage()
{
/*
		const OMXNordicSymStatus *symStatusMsg = reinterpret_cast<const OMXNordicSymStatus *>(_currentMsg);

		InstrState state = InstrState::UNKNOWN;
		switch(symStatusMsg->trdStatus)
		{
			case TradingStatusEnum::HALTED:
				state = InstrState::HALTED;
				break;

			case TradingStatusEnum::TRADING:
				state = InstrState::OPEN;
				break;

			case TradingStatusEnum::AUCTION_OPEN:
				state = InstrState::AUCTION_OPEN;
				break;

			case TradingStatusEnum::POSTCLOSE:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::CLOSED:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::AUCTION_CLOSE:
				state = InstrState::AUCTION_CLOSE;
				break;

			case TradingStatusEnum::AUCTION_REOPEN:
				state = InstrState::AUCTION_INTRA;
				break;

			case TradingStatusEnum::END_OF_TRADE_REPORTING:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::NO_ACTIVE_SESSION:
				state = InstrState::SUSPENDED;
				break;

			case TradingStatusEnum::END_OF_POST_CLOSE:
				state = InstrState::CLOSED;
				break;

			case TradingStatusEnum::PRETRADING:
				state = InstrState::PREOPEN;
				break;

			case TradingStatusEnum::CLOSING_PRICE_PUBL:
				state = InstrState::CLOSED;
				break;
		}

		_sub->_status.update(this
			, _sub
			, MessageType::SymStatus
			, _lastSeqNo
			, _xtSecs
			, symStatusMsg->nanoseconds
			, state);
	*/
}

void OMXNordicLine::tradingState()
{
		const OMXNordicTradingState *symStatusMsg = reinterpret_cast<const OMXNordicTradingState*>(_currentMsg);

		InstrState state = InstrState::UNKNOWN;
		switch(symStatusMsg->tradingState)
		{
			case TradingStatusEnum::HALTED:
				state = InstrState::HALTED;
				break;

			case TradingStatusEnum::TRADING:
				state = InstrState::OPEN;
				break;

			case TradingStatusEnum::AUCTION:
				state = InstrState::AUCTION;
				break;
		}

		_sub->_status.update(this
			, _sub
			, MessageType::TradingState
			, _lastSeqNo
			, _xtSecs
			, _xtNanoSecs 
			, state);
}

void OMXNordicLine::addOrder()
{
	const OMXNordicAddOrder *addOrderMsg = reinterpret_cast<const OMXNordicAddOrder*>(_currentMsg);
	Order::Add(this
		, _sub
		, MessageType::AddOrder
		, _lastSeqNo
		, _xtSecs
		, _xtNanoSecs
		, getUint64Price(addOrderMsg->price)
		, getUint64(addOrderMsg->quantity, sizeof(addOrderMsg->quantity))
		, static_cast<Side>(addOrderMsg->side)
		, getUint64(addOrderMsg->orderID, sizeof(addOrderMsg->orderID)));
}

void OMXNordicLine::addOrderMPID()
{
	const OMXNordicAddOrderMPID *addOrderMsg = reinterpret_cast<const OMXNordicAddOrderMPID*>(_currentMsg);
	Order::Add(this
		, _sub
		, MessageType::AddOrderMPID
		, _lastSeqNo
		, _xtSecs
		, _xtNanoSecs
		, getUint64Price(addOrderMsg->price)
		, getUint64(addOrderMsg->quantity, sizeof(addOrderMsg->quantity))
		, static_cast<Side>(addOrderMsg->side)
		, getUint64(addOrderMsg->orderID, sizeof(addOrderMsg->orderID)));
}

void OMXNordicLine::orderExec()
{
	const OMXNordicOrderExec *execOrderMsg = reinterpret_cast<const OMXNordicOrderExec *>(_currentMsg);
	Order::ExecuteSize(this
			, MessageType::OrderExec
			, _lastSeqNo
			, _xtSecs
			, _xtNanoSecs 
			, getUint64(execOrderMsg->orderID, sizeof(execOrderMsg->orderID))
			, getUint64(execOrderMsg->execQuantity, sizeof(execOrderMsg->execQuantity)));
}

void OMXNordicLine::orderExecPx()
{
	const OMXNordicOrderExecPx *execPxSizeMsg = reinterpret_cast<const OMXNordicOrderExecPx *>(_currentMsg);
		Order::ExecutePxSize(this
			, MessageType::OrderExecPx
			, _lastSeqNo
			, _xtSecs
			, _xtNanoSecs
			, getUint64(execPxSizeMsg->orderID, sizeof(execPxSizeMsg->orderID))
			, getUint64Price(execPxSizeMsg->tradePrice)
			, getUint64(execPxSizeMsg->execQuantity, sizeof(execPxSizeMsg->execQuantity)));
}

void OMXNordicLine::orderCancel()
{
	const OMXNordicOrderCancel *cancelOrderMsg = reinterpret_cast<const OMXNordicOrderCancel *>(_currentMsg);
	Order::CancelSize(this
		, MessageType::OrderCancel
		, _lastSeqNo
		, _xtSecs
		, _xtNanoSecs 
		, getUint64(cancelOrderMsg->orderID, sizeof(cancelOrderMsg->orderID))
		, getUint64(cancelOrderMsg->cancelledQty, sizeof(cancelOrderMsg->cancelledQty)));
}

void OMXNordicLine::orderDelete()
{
	const OMXNordicOrderDelete *delOrderMsg = reinterpret_cast<const OMXNordicOrderDelete *>(_currentMsg);
	
	Order::Delete(this
				, MessageType::OrderDelete
				, _lastSeqNo
				, _xtSecs
				, _xtNanoSecs 
				, getUint64(delOrderMsg->orderID, sizeof(delOrderMsg->orderID)));
}

void OMXNordicLine::trade()
{
	const OMXNordicTrade *tradeMsg = reinterpret_cast<const OMXNordicTrade*>(_currentMsg);
	_sub->_trade.update(this
			, MessageType::Trade
			, _lastSeqNo
			, _xtSecs
			, _xtNanoSecs 
			, getUint64Price(tradeMsg->price)
			, getUint64(tradeMsg->quantity, sizeof(tradeMsg->quantity))
			, SIDE_UNKNOWN 
			, getUint64(tradeMsg->tradeID, sizeof(tradeMsg->tradeID)));
}

void OMXNordicLine::crossTrade()
{
}

void OMXNordicLine::brokenTrade()
{
}

void OMXNordicLine::imbalance()
{
}

Line* OMXNordicLine::_OMXNordicLine(const MarketDataApplication *app, FeedHandler *feedHandler, LineGroup *lineGroup, Thread *thread, const pugi::xml_node& lineNode, LineAPI *pLineAPI)
{
	return new OMXNordicLine(app, reinterpret_cast<OMXNordicFeedHandler *>(feedHandler), reinterpret_cast<OMXNordicLineGroup *>(lineGroup), thread, lineNode, pLineAPI); 
}

OMXNordicLine::OMXNordicLine(const MarketDataApplication *app, OMXNordicFeedHandler *omxnordicFeedHander, OMXNordicLineGroup *pOMXNordicLineGroup, Thread *thread, const pugi::xml_node & lineNode, LineAPI *pLineAPI)
	: Line(app, omxnordicFeedHander, pOMXNordicLineGroup, thread, lineNode, pLineAPI,static_cast<Start>(&OMXNordicLine::start), static_cast<ProcessPacket>(&OMXNordicLine::processPacket),static_cast<GetPackStats>(&OMXNordicLine::getPacketStats),static_cast<GetPackStatsSnap>(&OMXNordicLine::getPacketStatsSnap),static_cast<ReRequestMissedPackets>(&OMXNordicLine::reRequestMissedPackets))
{
}

void OMXNordicLine::_start(Line *pLine)
{
	return reinterpret_cast<OMXNordicLine *>(pLine)->start();
}

void OMXNordicLine::start()
{
	logConsole(DEBUG, "Starting the Line %s", _name);
	initializeParseFunctions();
}

//void OMXNordicLine::getPacketStats(ContentType& _contentType, uint64_t& _headerSeqNo, uint64_t& _endSeqNo, const char*& _firstMsg)
void OMXNordicLine::_getPacketStats(Line *pLine)
{
	return reinterpret_cast<OMXNordicLine *>(pLine)->getPacketStats();
}

void OMXNordicLine::getPacketStats()
{
	OMXNordicPacketHeader *pHeader = (OMXNordicPacketHeader *) _packet->packetData();
	_headerSeqNo = pHeader->seqNum;
	_endSeqNo 	 = _headerSeqNo + pHeader->msgCount - 1;
	_currentMsg  = (char *)pHeader + sizeof(OMXNordicPacketHeader);

	if(!pHeader->msgCount)
	{
		_contentType = ContentType::HB;
	}
	else
	{
		_contentType = ContentType::DATA_PACKET;
	}
}

void OMXNordicLine::_getPacketStatsSnap(Line *pLine)
{
	return reinterpret_cast<OMXNordicLine *>(pLine)->getPacketStatsSnap();
}

void OMXNordicLine::getPacketStatsSnap()
{
	getPacketStats();

	_isSnapStarted = false;
	_lastSeqNo = _headerSeqNo - 1;
}

bool OMXNordicLine::_reRequestMissedPackets(Line *pLine, uint64_t first, uint64_t last)
{
	return reinterpret_cast<OMXNordicLine *>(pLine)->reRequestMissedPackets(first, last);
}

bool OMXNordicLine::reRequestMissedPackets(uint64_t first, uint64_t last)
{
}

/**
 * Process each message within the packet
 * this function here ensures that _processPacket above is called only once per packet.
 */
void OMXNordicLine::processPacket()
{
	//PacketHeader has been already processed
	uint64_t i = _headerSeqNo;

	for(; i <= _lastSeqNo; i++)
	{
		//Skip the message
		_currentMsg += parseFuncMap[((OMXNordicMsgHeader *)_currentMsg)->type]._size;
	}

	for(; i <= _endSeqNo; i++)
	{
		_lastSeqNo++;
		uint64_t len = parseFuncMap[((OMXNordicMsgHeader *)_currentMsg)->type]._size;
		processMsg_rev();
		// increment the message pointer correctly including length of message header
		_currentMsg += len;	
	}

	//@TODO: assert the below check
	if(_currentMsg != _packet->packetData() + _packet->packetDataLen())
	{
		logMessage(EXCEPTION, "Wrong Packet Processing _currentMsg %p != %p [packet Start:%p + Packet Len %u]", _currentMsg, _packet->packetData()+_packet->packetDataLen(), _packet->packetData(), _packet->packetDataLen());	
	}
}

void OMXNordicLine::processMsg_rev()
{
	uint8_t type = (uint8_t) ((OMXNordicMsgHeader *)_currentMsg)->type;
	
	// There is _processorQueue and this message could be assigned to
	// designated thread to process
	logMessage(TRACE, "Processing Message %lu : %lu.%lu",_lastSeqNo, _packet->_recordTime.tv_sec, _packet->_recordTime.tv_nsec);
	
	if(parseFuncMap[type]._couldAssign)
	{
		if(hasInterest(parseFuncMap[type]._callbacks))
		{
			_lineGroup->_mt = globalClock();
#ifdef __SUBMAP_LATENCTY__
			_sub = _lineGroup->getIdSub(getUint64(_currentMsg + parseFuncMap[type]._idOffset, 6));
			getLatency(_lineGroup, _lineGroup->_sf, _lineGroup->_mt);
#else
			_sub = _lineGroup->getIdSub(getUint64(_currentMsg + parseFuncMap[type]._idOffset, 6));
#endif

			if(_sub)
			{	
				NativFunc func = parseFuncMap[type]._nativFunc;
				(this->*func)();
			}
		}
	}
	else // process the message locally, line/feed specefic message or for group of symbols 
	{
		_sub = nullptr;
		NativFunc func = parseFuncMap[type]._nativFunc;
		_lineGroup->_mt = globalClock();
		(this->*func)();
	}
}

**************FILE************ ./source/0.9.0.0/feeds/omxnordic/OMXNordicCommon.h
#ifndef __OMXNORDIC_COMMON_H__
#define __OMXNORDIC_COMMON_H__
namespace omxnordic
{
	class OMXNordicFeedHandler;
	class OMXNordicLineGroup;
	class OMXNordicLine;
};
#endif //__OMXNORDIC_COMMON_H__
**************FILE************ ./source/0.9.0.0/feeds/omxnordic/OMXNordicMessages.h
#ifndef __OMXNORDIC_MESSEGES_H__
#define __OMXNORDIC_MESSEGES_H__

#include <stdint.h>

#define PACKED __attribute__((packed))

enum MessageType
{
	// System Messages
	Time = 'T',
	MSeconds = 'M',
	SystemEvent = 'S',
	StateMessage = 'O',
	RefData = 'R',
	TradingState= 'H',
	AddOrder = 'A',
	AddOrderMPID = 'F',
	OrderExec = 'E',
	OrderExecPx = 'C',
	OrderCancel = 'X',
	OrderDelete = 'D',
	Trade = 'P',
	CrossTrade = 'Q',
	BrokenTrade = 'B',
	Imbalance = 'I',
};

struct PACKED OMXNordicPacketHeader
{
	char session[10];
	uint32_t seqNum;
	uint16_t msgCount; 
};

struct PACKED OMXNordicMsgHeader
{
	uint16_t reserved1;
	uint8_t type;
};

struct PACKED OMXNordicTime
{
	OMXNordicMsgHeader header;
	uint32_t seconds;
	char	 reserved;
};

struct PACKED OMXNordicMSeconds
{
	OMXNordicMsgHeader header;
	uint16_t msecond;
	char reserved;
};

struct PACKED OMXNordicSystemEvent
{
	OMXNordicMsgHeader header;
	char eventCode; // O: Start of day, C : last message
};

struct PACKED OMXNordicStateMessage
{
	OMXNordicMsgHeader header;
	char segmentID[3];
	char eventCode;
};

struct PACKED OMXNordicRefData
{
	OMXNordicMsgHeader header;
	char symbolID[6];
	char symbol[16];
	char isin[12];
	char productType[3];
	char currency[3];
	char mic[4];
	char segmentID[3];
	uint64_t noteCodes;
	char roundLotSize[9];
};

enum TradingStatusEnum 
{
	HALTED = 'H',
	AUCTION = 'Q',
	TRADING = 'T'
};

struct PACKED OMXNordicTradingState
{
	OMXNordicMsgHeader header;
	char symbolID[6];
	char tradingState;
	char reserved;
	char reason[4];
};

struct PACKED OMXNordicAddOrder
{
	OMXNordicMsgHeader header;
	char orderID[9];
	char side;
	char quantity[9];
	char symbolID[6];
	char price[10];
};

struct PACKED OMXNordicAddOrderMPID
{
	OMXNordicMsgHeader header;
	char orderID[9];
	char side;
	char quantity[9];
	char symbolID[6];
	char price[10];
	uint32_t orderAttr;
};

struct PACKED OMXNordicOrderExec
{
	OMXNordicMsgHeader header;
	char orderID[9];
	char execQuantity[9];
	char tradeID[9];
	char participent[4];
	char counterParty[4];
};

struct PACKED OMXNordicOrderExecPx
{
	OMXNordicMsgHeader header;
	char orderID[9];
	char execQuantity[9];
	char tradeID[9];
	char printable;
	char tradePrice[10];
	char participent[4];
	char counterParty[4];
};

struct PACKED OMXNordicOrderCancel
{
	OMXNordicMsgHeader header;
	char orderID[9];
	char cancelledQty[9];
};

struct PACKED OMXNordicOrderDelete
{
	OMXNordicMsgHeader header;
	char orderID[9];
};

struct PACKED OMXNordicTrade
{
	OMXNordicMsgHeader header;
	char orderID[9];
	char tradeType;
	char quantity[9];
	char symbolID[6];
	char tradeID[9];
	char price[10];
	char participent[4];
	char counterParty[4];
};

struct PACKED OMXNordicCrossTrade
{
	OMXNordicMsgHeader header;
	char quantity[9];
	char symbolID[6];
	char crossPrice[10];
	char orderID[9];
	char crossType;
	char noofTrades[10];
};

struct PACKED OMXNordicBrokenTrade
{
	OMXNordicMsgHeader header;
	char tradeID[9];
};

struct PACKED OMXNordicImbalance
{
	OMXNordicMsgHeader header;
	char pairedQty[9];
	char imbalanceQty[9];
	char imbalanceDir;
	char symbolID[6];
	char eqPrice[10];
	char crossType;
	char bestBidPx[10];
	char bestBidQty[9];
	char bestAskPx[10];
	char bestAskQty[9];
};
#endif //__OMXNORDIC_MESSEGES_H__
**************FILE************ ./source/0.9.0.0/feeds/omxnordic/OMXNordicLineGroup.cpp

#include "feeds/omxnordic/OMXNordicFeedHandler.h"
#include "feeds/omxnordic/OMXNordicLineGroup.h"
#include "feeds/omxnordic/OMXNordicLine.h"

using namespace omxnordic;
using namespace base;

LineGroup* OMXNordicLineGroup::_OMXNordicLineGroup(const MarketDataApplication *app, FeedHandler *feedHandler, const pugi::xml_node& lineGroupNode, LineGroupAPI *lineGroupAPI)
{
	return new omxnordic::OMXNordicLineGroup(app, reinterpret_cast<omxnordic::OMXNordicFeedHandler *>(feedHandler), lineGroupNode, lineGroupAPI);
}

OMXNordicLineGroup:: OMXNordicLineGroup(const MarketDataApplication *app, OMXNordicFeedHandler *pOMXNordicFeedHandler, const pugi::xml_node & lineGroupNode, LineGroupAPI *lineGroupAPI)
	: LineGroup(app, pOMXNordicFeedHandler, lineGroupNode, OMXNordicLine::_OMXNordicLine, lineGroupAPI)
{
}

**************FILE************ ./source/0.9.0.0/feeds/omxnordic/OMXNordicFeedHandler.h
#ifndef __OMXNORDIC_FEEDMANAGER_H__
#define __OMXNORDIC_FEEDMANAGER_H__

#include "base/BaseCommon.h"
#include "base/FeedHandler.h"

using namespace base;

namespace omxnordic
{
	class OMXNordicFeedHandler: public FeedHandler
	{
		public:
			static bool _loaded;
			static FeedHandler* _OMXNordicFeedHandler(MarketDataApplication *app, const pugi::xml_node& feedHandlerNode, FeedAPI *feedAPI);

			OMXNordicFeedHandler(const MarketDataApplication *app, const pugi::xml_node & feedHandlerNode, FeedAPI *feedAPI);
	};
}
#endif //__OMXNORDIC_FEEDMANAGER_H__
**************FILE************ ./source/0.9.0.0/feeds/omxnordic/OMXNordicUtils.cpp
#include "feeds/omxnordic/OMXNordicUtils.h"

using namespace omxnordic;
// Assumes that str contains atleast one valid
// non space char
extern "C" 
uint32_t  ltrim(const char *str)
{
	uint32_t  i = 0;	
	// Trim leading space, ascii 32
	while(*str++ == ' ') i++;
	return i;
}

extern "C" 
uint64_t atoll(const char *str, uint32_t  size)
{
	uint32_t  i = 0;
	uint64_t result = 0;
	while( i < size)
	{
		result *= 10;
		result += str[i] - '0';
		i++;
	}
	return result;
}

extern "C" 
uint64_t getUint64(const char *str, uint32_t  size)
{
	uint32_t  i = omxnordic::ltrim(str);	
	return omxnordic::atoll(str+i, size - i);
}

extern "C" 
uint64_t getUint64Price(const char *str)
{
	double result = omxnordic::getUint64(str, 6);
	return result + (omxnordic::getUint64(str+6, 4)/10000.0);
}
**************FILE************ ./source/0.9.0.0/feeds/omxnordic/OMXNordicUtils.h
#ifndef __OMXNORIDCUTILS_H__
#define __OMXNORIDCUTILS_H__

#include <stdint.h>

namespace omxnordic
{
	// Assumes that str contains atleast one valid
	// non space char
	extern "C" uint32_t ltrim(const char *str);

	extern "C" uint64_t atoll(const char *str, uint32_t  size);
	extern "C" uint64_t getUint64(const char *str, uint32_t  size);
	extern "C" uint64_t getUint64Price(const char *str);
}

#endif // __OMXNORIDCUTILS_H__
**************FILE************ ./source/0.9.0.0/include
**************FILE************ ./source/0.9.0.0/include/libxml2
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/list.h
/*
 * Summary: lists interfaces
 * Description: this module implement the list support used in
 * various place in the library.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>
 */

#ifndef __XML_LINK_INCLUDE__
#define __XML_LINK_INCLUDE__

#include <libxml/xmlversion.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _xmlLink xmlLink;
typedef xmlLink *xmlLinkPtr;

typedef struct _xmlList xmlList;
typedef xmlList *xmlListPtr;

/**
 * xmlListDeallocator:
 * @lk:  the data to deallocate
 *
 * Callback function used to free data from a list.
 */
typedef void (*xmlListDeallocator) (xmlLinkPtr lk);
/**
 * xmlListDataCompare:
 * @data0: the first data
 * @data1: the second data
 *
 * Callback function used to compare 2 data.
 *
 * Returns 0 is equality, -1 or 1 otherwise depending on the ordering.
 */
typedef int  (*xmlListDataCompare) (const void *data0, const void *data1);
/**
 * xmlListWalker:
 * @data: the data found in the list
 * @user: extra user provided data to the walker
 *
 * Callback function used when walking a list with xmlListWalk().
 *
 * Returns 0 to stop walking the list, 1 otherwise.
 */
typedef int (*xmlListWalker) (const void *data, const void *user);

/* Creation/Deletion */
XMLPUBFUN xmlListPtr XMLCALL
		xmlListCreate		(xmlListDeallocator deallocator,
	                                 xmlListDataCompare compare);
XMLPUBFUN void XMLCALL
		xmlListDelete		(xmlListPtr l);

/* Basic Operators */
XMLPUBFUN void * XMLCALL
		xmlListSearch		(xmlListPtr l,
					 void *data);
XMLPUBFUN void * XMLCALL
		xmlListReverseSearch	(xmlListPtr l,
					 void *data);
XMLPUBFUN int XMLCALL
		xmlListInsert		(xmlListPtr l,
					 void *data) ;
XMLPUBFUN int XMLCALL
		xmlListAppend		(xmlListPtr l,
					 void *data) ;
XMLPUBFUN int XMLCALL
		xmlListRemoveFirst	(xmlListPtr l,
					 void *data);
XMLPUBFUN int XMLCALL
		xmlListRemoveLast	(xmlListPtr l,
					 void *data);
XMLPUBFUN int XMLCALL
		xmlListRemoveAll	(xmlListPtr l,
					 void *data);
XMLPUBFUN void XMLCALL
		xmlListClear		(xmlListPtr l);
XMLPUBFUN int XMLCALL
		xmlListEmpty		(xmlListPtr l);
XMLPUBFUN xmlLinkPtr XMLCALL
		xmlListFront		(xmlListPtr l);
XMLPUBFUN xmlLinkPtr XMLCALL
		xmlListEnd		(xmlListPtr l);
XMLPUBFUN int XMLCALL
		xmlListSize		(xmlListPtr l);

XMLPUBFUN void XMLCALL
		xmlListPopFront		(xmlListPtr l);
XMLPUBFUN void XMLCALL
		xmlListPopBack		(xmlListPtr l);
XMLPUBFUN int XMLCALL
		xmlListPushFront	(xmlListPtr l,
					 void *data);
XMLPUBFUN int XMLCALL
		xmlListPushBack		(xmlListPtr l,
					 void *data);

/* Advanced Operators */
XMLPUBFUN void XMLCALL
		xmlListReverse		(xmlListPtr l);
XMLPUBFUN void XMLCALL
		xmlListSort		(xmlListPtr l);
XMLPUBFUN void XMLCALL
		xmlListWalk		(xmlListPtr l,
					 xmlListWalker walker,
					 const void *user);
XMLPUBFUN void XMLCALL
		xmlListReverseWalk	(xmlListPtr l,
					 xmlListWalker walker,
					 const void *user);
XMLPUBFUN void XMLCALL
		xmlListMerge		(xmlListPtr l1,
					 xmlListPtr l2);
XMLPUBFUN xmlListPtr XMLCALL
		xmlListDup		(const xmlListPtr old);
XMLPUBFUN int XMLCALL
		xmlListCopy		(xmlListPtr cur,
					 const xmlListPtr old);
/* Link operators */
XMLPUBFUN void * XMLCALL
		xmlLinkGetData          (xmlLinkPtr lk);

/* xmlListUnique() */
/* xmlListSwap */

#ifdef __cplusplus
}
#endif

#endif /* __XML_LINK_INCLUDE__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/nanoftp.h
/*
 * Summary: minimal FTP implementation
 * Description: minimal FTP implementation allowing to fetch resources
 *              like external subset.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __NANO_FTP_H__
#define __NANO_FTP_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_FTP_ENABLED

/* Needed for portability to Windows 64 bits */
#if defined(__MINGW32__) || defined(_WIN32_WCE)
#include <winsock2.h>
#else
/**
 * SOCKET:
 *
 * macro used to provide portability of code to windows sockets
 */
#define SOCKET int
/**
 * INVALID_SOCKET:
 *
 * macro used to provide portability of code to windows sockets
 * the value to be used when the socket is not valid
 */
#undef  INVALID_SOCKET
#define INVALID_SOCKET (-1)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * ftpListCallback:
 * @userData:  user provided data for the callback
 * @filename:  the file name (including "->" when links are shown)
 * @attrib:  the attribute string
 * @owner:  the owner string
 * @group:  the group string
 * @size:  the file size
 * @links:  the link count
 * @year:  the year
 * @month:  the month
 * @day:  the day
 * @hour:  the hour
 * @minute:  the minute
 *
 * A callback for the xmlNanoFTPList command.
 * Note that only one of year and day:minute are specified.
 */
typedef void (*ftpListCallback) (void *userData,
	                         const char *filename, const char *attrib,
	                         const char *owner, const char *group,
				 unsigned long size, int links, int year,
				 const char *month, int day, int hour,
				 int minute);
/**
 * ftpDataCallback:
 * @userData: the user provided context
 * @data: the data received
 * @len: its size in bytes
 *
 * A callback for the xmlNanoFTPGet command.
 */
typedef void (*ftpDataCallback) (void *userData,
				 const char *data,
				 int len);

/*
 * Init
 */
XMLPUBFUN void XMLCALL
	xmlNanoFTPInit		(void);
XMLPUBFUN void XMLCALL
	xmlNanoFTPCleanup	(void);

/*
 * Creating/freeing contexts.
 */
XMLPUBFUN void * XMLCALL
	xmlNanoFTPNewCtxt	(const char *URL);
XMLPUBFUN void XMLCALL
	xmlNanoFTPFreeCtxt	(void * ctx);
XMLPUBFUN void * XMLCALL
	xmlNanoFTPConnectTo	(const char *server,
				 int port);
/*
 * Opening/closing session connections.
 */
XMLPUBFUN void * XMLCALL
	xmlNanoFTPOpen		(const char *URL);
XMLPUBFUN int XMLCALL
	xmlNanoFTPConnect	(void *ctx);
XMLPUBFUN int XMLCALL
	xmlNanoFTPClose		(void *ctx);
XMLPUBFUN int XMLCALL
	xmlNanoFTPQuit		(void *ctx);
XMLPUBFUN void XMLCALL
	xmlNanoFTPScanProxy	(const char *URL);
XMLPUBFUN void XMLCALL
	xmlNanoFTPProxy		(const char *host,
				 int port,
				 const char *user,
				 const char *passwd,
				 int type);
XMLPUBFUN int XMLCALL
	xmlNanoFTPUpdateURL	(void *ctx,
				 const char *URL);

/*
 * Rather internal commands.
 */
XMLPUBFUN int XMLCALL
	xmlNanoFTPGetResponse	(void *ctx);
XMLPUBFUN int XMLCALL
	xmlNanoFTPCheckResponse	(void *ctx);

/*
 * CD/DIR/GET handlers.
 */
XMLPUBFUN int XMLCALL
	xmlNanoFTPCwd		(void *ctx,
				 const char *directory);
XMLPUBFUN int XMLCALL
	xmlNanoFTPDele		(void *ctx,
				 const char *file);

XMLPUBFUN SOCKET XMLCALL
	xmlNanoFTPGetConnection	(void *ctx);
XMLPUBFUN int XMLCALL
	xmlNanoFTPCloseConnection(void *ctx);
XMLPUBFUN int XMLCALL
	xmlNanoFTPList		(void *ctx,
				 ftpListCallback callback,
				 void *userData,
				 const char *filename);
XMLPUBFUN SOCKET XMLCALL
	xmlNanoFTPGetSocket	(void *ctx,
				 const char *filename);
XMLPUBFUN int XMLCALL
	xmlNanoFTPGet		(void *ctx,
				 ftpDataCallback callback,
				 void *userData,
				 const char *filename);
XMLPUBFUN int XMLCALL
	xmlNanoFTPRead		(void *ctx,
				 void *dest,
				 int len);

#ifdef __cplusplus
}
#endif
#endif /* LIBXML_FTP_ENABLED */
#endif /* __NANO_FTP_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlmemory.h
/*
 * Summary: interface for the memory allocator
 * Description: provides interfaces for the memory allocator,
 *              including debugging capabilities.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */


#ifndef __DEBUG_MEMORY_ALLOC__
#define __DEBUG_MEMORY_ALLOC__

#include <stdio.h>
#include <libxml/xmlversion.h>

/**
 * DEBUG_MEMORY:
 *
 * DEBUG_MEMORY replaces the allocator with a collect and debug
 * shell to the libc allocator.
 * DEBUG_MEMORY should only be activated when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/* #define DEBUG_MEMORY_FREED */
/* #define DEBUG_MEMORY_LOCATION */

#ifdef DEBUG
#ifndef DEBUG_MEMORY
#define DEBUG_MEMORY
#endif
#endif

/**
 * DEBUG_MEMORY_LOCATION:
 *
 * DEBUG_MEMORY_LOCATION should be activated only when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
#ifdef DEBUG_MEMORY_LOCATION
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The XML memory wrapper support 4 basic overloadable functions.
 */
/**
 * xmlFreeFunc:
 * @mem: an already allocated block of memory
 *
 * Signature for a free() implementation.
 */
typedef void (XMLCALL *xmlFreeFunc)(void *mem);
/**
 * xmlMallocFunc:
 * @size:  the size requested in bytes
 *
 * Signature for a malloc() implementation.
 *
 * Returns a pointer to the newly allocated block or NULL in case of error.
 */
typedef void *(LIBXML_ATTR_ALLOC_SIZE(1) XMLCALL *xmlMallocFunc)(size_t size);

/**
 * xmlReallocFunc:
 * @mem: an already allocated block of memory
 * @size:  the new size requested in bytes
 *
 * Signature for a realloc() implementation.
 *
 * Returns a pointer to the newly reallocated block or NULL in case of error.
 */
typedef void *(XMLCALL *xmlReallocFunc)(void *mem, size_t size);

/**
 * xmlStrdupFunc:
 * @str: a zero terminated string
 *
 * Signature for an strdup() implementation.
 *
 * Returns the copy of the string or NULL in case of error.
 */
typedef char *(XMLCALL *xmlStrdupFunc)(const char *str);

/*
 * The 4 interfaces used for all memory handling within libxml.
LIBXML_DLL_IMPORT xmlFreeFunc xmlFree;
LIBXML_DLL_IMPORT xmlMallocFunc xmlMalloc;
LIBXML_DLL_IMPORT xmlMallocFunc xmlMallocAtomic;
LIBXML_DLL_IMPORT xmlReallocFunc xmlRealloc;
LIBXML_DLL_IMPORT xmlStrdupFunc xmlMemStrdup;
 */

/*
 * The way to overload the existing functions.
 * The xmlGc function have an extra entry for atomic block
 * allocations useful for garbage collected memory allocators
 */
XMLPUBFUN int XMLCALL
	xmlMemSetup	(xmlFreeFunc freeFunc,
			 xmlMallocFunc mallocFunc,
			 xmlReallocFunc reallocFunc,
			 xmlStrdupFunc strdupFunc);
XMLPUBFUN int XMLCALL
	xmlMemGet	(xmlFreeFunc *freeFunc,
			 xmlMallocFunc *mallocFunc,
			 xmlReallocFunc *reallocFunc,
			 xmlStrdupFunc *strdupFunc);
XMLPUBFUN int XMLCALL
	xmlGcMemSetup	(xmlFreeFunc freeFunc,
			 xmlMallocFunc mallocFunc,
			 xmlMallocFunc mallocAtomicFunc,
			 xmlReallocFunc reallocFunc,
			 xmlStrdupFunc strdupFunc);
XMLPUBFUN int XMLCALL
	xmlGcMemGet	(xmlFreeFunc *freeFunc,
			 xmlMallocFunc *mallocFunc,
			 xmlMallocFunc *mallocAtomicFunc,
			 xmlReallocFunc *reallocFunc,
			 xmlStrdupFunc *strdupFunc);

/*
 * Initialization of the memory layer.
 */
XMLPUBFUN int XMLCALL
	xmlInitMemory	(void);

/*
 * Cleanup of the memory layer.
 */
XMLPUBFUN void XMLCALL
                xmlCleanupMemory        (void);
/*
 * These are specific to the XML debug memory wrapper.
 */
XMLPUBFUN int XMLCALL
	xmlMemUsed	(void);
XMLPUBFUN int XMLCALL
	xmlMemBlocks	(void);
XMLPUBFUN void XMLCALL
	xmlMemDisplay	(FILE *fp);
XMLPUBFUN void XMLCALL
	xmlMemDisplayLast(FILE *fp, long nbBytes);
XMLPUBFUN void XMLCALL
	xmlMemShow	(FILE *fp, int nr);
XMLPUBFUN void XMLCALL
	xmlMemoryDump	(void);
XMLPUBFUN void * XMLCALL
	xmlMemMalloc	(size_t size) LIBXML_ATTR_ALLOC_SIZE(1);
XMLPUBFUN void * XMLCALL
	xmlMemRealloc	(void *ptr,size_t size);
XMLPUBFUN void XMLCALL
	xmlMemFree	(void *ptr);
XMLPUBFUN char * XMLCALL
	xmlMemoryStrdup	(const char *str);
XMLPUBFUN void * XMLCALL
	xmlMallocLoc	(size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);
XMLPUBFUN void * XMLCALL
	xmlReallocLoc	(void *ptr, size_t size, const char *file, int line);
XMLPUBFUN void * XMLCALL
	xmlMallocAtomicLoc (size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);
XMLPUBFUN char * XMLCALL
	xmlMemStrdupLoc	(const char *str, const char *file, int line);


#ifdef DEBUG_MEMORY_LOCATION
/**
 * xmlMalloc:
 * @size:  number of bytes to allocate
 *
 * Wrapper for the malloc() function used in the XML library.
 *
 * Returns the pointer to the allocated area or NULL in case of error.
 */
#define xmlMalloc(size) xmlMallocLoc((size), __FILE__, __LINE__)
/**
 * xmlMallocAtomic:
 * @size:  number of bytes to allocate
 *
 * Wrapper for the malloc() function used in the XML library for allocation
 * of block not containing pointers to other areas.
 *
 * Returns the pointer to the allocated area or NULL in case of error.
 */
#define xmlMallocAtomic(size) xmlMallocAtomicLoc((size), __FILE__, __LINE__)
/**
 * xmlRealloc:
 * @ptr:  pointer to the existing allocated area
 * @size:  number of bytes to allocate
 *
 * Wrapper for the realloc() function used in the XML library.
 *
 * Returns the pointer to the allocated area or NULL in case of error.
 */
#define xmlRealloc(ptr, size) xmlReallocLoc((ptr), (size), __FILE__, __LINE__)
/**
 * xmlMemStrdup:
 * @str:  pointer to the existing string
 *
 * Wrapper for the strdup() function, xmlStrdup() is usually preferred.
 *
 * Returns the pointer to the allocated area or NULL in case of error.
 */
#define xmlMemStrdup(str) xmlMemStrdupLoc((str), __FILE__, __LINE__)

#endif /* DEBUG_MEMORY_LOCATION */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef __XML_GLOBALS_H
#ifndef __XML_THREADS_H__
#include <libxml/threads.h>
#include <libxml/globals.h>
#endif
#endif

#endif  /* __DEBUG_MEMORY_ALLOC__ */

**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/encoding.h
/*
 * Summary: interface for the encoding conversion functions
 * Description: interface for the encoding conversion functions needed for
 *              XML basic encoding and iconv() support.
 *
 * Related specs are
 * rfc2044        (UTF-8 and UTF-16) F. Yergeau Alis Technologies
 * [ISO-10646]    UTF-8 and UTF-16 in Annexes
 * [ISO-8859-1]   ISO Latin-1 characters codes.
 * [UNICODE]      The Unicode Consortium, "The Unicode Standard --
 *                Worldwide Character Encoding -- Version 1.0", Addison-
 *                Wesley, Volume 1, 1991, Volume 2, 1992.  UTF-8 is
 *                described in Unicode Technical Report #4.
 * [US-ASCII]     Coded Character Set--7-bit American Standard Code for
 *                Information Interchange, ANSI X3.4-1986.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_CHAR_ENCODING_H__
#define __XML_CHAR_ENCODING_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_ICONV_ENABLED
#include <iconv.h>
#endif
#ifdef LIBXML_ICU_ENABLED
#include <unicode/ucnv.h>
#endif
#ifdef __cplusplus
extern "C" {
#endif

/*
 * xmlCharEncoding:
 *
 * Predefined values for some standard encodings.
 * Libxml does not do beforehand translation on UTF8 and ISOLatinX.
 * It also supports ASCII, ISO-8859-1, and UTF16 (LE and BE) by default.
 *
 * Anything else would have to be translated to UTF8 before being
 * given to the parser itself. The BOM for UTF16 and the encoding
 * declaration are looked at and a converter is looked for at that
 * point. If not found the parser stops here as asked by the XML REC. A
 * converter can be registered by the user using xmlRegisterCharEncodingHandler
 * but the current form doesn't allow stateful transcoding (a serious
 * problem agreed !). If iconv has been found it will be used
 * automatically and allow stateful transcoding, the simplest is then
 * to be sure to enable iconv and to provide iconv libs for the encoding
 * support needed.
 *
 * Note that the generic "UTF-16" is not a predefined value.  Instead, only
 * the specific UTF-16LE and UTF-16BE are present.
 */
typedef enum {
    XML_CHAR_ENCODING_ERROR=   -1, /* No char encoding detected */
    XML_CHAR_ENCODING_NONE=	0, /* No char encoding detected */
    XML_CHAR_ENCODING_UTF8=	1, /* UTF-8 */
    XML_CHAR_ENCODING_UTF16LE=	2, /* UTF-16 little endian */
    XML_CHAR_ENCODING_UTF16BE=	3, /* UTF-16 big endian */
    XML_CHAR_ENCODING_UCS4LE=	4, /* UCS-4 little endian */
    XML_CHAR_ENCODING_UCS4BE=	5, /* UCS-4 big endian */
    XML_CHAR_ENCODING_EBCDIC=	6, /* EBCDIC uh! */
    XML_CHAR_ENCODING_UCS4_2143=7, /* UCS-4 unusual ordering */
    XML_CHAR_ENCODING_UCS4_3412=8, /* UCS-4 unusual ordering */
    XML_CHAR_ENCODING_UCS2=	9, /* UCS-2 */
    XML_CHAR_ENCODING_8859_1=	10,/* ISO-8859-1 ISO Latin 1 */
    XML_CHAR_ENCODING_8859_2=	11,/* ISO-8859-2 ISO Latin 2 */
    XML_CHAR_ENCODING_8859_3=	12,/* ISO-8859-3 */
    XML_CHAR_ENCODING_8859_4=	13,/* ISO-8859-4 */
    XML_CHAR_ENCODING_8859_5=	14,/* ISO-8859-5 */
    XML_CHAR_ENCODING_8859_6=	15,/* ISO-8859-6 */
    XML_CHAR_ENCODING_8859_7=	16,/* ISO-8859-7 */
    XML_CHAR_ENCODING_8859_8=	17,/* ISO-8859-8 */
    XML_CHAR_ENCODING_8859_9=	18,/* ISO-8859-9 */
    XML_CHAR_ENCODING_2022_JP=  19,/* ISO-2022-JP */
    XML_CHAR_ENCODING_SHIFT_JIS=20,/* Shift_JIS */
    XML_CHAR_ENCODING_EUC_JP=   21,/* EUC-JP */
    XML_CHAR_ENCODING_ASCII=    22 /* pure ASCII */
} xmlCharEncoding;

/**
 * xmlCharEncodingInputFunc:
 * @out:  a pointer to an array of bytes to store the UTF-8 result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of chars in the original encoding
 * @inlen:  the length of @in
 *
 * Take a block of chars in the original encoding and try to convert
 * it to an UTF-8 block of chars out.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets consumed.
 */
typedef int (* xmlCharEncodingInputFunc)(unsigned char *out, int *outlen,
                                         const unsigned char *in, int *inlen);


/**
 * xmlCharEncodingOutputFunc:
 * @out:  a pointer to an array of bytes to store the result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of UTF-8 chars
 * @inlen:  the length of @in
 *
 * Take a block of UTF-8 chars in and try to convert it to another
 * encoding.
 * Note: a first call designed to produce heading info is called with
 * in = NULL. If stateful this should also initialize the encoder state.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets produced.
 */
typedef int (* xmlCharEncodingOutputFunc)(unsigned char *out, int *outlen,
                                          const unsigned char *in, int *inlen);


/*
 * Block defining the handlers for non UTF-8 encodings.
 * If iconv is supported, there are two extra fields.
 */
#ifdef LIBXML_ICU_ENABLED
struct _uconv_t {
  UConverter *uconv; /* for conversion between an encoding and UTF-16 */
  UConverter *utf8; /* for conversion between UTF-8 and UTF-16 */
};
typedef struct _uconv_t uconv_t;
#endif

typedef struct _xmlCharEncodingHandler xmlCharEncodingHandler;
typedef xmlCharEncodingHandler *xmlCharEncodingHandlerPtr;
struct _xmlCharEncodingHandler {
    char                       *name;
    xmlCharEncodingInputFunc   input;
    xmlCharEncodingOutputFunc  output;
#ifdef LIBXML_ICONV_ENABLED
    iconv_t                    iconv_in;
    iconv_t                    iconv_out;
#endif /* LIBXML_ICONV_ENABLED */
#ifdef LIBXML_ICU_ENABLED
    uconv_t                    *uconv_in;
    uconv_t                    *uconv_out;
#endif /* LIBXML_ICU_ENABLED */
};

#ifdef __cplusplus
}
#endif
#include <libxml/tree.h>
#ifdef __cplusplus
extern "C" {
#endif

/*
 * Interfaces for encoding handlers.
 */
XMLPUBFUN void XMLCALL
	xmlInitCharEncodingHandlers	(void);
XMLPUBFUN void XMLCALL
	xmlCleanupCharEncodingHandlers	(void);
XMLPUBFUN void XMLCALL
	xmlRegisterCharEncodingHandler	(xmlCharEncodingHandlerPtr handler);
XMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL
	xmlGetCharEncodingHandler	(xmlCharEncoding enc);
XMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL
	xmlFindCharEncodingHandler	(const char *name);
XMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL
	xmlNewCharEncodingHandler	(const char *name,
					 xmlCharEncodingInputFunc input,
					 xmlCharEncodingOutputFunc output);

/*
 * Interfaces for encoding names and aliases.
 */
XMLPUBFUN int XMLCALL
	xmlAddEncodingAlias		(const char *name,
					 const char *alias);
XMLPUBFUN int XMLCALL
	xmlDelEncodingAlias		(const char *alias);
XMLPUBFUN const char * XMLCALL
	xmlGetEncodingAlias		(const char *alias);
XMLPUBFUN void XMLCALL
	xmlCleanupEncodingAliases	(void);
XMLPUBFUN xmlCharEncoding XMLCALL
	xmlParseCharEncoding		(const char *name);
XMLPUBFUN const char * XMLCALL
	xmlGetCharEncodingName		(xmlCharEncoding enc);

/*
 * Interfaces directly used by the parsers.
 */
XMLPUBFUN xmlCharEncoding XMLCALL
	xmlDetectCharEncoding		(const unsigned char *in,
					 int len);

XMLPUBFUN int XMLCALL
	xmlCharEncOutFunc		(xmlCharEncodingHandler *handler,
					 xmlBufferPtr out,
					 xmlBufferPtr in);

XMLPUBFUN int XMLCALL
	xmlCharEncInFunc		(xmlCharEncodingHandler *handler,
					 xmlBufferPtr out,
					 xmlBufferPtr in);
XMLPUBFUN int XMLCALL
	xmlCharEncFirstLine		(xmlCharEncodingHandler *handler,
					 xmlBufferPtr out,
					 xmlBufferPtr in);
XMLPUBFUN int XMLCALL
	xmlCharEncCloseFunc		(xmlCharEncodingHandler *handler);

/*
 * Export a few useful functions
 */
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN int XMLCALL
	UTF8Toisolat1			(unsigned char *out,
					 int *outlen,
					 const unsigned char *in,
					 int *inlen);
#endif /* LIBXML_OUTPUT_ENABLED */
XMLPUBFUN int XMLCALL
	isolat1ToUTF8			(unsigned char *out,
					 int *outlen,
					 const unsigned char *in,
					 int *inlen);
#ifdef __cplusplus
}
#endif

#endif /* __XML_CHAR_ENCODING_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/uri.h
/**
 * Summary: library of generic URI related routines
 * Description: library of generic URI related routines
 *              Implements RFC 2396
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_URI_H__
#define __XML_URI_H__

#include <libxml/xmlversion.h>
#include <libxml/tree.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlURI:
 *
 * A parsed URI reference. This is a struct containing the various fields
 * as described in RFC 2396 but separated for further processing.
 *
 * Note: query is a deprecated field which is incorrectly unescaped.
 * query_raw takes precedence over query if the former is set.
 * See: http://mail.gnome.org/archives/xml/2007-April/thread.html#00127
 */
typedef struct _xmlURI xmlURI;
typedef xmlURI *xmlURIPtr;
struct _xmlURI {
    char *scheme;	/* the URI scheme */
    char *opaque;	/* opaque part */
    char *authority;	/* the authority part */
    char *server;	/* the server part */
    char *user;		/* the user part */
    int port;		/* the port number */
    char *path;		/* the path string */
    char *query;	/* the query string (deprecated - use with caution) */
    char *fragment;	/* the fragment identifier */
    int  cleanup;	/* parsing potentially unclean URI */
    char *query_raw;	/* the query string (as it appears in the URI) */
};

/*
 * This function is in tree.h:
 * xmlChar *	xmlNodeGetBase	(xmlDocPtr doc,
 *                               xmlNodePtr cur);
 */
XMLPUBFUN xmlURIPtr XMLCALL
		xmlCreateURI		(void);
XMLPUBFUN xmlChar * XMLCALL
		xmlBuildURI		(const xmlChar *URI,
					 const xmlChar *base);
XMLPUBFUN xmlChar * XMLCALL
		xmlBuildRelativeURI	(const xmlChar *URI,
					 const xmlChar *base);
XMLPUBFUN xmlURIPtr XMLCALL
		xmlParseURI		(const char *str);
XMLPUBFUN xmlURIPtr XMLCALL
		xmlParseURIRaw		(const char *str,
					 int raw);
XMLPUBFUN int XMLCALL
		xmlParseURIReference	(xmlURIPtr uri,
					 const char *str);
XMLPUBFUN xmlChar * XMLCALL
		xmlSaveUri		(xmlURIPtr uri);
XMLPUBFUN void XMLCALL
		xmlPrintURI		(FILE *stream,
					 xmlURIPtr uri);
XMLPUBFUN xmlChar * XMLCALL
		xmlURIEscapeStr         (const xmlChar *str,
					 const xmlChar *list);
XMLPUBFUN char * XMLCALL
		xmlURIUnescapeString	(const char *str,
					 int len,
					 char *target);
XMLPUBFUN int XMLCALL
		xmlNormalizeURIPath	(char *path);
XMLPUBFUN xmlChar * XMLCALL
		xmlURIEscape		(const xmlChar *str);
XMLPUBFUN void XMLCALL
		xmlFreeURI		(xmlURIPtr uri);
XMLPUBFUN xmlChar* XMLCALL
		xmlCanonicPath		(const xmlChar *path);
XMLPUBFUN xmlChar* XMLCALL
		xmlPathToURI		(const xmlChar *path);

#ifdef __cplusplus
}
#endif
#endif /* __XML_URI_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/DOCBparser.h
/*
 * Summary: old DocBook SGML parser
 * Description: interface for a DocBook SGML non-verifying parser
 * This code is DEPRECATED, and should not be used anymore.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __DOCB_PARSER_H__
#define __DOCB_PARSER_H__
#include <libxml/xmlversion.h>

#ifdef LIBXML_DOCB_ENABLED

#include <libxml/parser.h>
#include <libxml/parserInternals.h>

#ifndef IN_LIBXML
#ifdef __GNUC__
#warning "The DOCBparser module has been deprecated in libxml2-2.6.0"
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Most of the back-end structures from XML and SGML are shared.
 */
typedef xmlParserCtxt docbParserCtxt;
typedef xmlParserCtxtPtr docbParserCtxtPtr;
typedef xmlSAXHandler docbSAXHandler;
typedef xmlSAXHandlerPtr docbSAXHandlerPtr;
typedef xmlParserInput docbParserInput;
typedef xmlParserInputPtr docbParserInputPtr;
typedef xmlDocPtr docbDocPtr;

/*
 * There is only few public functions.
 */
XMLPUBFUN int XMLCALL
		     docbEncodeEntities(unsigned char *out,
                                        int *outlen,
                                        const unsigned char *in,
                                        int *inlen, int quoteChar);

XMLPUBFUN docbDocPtr XMLCALL
		     docbSAXParseDoc   (xmlChar *cur,
                                        const char *encoding,
                                        docbSAXHandlerPtr sax,
                                        void *userData);
XMLPUBFUN docbDocPtr XMLCALL
		     docbParseDoc      (xmlChar *cur,
                                        const char *encoding);
XMLPUBFUN docbDocPtr XMLCALL
		     docbSAXParseFile  (const char *filename,
                                        const char *encoding,
                                        docbSAXHandlerPtr sax,
                                        void *userData);
XMLPUBFUN docbDocPtr XMLCALL
		     docbParseFile     (const char *filename,
                                        const char *encoding);

/**
 * Interfaces for the Push mode.
 */
XMLPUBFUN void XMLCALL
		     docbFreeParserCtxt      (docbParserCtxtPtr ctxt);
XMLPUBFUN docbParserCtxtPtr XMLCALL
		     docbCreatePushParserCtxt(docbSAXHandlerPtr sax,
                                              void *user_data,
                                              const char *chunk,
                                              int size,
                                              const char *filename,
                                              xmlCharEncoding enc);
XMLPUBFUN int XMLCALL
		     docbParseChunk          (docbParserCtxtPtr ctxt,
                                              const char *chunk,
                                              int size,
                                              int terminate);
XMLPUBFUN docbParserCtxtPtr XMLCALL
		     docbCreateFileParserCtxt(const char *filename,
                                              const char *encoding);
XMLPUBFUN int XMLCALL
		     docbParseDocument       (docbParserCtxtPtr ctxt);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_DOCB_ENABLED */

#endif /* __DOCB_PARSER_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlreader.h
/*
 * Summary: the XMLReader implementation
 * Description: API of the XML streaming API based on C# interfaces.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_XMLREADER_H__
#define __XML_XMLREADER_H__

#include <libxml/xmlversion.h>
#include <libxml/tree.h>
#include <libxml/xmlIO.h>
#ifdef LIBXML_SCHEMAS_ENABLED
#include <libxml/relaxng.h>
#include <libxml/xmlschemas.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlParserSeverities:
 *
 * How severe an error callback is when the per-reader error callback API
 * is used.
 */
typedef enum {
    XML_PARSER_SEVERITY_VALIDITY_WARNING = 1,
    XML_PARSER_SEVERITY_VALIDITY_ERROR = 2,
    XML_PARSER_SEVERITY_WARNING = 3,
    XML_PARSER_SEVERITY_ERROR = 4
} xmlParserSeverities;

#ifdef LIBXML_READER_ENABLED

/**
 * xmlTextReaderMode:
 *
 * Internal state values for the reader.
 */
typedef enum {
    XML_TEXTREADER_MODE_INITIAL = 0,
    XML_TEXTREADER_MODE_INTERACTIVE = 1,
    XML_TEXTREADER_MODE_ERROR = 2,
    XML_TEXTREADER_MODE_EOF =3,
    XML_TEXTREADER_MODE_CLOSED = 4,
    XML_TEXTREADER_MODE_READING = 5
} xmlTextReaderMode;

/**
 * xmlParserProperties:
 *
 * Some common options to use with xmlTextReaderSetParserProp, but it
 * is better to use xmlParserOption and the xmlReaderNewxxx and
 * xmlReaderForxxx APIs now.
 */
typedef enum {
    XML_PARSER_LOADDTD = 1,
    XML_PARSER_DEFAULTATTRS = 2,
    XML_PARSER_VALIDATE = 3,
    XML_PARSER_SUBST_ENTITIES = 4
} xmlParserProperties;

/**
 * xmlReaderTypes:
 *
 * Predefined constants for the different types of nodes.
 */
typedef enum {
    XML_READER_TYPE_NONE = 0,
    XML_READER_TYPE_ELEMENT = 1,
    XML_READER_TYPE_ATTRIBUTE = 2,
    XML_READER_TYPE_TEXT = 3,
    XML_READER_TYPE_CDATA = 4,
    XML_READER_TYPE_ENTITY_REFERENCE = 5,
    XML_READER_TYPE_ENTITY = 6,
    XML_READER_TYPE_PROCESSING_INSTRUCTION = 7,
    XML_READER_TYPE_COMMENT = 8,
    XML_READER_TYPE_DOCUMENT = 9,
    XML_READER_TYPE_DOCUMENT_TYPE = 10,
    XML_READER_TYPE_DOCUMENT_FRAGMENT = 11,
    XML_READER_TYPE_NOTATION = 12,
    XML_READER_TYPE_WHITESPACE = 13,
    XML_READER_TYPE_SIGNIFICANT_WHITESPACE = 14,
    XML_READER_TYPE_END_ELEMENT = 15,
    XML_READER_TYPE_END_ENTITY = 16,
    XML_READER_TYPE_XML_DECLARATION = 17
} xmlReaderTypes;

/**
 * xmlTextReader:
 *
 * Structure for an xmlReader context.
 */
typedef struct _xmlTextReader xmlTextReader;

/**
 * xmlTextReaderPtr:
 *
 * Pointer to an xmlReader context.
 */
typedef xmlTextReader *xmlTextReaderPtr;

/*
 * Constructors & Destructor
 */
XMLPUBFUN xmlTextReaderPtr XMLCALL
			xmlNewTextReader	(xmlParserInputBufferPtr input,
	                                         const char *URI);
XMLPUBFUN xmlTextReaderPtr XMLCALL
			xmlNewTextReaderFilename(const char *URI);

XMLPUBFUN void XMLCALL
			xmlFreeTextReader	(xmlTextReaderPtr reader);

XMLPUBFUN int XMLCALL
            xmlTextReaderSetup(xmlTextReaderPtr reader,
                   xmlParserInputBufferPtr input, const char *URL,
                   const char *encoding, int options);

/*
 * Iterators
 */
XMLPUBFUN int XMLCALL
			xmlTextReaderRead	(xmlTextReaderPtr reader);

#ifdef LIBXML_WRITER_ENABLED
XMLPUBFUN xmlChar * XMLCALL
			xmlTextReaderReadInnerXml(xmlTextReaderPtr reader);

XMLPUBFUN xmlChar * XMLCALL
			xmlTextReaderReadOuterXml(xmlTextReaderPtr reader);
#endif

XMLPUBFUN xmlChar * XMLCALL
			xmlTextReaderReadString	(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
			xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader);

/*
 * Attributes of the node
 */
XMLPUBFUN int XMLCALL
			xmlTextReaderAttributeCount(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
			xmlTextReaderDepth	(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
			xmlTextReaderHasAttributes(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
			xmlTextReaderHasValue(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
			xmlTextReaderIsDefault	(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
			xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
			xmlTextReaderNodeType	(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
			xmlTextReaderQuoteChar	(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
			xmlTextReaderReadState	(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
                        xmlTextReaderIsNamespaceDecl(xmlTextReaderPtr reader);

XMLPUBFUN const xmlChar * XMLCALL
		    xmlTextReaderConstBaseUri	(xmlTextReaderPtr reader);
XMLPUBFUN const xmlChar * XMLCALL
		    xmlTextReaderConstLocalName	(xmlTextReaderPtr reader);
XMLPUBFUN const xmlChar * XMLCALL
		    xmlTextReaderConstName	(xmlTextReaderPtr reader);
XMLPUBFUN const xmlChar * XMLCALL
		    xmlTextReaderConstNamespaceUri(xmlTextReaderPtr reader);
XMLPUBFUN const xmlChar * XMLCALL
		    xmlTextReaderConstPrefix	(xmlTextReaderPtr reader);
XMLPUBFUN const xmlChar * XMLCALL
		    xmlTextReaderConstXmlLang	(xmlTextReaderPtr reader);
XMLPUBFUN const xmlChar * XMLCALL
		    xmlTextReaderConstString	(xmlTextReaderPtr reader,
						 const xmlChar *str);
XMLPUBFUN const xmlChar * XMLCALL
		    xmlTextReaderConstValue	(xmlTextReaderPtr reader);

/*
 * use the Const version of the routine for
 * better performance and simpler code
 */
XMLPUBFUN xmlChar * XMLCALL
			xmlTextReaderBaseUri	(xmlTextReaderPtr reader);
XMLPUBFUN xmlChar * XMLCALL
			xmlTextReaderLocalName	(xmlTextReaderPtr reader);
XMLPUBFUN xmlChar * XMLCALL
			xmlTextReaderName	(xmlTextReaderPtr reader);
XMLPUBFUN xmlChar * XMLCALL
			xmlTextReaderNamespaceUri(xmlTextReaderPtr reader);
XMLPUBFUN xmlChar * XMLCALL
			xmlTextReaderPrefix	(xmlTextReaderPtr reader);
XMLPUBFUN xmlChar * XMLCALL
			xmlTextReaderXmlLang	(xmlTextReaderPtr reader);
XMLPUBFUN xmlChar * XMLCALL
			xmlTextReaderValue	(xmlTextReaderPtr reader);

/*
 * Methods of the XmlTextReader
 */
XMLPUBFUN int XMLCALL
		    xmlTextReaderClose		(xmlTextReaderPtr reader);
XMLPUBFUN xmlChar * XMLCALL
		    xmlTextReaderGetAttributeNo	(xmlTextReaderPtr reader,
						 int no);
XMLPUBFUN xmlChar * XMLCALL
		    xmlTextReaderGetAttribute	(xmlTextReaderPtr reader,
						 const xmlChar *name);
XMLPUBFUN xmlChar * XMLCALL
		    xmlTextReaderGetAttributeNs	(xmlTextReaderPtr reader,
						 const xmlChar *localName,
						 const xmlChar *namespaceURI);
XMLPUBFUN xmlParserInputBufferPtr XMLCALL
		    xmlTextReaderGetRemainder	(xmlTextReaderPtr reader);
XMLPUBFUN xmlChar * XMLCALL
		    xmlTextReaderLookupNamespace(xmlTextReaderPtr reader,
						 const xmlChar *prefix);
XMLPUBFUN int XMLCALL
		    xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader,
						 int no);
XMLPUBFUN int XMLCALL
		    xmlTextReaderMoveToAttribute(xmlTextReaderPtr reader,
						 const xmlChar *name);
XMLPUBFUN int XMLCALL
		    xmlTextReaderMoveToAttributeNs(xmlTextReaderPtr reader,
						 const xmlChar *localName,
						 const xmlChar *namespaceURI);
XMLPUBFUN int XMLCALL
		    xmlTextReaderMoveToFirstAttribute(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
		    xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
		    xmlTextReaderMoveToElement	(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
		    xmlTextReaderNormalization	(xmlTextReaderPtr reader);
XMLPUBFUN const xmlChar * XMLCALL
		    xmlTextReaderConstEncoding  (xmlTextReaderPtr reader);

/*
 * Extensions
 */
XMLPUBFUN int XMLCALL
		    xmlTextReaderSetParserProp	(xmlTextReaderPtr reader,
						 int prop,
						 int value);
XMLPUBFUN int XMLCALL
		    xmlTextReaderGetParserProp	(xmlTextReaderPtr reader,
						 int prop);
XMLPUBFUN xmlNodePtr XMLCALL
		    xmlTextReaderCurrentNode	(xmlTextReaderPtr reader);

XMLPUBFUN int XMLCALL
            xmlTextReaderGetParserLineNumber(xmlTextReaderPtr reader);

XMLPUBFUN int XMLCALL
            xmlTextReaderGetParserColumnNumber(xmlTextReaderPtr reader);

XMLPUBFUN xmlNodePtr XMLCALL
		    xmlTextReaderPreserve	(xmlTextReaderPtr reader);
#ifdef LIBXML_PATTERN_ENABLED
XMLPUBFUN int XMLCALL
		    xmlTextReaderPreservePattern(xmlTextReaderPtr reader,
						 const xmlChar *pattern,
						 const xmlChar **namespaces);
#endif /* LIBXML_PATTERN_ENABLED */
XMLPUBFUN xmlDocPtr XMLCALL
		    xmlTextReaderCurrentDoc	(xmlTextReaderPtr reader);
XMLPUBFUN xmlNodePtr XMLCALL
		    xmlTextReaderExpand		(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
		    xmlTextReaderNext		(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
		    xmlTextReaderNextSibling	(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
		    xmlTextReaderIsValid	(xmlTextReaderPtr reader);
#ifdef LIBXML_SCHEMAS_ENABLED
XMLPUBFUN int XMLCALL
		    xmlTextReaderRelaxNGValidate(xmlTextReaderPtr reader,
						 const char *rng);
XMLPUBFUN int XMLCALL
		    xmlTextReaderRelaxNGValidateCtxt(xmlTextReaderPtr reader,
						 xmlRelaxNGValidCtxtPtr ctxt,
						 int options);

XMLPUBFUN int XMLCALL
		    xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader,
						 xmlRelaxNGPtr schema);
XMLPUBFUN int XMLCALL
		    xmlTextReaderSchemaValidate	(xmlTextReaderPtr reader,
						 const char *xsd);
XMLPUBFUN int XMLCALL
		    xmlTextReaderSchemaValidateCtxt(xmlTextReaderPtr reader,
						 xmlSchemaValidCtxtPtr ctxt,
						 int options);
XMLPUBFUN int XMLCALL
		    xmlTextReaderSetSchema	(xmlTextReaderPtr reader,
						 xmlSchemaPtr schema);
#endif
XMLPUBFUN const xmlChar * XMLCALL
		    xmlTextReaderConstXmlVersion(xmlTextReaderPtr reader);
XMLPUBFUN int XMLCALL
		    xmlTextReaderStandalone     (xmlTextReaderPtr reader);


/*
 * Index lookup
 */
XMLPUBFUN long XMLCALL
		xmlTextReaderByteConsumed	(xmlTextReaderPtr reader);

/*
 * New more complete APIs for simpler creation and reuse of readers
 */
XMLPUBFUN xmlTextReaderPtr XMLCALL
		xmlReaderWalker		(xmlDocPtr doc);
XMLPUBFUN xmlTextReaderPtr XMLCALL
		xmlReaderForDoc		(const xmlChar * cur,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlTextReaderPtr XMLCALL
		xmlReaderForFile	(const char *filename,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlTextReaderPtr XMLCALL
		xmlReaderForMemory	(const char *buffer,
					 int size,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlTextReaderPtr XMLCALL
		xmlReaderForFd		(int fd,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlTextReaderPtr XMLCALL
		xmlReaderForIO		(xmlInputReadCallback ioread,
					 xmlInputCloseCallback ioclose,
					 void *ioctx,
					 const char *URL,
					 const char *encoding,
					 int options);

XMLPUBFUN int XMLCALL
		xmlReaderNewWalker	(xmlTextReaderPtr reader,
					 xmlDocPtr doc);
XMLPUBFUN int XMLCALL
		xmlReaderNewDoc		(xmlTextReaderPtr reader,
					 const xmlChar * cur,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN int XMLCALL
		xmlReaderNewFile	(xmlTextReaderPtr reader,
					 const char *filename,
					 const char *encoding,
					 int options);
XMLPUBFUN int XMLCALL
		xmlReaderNewMemory	(xmlTextReaderPtr reader,
					 const char *buffer,
					 int size,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN int XMLCALL
		xmlReaderNewFd		(xmlTextReaderPtr reader,
					 int fd,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN int XMLCALL
		xmlReaderNewIO		(xmlTextReaderPtr reader,
					 xmlInputReadCallback ioread,
					 xmlInputCloseCallback ioclose,
					 void *ioctx,
					 const char *URL,
					 const char *encoding,
					 int options);
/*
 * Error handling extensions
 */
typedef void *  xmlTextReaderLocatorPtr;

/**
 * xmlTextReaderErrorFunc:
 * @arg: the user argument
 * @msg: the message
 * @severity: the severity of the error
 * @locator: a locator indicating where the error occured
 *
 * Signature of an error callback from a reader parser
 */
typedef void (XMLCALL *xmlTextReaderErrorFunc)(void *arg,
					       const char *msg,
					       xmlParserSeverities severity,
					       xmlTextReaderLocatorPtr locator);
XMLPUBFUN int XMLCALL
	    xmlTextReaderLocatorLineNumber(xmlTextReaderLocatorPtr locator);
XMLPUBFUN xmlChar * XMLCALL
	    xmlTextReaderLocatorBaseURI (xmlTextReaderLocatorPtr locator);
XMLPUBFUN void XMLCALL
	    xmlTextReaderSetErrorHandler(xmlTextReaderPtr reader,
					 xmlTextReaderErrorFunc f,
					 void *arg);
XMLPUBFUN void XMLCALL
	    xmlTextReaderSetStructuredErrorHandler(xmlTextReaderPtr reader,
						   xmlStructuredErrorFunc f,
						   void *arg);
XMLPUBFUN void XMLCALL
	    xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader,
					 xmlTextReaderErrorFunc *f,
					 void **arg);

#endif /* LIBXML_READER_ENABLED */

#ifdef __cplusplus
}
#endif

#endif /* __XML_XMLREADER_H__ */

**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlmodule.h
/*
 * Summary: dynamic module loading
 * Description: basic API for dynamic module loading, used by
 *              libexslt added in 2.6.17
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Joel W. Reed
 */

#ifndef __XML_MODULE_H__
#define __XML_MODULE_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_MODULES_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlModulePtr:
 *
 * A handle to a dynamically loaded module
 */
typedef struct _xmlModule xmlModule;
typedef xmlModule *xmlModulePtr;

/**
 * xmlModuleOption:
 *
 * enumeration of options that can be passed down to xmlModuleOpen()
 */
typedef enum {
    XML_MODULE_LAZY = 1,	/* lazy binding */
    XML_MODULE_LOCAL= 2		/* local binding */
} xmlModuleOption;

XMLPUBFUN xmlModulePtr XMLCALL xmlModuleOpen	(const char *filename,
						 int options);

XMLPUBFUN int XMLCALL xmlModuleSymbol		(xmlModulePtr module,
						 const char* name,
						 void **result);

XMLPUBFUN int XMLCALL xmlModuleClose		(xmlModulePtr module);

XMLPUBFUN int XMLCALL xmlModuleFree		(xmlModulePtr module);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_MODULES_ENABLED */

#endif /*__XML_MODULE_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/SAX2.h
/*
 * Summary: SAX2 parser interface used to build the DOM tree
 * Description: those are the default SAX2 interfaces used by
 *              the library when building DOM tree.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */


#ifndef __XML_SAX2_H__
#define __XML_SAX2_H__

#include <stdio.h>
#include <stdlib.h>
#include <libxml/xmlversion.h>
#include <libxml/parser.h>
#include <libxml/xlink.h>

#ifdef __cplusplus
extern "C" {
#endif
XMLPUBFUN const xmlChar * XMLCALL
		xmlSAX2GetPublicId		(void *ctx);
XMLPUBFUN const xmlChar * XMLCALL
		xmlSAX2GetSystemId		(void *ctx);
XMLPUBFUN void XMLCALL
		xmlSAX2SetDocumentLocator	(void *ctx,
						 xmlSAXLocatorPtr loc);

XMLPUBFUN int XMLCALL
		xmlSAX2GetLineNumber		(void *ctx);
XMLPUBFUN int XMLCALL
		xmlSAX2GetColumnNumber		(void *ctx);

XMLPUBFUN int XMLCALL
		xmlSAX2IsStandalone		(void *ctx);
XMLPUBFUN int XMLCALL
		xmlSAX2HasInternalSubset	(void *ctx);
XMLPUBFUN int XMLCALL
		xmlSAX2HasExternalSubset	(void *ctx);

XMLPUBFUN void XMLCALL
		xmlSAX2InternalSubset		(void *ctx,
						 const xmlChar *name,
						 const xmlChar *ExternalID,
						 const xmlChar *SystemID);
XMLPUBFUN void XMLCALL
		xmlSAX2ExternalSubset		(void *ctx,
						 const xmlChar *name,
						 const xmlChar *ExternalID,
						 const xmlChar *SystemID);
XMLPUBFUN xmlEntityPtr XMLCALL
		xmlSAX2GetEntity		(void *ctx,
						 const xmlChar *name);
XMLPUBFUN xmlEntityPtr XMLCALL
		xmlSAX2GetParameterEntity	(void *ctx,
						 const xmlChar *name);
XMLPUBFUN xmlParserInputPtr XMLCALL
		xmlSAX2ResolveEntity		(void *ctx,
						 const xmlChar *publicId,
						 const xmlChar *systemId);

XMLPUBFUN void XMLCALL
		xmlSAX2EntityDecl		(void *ctx,
						 const xmlChar *name,
						 int type,
						 const xmlChar *publicId,
						 const xmlChar *systemId,
						 xmlChar *content);
XMLPUBFUN void XMLCALL
		xmlSAX2AttributeDecl		(void *ctx,
						 const xmlChar *elem,
						 const xmlChar *fullname,
						 int type,
						 int def,
						 const xmlChar *defaultValue,
						 xmlEnumerationPtr tree);
XMLPUBFUN void XMLCALL
		xmlSAX2ElementDecl		(void *ctx,
						 const xmlChar *name,
						 int type,
						 xmlElementContentPtr content);
XMLPUBFUN void XMLCALL
		xmlSAX2NotationDecl		(void *ctx,
						 const xmlChar *name,
						 const xmlChar *publicId,
						 const xmlChar *systemId);
XMLPUBFUN void XMLCALL
		xmlSAX2UnparsedEntityDecl	(void *ctx,
						 const xmlChar *name,
						 const xmlChar *publicId,
						 const xmlChar *systemId,
						 const xmlChar *notationName);

XMLPUBFUN void XMLCALL
		xmlSAX2StartDocument		(void *ctx);
XMLPUBFUN void XMLCALL
		xmlSAX2EndDocument		(void *ctx);
#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED)
XMLPUBFUN void XMLCALL
		xmlSAX2StartElement		(void *ctx,
						 const xmlChar *fullname,
						 const xmlChar **atts);
XMLPUBFUN void XMLCALL
		xmlSAX2EndElement		(void *ctx,
						 const xmlChar *name);
#endif /* LIBXML_SAX1_ENABLED or LIBXML_HTML_ENABLED */
XMLPUBFUN void XMLCALL
		xmlSAX2StartElementNs		(void *ctx,
						 const xmlChar *localname,
						 const xmlChar *prefix,
						 const xmlChar *URI,
						 int nb_namespaces,
						 const xmlChar **namespaces,
						 int nb_attributes,
						 int nb_defaulted,
						 const xmlChar **attributes);
XMLPUBFUN void XMLCALL
		xmlSAX2EndElementNs		(void *ctx,
						 const xmlChar *localname,
						 const xmlChar *prefix,
						 const xmlChar *URI);
XMLPUBFUN void XMLCALL
		xmlSAX2Reference		(void *ctx,
						 const xmlChar *name);
XMLPUBFUN void XMLCALL
		xmlSAX2Characters		(void *ctx,
						 const xmlChar *ch,
						 int len);
XMLPUBFUN void XMLCALL
		xmlSAX2IgnorableWhitespace	(void *ctx,
						 const xmlChar *ch,
						 int len);
XMLPUBFUN void XMLCALL
		xmlSAX2ProcessingInstruction	(void *ctx,
						 const xmlChar *target,
						 const xmlChar *data);
XMLPUBFUN void XMLCALL
		xmlSAX2Comment			(void *ctx,
						 const xmlChar *value);
XMLPUBFUN void XMLCALL
		xmlSAX2CDataBlock		(void *ctx,
						 const xmlChar *value,
						 int len);

#ifdef LIBXML_SAX1_ENABLED
XMLPUBFUN int XMLCALL
		xmlSAXDefaultVersion		(int version);
#endif /* LIBXML_SAX1_ENABLED */

XMLPUBFUN int XMLCALL
		xmlSAXVersion			(xmlSAXHandler *hdlr,
						 int version);
XMLPUBFUN void XMLCALL
		xmlSAX2InitDefaultSAXHandler    (xmlSAXHandler *hdlr,
						 int warning);
#ifdef LIBXML_HTML_ENABLED
XMLPUBFUN void XMLCALL
		xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr);
XMLPUBFUN void XMLCALL
		htmlDefaultSAXHandlerInit	(void);
#endif
#ifdef LIBXML_DOCB_ENABLED
XMLPUBFUN void XMLCALL
		xmlSAX2InitDocbDefaultSAXHandler(xmlSAXHandler *hdlr);
XMLPUBFUN void XMLCALL
		docbDefaultSAXHandlerInit	(void);
#endif
XMLPUBFUN void XMLCALL
		xmlDefaultSAXHandlerInit	(void);
#ifdef __cplusplus
}
#endif
#endif /* __XML_SAX2_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlsave.h
/*
 * Summary: the XML document serializer
 * Description: API to save document or subtree of document
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_XMLSAVE_H__
#define __XML_XMLSAVE_H__

#include <libxml/xmlversion.h>
#include <libxml/tree.h>
#include <libxml/encoding.h>
#include <libxml/xmlIO.h>

#ifdef LIBXML_OUTPUT_ENABLED
#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlSaveOption:
 *
 * This is the set of XML save options that can be passed down
 * to the xmlSaveToFd() and similar calls.
 */
typedef enum {
    XML_SAVE_FORMAT     = 1<<0,	/* format save output */
    XML_SAVE_NO_DECL    = 1<<1,	/* drop the xml declaration */
    XML_SAVE_NO_EMPTY	= 1<<2, /* no empty tags */
    XML_SAVE_NO_XHTML	= 1<<3, /* disable XHTML1 specific rules */
    XML_SAVE_XHTML	= 1<<4, /* force XHTML1 specific rules */
    XML_SAVE_AS_XML     = 1<<5, /* force XML serialization on HTML doc */
    XML_SAVE_AS_HTML    = 1<<6, /* force HTML serialization on XML doc */
    XML_SAVE_WSNONSIG   = 1<<7  /* format with non-significant whitespace */
} xmlSaveOption;


typedef struct _xmlSaveCtxt xmlSaveCtxt;
typedef xmlSaveCtxt *xmlSaveCtxtPtr;

XMLPUBFUN xmlSaveCtxtPtr XMLCALL
		xmlSaveToFd		(int fd,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlSaveCtxtPtr XMLCALL
		xmlSaveToFilename	(const char *filename,
					 const char *encoding,
					 int options);

XMLPUBFUN xmlSaveCtxtPtr XMLCALL
		xmlSaveToBuffer		(xmlBufferPtr buffer,
					 const char *encoding,
					 int options);

XMLPUBFUN xmlSaveCtxtPtr XMLCALL
		xmlSaveToIO		(xmlOutputWriteCallback iowrite,
					 xmlOutputCloseCallback ioclose,
					 void *ioctx,
					 const char *encoding,
					 int options);

XMLPUBFUN long XMLCALL
		xmlSaveDoc		(xmlSaveCtxtPtr ctxt,
					 xmlDocPtr doc);
XMLPUBFUN long XMLCALL
		xmlSaveTree		(xmlSaveCtxtPtr ctxt,
					 xmlNodePtr node);

XMLPUBFUN int XMLCALL
		xmlSaveFlush		(xmlSaveCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
		xmlSaveClose		(xmlSaveCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
		xmlSaveSetEscape	(xmlSaveCtxtPtr ctxt,
					 xmlCharEncodingOutputFunc escape);
XMLPUBFUN int XMLCALL
		xmlSaveSetAttrEscape	(xmlSaveCtxtPtr ctxt,
					 xmlCharEncodingOutputFunc escape);
#ifdef __cplusplus
}
#endif
#endif /* LIBXML_OUTPUT_ENABLED */
#endif /* __XML_XMLSAVE_H__ */


**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlversion.h
/*
 * Summary: compile-time version informations
 * Description: compile-time version informations for the XML library
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_VERSION_H__
#define __XML_VERSION_H__

#include <libxml/xmlexports.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * use those to be sure nothing nasty will happen if
 * your library and includes mismatch
 */
#ifndef LIBXML2_COMPILING_MSCCDEF
XMLPUBFUN void XMLCALL xmlCheckVersion(int version);
#endif /* LIBXML2_COMPILING_MSCCDEF */

/**
 * LIBXML_DOTTED_VERSION:
 *
 * the version string like "1.2.3"
 */
#define LIBXML_DOTTED_VERSION "2.9.1"

/**
 * LIBXML_VERSION:
 *
 * the version number: 1.2.3 value is 10203
 */
#define LIBXML_VERSION 20901

/**
 * LIBXML_VERSION_STRING:
 *
 * the version number string, 1.2.3 value is "10203"
 */
#define LIBXML_VERSION_STRING "20901"

/**
 * LIBXML_VERSION_EXTRA:
 *
 * extra version information, used to show a CVS compilation
 */
#define LIBXML_VERSION_EXTRA ""

/**
 * LIBXML_TEST_VERSION:
 *
 * Macro to check that the libxml version in use is compatible with
 * the version the software has been compiled against
 */
#define LIBXML_TEST_VERSION xmlCheckVersion(20901);

#ifndef VMS
#if 0
/**
 * WITH_TRIO:
 *
 * defined if the trio support need to be configured in
 */
#define WITH_TRIO
#else
/**
 * WITHOUT_TRIO:
 *
 * defined if the trio support should not be configured in
 */
#define WITHOUT_TRIO
#endif
#else /* VMS */
/**
 * WITH_TRIO:
 *
 * defined if the trio support need to be configured in
 */
#define WITH_TRIO 1
#endif /* VMS */

/**
 * LIBXML_THREAD_ENABLED:
 *
 * Whether the thread support is configured in
 */
#if 1
#if defined(_REENTRANT) || defined(__MT__) || \
    (defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE - 0 >= 199506L))
#define LIBXML_THREAD_ENABLED
#endif
#endif

/**
 * LIBXML_THREAD_ALLOC_ENABLED:
 *
 * Whether the allocation hooks are per-thread
 */
#if 0
#define LIBXML_THREAD_ALLOC_ENABLED
#endif

/**
 * LIBXML_TREE_ENABLED:
 *
 * Whether the DOM like tree manipulation API support is configured in
 */
#if 1
#define LIBXML_TREE_ENABLED
#endif

/**
 * LIBXML_OUTPUT_ENABLED:
 *
 * Whether the serialization/saving support is configured in
 */
#if 1
#define LIBXML_OUTPUT_ENABLED
#endif

/**
 * LIBXML_PUSH_ENABLED:
 *
 * Whether the push parsing interfaces are configured in
 */
#if 1
#define LIBXML_PUSH_ENABLED
#endif

/**
 * LIBXML_READER_ENABLED:
 *
 * Whether the xmlReader parsing interface is configured in
 */
#if 1
#define LIBXML_READER_ENABLED
#endif

/**
 * LIBXML_PATTERN_ENABLED:
 *
 * Whether the xmlPattern node selection interface is configured in
 */
#if 1
#define LIBXML_PATTERN_ENABLED
#endif

/**
 * LIBXML_WRITER_ENABLED:
 *
 * Whether the xmlWriter saving interface is configured in
 */
#if 1
#define LIBXML_WRITER_ENABLED
#endif

/**
 * LIBXML_SAX1_ENABLED:
 *
 * Whether the older SAX1 interface is configured in
 */
#if 1
#define LIBXML_SAX1_ENABLED
#endif

/**
 * LIBXML_FTP_ENABLED:
 *
 * Whether the FTP support is configured in
 */
#if 1
#define LIBXML_FTP_ENABLED
#endif

/**
 * LIBXML_HTTP_ENABLED:
 *
 * Whether the HTTP support is configured in
 */
#if 1
#define LIBXML_HTTP_ENABLED
#endif

/**
 * LIBXML_VALID_ENABLED:
 *
 * Whether the DTD validation support is configured in
 */
#if 1
#define LIBXML_VALID_ENABLED
#endif

/**
 * LIBXML_HTML_ENABLED:
 *
 * Whether the HTML support is configured in
 */
#if 1
#define LIBXML_HTML_ENABLED
#endif

/**
 * LIBXML_LEGACY_ENABLED:
 *
 * Whether the deprecated APIs are compiled in for compatibility
 */
#if 1
#define LIBXML_LEGACY_ENABLED
#endif

/**
 * LIBXML_C14N_ENABLED:
 *
 * Whether the Canonicalization support is configured in
 */
#if 1
#define LIBXML_C14N_ENABLED
#endif

/**
 * LIBXML_CATALOG_ENABLED:
 *
 * Whether the Catalog support is configured in
 */
#if 1
#define LIBXML_CATALOG_ENABLED
#endif

/**
 * LIBXML_DOCB_ENABLED:
 *
 * Whether the SGML Docbook support is configured in
 */
#if 1
#define LIBXML_DOCB_ENABLED
#endif

/**
 * LIBXML_XPATH_ENABLED:
 *
 * Whether XPath is configured in
 */
#if 1
#define LIBXML_XPATH_ENABLED
#endif

/**
 * LIBXML_XPTR_ENABLED:
 *
 * Whether XPointer is configured in
 */
#if 1
#define LIBXML_XPTR_ENABLED
#endif

/**
 * LIBXML_XINCLUDE_ENABLED:
 *
 * Whether XInclude is configured in
 */
#if 1
#define LIBXML_XINCLUDE_ENABLED
#endif

/**
 * LIBXML_ICONV_ENABLED:
 *
 * Whether iconv support is available
 */
#if 1
#define LIBXML_ICONV_ENABLED
#endif

/**
 * LIBXML_ICU_ENABLED:
 *
 * Whether icu support is available
 */
#if 0
#define LIBXML_ICU_ENABLED
#endif

/**
 * LIBXML_ISO8859X_ENABLED:
 *
 * Whether ISO-8859-* support is made available in case iconv is not
 */
#if 1
#define LIBXML_ISO8859X_ENABLED
#endif

/**
 * LIBXML_DEBUG_ENABLED:
 *
 * Whether Debugging module is configured in
 */
#if 1
#define LIBXML_DEBUG_ENABLED
#endif

/**
 * DEBUG_MEMORY_LOCATION:
 *
 * Whether the memory debugging is configured in
 */
#if 0
#define DEBUG_MEMORY_LOCATION
#endif

/**
 * LIBXML_DEBUG_RUNTIME:
 *
 * Whether the runtime debugging is configured in
 */
#if 0
#define LIBXML_DEBUG_RUNTIME
#endif

/**
 * LIBXML_UNICODE_ENABLED:
 *
 * Whether the Unicode related interfaces are compiled in
 */
#if 1
#define LIBXML_UNICODE_ENABLED
#endif

/**
 * LIBXML_REGEXP_ENABLED:
 *
 * Whether the regular expressions interfaces are compiled in
 */
#if 1
#define LIBXML_REGEXP_ENABLED
#endif

/**
 * LIBXML_AUTOMATA_ENABLED:
 *
 * Whether the automata interfaces are compiled in
 */
#if 1
#define LIBXML_AUTOMATA_ENABLED
#endif

/**
 * LIBXML_EXPR_ENABLED:
 *
 * Whether the formal expressions interfaces are compiled in
 */
#if 1
#define LIBXML_EXPR_ENABLED
#endif

/**
 * LIBXML_SCHEMAS_ENABLED:
 *
 * Whether the Schemas validation interfaces are compiled in
 */
#if 1
#define LIBXML_SCHEMAS_ENABLED
#endif

/**
 * LIBXML_SCHEMATRON_ENABLED:
 *
 * Whether the Schematron validation interfaces are compiled in
 */
#if 1
#define LIBXML_SCHEMATRON_ENABLED
#endif

/**
 * LIBXML_MODULES_ENABLED:
 *
 * Whether the module interfaces are compiled in
 */
#if 1
#define LIBXML_MODULES_ENABLED
/**
 * LIBXML_MODULE_EXTENSION:
 *
 * the string suffix used by dynamic modules (usually shared libraries)
 */
#define LIBXML_MODULE_EXTENSION ".so" 
#endif

/**
 * LIBXML_ZLIB_ENABLED:
 *
 * Whether the Zlib support is compiled in
 */
#if 1
#define LIBXML_ZLIB_ENABLED
#endif

/**
 * LIBXML_LZMA_ENABLED:
 *
 * Whether the Lzma support is compiled in
 */
#if 1
#define LIBXML_LZMA_ENABLED
#endif

#ifdef __GNUC__
#ifdef HAVE_ANSIDECL_H
#include <ansidecl.h>
#endif

/**
 * ATTRIBUTE_UNUSED:
 *
 * Macro used to signal to GCC unused function parameters
 */

#ifndef ATTRIBUTE_UNUSED
# if ((__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ >= 7)))
#  define ATTRIBUTE_UNUSED __attribute__((unused))
# else
#  define ATTRIBUTE_UNUSED
# endif
#endif

/**
 * LIBXML_ATTR_ALLOC_SIZE:
 *
 * Macro used to indicate to GCC this is an allocator function
 */

#ifndef LIBXML_ATTR_ALLOC_SIZE
# if ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)))
#  define LIBXML_ATTR_ALLOC_SIZE(x) __attribute__((alloc_size(x)))
# else
#  define LIBXML_ATTR_ALLOC_SIZE(x)
# endif
#else
# define LIBXML_ATTR_ALLOC_SIZE(x)
#endif

/**
 * LIBXML_ATTR_FORMAT:
 *
 * Macro used to indicate to GCC the parameter are printf like
 */

#ifndef LIBXML_ATTR_FORMAT
# if ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)))
#  define LIBXML_ATTR_FORMAT(fmt,args) __attribute__((__format__(__printf__,fmt,args)))
# else
#  define LIBXML_ATTR_FORMAT(fmt,args)
# endif
#else
# define LIBXML_ATTR_FORMAT(fmt,args)
#endif

#else /* ! __GNUC__ */
/**
 * ATTRIBUTE_UNUSED:
 *
 * Macro used to signal to GCC unused function parameters
 */
#define ATTRIBUTE_UNUSED
/**
 * LIBXML_ATTR_ALLOC_SIZE:
 *
 * Macro used to indicate to GCC this is an allocator function
 */
#define LIBXML_ATTR_ALLOC_SIZE(x)
/**
 * LIBXML_ATTR_FORMAT:
 *
 * Macro used to indicate to GCC the parameter are printf like
 */
#define LIBXML_ATTR_FORMAT(fmt,args)
#endif /* __GNUC__ */

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif


**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/chvalid.h
/*
 * Summary: Unicode character range checking
 * Description: this module exports interfaces for the character
 *               range validation APIs
 *
 * This file is automatically generated from the cvs source
 * definition files using the genChRanges.py Python script
 *
 * Generation date: Mon Mar 27 11:09:48 2006
 * Sources: chvalid.def
 * Author: William Brack <wbrack@mmm.com.hk>
 */

#ifndef __XML_CHVALID_H__
#define __XML_CHVALID_H__

#include <libxml/xmlversion.h>
#include <libxml/xmlstring.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Define our typedefs and structures
 *
 */
typedef struct _xmlChSRange xmlChSRange;
typedef xmlChSRange *xmlChSRangePtr;
struct _xmlChSRange {
    unsigned short	low;
    unsigned short	high;
};

typedef struct _xmlChLRange xmlChLRange;
typedef xmlChLRange *xmlChLRangePtr;
struct _xmlChLRange {
    unsigned int	low;
    unsigned int	high;
};

typedef struct _xmlChRangeGroup xmlChRangeGroup;
typedef xmlChRangeGroup *xmlChRangeGroupPtr;
struct _xmlChRangeGroup {
    int			nbShortRange;
    int			nbLongRange;
    const xmlChSRange	*shortRange;	/* points to an array of ranges */
    const xmlChLRange	*longRange;
};

/**
 * Range checking routine
 */
XMLPUBFUN int XMLCALL
		xmlCharInRange(unsigned int val, const xmlChRangeGroup *group);


/**
 * xmlIsBaseChar_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
				  (0xf8 <= (c)))

/**
 * xmlIsBaseCharQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
				 xmlIsBaseChar_ch((c)) : \
				 xmlCharInRange((c), &xmlIsBaseCharGroup))

XMLPUBVAR const xmlChRangeGroup xmlIsBaseCharGroup;

/**
 * xmlIsBlank_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
				 ((c) == 0xd))

/**
 * xmlIsBlankQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsBlankQ(c)		(((c) < 0x100) ? \
				 xmlIsBlank_ch((c)) : 0)


/**
 * xmlIsChar_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
				 ((c) == 0xd) || \
				  (0x20 <= (c)))

/**
 * xmlIsCharQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsCharQ(c)		(((c) < 0x100) ? \
				 xmlIsChar_ch((c)) :\
				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))

XMLPUBVAR const xmlChRangeGroup xmlIsCharGroup;

/**
 * xmlIsCombiningQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
				 0 : \
				 xmlCharInRange((c), &xmlIsCombiningGroup))

XMLPUBVAR const xmlChRangeGroup xmlIsCombiningGroup;

/**
 * xmlIsDigit_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))

/**
 * xmlIsDigitQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
				 xmlIsDigit_ch((c)) : \
				 xmlCharInRange((c), &xmlIsDigitGroup))

XMLPUBVAR const xmlChRangeGroup xmlIsDigitGroup;

/**
 * xmlIsExtender_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsExtender_ch(c)	(((c) == 0xb7))

/**
 * xmlIsExtenderQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
				 xmlIsExtender_ch((c)) : \
				 xmlCharInRange((c), &xmlIsExtenderGroup))

XMLPUBVAR const xmlChRangeGroup xmlIsExtenderGroup;

/**
 * xmlIsIdeographicQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
				 0 :\
				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
				 ((c) == 0x3007) || \
				 ((0x3021 <= (c)) && ((c) <= 0x3029))))

XMLPUBVAR const xmlChRangeGroup xmlIsIdeographicGroup;
XMLPUBVAR const unsigned char xmlIsPubidChar_tab[256];

/**
 * xmlIsPubidChar_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsPubidChar_ch(c)	(xmlIsPubidChar_tab[(c)])

/**
 * xmlIsPubidCharQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#define xmlIsPubidCharQ(c)	(((c) < 0x100) ? \
				 xmlIsPubidChar_ch((c)) : 0)

XMLPUBFUN int XMLCALL
		xmlIsBaseChar(unsigned int ch);
XMLPUBFUN int XMLCALL
		xmlIsBlank(unsigned int ch);
XMLPUBFUN int XMLCALL
		xmlIsChar(unsigned int ch);
XMLPUBFUN int XMLCALL
		xmlIsCombining(unsigned int ch);
XMLPUBFUN int XMLCALL
		xmlIsDigit(unsigned int ch);
XMLPUBFUN int XMLCALL
		xmlIsExtender(unsigned int ch);
XMLPUBFUN int XMLCALL
		xmlIsIdeographic(unsigned int ch);
XMLPUBFUN int XMLCALL
		xmlIsPubidChar(unsigned int ch);

#ifdef __cplusplus
}
#endif
#endif /* __XML_CHVALID_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlerror.h
/*
 * Summary: error handling
 * Description: the API used to report errors
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#include <libxml/parser.h>

#ifndef __XML_ERROR_H__
#define __XML_ERROR_H__

#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlErrorLevel:
 *
 * Indicates the level of an error
 */
typedef enum {
    XML_ERR_NONE = 0,
    XML_ERR_WARNING = 1,	/* A simple warning */
    XML_ERR_ERROR = 2,		/* A recoverable error */
    XML_ERR_FATAL = 3		/* A fatal error */
} xmlErrorLevel;

/**
 * xmlErrorDomain:
 *
 * Indicates where an error may have come from
 */
typedef enum {
    XML_FROM_NONE = 0,
    XML_FROM_PARSER,	/* The XML parser */
    XML_FROM_TREE,	/* The tree module */
    XML_FROM_NAMESPACE,	/* The XML Namespace module */
    XML_FROM_DTD,	/* The XML DTD validation with parser context*/
    XML_FROM_HTML,	/* The HTML parser */
    XML_FROM_MEMORY,	/* The memory allocator */
    XML_FROM_OUTPUT,	/* The serialization code */
    XML_FROM_IO,	/* The Input/Output stack */
    XML_FROM_FTP,	/* The FTP module */
    XML_FROM_HTTP,	/* The HTTP module */
    XML_FROM_XINCLUDE,	/* The XInclude processing */
    XML_FROM_XPATH,	/* The XPath module */
    XML_FROM_XPOINTER,	/* The XPointer module */
    XML_FROM_REGEXP,	/* The regular expressions module */
    XML_FROM_DATATYPE,	/* The W3C XML Schemas Datatype module */
    XML_FROM_SCHEMASP,	/* The W3C XML Schemas parser module */
    XML_FROM_SCHEMASV,	/* The W3C XML Schemas validation module */
    XML_FROM_RELAXNGP,	/* The Relax-NG parser module */
    XML_FROM_RELAXNGV,	/* The Relax-NG validator module */
    XML_FROM_CATALOG,	/* The Catalog module */
    XML_FROM_C14N,	/* The Canonicalization module */
    XML_FROM_XSLT,	/* The XSLT engine from libxslt */
    XML_FROM_VALID,	/* The XML DTD validation with valid context */
    XML_FROM_CHECK,	/* The error checking module */
    XML_FROM_WRITER,	/* The xmlwriter module */
    XML_FROM_MODULE,	/* The dynamically loaded module module*/
    XML_FROM_I18N,	/* The module handling character conversion */
    XML_FROM_SCHEMATRONV,/* The Schematron validator module */
    XML_FROM_BUFFER,    /* The buffers module */
    XML_FROM_URI        /* The URI module */
} xmlErrorDomain;

/**
 * xmlError:
 *
 * An XML Error instance.
 */

typedef struct _xmlError xmlError;
typedef xmlError *xmlErrorPtr;
struct _xmlError {
    int		domain;	/* What part of the library raised this error */
    int		code;	/* The error code, e.g. an xmlParserError */
    char       *message;/* human-readable informative error message */
    xmlErrorLevel level;/* how consequent is the error */
    char       *file;	/* the filename */
    int		line;	/* the line number if available */
    char       *str1;	/* extra string information */
    char       *str2;	/* extra string information */
    char       *str3;	/* extra string information */
    int		int1;	/* extra number information */
    int		int2;	/* column number of the error or 0 if N/A (todo: rename this field when we would break ABI) */
    void       *ctxt;   /* the parser context if available */
    void       *node;   /* the node in the tree */
};

/**
 * xmlParserError:
 *
 * This is an error that the XML (or HTML) parser can generate
 */
typedef enum {
    XML_ERR_OK = 0,
    XML_ERR_INTERNAL_ERROR, /* 1 */
    XML_ERR_NO_MEMORY, /* 2 */
    XML_ERR_DOCUMENT_START, /* 3 */
    XML_ERR_DOCUMENT_EMPTY, /* 4 */
    XML_ERR_DOCUMENT_END, /* 5 */
    XML_ERR_INVALID_HEX_CHARREF, /* 6 */
    XML_ERR_INVALID_DEC_CHARREF, /* 7 */
    XML_ERR_INVALID_CHARREF, /* 8 */
    XML_ERR_INVALID_CHAR, /* 9 */
    XML_ERR_CHARREF_AT_EOF, /* 10 */
    XML_ERR_CHARREF_IN_PROLOG, /* 11 */
    XML_ERR_CHARREF_IN_EPILOG, /* 12 */
    XML_ERR_CHARREF_IN_DTD, /* 13 */
    XML_ERR_ENTITYREF_AT_EOF, /* 14 */
    XML_ERR_ENTITYREF_IN_PROLOG, /* 15 */
    XML_ERR_ENTITYREF_IN_EPILOG, /* 16 */
    XML_ERR_ENTITYREF_IN_DTD, /* 17 */
    XML_ERR_PEREF_AT_EOF, /* 18 */
    XML_ERR_PEREF_IN_PROLOG, /* 19 */
    XML_ERR_PEREF_IN_EPILOG, /* 20 */
    XML_ERR_PEREF_IN_INT_SUBSET, /* 21 */
    XML_ERR_ENTITYREF_NO_NAME, /* 22 */
    XML_ERR_ENTITYREF_SEMICOL_MISSING, /* 23 */
    XML_ERR_PEREF_NO_NAME, /* 24 */
    XML_ERR_PEREF_SEMICOL_MISSING, /* 25 */
    XML_ERR_UNDECLARED_ENTITY, /* 26 */
    XML_WAR_UNDECLARED_ENTITY, /* 27 */
    XML_ERR_UNPARSED_ENTITY, /* 28 */
    XML_ERR_ENTITY_IS_EXTERNAL, /* 29 */
    XML_ERR_ENTITY_IS_PARAMETER, /* 30 */
    XML_ERR_UNKNOWN_ENCODING, /* 31 */
    XML_ERR_UNSUPPORTED_ENCODING, /* 32 */
    XML_ERR_STRING_NOT_STARTED, /* 33 */
    XML_ERR_STRING_NOT_CLOSED, /* 34 */
    XML_ERR_NS_DECL_ERROR, /* 35 */
    XML_ERR_ENTITY_NOT_STARTED, /* 36 */
    XML_ERR_ENTITY_NOT_FINISHED, /* 37 */
    XML_ERR_LT_IN_ATTRIBUTE, /* 38 */
    XML_ERR_ATTRIBUTE_NOT_STARTED, /* 39 */
    XML_ERR_ATTRIBUTE_NOT_FINISHED, /* 40 */
    XML_ERR_ATTRIBUTE_WITHOUT_VALUE, /* 41 */
    XML_ERR_ATTRIBUTE_REDEFINED, /* 42 */
    XML_ERR_LITERAL_NOT_STARTED, /* 43 */
    XML_ERR_LITERAL_NOT_FINISHED, /* 44 */
    XML_ERR_COMMENT_NOT_FINISHED, /* 45 */
    XML_ERR_PI_NOT_STARTED, /* 46 */
    XML_ERR_PI_NOT_FINISHED, /* 47 */
    XML_ERR_NOTATION_NOT_STARTED, /* 48 */
    XML_ERR_NOTATION_NOT_FINISHED, /* 49 */
    XML_ERR_ATTLIST_NOT_STARTED, /* 50 */
    XML_ERR_ATTLIST_NOT_FINISHED, /* 51 */
    XML_ERR_MIXED_NOT_STARTED, /* 52 */
    XML_ERR_MIXED_NOT_FINISHED, /* 53 */
    XML_ERR_ELEMCONTENT_NOT_STARTED, /* 54 */
    XML_ERR_ELEMCONTENT_NOT_FINISHED, /* 55 */
    XML_ERR_XMLDECL_NOT_STARTED, /* 56 */
    XML_ERR_XMLDECL_NOT_FINISHED, /* 57 */
    XML_ERR_CONDSEC_NOT_STARTED, /* 58 */
    XML_ERR_CONDSEC_NOT_FINISHED, /* 59 */
    XML_ERR_EXT_SUBSET_NOT_FINISHED, /* 60 */
    XML_ERR_DOCTYPE_NOT_FINISHED, /* 61 */
    XML_ERR_MISPLACED_CDATA_END, /* 62 */
    XML_ERR_CDATA_NOT_FINISHED, /* 63 */
    XML_ERR_RESERVED_XML_NAME, /* 64 */
    XML_ERR_SPACE_REQUIRED, /* 65 */
    XML_ERR_SEPARATOR_REQUIRED, /* 66 */
    XML_ERR_NMTOKEN_REQUIRED, /* 67 */
    XML_ERR_NAME_REQUIRED, /* 68 */
    XML_ERR_PCDATA_REQUIRED, /* 69 */
    XML_ERR_URI_REQUIRED, /* 70 */
    XML_ERR_PUBID_REQUIRED, /* 71 */
    XML_ERR_LT_REQUIRED, /* 72 */
    XML_ERR_GT_REQUIRED, /* 73 */
    XML_ERR_LTSLASH_REQUIRED, /* 74 */
    XML_ERR_EQUAL_REQUIRED, /* 75 */
    XML_ERR_TAG_NAME_MISMATCH, /* 76 */
    XML_ERR_TAG_NOT_FINISHED, /* 77 */
    XML_ERR_STANDALONE_VALUE, /* 78 */
    XML_ERR_ENCODING_NAME, /* 79 */
    XML_ERR_HYPHEN_IN_COMMENT, /* 80 */
    XML_ERR_INVALID_ENCODING, /* 81 */
    XML_ERR_EXT_ENTITY_STANDALONE, /* 82 */
    XML_ERR_CONDSEC_INVALID, /* 83 */
    XML_ERR_VALUE_REQUIRED, /* 84 */
    XML_ERR_NOT_WELL_BALANCED, /* 85 */
    XML_ERR_EXTRA_CONTENT, /* 86 */
    XML_ERR_ENTITY_CHAR_ERROR, /* 87 */
    XML_ERR_ENTITY_PE_INTERNAL, /* 88 */
    XML_ERR_ENTITY_LOOP, /* 89 */
    XML_ERR_ENTITY_BOUNDARY, /* 90 */
    XML_ERR_INVALID_URI, /* 91 */
    XML_ERR_URI_FRAGMENT, /* 92 */
    XML_WAR_CATALOG_PI, /* 93 */
    XML_ERR_NO_DTD, /* 94 */
    XML_ERR_CONDSEC_INVALID_KEYWORD, /* 95 */
    XML_ERR_VERSION_MISSING, /* 96 */
    XML_WAR_UNKNOWN_VERSION, /* 97 */
    XML_WAR_LANG_VALUE, /* 98 */
    XML_WAR_NS_URI, /* 99 */
    XML_WAR_NS_URI_RELATIVE, /* 100 */
    XML_ERR_MISSING_ENCODING, /* 101 */
    XML_WAR_SPACE_VALUE, /* 102 */
    XML_ERR_NOT_STANDALONE, /* 103 */
    XML_ERR_ENTITY_PROCESSING, /* 104 */
    XML_ERR_NOTATION_PROCESSING, /* 105 */
    XML_WAR_NS_COLUMN, /* 106 */
    XML_WAR_ENTITY_REDEFINED, /* 107 */
    XML_ERR_UNKNOWN_VERSION, /* 108 */
    XML_ERR_VERSION_MISMATCH, /* 109 */
    XML_ERR_NAME_TOO_LONG, /* 110 */
    XML_ERR_USER_STOP, /* 111 */
    XML_NS_ERR_XML_NAMESPACE = 200,
    XML_NS_ERR_UNDEFINED_NAMESPACE, /* 201 */
    XML_NS_ERR_QNAME, /* 202 */
    XML_NS_ERR_ATTRIBUTE_REDEFINED, /* 203 */
    XML_NS_ERR_EMPTY, /* 204 */
    XML_NS_ERR_COLON, /* 205 */
    XML_DTD_ATTRIBUTE_DEFAULT = 500,
    XML_DTD_ATTRIBUTE_REDEFINED, /* 501 */
    XML_DTD_ATTRIBUTE_VALUE, /* 502 */
    XML_DTD_CONTENT_ERROR, /* 503 */
    XML_DTD_CONTENT_MODEL, /* 504 */
    XML_DTD_CONTENT_NOT_DETERMINIST, /* 505 */
    XML_DTD_DIFFERENT_PREFIX, /* 506 */
    XML_DTD_ELEM_DEFAULT_NAMESPACE, /* 507 */
    XML_DTD_ELEM_NAMESPACE, /* 508 */
    XML_DTD_ELEM_REDEFINED, /* 509 */
    XML_DTD_EMPTY_NOTATION, /* 510 */
    XML_DTD_ENTITY_TYPE, /* 511 */
    XML_DTD_ID_FIXED, /* 512 */
    XML_DTD_ID_REDEFINED, /* 513 */
    XML_DTD_ID_SUBSET, /* 514 */
    XML_DTD_INVALID_CHILD, /* 515 */
    XML_DTD_INVALID_DEFAULT, /* 516 */
    XML_DTD_LOAD_ERROR, /* 517 */
    XML_DTD_MISSING_ATTRIBUTE, /* 518 */
    XML_DTD_MIXED_CORRUPT, /* 519 */
    XML_DTD_MULTIPLE_ID, /* 520 */
    XML_DTD_NO_DOC, /* 521 */
    XML_DTD_NO_DTD, /* 522 */
    XML_DTD_NO_ELEM_NAME, /* 523 */
    XML_DTD_NO_PREFIX, /* 524 */
    XML_DTD_NO_ROOT, /* 525 */
    XML_DTD_NOTATION_REDEFINED, /* 526 */
    XML_DTD_NOTATION_VALUE, /* 527 */
    XML_DTD_NOT_EMPTY, /* 528 */
    XML_DTD_NOT_PCDATA, /* 529 */
    XML_DTD_NOT_STANDALONE, /* 530 */
    XML_DTD_ROOT_NAME, /* 531 */
    XML_DTD_STANDALONE_WHITE_SPACE, /* 532 */
    XML_DTD_UNKNOWN_ATTRIBUTE, /* 533 */
    XML_DTD_UNKNOWN_ELEM, /* 534 */
    XML_DTD_UNKNOWN_ENTITY, /* 535 */
    XML_DTD_UNKNOWN_ID, /* 536 */
    XML_DTD_UNKNOWN_NOTATION, /* 537 */
    XML_DTD_STANDALONE_DEFAULTED, /* 538 */
    XML_DTD_XMLID_VALUE, /* 539 */
    XML_DTD_XMLID_TYPE, /* 540 */
    XML_DTD_DUP_TOKEN, /* 541 */
    XML_HTML_STRUCURE_ERROR = 800,
    XML_HTML_UNKNOWN_TAG, /* 801 */
    XML_RNGP_ANYNAME_ATTR_ANCESTOR = 1000,
    XML_RNGP_ATTR_CONFLICT, /* 1001 */
    XML_RNGP_ATTRIBUTE_CHILDREN, /* 1002 */
    XML_RNGP_ATTRIBUTE_CONTENT, /* 1003 */
    XML_RNGP_ATTRIBUTE_EMPTY, /* 1004 */
    XML_RNGP_ATTRIBUTE_NOOP, /* 1005 */
    XML_RNGP_CHOICE_CONTENT, /* 1006 */
    XML_RNGP_CHOICE_EMPTY, /* 1007 */
    XML_RNGP_CREATE_FAILURE, /* 1008 */
    XML_RNGP_DATA_CONTENT, /* 1009 */
    XML_RNGP_DEF_CHOICE_AND_INTERLEAVE, /* 1010 */
    XML_RNGP_DEFINE_CREATE_FAILED, /* 1011 */
    XML_RNGP_DEFINE_EMPTY, /* 1012 */
    XML_RNGP_DEFINE_MISSING, /* 1013 */
    XML_RNGP_DEFINE_NAME_MISSING, /* 1014 */
    XML_RNGP_ELEM_CONTENT_EMPTY, /* 1015 */
    XML_RNGP_ELEM_CONTENT_ERROR, /* 1016 */
    XML_RNGP_ELEMENT_EMPTY, /* 1017 */
    XML_RNGP_ELEMENT_CONTENT, /* 1018 */
    XML_RNGP_ELEMENT_NAME, /* 1019 */
    XML_RNGP_ELEMENT_NO_CONTENT, /* 1020 */
    XML_RNGP_ELEM_TEXT_CONFLICT, /* 1021 */
    XML_RNGP_EMPTY, /* 1022 */
    XML_RNGP_EMPTY_CONSTRUCT, /* 1023 */
    XML_RNGP_EMPTY_CONTENT, /* 1024 */
    XML_RNGP_EMPTY_NOT_EMPTY, /* 1025 */
    XML_RNGP_ERROR_TYPE_LIB, /* 1026 */
    XML_RNGP_EXCEPT_EMPTY, /* 1027 */
    XML_RNGP_EXCEPT_MISSING, /* 1028 */
    XML_RNGP_EXCEPT_MULTIPLE, /* 1029 */
    XML_RNGP_EXCEPT_NO_CONTENT, /* 1030 */
    XML_RNGP_EXTERNALREF_EMTPY, /* 1031 */
    XML_RNGP_EXTERNAL_REF_FAILURE, /* 1032 */
    XML_RNGP_EXTERNALREF_RECURSE, /* 1033 */
    XML_RNGP_FORBIDDEN_ATTRIBUTE, /* 1034 */
    XML_RNGP_FOREIGN_ELEMENT, /* 1035 */
    XML_RNGP_GRAMMAR_CONTENT, /* 1036 */
    XML_RNGP_GRAMMAR_EMPTY, /* 1037 */
    XML_RNGP_GRAMMAR_MISSING, /* 1038 */
    XML_RNGP_GRAMMAR_NO_START, /* 1039 */
    XML_RNGP_GROUP_ATTR_CONFLICT, /* 1040 */
    XML_RNGP_HREF_ERROR, /* 1041 */
    XML_RNGP_INCLUDE_EMPTY, /* 1042 */
    XML_RNGP_INCLUDE_FAILURE, /* 1043 */
    XML_RNGP_INCLUDE_RECURSE, /* 1044 */
    XML_RNGP_INTERLEAVE_ADD, /* 1045 */
    XML_RNGP_INTERLEAVE_CREATE_FAILED, /* 1046 */
    XML_RNGP_INTERLEAVE_EMPTY, /* 1047 */
    XML_RNGP_INTERLEAVE_NO_CONTENT, /* 1048 */
    XML_RNGP_INVALID_DEFINE_NAME, /* 1049 */
    XML_RNGP_INVALID_URI, /* 1050 */
    XML_RNGP_INVALID_VALUE, /* 1051 */
    XML_RNGP_MISSING_HREF, /* 1052 */
    XML_RNGP_NAME_MISSING, /* 1053 */
    XML_RNGP_NEED_COMBINE, /* 1054 */
    XML_RNGP_NOTALLOWED_NOT_EMPTY, /* 1055 */
    XML_RNGP_NSNAME_ATTR_ANCESTOR, /* 1056 */
    XML_RNGP_NSNAME_NO_NS, /* 1057 */
    XML_RNGP_PARAM_FORBIDDEN, /* 1058 */
    XML_RNGP_PARAM_NAME_MISSING, /* 1059 */
    XML_RNGP_PARENTREF_CREATE_FAILED, /* 1060 */
    XML_RNGP_PARENTREF_NAME_INVALID, /* 1061 */
    XML_RNGP_PARENTREF_NO_NAME, /* 1062 */
    XML_RNGP_PARENTREF_NO_PARENT, /* 1063 */
    XML_RNGP_PARENTREF_NOT_EMPTY, /* 1064 */
    XML_RNGP_PARSE_ERROR, /* 1065 */
    XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME, /* 1066 */
    XML_RNGP_PAT_ATTR_ATTR, /* 1067 */
    XML_RNGP_PAT_ATTR_ELEM, /* 1068 */
    XML_RNGP_PAT_DATA_EXCEPT_ATTR, /* 1069 */
    XML_RNGP_PAT_DATA_EXCEPT_ELEM, /* 1070 */
    XML_RNGP_PAT_DATA_EXCEPT_EMPTY, /* 1071 */
    XML_RNGP_PAT_DATA_EXCEPT_GROUP, /* 1072 */
    XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE, /* 1073 */
    XML_RNGP_PAT_DATA_EXCEPT_LIST, /* 1074 */
    XML_RNGP_PAT_DATA_EXCEPT_ONEMORE, /* 1075 */
    XML_RNGP_PAT_DATA_EXCEPT_REF, /* 1076 */
    XML_RNGP_PAT_DATA_EXCEPT_TEXT, /* 1077 */
    XML_RNGP_PAT_LIST_ATTR, /* 1078 */
    XML_RNGP_PAT_LIST_ELEM, /* 1079 */
    XML_RNGP_PAT_LIST_INTERLEAVE, /* 1080 */
    XML_RNGP_PAT_LIST_LIST, /* 1081 */
    XML_RNGP_PAT_LIST_REF, /* 1082 */
    XML_RNGP_PAT_LIST_TEXT, /* 1083 */
    XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME, /* 1084 */
    XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME, /* 1085 */
    XML_RNGP_PAT_ONEMORE_GROUP_ATTR, /* 1086 */
    XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR, /* 1087 */
    XML_RNGP_PAT_START_ATTR, /* 1088 */
    XML_RNGP_PAT_START_DATA, /* 1089 */
    XML_RNGP_PAT_START_EMPTY, /* 1090 */
    XML_RNGP_PAT_START_GROUP, /* 1091 */
    XML_RNGP_PAT_START_INTERLEAVE, /* 1092 */
    XML_RNGP_PAT_START_LIST, /* 1093 */
    XML_RNGP_PAT_START_ONEMORE, /* 1094 */
    XML_RNGP_PAT_START_TEXT, /* 1095 */
    XML_RNGP_PAT_START_VALUE, /* 1096 */
    XML_RNGP_PREFIX_UNDEFINED, /* 1097 */
    XML_RNGP_REF_CREATE_FAILED, /* 1098 */
    XML_RNGP_REF_CYCLE, /* 1099 */
    XML_RNGP_REF_NAME_INVALID, /* 1100 */
    XML_RNGP_REF_NO_DEF, /* 1101 */
    XML_RNGP_REF_NO_NAME, /* 1102 */
    XML_RNGP_REF_NOT_EMPTY, /* 1103 */
    XML_RNGP_START_CHOICE_AND_INTERLEAVE, /* 1104 */
    XML_RNGP_START_CONTENT, /* 1105 */
    XML_RNGP_START_EMPTY, /* 1106 */
    XML_RNGP_START_MISSING, /* 1107 */
    XML_RNGP_TEXT_EXPECTED, /* 1108 */
    XML_RNGP_TEXT_HAS_CHILD, /* 1109 */
    XML_RNGP_TYPE_MISSING, /* 1110 */
    XML_RNGP_TYPE_NOT_FOUND, /* 1111 */
    XML_RNGP_TYPE_VALUE, /* 1112 */
    XML_RNGP_UNKNOWN_ATTRIBUTE, /* 1113 */
    XML_RNGP_UNKNOWN_COMBINE, /* 1114 */
    XML_RNGP_UNKNOWN_CONSTRUCT, /* 1115 */
    XML_RNGP_UNKNOWN_TYPE_LIB, /* 1116 */
    XML_RNGP_URI_FRAGMENT, /* 1117 */
    XML_RNGP_URI_NOT_ABSOLUTE, /* 1118 */
    XML_RNGP_VALUE_EMPTY, /* 1119 */
    XML_RNGP_VALUE_NO_CONTENT, /* 1120 */
    XML_RNGP_XMLNS_NAME, /* 1121 */
    XML_RNGP_XML_NS, /* 1122 */
    XML_XPATH_EXPRESSION_OK = 1200,
    XML_XPATH_NUMBER_ERROR, /* 1201 */
    XML_XPATH_UNFINISHED_LITERAL_ERROR, /* 1202 */
    XML_XPATH_START_LITERAL_ERROR, /* 1203 */
    XML_XPATH_VARIABLE_REF_ERROR, /* 1204 */
    XML_XPATH_UNDEF_VARIABLE_ERROR, /* 1205 */
    XML_XPATH_INVALID_PREDICATE_ERROR, /* 1206 */
    XML_XPATH_EXPR_ERROR, /* 1207 */
    XML_XPATH_UNCLOSED_ERROR, /* 1208 */
    XML_XPATH_UNKNOWN_FUNC_ERROR, /* 1209 */
    XML_XPATH_INVALID_OPERAND, /* 1210 */
    XML_XPATH_INVALID_TYPE, /* 1211 */
    XML_XPATH_INVALID_ARITY, /* 1212 */
    XML_XPATH_INVALID_CTXT_SIZE, /* 1213 */
    XML_XPATH_INVALID_CTXT_POSITION, /* 1214 */
    XML_XPATH_MEMORY_ERROR, /* 1215 */
    XML_XPTR_SYNTAX_ERROR, /* 1216 */
    XML_XPTR_RESOURCE_ERROR, /* 1217 */
    XML_XPTR_SUB_RESOURCE_ERROR, /* 1218 */
    XML_XPATH_UNDEF_PREFIX_ERROR, /* 1219 */
    XML_XPATH_ENCODING_ERROR, /* 1220 */
    XML_XPATH_INVALID_CHAR_ERROR, /* 1221 */
    XML_TREE_INVALID_HEX = 1300,
    XML_TREE_INVALID_DEC, /* 1301 */
    XML_TREE_UNTERMINATED_ENTITY, /* 1302 */
    XML_TREE_NOT_UTF8, /* 1303 */
    XML_SAVE_NOT_UTF8 = 1400,
    XML_SAVE_CHAR_INVALID, /* 1401 */
    XML_SAVE_NO_DOCTYPE, /* 1402 */
    XML_SAVE_UNKNOWN_ENCODING, /* 1403 */
    XML_REGEXP_COMPILE_ERROR = 1450,
    XML_IO_UNKNOWN = 1500,
    XML_IO_EACCES, /* 1501 */
    XML_IO_EAGAIN, /* 1502 */
    XML_IO_EBADF, /* 1503 */
    XML_IO_EBADMSG, /* 1504 */
    XML_IO_EBUSY, /* 1505 */
    XML_IO_ECANCELED, /* 1506 */
    XML_IO_ECHILD, /* 1507 */
    XML_IO_EDEADLK, /* 1508 */
    XML_IO_EDOM, /* 1509 */
    XML_IO_EEXIST, /* 1510 */
    XML_IO_EFAULT, /* 1511 */
    XML_IO_EFBIG, /* 1512 */
    XML_IO_EINPROGRESS, /* 1513 */
    XML_IO_EINTR, /* 1514 */
    XML_IO_EINVAL, /* 1515 */
    XML_IO_EIO, /* 1516 */
    XML_IO_EISDIR, /* 1517 */
    XML_IO_EMFILE, /* 1518 */
    XML_IO_EMLINK, /* 1519 */
    XML_IO_EMSGSIZE, /* 1520 */
    XML_IO_ENAMETOOLONG, /* 1521 */
    XML_IO_ENFILE, /* 1522 */
    XML_IO_ENODEV, /* 1523 */
    XML_IO_ENOENT, /* 1524 */
    XML_IO_ENOEXEC, /* 1525 */
    XML_IO_ENOLCK, /* 1526 */
    XML_IO_ENOMEM, /* 1527 */
    XML_IO_ENOSPC, /* 1528 */
    XML_IO_ENOSYS, /* 1529 */
    XML_IO_ENOTDIR, /* 1530 */
    XML_IO_ENOTEMPTY, /* 1531 */
    XML_IO_ENOTSUP, /* 1532 */
    XML_IO_ENOTTY, /* 1533 */
    XML_IO_ENXIO, /* 1534 */
    XML_IO_EPERM, /* 1535 */
    XML_IO_EPIPE, /* 1536 */
    XML_IO_ERANGE, /* 1537 */
    XML_IO_EROFS, /* 1538 */
    XML_IO_ESPIPE, /* 1539 */
    XML_IO_ESRCH, /* 1540 */
    XML_IO_ETIMEDOUT, /* 1541 */
    XML_IO_EXDEV, /* 1542 */
    XML_IO_NETWORK_ATTEMPT, /* 1543 */
    XML_IO_ENCODER, /* 1544 */
    XML_IO_FLUSH, /* 1545 */
    XML_IO_WRITE, /* 1546 */
    XML_IO_NO_INPUT, /* 1547 */
    XML_IO_BUFFER_FULL, /* 1548 */
    XML_IO_LOAD_ERROR, /* 1549 */
    XML_IO_ENOTSOCK, /* 1550 */
    XML_IO_EISCONN, /* 1551 */
    XML_IO_ECONNREFUSED, /* 1552 */
    XML_IO_ENETUNREACH, /* 1553 */
    XML_IO_EADDRINUSE, /* 1554 */
    XML_IO_EALREADY, /* 1555 */
    XML_IO_EAFNOSUPPORT, /* 1556 */
    XML_XINCLUDE_RECURSION=1600,
    XML_XINCLUDE_PARSE_VALUE, /* 1601 */
    XML_XINCLUDE_ENTITY_DEF_MISMATCH, /* 1602 */
    XML_XINCLUDE_NO_HREF, /* 1603 */
    XML_XINCLUDE_NO_FALLBACK, /* 1604 */
    XML_XINCLUDE_HREF_URI, /* 1605 */
    XML_XINCLUDE_TEXT_FRAGMENT, /* 1606 */
    XML_XINCLUDE_TEXT_DOCUMENT, /* 1607 */
    XML_XINCLUDE_INVALID_CHAR, /* 1608 */
    XML_XINCLUDE_BUILD_FAILED, /* 1609 */
    XML_XINCLUDE_UNKNOWN_ENCODING, /* 1610 */
    XML_XINCLUDE_MULTIPLE_ROOT, /* 1611 */
    XML_XINCLUDE_XPTR_FAILED, /* 1612 */
    XML_XINCLUDE_XPTR_RESULT, /* 1613 */
    XML_XINCLUDE_INCLUDE_IN_INCLUDE, /* 1614 */
    XML_XINCLUDE_FALLBACKS_IN_INCLUDE, /* 1615 */
    XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE, /* 1616 */
    XML_XINCLUDE_DEPRECATED_NS, /* 1617 */
    XML_XINCLUDE_FRAGMENT_ID, /* 1618 */
    XML_CATALOG_MISSING_ATTR = 1650,
    XML_CATALOG_ENTRY_BROKEN, /* 1651 */
    XML_CATALOG_PREFER_VALUE, /* 1652 */
    XML_CATALOG_NOT_CATALOG, /* 1653 */
    XML_CATALOG_RECURSION, /* 1654 */
    XML_SCHEMAP_PREFIX_UNDEFINED = 1700,
    XML_SCHEMAP_ATTRFORMDEFAULT_VALUE, /* 1701 */
    XML_SCHEMAP_ATTRGRP_NONAME_NOREF, /* 1702 */
    XML_SCHEMAP_ATTR_NONAME_NOREF, /* 1703 */
    XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF, /* 1704 */
    XML_SCHEMAP_ELEMFORMDEFAULT_VALUE, /* 1705 */
    XML_SCHEMAP_ELEM_NONAME_NOREF, /* 1706 */
    XML_SCHEMAP_EXTENSION_NO_BASE, /* 1707 */
    XML_SCHEMAP_FACET_NO_VALUE, /* 1708 */
    XML_SCHEMAP_FAILED_BUILD_IMPORT, /* 1709 */
    XML_SCHEMAP_GROUP_NONAME_NOREF, /* 1710 */
    XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI, /* 1711 */
    XML_SCHEMAP_IMPORT_REDEFINE_NSNAME, /* 1712 */
    XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI, /* 1713 */
    XML_SCHEMAP_INVALID_BOOLEAN, /* 1714 */
    XML_SCHEMAP_INVALID_ENUM, /* 1715 */
    XML_SCHEMAP_INVALID_FACET, /* 1716 */
    XML_SCHEMAP_INVALID_FACET_VALUE, /* 1717 */
    XML_SCHEMAP_INVALID_MAXOCCURS, /* 1718 */
    XML_SCHEMAP_INVALID_MINOCCURS, /* 1719 */
    XML_SCHEMAP_INVALID_REF_AND_SUBTYPE, /* 1720 */
    XML_SCHEMAP_INVALID_WHITE_SPACE, /* 1721 */
    XML_SCHEMAP_NOATTR_NOREF, /* 1722 */
    XML_SCHEMAP_NOTATION_NO_NAME, /* 1723 */
    XML_SCHEMAP_NOTYPE_NOREF, /* 1724 */
    XML_SCHEMAP_REF_AND_SUBTYPE, /* 1725 */
    XML_SCHEMAP_RESTRICTION_NONAME_NOREF, /* 1726 */
    XML_SCHEMAP_SIMPLETYPE_NONAME, /* 1727 */
    XML_SCHEMAP_TYPE_AND_SUBTYPE, /* 1728 */
    XML_SCHEMAP_UNKNOWN_ALL_CHILD, /* 1729 */
    XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD, /* 1730 */
    XML_SCHEMAP_UNKNOWN_ATTR_CHILD, /* 1731 */
    XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD, /* 1732 */
    XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP, /* 1733 */
    XML_SCHEMAP_UNKNOWN_BASE_TYPE, /* 1734 */
    XML_SCHEMAP_UNKNOWN_CHOICE_CHILD, /* 1735 */
    XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD, /* 1736 */
    XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD, /* 1737 */
    XML_SCHEMAP_UNKNOWN_ELEM_CHILD, /* 1738 */
    XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD, /* 1739 */
    XML_SCHEMAP_UNKNOWN_FACET_CHILD, /* 1740 */
    XML_SCHEMAP_UNKNOWN_FACET_TYPE, /* 1741 */
    XML_SCHEMAP_UNKNOWN_GROUP_CHILD, /* 1742 */
    XML_SCHEMAP_UNKNOWN_IMPORT_CHILD, /* 1743 */
    XML_SCHEMAP_UNKNOWN_LIST_CHILD, /* 1744 */
    XML_SCHEMAP_UNKNOWN_NOTATION_CHILD, /* 1745 */
    XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD, /* 1746 */
    XML_SCHEMAP_UNKNOWN_REF, /* 1747 */
    XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD, /* 1748 */
    XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD, /* 1749 */
    XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD, /* 1750 */
    XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD, /* 1751 */
    XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD, /* 1752 */
    XML_SCHEMAP_UNKNOWN_TYPE, /* 1753 */
    XML_SCHEMAP_UNKNOWN_UNION_CHILD, /* 1754 */
    XML_SCHEMAP_ELEM_DEFAULT_FIXED, /* 1755 */
    XML_SCHEMAP_REGEXP_INVALID, /* 1756 */
    XML_SCHEMAP_FAILED_LOAD, /* 1757 */
    XML_SCHEMAP_NOTHING_TO_PARSE, /* 1758 */
    XML_SCHEMAP_NOROOT, /* 1759 */
    XML_SCHEMAP_REDEFINED_GROUP, /* 1760 */
    XML_SCHEMAP_REDEFINED_TYPE, /* 1761 */
    XML_SCHEMAP_REDEFINED_ELEMENT, /* 1762 */
    XML_SCHEMAP_REDEFINED_ATTRGROUP, /* 1763 */
    XML_SCHEMAP_REDEFINED_ATTR, /* 1764 */
    XML_SCHEMAP_REDEFINED_NOTATION, /* 1765 */
    XML_SCHEMAP_FAILED_PARSE, /* 1766 */
    XML_SCHEMAP_UNKNOWN_PREFIX, /* 1767 */
    XML_SCHEMAP_DEF_AND_PREFIX, /* 1768 */
    XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD, /* 1769 */
    XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI, /* 1770 */
    XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI, /* 1771 */
    XML_SCHEMAP_NOT_SCHEMA, /* 1772 */
    XML_SCHEMAP_UNKNOWN_MEMBER_TYPE, /* 1773 */
    XML_SCHEMAP_INVALID_ATTR_USE, /* 1774 */
    XML_SCHEMAP_RECURSIVE, /* 1775 */
    XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE, /* 1776 */
    XML_SCHEMAP_INVALID_ATTR_COMBINATION, /* 1777 */
    XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION, /* 1778 */
    XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD, /* 1779 */
    XML_SCHEMAP_INVALID_ATTR_NAME, /* 1780 */
    XML_SCHEMAP_REF_AND_CONTENT, /* 1781 */
    XML_SCHEMAP_CT_PROPS_CORRECT_1, /* 1782 */
    XML_SCHEMAP_CT_PROPS_CORRECT_2, /* 1783 */
    XML_SCHEMAP_CT_PROPS_CORRECT_3, /* 1784 */
    XML_SCHEMAP_CT_PROPS_CORRECT_4, /* 1785 */
    XML_SCHEMAP_CT_PROPS_CORRECT_5, /* 1786 */
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1, /* 1787 */
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1, /* 1788 */
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2, /* 1789 */
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2, /* 1790 */
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3, /* 1791 */
    XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER, /* 1792 */
    XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE, /* 1793 */
    XML_SCHEMAP_UNION_NOT_EXPRESSIBLE, /* 1794 */
    XML_SCHEMAP_SRC_IMPORT_3_1, /* 1795 */
    XML_SCHEMAP_SRC_IMPORT_3_2, /* 1796 */
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1, /* 1797 */
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2, /* 1798 */
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3, /* 1799 */
    XML_SCHEMAP_COS_CT_EXTENDS_1_3, /* 1800 */
    XML_SCHEMAV_NOROOT = 1801,
    XML_SCHEMAV_UNDECLAREDELEM, /* 1802 */
    XML_SCHEMAV_NOTTOPLEVEL, /* 1803 */
    XML_SCHEMAV_MISSING, /* 1804 */
    XML_SCHEMAV_WRONGELEM, /* 1805 */
    XML_SCHEMAV_NOTYPE, /* 1806 */
    XML_SCHEMAV_NOROLLBACK, /* 1807 */
    XML_SCHEMAV_ISABSTRACT, /* 1808 */
    XML_SCHEMAV_NOTEMPTY, /* 1809 */
    XML_SCHEMAV_ELEMCONT, /* 1810 */
    XML_SCHEMAV_HAVEDEFAULT, /* 1811 */
    XML_SCHEMAV_NOTNILLABLE, /* 1812 */
    XML_SCHEMAV_EXTRACONTENT, /* 1813 */
    XML_SCHEMAV_INVALIDATTR, /* 1814 */
    XML_SCHEMAV_INVALIDELEM, /* 1815 */
    XML_SCHEMAV_NOTDETERMINIST, /* 1816 */
    XML_SCHEMAV_CONSTRUCT, /* 1817 */
    XML_SCHEMAV_INTERNAL, /* 1818 */
    XML_SCHEMAV_NOTSIMPLE, /* 1819 */
    XML_SCHEMAV_ATTRUNKNOWN, /* 1820 */
    XML_SCHEMAV_ATTRINVALID, /* 1821 */
    XML_SCHEMAV_VALUE, /* 1822 */
    XML_SCHEMAV_FACET, /* 1823 */
    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1, /* 1824 */
    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2, /* 1825 */
    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3, /* 1826 */
    XML_SCHEMAV_CVC_TYPE_3_1_1, /* 1827 */
    XML_SCHEMAV_CVC_TYPE_3_1_2, /* 1828 */
    XML_SCHEMAV_CVC_FACET_VALID, /* 1829 */
    XML_SCHEMAV_CVC_LENGTH_VALID, /* 1830 */
    XML_SCHEMAV_CVC_MINLENGTH_VALID, /* 1831 */
    XML_SCHEMAV_CVC_MAXLENGTH_VALID, /* 1832 */
    XML_SCHEMAV_CVC_MININCLUSIVE_VALID, /* 1833 */
    XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID, /* 1834 */
    XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID, /* 1835 */
    XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID, /* 1836 */
    XML_SCHEMAV_CVC_TOTALDIGITS_VALID, /* 1837 */
    XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID, /* 1838 */
    XML_SCHEMAV_CVC_PATTERN_VALID, /* 1839 */
    XML_SCHEMAV_CVC_ENUMERATION_VALID, /* 1840 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1, /* 1841 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2, /* 1842 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3, /* 1843 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4, /* 1844 */
    XML_SCHEMAV_CVC_ELT_1, /* 1845 */
    XML_SCHEMAV_CVC_ELT_2, /* 1846 */
    XML_SCHEMAV_CVC_ELT_3_1, /* 1847 */
    XML_SCHEMAV_CVC_ELT_3_2_1, /* 1848 */
    XML_SCHEMAV_CVC_ELT_3_2_2, /* 1849 */
    XML_SCHEMAV_CVC_ELT_4_1, /* 1850 */
    XML_SCHEMAV_CVC_ELT_4_2, /* 1851 */
    XML_SCHEMAV_CVC_ELT_4_3, /* 1852 */
    XML_SCHEMAV_CVC_ELT_5_1_1, /* 1853 */
    XML_SCHEMAV_CVC_ELT_5_1_2, /* 1854 */
    XML_SCHEMAV_CVC_ELT_5_2_1, /* 1855 */
    XML_SCHEMAV_CVC_ELT_5_2_2_1, /* 1856 */
    XML_SCHEMAV_CVC_ELT_5_2_2_2_1, /* 1857 */
    XML_SCHEMAV_CVC_ELT_5_2_2_2_2, /* 1858 */
    XML_SCHEMAV_CVC_ELT_6, /* 1859 */
    XML_SCHEMAV_CVC_ELT_7, /* 1860 */
    XML_SCHEMAV_CVC_ATTRIBUTE_1, /* 1861 */
    XML_SCHEMAV_CVC_ATTRIBUTE_2, /* 1862 */
    XML_SCHEMAV_CVC_ATTRIBUTE_3, /* 1863 */
    XML_SCHEMAV_CVC_ATTRIBUTE_4, /* 1864 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1, /* 1865 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1, /* 1866 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2, /* 1867 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_4, /* 1868 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1, /* 1869 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2, /* 1870 */
    XML_SCHEMAV_ELEMENT_CONTENT, /* 1871 */
    XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING, /* 1872 */
    XML_SCHEMAV_CVC_COMPLEX_TYPE_1, /* 1873 */
    XML_SCHEMAV_CVC_AU, /* 1874 */
    XML_SCHEMAV_CVC_TYPE_1, /* 1875 */
    XML_SCHEMAV_CVC_TYPE_2, /* 1876 */
    XML_SCHEMAV_CVC_IDC, /* 1877 */
    XML_SCHEMAV_CVC_WILDCARD, /* 1878 */
    XML_SCHEMAV_MISC, /* 1879 */
    XML_XPTR_UNKNOWN_SCHEME = 1900,
    XML_XPTR_CHILDSEQ_START, /* 1901 */
    XML_XPTR_EVAL_FAILED, /* 1902 */
    XML_XPTR_EXTRA_OBJECTS, /* 1903 */
    XML_C14N_CREATE_CTXT = 1950,
    XML_C14N_REQUIRES_UTF8, /* 1951 */
    XML_C14N_CREATE_STACK, /* 1952 */
    XML_C14N_INVALID_NODE, /* 1953 */
    XML_C14N_UNKNOW_NODE, /* 1954 */
    XML_C14N_RELATIVE_NAMESPACE, /* 1955 */
    XML_FTP_PASV_ANSWER = 2000,
    XML_FTP_EPSV_ANSWER, /* 2001 */
    XML_FTP_ACCNT, /* 2002 */
    XML_FTP_URL_SYNTAX, /* 2003 */
    XML_HTTP_URL_SYNTAX = 2020,
    XML_HTTP_USE_IP, /* 2021 */
    XML_HTTP_UNKNOWN_HOST, /* 2022 */
    XML_SCHEMAP_SRC_SIMPLE_TYPE_1 = 3000,
    XML_SCHEMAP_SRC_SIMPLE_TYPE_2, /* 3001 */
    XML_SCHEMAP_SRC_SIMPLE_TYPE_3, /* 3002 */
    XML_SCHEMAP_SRC_SIMPLE_TYPE_4, /* 3003 */
    XML_SCHEMAP_SRC_RESOLVE, /* 3004 */
    XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE, /* 3005 */
    XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE, /* 3006 */
    XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES, /* 3007 */
    XML_SCHEMAP_ST_PROPS_CORRECT_1, /* 3008 */
    XML_SCHEMAP_ST_PROPS_CORRECT_2, /* 3009 */
    XML_SCHEMAP_ST_PROPS_CORRECT_3, /* 3010 */
    XML_SCHEMAP_COS_ST_RESTRICTS_1_1, /* 3011 */
    XML_SCHEMAP_COS_ST_RESTRICTS_1_2, /* 3012 */
    XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1, /* 3013 */
    XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2, /* 3014 */
    XML_SCHEMAP_COS_ST_RESTRICTS_2_1, /* 3015 */
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1, /* 3016 */
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2, /* 3017 */
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1, /* 3018 */
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2, /* 3019 */
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3, /* 3020 */
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4, /* 3021 */
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5, /* 3022 */
    XML_SCHEMAP_COS_ST_RESTRICTS_3_1, /* 3023 */
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1, /* 3024 */
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2, /* 3025 */
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2, /* 3026 */
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1, /* 3027 */
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3, /* 3028 */
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4, /* 3029 */
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5, /* 3030 */
    XML_SCHEMAP_COS_ST_DERIVED_OK_2_1, /* 3031 */
    XML_SCHEMAP_COS_ST_DERIVED_OK_2_2, /* 3032 */
    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED, /* 3033 */
    XML_SCHEMAP_S4S_ELEM_MISSING, /* 3034 */
    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, /* 3035 */
    XML_SCHEMAP_S4S_ATTR_MISSING, /* 3036 */
    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE, /* 3037 */
    XML_SCHEMAP_SRC_ELEMENT_1, /* 3038 */
    XML_SCHEMAP_SRC_ELEMENT_2_1, /* 3039 */
    XML_SCHEMAP_SRC_ELEMENT_2_2, /* 3040 */
    XML_SCHEMAP_SRC_ELEMENT_3, /* 3041 */
    XML_SCHEMAP_P_PROPS_CORRECT_1, /* 3042 */
    XML_SCHEMAP_P_PROPS_CORRECT_2_1, /* 3043 */
    XML_SCHEMAP_P_PROPS_CORRECT_2_2, /* 3044 */
    XML_SCHEMAP_E_PROPS_CORRECT_2, /* 3045 */
    XML_SCHEMAP_E_PROPS_CORRECT_3, /* 3046 */
    XML_SCHEMAP_E_PROPS_CORRECT_4, /* 3047 */
    XML_SCHEMAP_E_PROPS_CORRECT_5, /* 3048 */
    XML_SCHEMAP_E_PROPS_CORRECT_6, /* 3049 */
    XML_SCHEMAP_SRC_INCLUDE, /* 3050 */
    XML_SCHEMAP_SRC_ATTRIBUTE_1, /* 3051 */
    XML_SCHEMAP_SRC_ATTRIBUTE_2, /* 3052 */
    XML_SCHEMAP_SRC_ATTRIBUTE_3_1, /* 3053 */
    XML_SCHEMAP_SRC_ATTRIBUTE_3_2, /* 3054 */
    XML_SCHEMAP_SRC_ATTRIBUTE_4, /* 3055 */
    XML_SCHEMAP_NO_XMLNS, /* 3056 */
    XML_SCHEMAP_NO_XSI, /* 3057 */
    XML_SCHEMAP_COS_VALID_DEFAULT_1, /* 3058 */
    XML_SCHEMAP_COS_VALID_DEFAULT_2_1, /* 3059 */
    XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1, /* 3060 */
    XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2, /* 3061 */
    XML_SCHEMAP_CVC_SIMPLE_TYPE, /* 3062 */
    XML_SCHEMAP_COS_CT_EXTENDS_1_1, /* 3063 */
    XML_SCHEMAP_SRC_IMPORT_1_1, /* 3064 */
    XML_SCHEMAP_SRC_IMPORT_1_2, /* 3065 */
    XML_SCHEMAP_SRC_IMPORT_2, /* 3066 */
    XML_SCHEMAP_SRC_IMPORT_2_1, /* 3067 */
    XML_SCHEMAP_SRC_IMPORT_2_2, /* 3068 */
    XML_SCHEMAP_INTERNAL, /* 3069 non-W3C */
    XML_SCHEMAP_NOT_DETERMINISTIC, /* 3070 non-W3C */
    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1, /* 3071 */
    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2, /* 3072 */
    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3, /* 3073 */
    XML_SCHEMAP_MG_PROPS_CORRECT_1, /* 3074 */
    XML_SCHEMAP_MG_PROPS_CORRECT_2, /* 3075 */
    XML_SCHEMAP_SRC_CT_1, /* 3076 */
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3, /* 3077 */
    XML_SCHEMAP_AU_PROPS_CORRECT_2, /* 3078 */
    XML_SCHEMAP_A_PROPS_CORRECT_2, /* 3079 */
    XML_SCHEMAP_C_PROPS_CORRECT, /* 3080 */
    XML_SCHEMAP_SRC_REDEFINE, /* 3081 */
    XML_SCHEMAP_SRC_IMPORT, /* 3082 */
    XML_SCHEMAP_WARN_SKIP_SCHEMA, /* 3083 */
    XML_SCHEMAP_WARN_UNLOCATED_SCHEMA, /* 3084 */
    XML_SCHEMAP_WARN_ATTR_REDECL_PROH, /* 3085 */
    XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH, /* 3085 */
    XML_SCHEMAP_AG_PROPS_CORRECT, /* 3086 */
    XML_SCHEMAP_COS_CT_EXTENDS_1_2, /* 3087 */
    XML_SCHEMAP_AU_PROPS_CORRECT, /* 3088 */
    XML_SCHEMAP_A_PROPS_CORRECT_3, /* 3089 */
    XML_SCHEMAP_COS_ALL_LIMITED, /* 3090 */
    XML_SCHEMATRONV_ASSERT = 4000, /* 4000 */
    XML_SCHEMATRONV_REPORT,
    XML_MODULE_OPEN = 4900, /* 4900 */
    XML_MODULE_CLOSE, /* 4901 */
    XML_CHECK_FOUND_ELEMENT = 5000,
    XML_CHECK_FOUND_ATTRIBUTE, /* 5001 */
    XML_CHECK_FOUND_TEXT, /* 5002 */
    XML_CHECK_FOUND_CDATA, /* 5003 */
    XML_CHECK_FOUND_ENTITYREF, /* 5004 */
    XML_CHECK_FOUND_ENTITY, /* 5005 */
    XML_CHECK_FOUND_PI, /* 5006 */
    XML_CHECK_FOUND_COMMENT, /* 5007 */
    XML_CHECK_FOUND_DOCTYPE, /* 5008 */
    XML_CHECK_FOUND_FRAGMENT, /* 5009 */
    XML_CHECK_FOUND_NOTATION, /* 5010 */
    XML_CHECK_UNKNOWN_NODE, /* 5011 */
    XML_CHECK_ENTITY_TYPE, /* 5012 */
    XML_CHECK_NO_PARENT, /* 5013 */
    XML_CHECK_NO_DOC, /* 5014 */
    XML_CHECK_NO_NAME, /* 5015 */
    XML_CHECK_NO_ELEM, /* 5016 */
    XML_CHECK_WRONG_DOC, /* 5017 */
    XML_CHECK_NO_PREV, /* 5018 */
    XML_CHECK_WRONG_PREV, /* 5019 */
    XML_CHECK_NO_NEXT, /* 5020 */
    XML_CHECK_WRONG_NEXT, /* 5021 */
    XML_CHECK_NOT_DTD, /* 5022 */
    XML_CHECK_NOT_ATTR, /* 5023 */
    XML_CHECK_NOT_ATTR_DECL, /* 5024 */
    XML_CHECK_NOT_ELEM_DECL, /* 5025 */
    XML_CHECK_NOT_ENTITY_DECL, /* 5026 */
    XML_CHECK_NOT_NS_DECL, /* 5027 */
    XML_CHECK_NO_HREF, /* 5028 */
    XML_CHECK_WRONG_PARENT,/* 5029 */
    XML_CHECK_NS_SCOPE, /* 5030 */
    XML_CHECK_NS_ANCESTOR, /* 5031 */
    XML_CHECK_NOT_UTF8, /* 5032 */
    XML_CHECK_NO_DICT, /* 5033 */
    XML_CHECK_NOT_NCNAME, /* 5034 */
    XML_CHECK_OUTSIDE_DICT, /* 5035 */
    XML_CHECK_WRONG_NAME, /* 5036 */
    XML_CHECK_NAME_NOT_NULL, /* 5037 */
    XML_I18N_NO_NAME = 6000,
    XML_I18N_NO_HANDLER, /* 6001 */
    XML_I18N_EXCESS_HANDLER, /* 6002 */
    XML_I18N_CONV_FAILED, /* 6003 */
    XML_I18N_NO_OUTPUT, /* 6004 */
    XML_BUF_OVERFLOW = 7000
} xmlParserErrors;

/**
 * xmlGenericErrorFunc:
 * @ctx:  a parsing context
 * @msg:  the message
 * @...:  the extra arguments of the varags to format the message
 *
 * Signature of the function to use when there is an error and
 * no parsing or validity context available .
 */
typedef void (XMLCDECL *xmlGenericErrorFunc) (void *ctx,
				 const char *msg,
				 ...) LIBXML_ATTR_FORMAT(2,3);
/**
 * xmlStructuredErrorFunc:
 * @userData:  user provided data for the error callback
 * @error:  the error being raised.
 *
 * Signature of the function to use when there is an error and
 * the module handles the new error reporting mechanism.
 */
typedef void (XMLCALL *xmlStructuredErrorFunc) (void *userData, xmlErrorPtr error);

/*
 * Use the following function to reset the two global variables
 * xmlGenericError and xmlGenericErrorContext.
 */
XMLPUBFUN void XMLCALL
    xmlSetGenericErrorFunc	(void *ctx,
				 xmlGenericErrorFunc handler);
XMLPUBFUN void XMLCALL
    initGenericErrorDefaultFunc	(xmlGenericErrorFunc *handler);

XMLPUBFUN void XMLCALL
    xmlSetStructuredErrorFunc	(void *ctx,
				 xmlStructuredErrorFunc handler);
/*
 * Default message routines used by SAX and Valid context for error
 * and warning reporting.
 */
XMLPUBFUN void XMLCDECL
    xmlParserError		(void *ctx,
				 const char *msg,
				 ...) LIBXML_ATTR_FORMAT(2,3);
XMLPUBFUN void XMLCDECL
    xmlParserWarning		(void *ctx,
				 const char *msg,
				 ...) LIBXML_ATTR_FORMAT(2,3);
XMLPUBFUN void XMLCDECL
    xmlParserValidityError	(void *ctx,
				 const char *msg,
				 ...) LIBXML_ATTR_FORMAT(2,3);
XMLPUBFUN void XMLCDECL
    xmlParserValidityWarning	(void *ctx,
				 const char *msg,
				 ...) LIBXML_ATTR_FORMAT(2,3);
XMLPUBFUN void XMLCALL
    xmlParserPrintFileInfo	(xmlParserInputPtr input);
XMLPUBFUN void XMLCALL
    xmlParserPrintFileContext	(xmlParserInputPtr input);

/*
 * Extended error information routines
 */
XMLPUBFUN xmlErrorPtr XMLCALL
    xmlGetLastError		(void);
XMLPUBFUN void XMLCALL
    xmlResetLastError		(void);
XMLPUBFUN xmlErrorPtr XMLCALL
    xmlCtxtGetLastError		(void *ctx);
XMLPUBFUN void XMLCALL
    xmlCtxtResetLastError	(void *ctx);
XMLPUBFUN void XMLCALL
    xmlResetError		(xmlErrorPtr err);
XMLPUBFUN int XMLCALL
    xmlCopyError		(xmlErrorPtr from,
				 xmlErrorPtr to);

#ifdef IN_LIBXML
/*
 * Internal callback reporting routine
 */
XMLPUBFUN void XMLCALL
    __xmlRaiseError		(xmlStructuredErrorFunc schannel,
				 xmlGenericErrorFunc channel,
				 void *data,
                                 void *ctx,
				 void *node,
				 int domain,
				 int code,
				 xmlErrorLevel level,
				 const char *file,
				 int line,
				 const char *str1,
				 const char *str2,
				 const char *str3,
				 int int1,
				 int col,
				 const char *msg,
				 ...) LIBXML_ATTR_FORMAT(16,17);
XMLPUBFUN void XMLCALL
    __xmlSimpleError		(int domain,
				 int code,
				 xmlNodePtr node,
				 const char *msg,
				 const char *extra);
#endif
#ifdef __cplusplus
}
#endif
#endif /* __XML_ERROR_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xinclude.h
/*
 * Summary: implementation of XInclude
 * Description: API to handle XInclude processing,
 * implements the
 * World Wide Web Consortium Last Call Working Draft 10 November 2003
 * http://www.w3.org/TR/2003/WD-xinclude-20031110
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_XINCLUDE_H__
#define __XML_XINCLUDE_H__

#include <libxml/xmlversion.h>
#include <libxml/tree.h>

#ifdef LIBXML_XINCLUDE_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

/**
 * XINCLUDE_NS:
 *
 * Macro defining the Xinclude namespace: http://www.w3.org/2003/XInclude
 */
#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
/**
 * XINCLUDE_OLD_NS:
 *
 * Macro defining the draft Xinclude namespace: http://www.w3.org/2001/XInclude
 */
#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
/**
 * XINCLUDE_NODE:
 *
 * Macro defining "include"
 */
#define XINCLUDE_NODE (const xmlChar *) "include"
/**
 * XINCLUDE_FALLBACK:
 *
 * Macro defining "fallback"
 */
#define XINCLUDE_FALLBACK (const xmlChar *) "fallback"
/**
 * XINCLUDE_HREF:
 *
 * Macro defining "href"
 */
#define XINCLUDE_HREF (const xmlChar *) "href"
/**
 * XINCLUDE_PARSE:
 *
 * Macro defining "parse"
 */
#define XINCLUDE_PARSE (const xmlChar *) "parse"
/**
 * XINCLUDE_PARSE_XML:
 *
 * Macro defining "xml"
 */
#define XINCLUDE_PARSE_XML (const xmlChar *) "xml"
/**
 * XINCLUDE_PARSE_TEXT:
 *
 * Macro defining "text"
 */
#define XINCLUDE_PARSE_TEXT (const xmlChar *) "text"
/**
 * XINCLUDE_PARSE_ENCODING:
 *
 * Macro defining "encoding"
 */
#define XINCLUDE_PARSE_ENCODING (const xmlChar *) "encoding"
/**
 * XINCLUDE_PARSE_XPOINTER:
 *
 * Macro defining "xpointer"
 */
#define XINCLUDE_PARSE_XPOINTER (const xmlChar *) "xpointer"

typedef struct _xmlXIncludeCtxt xmlXIncludeCtxt;
typedef xmlXIncludeCtxt *xmlXIncludeCtxtPtr;

/*
 * standalone processing
 */
XMLPUBFUN int XMLCALL
		xmlXIncludeProcess	(xmlDocPtr doc);
XMLPUBFUN int XMLCALL
		xmlXIncludeProcessFlags	(xmlDocPtr doc,
					 int flags);
XMLPUBFUN int XMLCALL
		xmlXIncludeProcessFlagsData(xmlDocPtr doc,
					 int flags,
					 void *data);
XMLPUBFUN int XMLCALL
                xmlXIncludeProcessTreeFlagsData(xmlNodePtr tree,
                                         int flags,
                                         void *data);
XMLPUBFUN int XMLCALL
		xmlXIncludeProcessTree	(xmlNodePtr tree);
XMLPUBFUN int XMLCALL
		xmlXIncludeProcessTreeFlags(xmlNodePtr tree,
					 int flags);
/*
 * contextual processing
 */
XMLPUBFUN xmlXIncludeCtxtPtr XMLCALL
		xmlXIncludeNewContext	(xmlDocPtr doc);
XMLPUBFUN int XMLCALL
		xmlXIncludeSetFlags	(xmlXIncludeCtxtPtr ctxt,
					 int flags);
XMLPUBFUN void XMLCALL
		xmlXIncludeFreeContext	(xmlXIncludeCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
		xmlXIncludeProcessNode	(xmlXIncludeCtxtPtr ctxt,
					 xmlNodePtr tree);
#ifdef __cplusplus
}
#endif

#endif /* LIBXML_XINCLUDE_ENABLED */

#endif /* __XML_XINCLUDE_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/parserInternals.h
/*
 * Summary: internals routines and limits exported by the parser.
 * Description: this module exports a number of internal parsing routines
 *              they are not really all intended for applications but
 *              can prove useful doing low level processing.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_PARSER_INTERNALS_H__
#define __XML_PARSER_INTERNALS_H__

#include <libxml/xmlversion.h>
#include <libxml/parser.h>
#include <libxml/HTMLparser.h>
#include <libxml/chvalid.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlParserMaxDepth:
 *
 * arbitrary depth limit for the XML documents that we allow to
 * process. This is not a limitation of the parser but a safety
 * boundary feature, use XML_PARSE_HUGE option to override it.
 */
XMLPUBVAR unsigned int xmlParserMaxDepth;

/**
 * XML_MAX_TEXT_LENGTH:
 *
 * Maximum size allowed for a single text node when building a tree.
 * This is not a limitation of the parser but a safety boundary feature,
 * use XML_PARSE_HUGE option to override it.
 * Introduced in 2.9.0
 */
#define XML_MAX_TEXT_LENGTH 10000000

/**
 * XML_MAX_NAME_LENGTH:
 *
 * Maximum size allowed for a markup identitier
 * This is not a limitation of the parser but a safety boundary feature,
 * use XML_PARSE_HUGE option to override it.
 * Note that with the use of parsing dictionaries overriding the limit
 * may result in more runtime memory usage in face of "unfriendly' content
 * Introduced in 2.9.0
 */
#define XML_MAX_NAME_LENGTH 50000

/**
 * XML_MAX_DICTIONARY_LIMIT:
 *
 * Maximum size allowed by the parser for a dictionary by default
 * This is not a limitation of the parser but a safety boundary feature,
 * use XML_PARSE_HUGE option to override it.
 * Introduced in 2.9.0
 */
#define XML_MAX_DICTIONARY_LIMIT 10000000

/**
 * XML_MAX_LOOKUP_LIMIT:
 *
 * Maximum size allowed by the parser for ahead lookup
 * This is an upper boundary enforced by the parser to avoid bad
 * behaviour on "unfriendly' content
 * Introduced in 2.9.0
 */
#define XML_MAX_LOOKUP_LIMIT 10000000

/**
 * XML_MAX_NAMELEN:
 *
 * Identifiers can be longer, but this will be more costly
 * at runtime.
 */
#define XML_MAX_NAMELEN 100

/**
 * INPUT_CHUNK:
 *
 * The parser tries to always have that amount of input ready.
 * One of the point is providing context when reporting errors.
 */
#define INPUT_CHUNK	250

/************************************************************************
 *									*
 * UNICODE version of the macros.					*
 *									*
 ************************************************************************/
/**
 * IS_BYTE_CHAR:
 * @c:  an byte value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [2] Char ::= #x9 | #xA | #xD | [#x20...]
 * any byte character in the accepted range
 */
#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)

/**
 * IS_CHAR:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]
 *                  | [#x10000-#x10FFFF]
 * any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.
 */
#define IS_CHAR(c)   xmlIsCharQ(c)

/**
 * IS_CHAR_CH:
 * @c: an xmlChar (usually an unsigned char)
 *
 * Behaves like IS_CHAR on single-byte value
 */
#define IS_CHAR_CH(c)  xmlIsChar_ch(c)

/**
 * IS_BLANK:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [3] S ::= (#x20 | #x9 | #xD | #xA)+
 */
#define IS_BLANK(c)  xmlIsBlankQ(c)

/**
 * IS_BLANK_CH:
 * @c:  an xmlChar value (normally unsigned char)
 *
 * Behaviour same as IS_BLANK
 */
#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)

/**
 * IS_BASECHAR:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [85] BaseChar ::= ... long list see REC ...
 */
#define IS_BASECHAR(c) xmlIsBaseCharQ(c)

/**
 * IS_DIGIT:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [88] Digit ::= ... long list see REC ...
 */
#define IS_DIGIT(c) xmlIsDigitQ(c)

/**
 * IS_DIGIT_CH:
 * @c:  an xmlChar value (usually an unsigned char)
 *
 * Behaves like IS_DIGIT but with a single byte argument
 */
#define IS_DIGIT_CH(c)  xmlIsDigit_ch(c)

/**
 * IS_COMBINING:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [87] CombiningChar ::= ... long list see REC ...
 */
#define IS_COMBINING(c) xmlIsCombiningQ(c)

/**
 * IS_COMBINING_CH:
 * @c:  an xmlChar (usually an unsigned char)
 *
 * Always false (all combining chars > 0xff)
 */
#define IS_COMBINING_CH(c) 0

/**
 * IS_EXTENDER:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 *
 * [89] Extender ::= #x00B7 | #x02D0 | #x02D1 | #x0387 | #x0640 |
 *                   #x0E46 | #x0EC6 | #x3005 | [#x3031-#x3035] |
 *                   [#x309D-#x309E] | [#x30FC-#x30FE]
 */
#define IS_EXTENDER(c) xmlIsExtenderQ(c)

/**
 * IS_EXTENDER_CH:
 * @c:  an xmlChar value (usually an unsigned char)
 *
 * Behaves like IS_EXTENDER but with a single-byte argument
 */
#define IS_EXTENDER_CH(c)  xmlIsExtender_ch(c)

/**
 * IS_IDEOGRAPHIC:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 *
 * [86] Ideographic ::= [#x4E00-#x9FA5] | #x3007 | [#x3021-#x3029]
 */
#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)

/**
 * IS_LETTER:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 *
 * [84] Letter ::= BaseChar | Ideographic
 */
#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))

/**
 * IS_LETTER_CH:
 * @c:  an xmlChar value (normally unsigned char)
 *
 * Macro behaves like IS_LETTER, but only check base chars
 *
 */
#define IS_LETTER_CH(c) xmlIsBaseChar_ch(c)

/**
 * IS_ASCII_LETTER:
 * @c: an xmlChar value
 *
 * Macro to check [a-zA-Z]
 *
 */
#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
				 ((0x61 <= (c)) && ((c) <= 0x7a)))

/**
 * IS_ASCII_DIGIT:
 * @c: an xmlChar value
 *
 * Macro to check [0-9]
 *
 */
#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))

/**
 * IS_PUBIDCHAR:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 *
 * [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
 */
#define IS_PUBIDCHAR(c)	xmlIsPubidCharQ(c)

/**
 * IS_PUBIDCHAR_CH:
 * @c:  an xmlChar value (normally unsigned char)
 *
 * Same as IS_PUBIDCHAR but for single-byte value
 */
#define IS_PUBIDCHAR_CH(c) xmlIsPubidChar_ch(c)

/**
 * SKIP_EOL:
 * @p:  and UTF8 string pointer
 *
 * Skips the end of line chars.
 */
#define SKIP_EOL(p)							\
    if (*(p) == 0x13) { p++ ; if (*(p) == 0x10) p++; }			\
    if (*(p) == 0x10) { p++ ; if (*(p) == 0x13) p++; }

/**
 * MOVETO_ENDTAG:
 * @p:  and UTF8 string pointer
 *
 * Skips to the next '>' char.
 */
#define MOVETO_ENDTAG(p)						\
    while ((*p) && (*(p) != '>')) (p)++

/**
 * MOVETO_STARTTAG:
 * @p:  and UTF8 string pointer
 *
 * Skips to the next '<' char.
 */
#define MOVETO_STARTTAG(p)						\
    while ((*p) && (*(p) != '<')) (p)++

/**
 * Global variables used for predefined strings.
 */
XMLPUBVAR const xmlChar xmlStringText[];
XMLPUBVAR const xmlChar xmlStringTextNoenc[];
XMLPUBVAR const xmlChar xmlStringComment[];

/*
 * Function to finish the work of the macros where needed.
 */
XMLPUBFUN int XMLCALL                   xmlIsLetter     (int c);

/**
 * Parser context.
 */
XMLPUBFUN xmlParserCtxtPtr XMLCALL
			xmlCreateFileParserCtxt	(const char *filename);
XMLPUBFUN xmlParserCtxtPtr XMLCALL
			xmlCreateURLParserCtxt	(const char *filename,
						 int options);
XMLPUBFUN xmlParserCtxtPtr XMLCALL
			xmlCreateMemoryParserCtxt(const char *buffer,
						 int size);
XMLPUBFUN xmlParserCtxtPtr XMLCALL
			xmlCreateEntityParserCtxt(const xmlChar *URL,
						 const xmlChar *ID,
						 const xmlChar *base);
XMLPUBFUN int XMLCALL
			xmlSwitchEncoding	(xmlParserCtxtPtr ctxt,
						 xmlCharEncoding enc);
XMLPUBFUN int XMLCALL
			xmlSwitchToEncoding	(xmlParserCtxtPtr ctxt,
					 xmlCharEncodingHandlerPtr handler);
XMLPUBFUN int XMLCALL
			xmlSwitchInputEncoding	(xmlParserCtxtPtr ctxt,
						 xmlParserInputPtr input,
					 xmlCharEncodingHandlerPtr handler);

#ifdef IN_LIBXML
/* internal error reporting */
XMLPUBFUN void XMLCALL
			__xmlErrEncoding	(xmlParserCtxtPtr ctxt,
						 xmlParserErrors xmlerr,
						 const char *msg,
						 const xmlChar * str1,
						 const xmlChar * str2);
#endif

/**
 * Input Streams.
 */
XMLPUBFUN xmlParserInputPtr XMLCALL
			xmlNewStringInputStream	(xmlParserCtxtPtr ctxt,
						 const xmlChar *buffer);
XMLPUBFUN xmlParserInputPtr XMLCALL
			xmlNewEntityInputStream	(xmlParserCtxtPtr ctxt,
						 xmlEntityPtr entity);
XMLPUBFUN int XMLCALL
			xmlPushInput		(xmlParserCtxtPtr ctxt,
						 xmlParserInputPtr input);
XMLPUBFUN xmlChar XMLCALL
			xmlPopInput		(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlFreeInputStream	(xmlParserInputPtr input);
XMLPUBFUN xmlParserInputPtr XMLCALL
			xmlNewInputFromFile	(xmlParserCtxtPtr ctxt,
						 const char *filename);
XMLPUBFUN xmlParserInputPtr XMLCALL
			xmlNewInputStream	(xmlParserCtxtPtr ctxt);

/**
 * Namespaces.
 */
XMLPUBFUN xmlChar * XMLCALL
			xmlSplitQName		(xmlParserCtxtPtr ctxt,
						 const xmlChar *name,
						 xmlChar **prefix);

/**
 * Generic production rules.
 */
XMLPUBFUN const xmlChar * XMLCALL
			xmlParseName		(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlParseNmtoken		(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlParseEntityValue	(xmlParserCtxtPtr ctxt,
						 xmlChar **orig);
XMLPUBFUN xmlChar * XMLCALL
			xmlParseAttValue	(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlParseSystemLiteral	(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlParsePubidLiteral	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseCharData	(xmlParserCtxtPtr ctxt,
						 int cdata);
XMLPUBFUN xmlChar * XMLCALL
			xmlParseExternalID	(xmlParserCtxtPtr ctxt,
						 xmlChar **publicID,
						 int strict);
XMLPUBFUN void XMLCALL
			xmlParseComment		(xmlParserCtxtPtr ctxt);
XMLPUBFUN const xmlChar * XMLCALL
			xmlParsePITarget	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParsePI		(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseNotationDecl	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseEntityDecl	(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
			xmlParseDefaultDecl	(xmlParserCtxtPtr ctxt,
						 xmlChar **value);
XMLPUBFUN xmlEnumerationPtr XMLCALL
			xmlParseNotationType	(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlEnumerationPtr XMLCALL
			xmlParseEnumerationType	(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
			xmlParseEnumeratedType	(xmlParserCtxtPtr ctxt,
						 xmlEnumerationPtr *tree);
XMLPUBFUN int XMLCALL
			xmlParseAttributeType	(xmlParserCtxtPtr ctxt,
						 xmlEnumerationPtr *tree);
XMLPUBFUN void XMLCALL
			xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlElementContentPtr XMLCALL
			xmlParseElementMixedContentDecl
						(xmlParserCtxtPtr ctxt,
						 int inputchk);
XMLPUBFUN xmlElementContentPtr XMLCALL
			xmlParseElementChildrenContentDecl
						(xmlParserCtxtPtr ctxt,
						 int inputchk);
XMLPUBFUN int XMLCALL
			xmlParseElementContentDecl(xmlParserCtxtPtr ctxt,
						 const xmlChar *name,
						 xmlElementContentPtr *result);
XMLPUBFUN int XMLCALL
			xmlParseElementDecl	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseMarkupDecl	(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
			xmlParseCharRef		(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlEntityPtr XMLCALL
			xmlParseEntityRef	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseReference	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParsePEReference	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseDocTypeDecl	(xmlParserCtxtPtr ctxt);
#ifdef LIBXML_SAX1_ENABLED
XMLPUBFUN const xmlChar * XMLCALL
			xmlParseAttribute	(xmlParserCtxtPtr ctxt,
						 xmlChar **value);
XMLPUBFUN const xmlChar * XMLCALL
			xmlParseStartTag	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseEndTag		(xmlParserCtxtPtr ctxt);
#endif /* LIBXML_SAX1_ENABLED */
XMLPUBFUN void XMLCALL
			xmlParseCDSect		(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseContent		(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseElement		(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlParseVersionNum	(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlParseVersionInfo	(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlParseEncName		(xmlParserCtxtPtr ctxt);
XMLPUBFUN const xmlChar * XMLCALL
			xmlParseEncodingDecl	(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
			xmlParseSDDecl		(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseXMLDecl		(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseTextDecl	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseMisc		(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			xmlParseExternalSubset	(xmlParserCtxtPtr ctxt,
						 const xmlChar *ExternalID,
						 const xmlChar *SystemID);
/**
 * XML_SUBSTITUTE_NONE:
 *
 * If no entities need to be substituted.
 */
#define XML_SUBSTITUTE_NONE	0
/**
 * XML_SUBSTITUTE_REF:
 *
 * Whether general entities need to be substituted.
 */
#define XML_SUBSTITUTE_REF	1
/**
 * XML_SUBSTITUTE_PEREF:
 *
 * Whether parameter entities need to be substituted.
 */
#define XML_SUBSTITUTE_PEREF	2
/**
 * XML_SUBSTITUTE_BOTH:
 *
 * Both general and parameter entities need to be substituted.
 */
#define XML_SUBSTITUTE_BOTH	3

XMLPUBFUN xmlChar * XMLCALL
		xmlStringDecodeEntities		(xmlParserCtxtPtr ctxt,
						 const xmlChar *str,
						 int what,
						 xmlChar end,
						 xmlChar  end2,
						 xmlChar end3);
XMLPUBFUN xmlChar * XMLCALL
		xmlStringLenDecodeEntities	(xmlParserCtxtPtr ctxt,
						 const xmlChar *str,
						 int len,
						 int what,
						 xmlChar end,
						 xmlChar  end2,
						 xmlChar end3);

/*
 * Generated by MACROS on top of parser.c c.f. PUSH_AND_POP.
 */
XMLPUBFUN int XMLCALL			nodePush		(xmlParserCtxtPtr ctxt,
						 xmlNodePtr value);
XMLPUBFUN xmlNodePtr XMLCALL		nodePop			(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL			inputPush		(xmlParserCtxtPtr ctxt,
						 xmlParserInputPtr value);
XMLPUBFUN xmlParserInputPtr XMLCALL	inputPop		(xmlParserCtxtPtr ctxt);
XMLPUBFUN const xmlChar * XMLCALL	namePop			(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL			namePush		(xmlParserCtxtPtr ctxt,
						 const xmlChar *value);

/*
 * other commodities shared between parser.c and parserInternals.
 */
XMLPUBFUN int XMLCALL			xmlSkipBlankChars	(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL			xmlStringCurrentChar	(xmlParserCtxtPtr ctxt,
						 const xmlChar *cur,
						 int *len);
XMLPUBFUN void XMLCALL			xmlParserHandlePEReference(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL			xmlCheckLanguageID	(const xmlChar *lang);

/*
 * Really core function shared with HTML parser.
 */
XMLPUBFUN int XMLCALL			xmlCurrentChar		(xmlParserCtxtPtr ctxt,
						 int *len);
XMLPUBFUN int XMLCALL		xmlCopyCharMultiByte	(xmlChar *out,
						 int val);
XMLPUBFUN int XMLCALL			xmlCopyChar		(int len,
						 xmlChar *out,
						 int val);
XMLPUBFUN void XMLCALL			xmlNextChar		(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL			xmlParserInputShrink	(xmlParserInputPtr in);

#ifdef LIBXML_HTML_ENABLED
/*
 * Actually comes from the HTML parser but launched from the init stuff.
 */
XMLPUBFUN void XMLCALL			htmlInitAutoClose	(void);
XMLPUBFUN htmlParserCtxtPtr XMLCALL	htmlCreateFileParserCtxt(const char *filename,
	                                         const char *encoding);
#endif

/*
 * Specific function to keep track of entities references
 * and used by the XSLT debugger.
 */
#ifdef LIBXML_LEGACY_ENABLED
/**
 * xmlEntityReferenceFunc:
 * @ent: the entity
 * @firstNode:  the fist node in the chunk
 * @lastNode:  the last nod in the chunk
 *
 * Callback function used when one needs to be able to track back the
 * provenance of a chunk of nodes inherited from an entity replacement.
 */
typedef	void	(*xmlEntityReferenceFunc)	(xmlEntityPtr ent,
						 xmlNodePtr firstNode,
						 xmlNodePtr lastNode);

XMLPUBFUN void XMLCALL		xmlSetEntityReferenceFunc	(xmlEntityReferenceFunc func);

XMLPUBFUN xmlChar * XMLCALL
			xmlParseQuotedString	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
                        xmlParseNamespace       (xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlNamespaceParseNSDef	(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlScanName		(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlNamespaceParseNCName	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL	xmlParserHandleReference(xmlParserCtxtPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
			xmlNamespaceParseQName	(xmlParserCtxtPtr ctxt,
						 xmlChar **prefix);
/**
 * Entities
 */
XMLPUBFUN xmlChar * XMLCALL
		xmlDecodeEntities		(xmlParserCtxtPtr ctxt,
						 int len,
						 int what,
						 xmlChar end,
						 xmlChar  end2,
						 xmlChar end3);
XMLPUBFUN void XMLCALL
			xmlHandleEntity		(xmlParserCtxtPtr ctxt,
						 xmlEntityPtr entity);

#endif /* LIBXML_LEGACY_ENABLED */

#ifdef IN_LIBXML
/*
 * internal only
 */
XMLPUBFUN void XMLCALL
	xmlErrMemory		(xmlParserCtxtPtr ctxt,
				 const char *extra);
#endif

#ifdef __cplusplus
}
#endif
#endif /* __XML_PARSER_INTERNALS_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xpointer.h
/*
 * Summary: API to handle XML Pointers
 * Description: API to handle XML Pointers
 * Base implementation was made accordingly to
 * W3C Candidate Recommendation 7 June 2000
 * http://www.w3.org/TR/2000/CR-xptr-20000607
 *
 * Added support for the element() scheme described in:
 * W3C Proposed Recommendation 13 November 2002
 * http://www.w3.org/TR/2002/PR-xptr-element-20021113/
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_XPTR_H__
#define __XML_XPTR_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_XPTR_ENABLED

#include <libxml/tree.h>
#include <libxml/xpath.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * A Location Set
 */
typedef struct _xmlLocationSet xmlLocationSet;
typedef xmlLocationSet *xmlLocationSetPtr;
struct _xmlLocationSet {
    int locNr;		      /* number of locations in the set */
    int locMax;		      /* size of the array as allocated */
    xmlXPathObjectPtr *locTab;/* array of locations */
};

/*
 * Handling of location sets.
 */

XMLPUBFUN xmlLocationSetPtr XMLCALL
		    xmlXPtrLocationSetCreate	(xmlXPathObjectPtr val);
XMLPUBFUN void XMLCALL
		    xmlXPtrFreeLocationSet	(xmlLocationSetPtr obj);
XMLPUBFUN xmlLocationSetPtr XMLCALL
		    xmlXPtrLocationSetMerge	(xmlLocationSetPtr val1,
						 xmlLocationSetPtr val2);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrNewRange		(xmlNodePtr start,
						 int startindex,
						 xmlNodePtr end,
						 int endindex);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrNewRangePoints	(xmlXPathObjectPtr start,
						 xmlXPathObjectPtr end);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrNewRangeNodePoint	(xmlNodePtr start,
						 xmlXPathObjectPtr end);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrNewRangePointNode	(xmlXPathObjectPtr start,
						 xmlNodePtr end);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrNewRangeNodes	(xmlNodePtr start,
						 xmlNodePtr end);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrNewLocationSetNodes	(xmlNodePtr start,
						 xmlNodePtr end);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrNewRangeNodeObject	(xmlNodePtr start,
						 xmlXPathObjectPtr end);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrNewCollapsedRange	(xmlNodePtr start);
XMLPUBFUN void XMLCALL
		    xmlXPtrLocationSetAdd	(xmlLocationSetPtr cur,
						 xmlXPathObjectPtr val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrWrapLocationSet	(xmlLocationSetPtr val);
XMLPUBFUN void XMLCALL
		    xmlXPtrLocationSetDel	(xmlLocationSetPtr cur,
						 xmlXPathObjectPtr val);
XMLPUBFUN void XMLCALL
		    xmlXPtrLocationSetRemove	(xmlLocationSetPtr cur,
						 int val);

/*
 * Functions.
 */
XMLPUBFUN xmlXPathContextPtr XMLCALL
		    xmlXPtrNewContext		(xmlDocPtr doc,
						 xmlNodePtr here,
						 xmlNodePtr origin);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPtrEval			(const xmlChar *str,
						 xmlXPathContextPtr ctx);
XMLPUBFUN void XMLCALL
		    xmlXPtrRangeToFunction	(xmlXPathParserContextPtr ctxt,
						 int nargs);
XMLPUBFUN xmlNodePtr XMLCALL
		    xmlXPtrBuildNodeList	(xmlXPathObjectPtr obj);
XMLPUBFUN void XMLCALL
		    xmlXPtrEvalRangePredicate	(xmlXPathParserContextPtr ctxt);
#ifdef __cplusplus
}
#endif

#endif /* LIBXML_XPTR_ENABLED */
#endif /* __XML_XPTR_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/nanohttp.h
/*
 * Summary: minimal HTTP implementation
 * Description: minimal HTTP implementation allowing to fetch resources
 *              like external subset.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __NANO_HTTP_H__
#define __NANO_HTTP_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_HTTP_ENABLED

#ifdef __cplusplus
extern "C" {
#endif
XMLPUBFUN void XMLCALL
	xmlNanoHTTPInit		(void);
XMLPUBFUN void XMLCALL
	xmlNanoHTTPCleanup	(void);
XMLPUBFUN void XMLCALL
	xmlNanoHTTPScanProxy	(const char *URL);
XMLPUBFUN int XMLCALL
	xmlNanoHTTPFetch	(const char *URL,
				 const char *filename,
				 char **contentType);
XMLPUBFUN void * XMLCALL
	xmlNanoHTTPMethod	(const char *URL,
				 const char *method,
				 const char *input,
				 char **contentType,
				 const char *headers,
				 int   ilen);
XMLPUBFUN void * XMLCALL
	xmlNanoHTTPMethodRedir	(const char *URL,
				 const char *method,
				 const char *input,
				 char **contentType,
				 char **redir,
				 const char *headers,
				 int   ilen);
XMLPUBFUN void * XMLCALL
	xmlNanoHTTPOpen		(const char *URL,
				 char **contentType);
XMLPUBFUN void * XMLCALL
	xmlNanoHTTPOpenRedir	(const char *URL,
				 char **contentType,
				 char **redir);
XMLPUBFUN int XMLCALL
	xmlNanoHTTPReturnCode	(void *ctx);
XMLPUBFUN const char * XMLCALL
	xmlNanoHTTPAuthHeader	(void *ctx);
XMLPUBFUN const char * XMLCALL
	xmlNanoHTTPRedir	(void *ctx);
XMLPUBFUN int XMLCALL
	xmlNanoHTTPContentLength( void * ctx );
XMLPUBFUN const char * XMLCALL
	xmlNanoHTTPEncoding	(void *ctx);
XMLPUBFUN const char * XMLCALL
	xmlNanoHTTPMimeType	(void *ctx);
XMLPUBFUN int XMLCALL
	xmlNanoHTTPRead		(void *ctx,
				 void *dest,
				 int len);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN int XMLCALL
	xmlNanoHTTPSave		(void *ctxt,
				 const char *filename);
#endif /* LIBXML_OUTPUT_ENABLED */
XMLPUBFUN void XMLCALL
	xmlNanoHTTPClose	(void *ctx);
#ifdef __cplusplus
}
#endif

#endif /* LIBXML_HTTP_ENABLED */
#endif /* __NANO_HTTP_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlschemastypes.h
/*
 * Summary: implementation of XML Schema Datatypes
 * Description: module providing the XML Schema Datatypes implementation
 *              both definition and validity checking
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */


#ifndef __XML_SCHEMA_TYPES_H__
#define __XML_SCHEMA_TYPES_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_SCHEMAS_ENABLED

#include <libxml/schemasInternals.h>
#include <libxml/xmlschemas.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    XML_SCHEMA_WHITESPACE_UNKNOWN = 0,
    XML_SCHEMA_WHITESPACE_PRESERVE = 1,
    XML_SCHEMA_WHITESPACE_REPLACE = 2,
    XML_SCHEMA_WHITESPACE_COLLAPSE = 3
} xmlSchemaWhitespaceValueType;

XMLPUBFUN void XMLCALL
		xmlSchemaInitTypes		(void);
XMLPUBFUN void XMLCALL
		xmlSchemaCleanupTypes		(void);
XMLPUBFUN xmlSchemaTypePtr XMLCALL
		xmlSchemaGetPredefinedType	(const xmlChar *name,
						 const xmlChar *ns);
XMLPUBFUN int XMLCALL
		xmlSchemaValidatePredefinedType	(xmlSchemaTypePtr type,
						 const xmlChar *value,
						 xmlSchemaValPtr *val);
XMLPUBFUN int XMLCALL
		xmlSchemaValPredefTypeNode	(xmlSchemaTypePtr type,
						 const xmlChar *value,
						 xmlSchemaValPtr *val,
						 xmlNodePtr node);
XMLPUBFUN int XMLCALL
		xmlSchemaValidateFacet		(xmlSchemaTypePtr base,
						 xmlSchemaFacetPtr facet,
						 const xmlChar *value,
						 xmlSchemaValPtr val);
XMLPUBFUN int XMLCALL
		xmlSchemaValidateFacetWhtsp	(xmlSchemaFacetPtr facet,
						 xmlSchemaWhitespaceValueType fws,
						 xmlSchemaValType valType,
						 const xmlChar *value,
						 xmlSchemaValPtr val,
						 xmlSchemaWhitespaceValueType ws);
XMLPUBFUN void XMLCALL
		xmlSchemaFreeValue		(xmlSchemaValPtr val);
XMLPUBFUN xmlSchemaFacetPtr XMLCALL
		xmlSchemaNewFacet		(void);
XMLPUBFUN int XMLCALL
		xmlSchemaCheckFacet		(xmlSchemaFacetPtr facet,
						 xmlSchemaTypePtr typeDecl,
						 xmlSchemaParserCtxtPtr ctxt,
						 const xmlChar *name);
XMLPUBFUN void XMLCALL
		xmlSchemaFreeFacet		(xmlSchemaFacetPtr facet);
XMLPUBFUN int XMLCALL
		xmlSchemaCompareValues		(xmlSchemaValPtr x,
						 xmlSchemaValPtr y);
XMLPUBFUN xmlSchemaTypePtr XMLCALL
    xmlSchemaGetBuiltInListSimpleTypeItemType	(xmlSchemaTypePtr type);
XMLPUBFUN int XMLCALL
    xmlSchemaValidateListSimpleTypeFacet	(xmlSchemaFacetPtr facet,
						 const xmlChar *value,
						 unsigned long actualLen,
						 unsigned long *expectedLen);
XMLPUBFUN xmlSchemaTypePtr XMLCALL
		xmlSchemaGetBuiltInType		(xmlSchemaValType type);
XMLPUBFUN int XMLCALL
		xmlSchemaIsBuiltInTypeFacet	(xmlSchemaTypePtr type,
						 int facetType);
XMLPUBFUN xmlChar * XMLCALL
		xmlSchemaCollapseString		(const xmlChar *value);
XMLPUBFUN xmlChar * XMLCALL
		xmlSchemaWhiteSpaceReplace	(const xmlChar *value);
XMLPUBFUN unsigned long  XMLCALL
		xmlSchemaGetFacetValueAsULong	(xmlSchemaFacetPtr facet);
XMLPUBFUN int XMLCALL
		xmlSchemaValidateLengthFacet	(xmlSchemaTypePtr type,
						 xmlSchemaFacetPtr facet,
						 const xmlChar *value,
						 xmlSchemaValPtr val,
						 unsigned long *length);
XMLPUBFUN int XMLCALL
		xmlSchemaValidateLengthFacetWhtsp(xmlSchemaFacetPtr facet,
						  xmlSchemaValType valType,
						  const xmlChar *value,
						  xmlSchemaValPtr val,
						  unsigned long *length,
						  xmlSchemaWhitespaceValueType ws);
XMLPUBFUN int XMLCALL
		xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type,
						 const xmlChar *value,
						 xmlSchemaValPtr *val,
						 xmlNodePtr node);
XMLPUBFUN int XMLCALL
		xmlSchemaGetCanonValue		(xmlSchemaValPtr val,
						 const xmlChar **retValue);
XMLPUBFUN int XMLCALL
		xmlSchemaGetCanonValueWhtsp	(xmlSchemaValPtr val,
						 const xmlChar **retValue,
						 xmlSchemaWhitespaceValueType ws);
XMLPUBFUN int XMLCALL
		xmlSchemaValueAppend		(xmlSchemaValPtr prev,
						 xmlSchemaValPtr cur);
XMLPUBFUN xmlSchemaValPtr XMLCALL
		xmlSchemaValueGetNext		(xmlSchemaValPtr cur);
XMLPUBFUN const xmlChar * XMLCALL
		xmlSchemaValueGetAsString	(xmlSchemaValPtr val);
XMLPUBFUN int XMLCALL
		xmlSchemaValueGetAsBoolean	(xmlSchemaValPtr val);
XMLPUBFUN xmlSchemaValPtr XMLCALL
		xmlSchemaNewStringValue		(xmlSchemaValType type,
						 const xmlChar *value);
XMLPUBFUN xmlSchemaValPtr XMLCALL
		xmlSchemaNewNOTATIONValue	(const xmlChar *name,
						 const xmlChar *ns);
XMLPUBFUN xmlSchemaValPtr XMLCALL
		xmlSchemaNewQNameValue		(const xmlChar *namespaceName,
						 const xmlChar *localName);
XMLPUBFUN int XMLCALL
		xmlSchemaCompareValuesWhtsp	(xmlSchemaValPtr x,
						 xmlSchemaWhitespaceValueType xws,
						 xmlSchemaValPtr y,
						 xmlSchemaWhitespaceValueType yws);
XMLPUBFUN xmlSchemaValPtr XMLCALL
		xmlSchemaCopyValue		(xmlSchemaValPtr val);
XMLPUBFUN xmlSchemaValType XMLCALL
		xmlSchemaGetValType		(xmlSchemaValPtr val);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_SCHEMAS_ENABLED */
#endif /* __XML_SCHEMA_TYPES_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/parser.h
/*
 * Summary: the core parser module
 * Description: Interfaces, constants and types related to the XML parser
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_PARSER_H__
#define __XML_PARSER_H__

#include <stdarg.h>

#include <libxml/xmlversion.h>
#include <libxml/tree.h>
#include <libxml/dict.h>
#include <libxml/hash.h>
#include <libxml/valid.h>
#include <libxml/entities.h>
#include <libxml/xmlerror.h>
#include <libxml/xmlstring.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * XML_DEFAULT_VERSION:
 *
 * The default version of XML used: 1.0
 */
#define XML_DEFAULT_VERSION	"1.0"

/**
 * xmlParserInput:
 *
 * An xmlParserInput is an input flow for the XML processor.
 * Each entity parsed is associated an xmlParserInput (except the
 * few predefined ones). This is the case both for internal entities
 * - in which case the flow is already completely in memory - or
 * external entities - in which case we use the buf structure for
 * progressive reading and I18N conversions to the internal UTF-8 format.
 */

/**
 * xmlParserInputDeallocate:
 * @str:  the string to deallocate
 *
 * Callback for freeing some parser input allocations.
 */
typedef void (* xmlParserInputDeallocate)(xmlChar *str);

struct _xmlParserInput {
    /* Input buffer */
    xmlParserInputBufferPtr buf;      /* UTF-8 encoded buffer */

    const char *filename;             /* The file analyzed, if any */
    const char *directory;            /* the directory/base of the file */
    const xmlChar *base;              /* Base of the array to parse */
    const xmlChar *cur;               /* Current char being parsed */
    const xmlChar *end;               /* end of the array to parse */
    int length;                       /* length if known */
    int line;                         /* Current line */
    int col;                          /* Current column */
    /*
     * NOTE: consumed is only tested for equality in the parser code,
     *       so even if there is an overflow this should not give troubles
     *       for parsing very large instances.
     */
    unsigned long consumed;           /* How many xmlChars already consumed */
    xmlParserInputDeallocate free;    /* function to deallocate the base */
    const xmlChar *encoding;          /* the encoding string for entity */
    const xmlChar *version;           /* the version string for entity */
    int standalone;                   /* Was that entity marked standalone */
    int id;                           /* an unique identifier for the entity */
};

/**
 * xmlParserNodeInfo:
 *
 * The parser can be asked to collect Node informations, i.e. at what
 * place in the file they were detected.
 * NOTE: This is off by default and not very well tested.
 */
typedef struct _xmlParserNodeInfo xmlParserNodeInfo;
typedef xmlParserNodeInfo *xmlParserNodeInfoPtr;

struct _xmlParserNodeInfo {
  const struct _xmlNode* node;
  /* Position & line # that text that created the node begins & ends on */
  unsigned long begin_pos;
  unsigned long begin_line;
  unsigned long end_pos;
  unsigned long end_line;
};

typedef struct _xmlParserNodeInfoSeq xmlParserNodeInfoSeq;
typedef xmlParserNodeInfoSeq *xmlParserNodeInfoSeqPtr;
struct _xmlParserNodeInfoSeq {
  unsigned long maximum;
  unsigned long length;
  xmlParserNodeInfo* buffer;
};

/**
 * xmlParserInputState:
 *
 * The parser is now working also as a state based parser.
 * The recursive one use the state info for entities processing.
 */
typedef enum {
    XML_PARSER_EOF = -1,	/* nothing is to be parsed */
    XML_PARSER_START = 0,	/* nothing has been parsed */
    XML_PARSER_MISC,		/* Misc* before int subset */
    XML_PARSER_PI,		/* Within a processing instruction */
    XML_PARSER_DTD,		/* within some DTD content */
    XML_PARSER_PROLOG,		/* Misc* after internal subset */
    XML_PARSER_COMMENT,		/* within a comment */
    XML_PARSER_START_TAG,	/* within a start tag */
    XML_PARSER_CONTENT,		/* within the content */
    XML_PARSER_CDATA_SECTION,	/* within a CDATA section */
    XML_PARSER_END_TAG,		/* within a closing tag */
    XML_PARSER_ENTITY_DECL,	/* within an entity declaration */
    XML_PARSER_ENTITY_VALUE,	/* within an entity value in a decl */
    XML_PARSER_ATTRIBUTE_VALUE,	/* within an attribute value */
    XML_PARSER_SYSTEM_LITERAL,	/* within a SYSTEM value */
    XML_PARSER_EPILOG,		/* the Misc* after the last end tag */
    XML_PARSER_IGNORE,		/* within an IGNORED section */
    XML_PARSER_PUBLIC_LITERAL	/* within a PUBLIC value */
} xmlParserInputState;

/**
 * XML_DETECT_IDS:
 *
 * Bit in the loadsubset context field to tell to do ID/REFs lookups.
 * Use it to initialize xmlLoadExtDtdDefaultValue.
 */
#define XML_DETECT_IDS		2

/**
 * XML_COMPLETE_ATTRS:
 *
 * Bit in the loadsubset context field to tell to do complete the
 * elements attributes lists with the ones defaulted from the DTDs.
 * Use it to initialize xmlLoadExtDtdDefaultValue.
 */
#define XML_COMPLETE_ATTRS	4

/**
 * XML_SKIP_IDS:
 *
 * Bit in the loadsubset context field to tell to not do ID/REFs registration.
 * Used to initialize xmlLoadExtDtdDefaultValue in some special cases.
 */
#define XML_SKIP_IDS		8

/**
 * xmlParserMode:
 *
 * A parser can operate in various modes
 */
typedef enum {
    XML_PARSE_UNKNOWN = 0,
    XML_PARSE_DOM = 1,
    XML_PARSE_SAX = 2,
    XML_PARSE_PUSH_DOM = 3,
    XML_PARSE_PUSH_SAX = 4,
    XML_PARSE_READER = 5
} xmlParserMode;

/**
 * xmlParserCtxt:
 *
 * The parser context.
 * NOTE This doesn't completely define the parser state, the (current ?)
 *      design of the parser uses recursive function calls since this allow
 *      and easy mapping from the production rules of the specification
 *      to the actual code. The drawback is that the actual function call
 *      also reflect the parser state. However most of the parsing routines
 *      takes as the only argument the parser context pointer, so migrating
 *      to a state based parser for progressive parsing shouldn't be too hard.
 */
struct _xmlParserCtxt {
    struct _xmlSAXHandler *sax;       /* The SAX handler */
    void            *userData;        /* For SAX interface only, used by DOM build */
    xmlDocPtr           myDoc;        /* the document being built */
    int            wellFormed;        /* is the document well formed */
    int       replaceEntities;        /* shall we replace entities ? */
    const xmlChar    *version;        /* the XML version string */
    const xmlChar   *encoding;        /* the declared encoding, if any */
    int            standalone;        /* standalone document */
    int                  html;        /* an HTML(1)/Docbook(2) document
                                       * 3 is HTML after <head>
                                       * 10 is HTML after <body>
                                       */

    /* Input stream stack */
    xmlParserInputPtr  input;         /* Current input stream */
    int                inputNr;       /* Number of current input streams */
    int                inputMax;      /* Max number of input streams */
    xmlParserInputPtr *inputTab;      /* stack of inputs */

    /* Node analysis stack only used for DOM building */
    xmlNodePtr         node;          /* Current parsed Node */
    int                nodeNr;        /* Depth of the parsing stack */
    int                nodeMax;       /* Max depth of the parsing stack */
    xmlNodePtr        *nodeTab;       /* array of nodes */

    int record_info;                  /* Whether node info should be kept */
    xmlParserNodeInfoSeq node_seq;    /* info about each node parsed */

    int errNo;                        /* error code */

    int     hasExternalSubset;        /* reference and external subset */
    int             hasPErefs;        /* the internal subset has PE refs */
    int              external;        /* are we parsing an external entity */

    int                 valid;        /* is the document valid */
    int              validate;        /* shall we try to validate ? */
    xmlValidCtxt        vctxt;        /* The validity context */

    xmlParserInputState instate;      /* current type of input */
    int                 token;        /* next char look-ahead */

    char           *directory;        /* the data directory */

    /* Node name stack */
    const xmlChar     *name;          /* Current parsed Node */
    int                nameNr;        /* Depth of the parsing stack */
    int                nameMax;       /* Max depth of the parsing stack */
    const xmlChar *   *nameTab;       /* array of nodes */

    long               nbChars;       /* number of xmlChar processed */
    long            checkIndex;       /* used by progressive parsing lookup */
    int             keepBlanks;       /* ugly but ... */
    int             disableSAX;       /* SAX callbacks are disabled */
    int               inSubset;       /* Parsing is in int 1/ext 2 subset */
    const xmlChar *    intSubName;    /* name of subset */
    xmlChar *          extSubURI;     /* URI of external subset */
    xmlChar *          extSubSystem;  /* SYSTEM ID of external subset */

    /* xml:space values */
    int *              space;         /* Should the parser preserve spaces */
    int                spaceNr;       /* Depth of the parsing stack */
    int                spaceMax;      /* Max depth of the parsing stack */
    int *              spaceTab;      /* array of space infos */

    int                depth;         /* to prevent entity substitution loops */
    xmlParserInputPtr  entity;        /* used to check entities boundaries */
    int                charset;       /* encoding of the in-memory content
				         actually an xmlCharEncoding */
    int                nodelen;       /* Those two fields are there to */
    int                nodemem;       /* Speed up large node parsing */
    int                pedantic;      /* signal pedantic warnings */
    void              *_private;      /* For user data, libxml won't touch it */

    int                loadsubset;    /* should the external subset be loaded */
    int                linenumbers;   /* set line number in element content */
    void              *catalogs;      /* document's own catalog */
    int                recovery;      /* run in recovery mode */
    int                progressive;   /* is this a progressive parsing */
    xmlDictPtr         dict;          /* dictionnary for the parser */
    const xmlChar *   *atts;          /* array for the attributes callbacks */
    int                maxatts;       /* the size of the array */
    int                docdict;       /* use strings from dict to build tree */

    /*
     * pre-interned strings
     */
    const xmlChar *str_xml;
    const xmlChar *str_xmlns;
    const xmlChar *str_xml_ns;

    /*
     * Everything below is used only by the new SAX mode
     */
    int                sax2;          /* operating in the new SAX mode */
    int                nsNr;          /* the number of inherited namespaces */
    int                nsMax;         /* the size of the arrays */
    const xmlChar *   *nsTab;         /* the array of prefix/namespace name */
    int               *attallocs;     /* which attribute were allocated */
    void *            *pushTab;       /* array of data for push */
    xmlHashTablePtr    attsDefault;   /* defaulted attributes if any */
    xmlHashTablePtr    attsSpecial;   /* non-CDATA attributes if any */
    int                nsWellFormed;  /* is the document XML Nanespace okay */
    int                options;       /* Extra options */

    /*
     * Those fields are needed only for treaming parsing so far
     */
    int               dictNames;    /* Use dictionary names for the tree */
    int               freeElemsNr;  /* number of freed element nodes */
    xmlNodePtr        freeElems;    /* List of freed element nodes */
    int               freeAttrsNr;  /* number of freed attributes nodes */
    xmlAttrPtr        freeAttrs;    /* List of freed attributes nodes */

    /*
     * the complete error informations for the last error.
     */
    xmlError          lastError;
    xmlParserMode     parseMode;    /* the parser mode */
    unsigned long    nbentities;    /* number of entities references */
    unsigned long  sizeentities;    /* size of parsed entities */

    /* for use by HTML non-recursive parser */
    xmlParserNodeInfo *nodeInfo;      /* Current NodeInfo */
    int                nodeInfoNr;    /* Depth of the parsing stack */
    int                nodeInfoMax;   /* Max depth of the parsing stack */
    xmlParserNodeInfo *nodeInfoTab;   /* array of nodeInfos */

    int                input_id;      /* we need to label inputs */
    unsigned long      sizeentcopy;   /* volume of entity copy */
};

/**
 * xmlSAXLocator:
 *
 * A SAX Locator.
 */
struct _xmlSAXLocator {
    const xmlChar *(*getPublicId)(void *ctx);
    const xmlChar *(*getSystemId)(void *ctx);
    int (*getLineNumber)(void *ctx);
    int (*getColumnNumber)(void *ctx);
};

/**
 * xmlSAXHandler:
 *
 * A SAX handler is bunch of callbacks called by the parser when processing
 * of the input generate data or structure informations.
 */

/**
 * resolveEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * Callback:
 * The entity loader, to control the loading of external entities,
 * the application can either:
 *    - override this resolveEntity() callback in the SAX block
 *    - or better use the xmlSetExternalEntityLoader() function to
 *      set up it's own entity resolution routine
 *
 * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
 */
typedef xmlParserInputPtr (*resolveEntitySAXFunc) (void *ctx,
				const xmlChar *publicId,
				const xmlChar *systemId);
/**
 * internalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on internal subset declaration.
 */
typedef void (*internalSubsetSAXFunc) (void *ctx,
				const xmlChar *name,
				const xmlChar *ExternalID,
				const xmlChar *SystemID);
/**
 * externalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on external subset declaration.
 */
typedef void (*externalSubsetSAXFunc) (void *ctx,
				const xmlChar *name,
				const xmlChar *ExternalID,
				const xmlChar *SystemID);
/**
 * getEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get an entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
typedef xmlEntityPtr (*getEntitySAXFunc) (void *ctx,
				const xmlChar *name);
/**
 * getParameterEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get a parameter entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
typedef xmlEntityPtr (*getParameterEntitySAXFunc) (void *ctx,
				const xmlChar *name);
/**
 * entityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the entity name
 * @type:  the entity type
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @content: the entity value (without processing).
 *
 * An entity definition has been parsed.
 */
typedef void (*entityDeclSAXFunc) (void *ctx,
				const xmlChar *name,
				int type,
				const xmlChar *publicId,
				const xmlChar *systemId,
				xmlChar *content);
/**
 * notationDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the notation
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * What to do when a notation declaration has been parsed.
 */
typedef void (*notationDeclSAXFunc)(void *ctx,
				const xmlChar *name,
				const xmlChar *publicId,
				const xmlChar *systemId);
/**
 * attributeDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @elem:  the name of the element
 * @fullname:  the attribute name
 * @type:  the attribute type
 * @def:  the type of default value
 * @defaultValue: the attribute default value
 * @tree:  the tree of enumerated value set
 *
 * An attribute definition has been parsed.
 */
typedef void (*attributeDeclSAXFunc)(void *ctx,
				const xmlChar *elem,
				const xmlChar *fullname,
				int type,
				int def,
				const xmlChar *defaultValue,
				xmlEnumerationPtr tree);
/**
 * elementDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the element name
 * @type:  the element type
 * @content: the element value tree
 *
 * An element definition has been parsed.
 */
typedef void (*elementDeclSAXFunc)(void *ctx,
				const xmlChar *name,
				int type,
				xmlElementContentPtr content);
/**
 * unparsedEntityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the entity
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @notationName: the name of the notation
 *
 * What to do when an unparsed entity declaration is parsed.
 */
typedef void (*unparsedEntityDeclSAXFunc)(void *ctx,
				const xmlChar *name,
				const xmlChar *publicId,
				const xmlChar *systemId,
				const xmlChar *notationName);
/**
 * setDocumentLocatorSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @loc: A SAX Locator
 *
 * Receive the document locator at startup, actually xmlDefaultSAXLocator.
 * Everything is available on the context, so this is useless in our case.
 */
typedef void (*setDocumentLocatorSAXFunc) (void *ctx,
				xmlSAXLocatorPtr loc);
/**
 * startDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document start being processed.
 */
typedef void (*startDocumentSAXFunc) (void *ctx);
/**
 * endDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document end has been detected.
 */
typedef void (*endDocumentSAXFunc) (void *ctx);
/**
 * startElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name, including namespace prefix
 * @atts:  An array of name/value attributes pairs, NULL terminated
 *
 * Called when an opening tag has been processed.
 */
typedef void (*startElementSAXFunc) (void *ctx,
				const xmlChar *name,
				const xmlChar **atts);
/**
 * endElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name
 *
 * Called when the end of an element has been detected.
 */
typedef void (*endElementSAXFunc) (void *ctx,
				const xmlChar *name);
/**
 * attributeSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The attribute name, including namespace prefix
 * @value:  The attribute value
 *
 * Handle an attribute that has been read by the parser.
 * The default handling is to convert the attribute into an
 * DOM subtree and past it in a new xmlAttr element added to
 * the element.
 */
typedef void (*attributeSAXFunc) (void *ctx,
				const xmlChar *name,
				const xmlChar *value);
/**
 * referenceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The entity name
 *
 * Called when an entity reference is detected.
 */
typedef void (*referenceSAXFunc) (void *ctx,
				const xmlChar *name);
/**
 * charactersSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some chars from the parser.
 */
typedef void (*charactersSAXFunc) (void *ctx,
				const xmlChar *ch,
				int len);
/**
 * ignorableWhitespaceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some ignorable whitespaces from the parser.
 * UNUSED: by default the DOM building will use characters.
 */
typedef void (*ignorableWhitespaceSAXFunc) (void *ctx,
				const xmlChar *ch,
				int len);
/**
 * processingInstructionSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @target:  the target name
 * @data: the PI data's
 *
 * A processing instruction has been parsed.
 */
typedef void (*processingInstructionSAXFunc) (void *ctx,
				const xmlChar *target,
				const xmlChar *data);
/**
 * commentSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  the comment content
 *
 * A comment has been parsed.
 */
typedef void (*commentSAXFunc) (void *ctx,
				const xmlChar *value);
/**
 * cdataBlockSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  The pcdata content
 * @len:  the block length
 *
 * Called when a pcdata block has been parsed.
 */
typedef void (*cdataBlockSAXFunc) (
	                        void *ctx,
				const xmlChar *value,
				int len);
/**
 * warningSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format a warning messages, callback.
 */
typedef void (XMLCDECL *warningSAXFunc) (void *ctx,
				const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);
/**
 * errorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format an error messages, callback.
 */
typedef void (XMLCDECL *errorSAXFunc) (void *ctx,
				const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);
/**
 * fatalErrorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format fatal error messages, callback.
 * Note: so far fatalError() SAX callbacks are not used, error()
 *       get all the callbacks for errors.
 */
typedef void (XMLCDECL *fatalErrorSAXFunc) (void *ctx,
				const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);
/**
 * isStandaloneSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Is this document tagged standalone?
 *
 * Returns 1 if true
 */
typedef int (*isStandaloneSAXFunc) (void *ctx);
/**
 * hasInternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an internal subset.
 *
 * Returns 1 if true
 */
typedef int (*hasInternalSubsetSAXFunc) (void *ctx);

/**
 * hasExternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an external subset?
 *
 * Returns 1 if true
 */
typedef int (*hasExternalSubsetSAXFunc) (void *ctx);

/************************************************************************
 *									*
 *			The SAX version 2 API extensions		*
 *									*
 ************************************************************************/
/**
 * XML_SAX2_MAGIC:
 *
 * Special constant found in SAX2 blocks initialized fields
 */
#define XML_SAX2_MAGIC 0xDEEDBEAF

/**
 * startElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 * @nb_namespaces:  number of namespace definitions on that node
 * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
 * @nb_attributes:  the number of attributes on that node
 * @nb_defaulted:  the number of defaulted attributes. The defaulted
 *                  ones are at the end of the array
 * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
 *               attribute values.
 *
 * SAX2 callback when an element start has been detected by the parser.
 * It provides the namespace informations for the element, as well as
 * the new namespace declarations on the element.
 */

typedef void (*startElementNsSAX2Func) (void *ctx,
					const xmlChar *localname,
					const xmlChar *prefix,
					const xmlChar *URI,
					int nb_namespaces,
					const xmlChar **namespaces,
					int nb_attributes,
					int nb_defaulted,
					const xmlChar **attributes);

/**
 * endElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 *
 * SAX2 callback when an element end has been detected by the parser.
 * It provides the namespace informations for the element.
 */

typedef void (*endElementNsSAX2Func)   (void *ctx,
					const xmlChar *localname,
					const xmlChar *prefix,
					const xmlChar *URI);


struct _xmlSAXHandler {
    internalSubsetSAXFunc internalSubset;
    isStandaloneSAXFunc isStandalone;
    hasInternalSubsetSAXFunc hasInternalSubset;
    hasExternalSubsetSAXFunc hasExternalSubset;
    resolveEntitySAXFunc resolveEntity;
    getEntitySAXFunc getEntity;
    entityDeclSAXFunc entityDecl;
    notationDeclSAXFunc notationDecl;
    attributeDeclSAXFunc attributeDecl;
    elementDeclSAXFunc elementDecl;
    unparsedEntityDeclSAXFunc unparsedEntityDecl;
    setDocumentLocatorSAXFunc setDocumentLocator;
    startDocumentSAXFunc startDocument;
    endDocumentSAXFunc endDocument;
    startElementSAXFunc startElement;
    endElementSAXFunc endElement;
    referenceSAXFunc reference;
    charactersSAXFunc characters;
    ignorableWhitespaceSAXFunc ignorableWhitespace;
    processingInstructionSAXFunc processingInstruction;
    commentSAXFunc comment;
    warningSAXFunc warning;
    errorSAXFunc error;
    fatalErrorSAXFunc fatalError; /* unused error() get all the errors */
    getParameterEntitySAXFunc getParameterEntity;
    cdataBlockSAXFunc cdataBlock;
    externalSubsetSAXFunc externalSubset;
    unsigned int initialized;
    /* The following fields are extensions available only on version 2 */
    void *_private;
    startElementNsSAX2Func startElementNs;
    endElementNsSAX2Func endElementNs;
    xmlStructuredErrorFunc serror;
};

/*
 * SAX Version 1
 */
typedef struct _xmlSAXHandlerV1 xmlSAXHandlerV1;
typedef xmlSAXHandlerV1 *xmlSAXHandlerV1Ptr;
struct _xmlSAXHandlerV1 {
    internalSubsetSAXFunc internalSubset;
    isStandaloneSAXFunc isStandalone;
    hasInternalSubsetSAXFunc hasInternalSubset;
    hasExternalSubsetSAXFunc hasExternalSubset;
    resolveEntitySAXFunc resolveEntity;
    getEntitySAXFunc getEntity;
    entityDeclSAXFunc entityDecl;
    notationDeclSAXFunc notationDecl;
    attributeDeclSAXFunc attributeDecl;
    elementDeclSAXFunc elementDecl;
    unparsedEntityDeclSAXFunc unparsedEntityDecl;
    setDocumentLocatorSAXFunc setDocumentLocator;
    startDocumentSAXFunc startDocument;
    endDocumentSAXFunc endDocument;
    startElementSAXFunc startElement;
    endElementSAXFunc endElement;
    referenceSAXFunc reference;
    charactersSAXFunc characters;
    ignorableWhitespaceSAXFunc ignorableWhitespace;
    processingInstructionSAXFunc processingInstruction;
    commentSAXFunc comment;
    warningSAXFunc warning;
    errorSAXFunc error;
    fatalErrorSAXFunc fatalError; /* unused error() get all the errors */
    getParameterEntitySAXFunc getParameterEntity;
    cdataBlockSAXFunc cdataBlock;
    externalSubsetSAXFunc externalSubset;
    unsigned int initialized;
};


/**
 * xmlExternalEntityLoader:
 * @URL: The System ID of the resource requested
 * @ID: The Public ID of the resource requested
 * @context: the XML parser context
 *
 * External entity loaders types.
 *
 * Returns the entity input parser.
 */
typedef xmlParserInputPtr (*xmlExternalEntityLoader) (const char *URL,
					 const char *ID,
					 xmlParserCtxtPtr context);

#ifdef __cplusplus
}
#endif

#include <libxml/encoding.h>
#include <libxml/xmlIO.h>
#include <libxml/globals.h>

#ifdef __cplusplus
extern "C" {
#endif


/*
 * Init/Cleanup
 */
XMLPUBFUN void XMLCALL
		xmlInitParser		(void);
XMLPUBFUN void XMLCALL
		xmlCleanupParser	(void);

/*
 * Input functions
 */
XMLPUBFUN int XMLCALL
		xmlParserInputRead	(xmlParserInputPtr in,
					 int len);
XMLPUBFUN int XMLCALL
		xmlParserInputGrow	(xmlParserInputPtr in,
					 int len);

/*
 * Basic parsing Interfaces
 */
#ifdef LIBXML_SAX1_ENABLED
XMLPUBFUN xmlDocPtr XMLCALL
		xmlParseDoc		(const xmlChar *cur);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlParseFile		(const char *filename);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlParseMemory		(const char *buffer,
					 int size);
#endif /* LIBXML_SAX1_ENABLED */
XMLPUBFUN int XMLCALL
		xmlSubstituteEntitiesDefault(int val);
XMLPUBFUN int XMLCALL
		xmlKeepBlanksDefault	(int val);
XMLPUBFUN void XMLCALL
		xmlStopParser		(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
		xmlPedanticParserDefault(int val);
XMLPUBFUN int XMLCALL
		xmlLineNumbersDefault	(int val);

#ifdef LIBXML_SAX1_ENABLED
/*
 * Recovery mode
 */
XMLPUBFUN xmlDocPtr XMLCALL
		xmlRecoverDoc		(const xmlChar *cur);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlRecoverMemory	(const char *buffer,
					 int size);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlRecoverFile		(const char *filename);
#endif /* LIBXML_SAX1_ENABLED */

/*
 * Less common routines and SAX interfaces
 */
XMLPUBFUN int XMLCALL
		xmlParseDocument	(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
		xmlParseExtParsedEnt	(xmlParserCtxtPtr ctxt);
#ifdef LIBXML_SAX1_ENABLED
XMLPUBFUN int XMLCALL
		xmlSAXUserParseFile	(xmlSAXHandlerPtr sax,
					 void *user_data,
					 const char *filename);
XMLPUBFUN int XMLCALL
		xmlSAXUserParseMemory	(xmlSAXHandlerPtr sax,
					 void *user_data,
					 const char *buffer,
					 int size);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlSAXParseDoc		(xmlSAXHandlerPtr sax,
					 const xmlChar *cur,
					 int recovery);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlSAXParseMemory	(xmlSAXHandlerPtr sax,
					 const char *buffer,
					 int size,
					 int recovery);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlSAXParseMemoryWithData (xmlSAXHandlerPtr sax,
					 const char *buffer,
					 int size,
					 int recovery,
					 void *data);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlSAXParseFile		(xmlSAXHandlerPtr sax,
					 const char *filename,
					 int recovery);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlSAXParseFileWithData	(xmlSAXHandlerPtr sax,
					 const char *filename,
					 int recovery,
					 void *data);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlSAXParseEntity	(xmlSAXHandlerPtr sax,
					 const char *filename);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlParseEntity		(const char *filename);
#endif /* LIBXML_SAX1_ENABLED */

#ifdef LIBXML_VALID_ENABLED
XMLPUBFUN xmlDtdPtr XMLCALL
		xmlSAXParseDTD		(xmlSAXHandlerPtr sax,
					 const xmlChar *ExternalID,
					 const xmlChar *SystemID);
XMLPUBFUN xmlDtdPtr XMLCALL
		xmlParseDTD		(const xmlChar *ExternalID,
					 const xmlChar *SystemID);
XMLPUBFUN xmlDtdPtr XMLCALL
		xmlIOParseDTD		(xmlSAXHandlerPtr sax,
					 xmlParserInputBufferPtr input,
					 xmlCharEncoding enc);
#endif /* LIBXML_VALID_ENABLE */
#ifdef LIBXML_SAX1_ENABLED
XMLPUBFUN int XMLCALL
		xmlParseBalancedChunkMemory(xmlDocPtr doc,
					 xmlSAXHandlerPtr sax,
					 void *user_data,
					 int depth,
					 const xmlChar *string,
					 xmlNodePtr *lst);
#endif /* LIBXML_SAX1_ENABLED */
XMLPUBFUN xmlParserErrors XMLCALL
		xmlParseInNodeContext	(xmlNodePtr node,
					 const char *data,
					 int datalen,
					 int options,
					 xmlNodePtr *lst);
#ifdef LIBXML_SAX1_ENABLED
XMLPUBFUN int XMLCALL
		xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc,
                     xmlSAXHandlerPtr sax,
                     void *user_data,
                     int depth,
                     const xmlChar *string,
                     xmlNodePtr *lst,
                     int recover);
XMLPUBFUN int XMLCALL
		xmlParseExternalEntity	(xmlDocPtr doc,
					 xmlSAXHandlerPtr sax,
					 void *user_data,
					 int depth,
					 const xmlChar *URL,
					 const xmlChar *ID,
					 xmlNodePtr *lst);
#endif /* LIBXML_SAX1_ENABLED */
XMLPUBFUN int XMLCALL
		xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx,
					 const xmlChar *URL,
					 const xmlChar *ID,
					 xmlNodePtr *lst);

/*
 * Parser contexts handling.
 */
XMLPUBFUN xmlParserCtxtPtr XMLCALL
		xmlNewParserCtxt	(void);
XMLPUBFUN int XMLCALL
		xmlInitParserCtxt	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
		xmlClearParserCtxt	(xmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
		xmlFreeParserCtxt	(xmlParserCtxtPtr ctxt);
#ifdef LIBXML_SAX1_ENABLED
XMLPUBFUN void XMLCALL
		xmlSetupParserForBuffer	(xmlParserCtxtPtr ctxt,
					 const xmlChar* buffer,
					 const char *filename);
#endif /* LIBXML_SAX1_ENABLED */
XMLPUBFUN xmlParserCtxtPtr XMLCALL
		xmlCreateDocParserCtxt	(const xmlChar *cur);

#ifdef LIBXML_LEGACY_ENABLED
/*
 * Reading/setting optional parsing features.
 */
XMLPUBFUN int XMLCALL
		xmlGetFeaturesList	(int *len,
					 const char **result);
XMLPUBFUN int XMLCALL
		xmlGetFeature		(xmlParserCtxtPtr ctxt,
					 const char *name,
					 void *result);
XMLPUBFUN int XMLCALL
		xmlSetFeature		(xmlParserCtxtPtr ctxt,
					 const char *name,
					 void *value);
#endif /* LIBXML_LEGACY_ENABLED */

#ifdef LIBXML_PUSH_ENABLED
/*
 * Interfaces for the Push mode.
 */
XMLPUBFUN xmlParserCtxtPtr XMLCALL
		xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax,
					 void *user_data,
					 const char *chunk,
					 int size,
					 const char *filename);
XMLPUBFUN int XMLCALL
		xmlParseChunk		(xmlParserCtxtPtr ctxt,
					 const char *chunk,
					 int size,
					 int terminate);
#endif /* LIBXML_PUSH_ENABLED */

/*
 * Special I/O mode.
 */

XMLPUBFUN xmlParserCtxtPtr XMLCALL
		xmlCreateIOParserCtxt	(xmlSAXHandlerPtr sax,
					 void *user_data,
					 xmlInputReadCallback   ioread,
					 xmlInputCloseCallback  ioclose,
					 void *ioctx,
					 xmlCharEncoding enc);

XMLPUBFUN xmlParserInputPtr XMLCALL
		xmlNewIOInputStream	(xmlParserCtxtPtr ctxt,
					 xmlParserInputBufferPtr input,
					 xmlCharEncoding enc);

/*
 * Node infos.
 */
XMLPUBFUN const xmlParserNodeInfo* XMLCALL
		xmlParserFindNodeInfo	(const xmlParserCtxtPtr ctxt,
				         const xmlNodePtr node);
XMLPUBFUN void XMLCALL
		xmlInitNodeInfoSeq	(xmlParserNodeInfoSeqPtr seq);
XMLPUBFUN void XMLCALL
		xmlClearNodeInfoSeq	(xmlParserNodeInfoSeqPtr seq);
XMLPUBFUN unsigned long XMLCALL
		xmlParserFindNodeInfoIndex(const xmlParserNodeInfoSeqPtr seq,
                                         const xmlNodePtr node);
XMLPUBFUN void XMLCALL
		xmlParserAddNodeInfo	(xmlParserCtxtPtr ctxt,
					 const xmlParserNodeInfoPtr info);

/*
 * External entities handling actually implemented in xmlIO.
 */

XMLPUBFUN void XMLCALL
		xmlSetExternalEntityLoader(xmlExternalEntityLoader f);
XMLPUBFUN xmlExternalEntityLoader XMLCALL
		xmlGetExternalEntityLoader(void);
XMLPUBFUN xmlParserInputPtr XMLCALL
		xmlLoadExternalEntity	(const char *URL,
					 const char *ID,
					 xmlParserCtxtPtr ctxt);

/*
 * Index lookup, actually implemented in the encoding module
 */
XMLPUBFUN long XMLCALL
		xmlByteConsumed		(xmlParserCtxtPtr ctxt);

/*
 * New set of simpler/more flexible APIs
 */
/**
 * xmlParserOption:
 *
 * This is the set of XML parser options that can be passed down
 * to the xmlReadDoc() and similar calls.
 */
typedef enum {
    XML_PARSE_RECOVER	= 1<<0,	/* recover on errors */
    XML_PARSE_NOENT	= 1<<1,	/* substitute entities */
    XML_PARSE_DTDLOAD	= 1<<2,	/* load the external subset */
    XML_PARSE_DTDATTR	= 1<<3,	/* default DTD attributes */
    XML_PARSE_DTDVALID	= 1<<4,	/* validate with the DTD */
    XML_PARSE_NOERROR	= 1<<5,	/* suppress error reports */
    XML_PARSE_NOWARNING	= 1<<6,	/* suppress warning reports */
    XML_PARSE_PEDANTIC	= 1<<7,	/* pedantic error reporting */
    XML_PARSE_NOBLANKS	= 1<<8,	/* remove blank nodes */
    XML_PARSE_SAX1	= 1<<9,	/* use the SAX1 interface internally */
    XML_PARSE_XINCLUDE	= 1<<10,/* Implement XInclude substitition  */
    XML_PARSE_NONET	= 1<<11,/* Forbid network access */
    XML_PARSE_NODICT	= 1<<12,/* Do not reuse the context dictionnary */
    XML_PARSE_NSCLEAN	= 1<<13,/* remove redundant namespaces declarations */
    XML_PARSE_NOCDATA	= 1<<14,/* merge CDATA as text nodes */
    XML_PARSE_NOXINCNODE= 1<<15,/* do not generate XINCLUDE START/END nodes */
    XML_PARSE_COMPACT   = 1<<16,/* compact small text nodes; no modification of
                                   the tree allowed afterwards (will possibly
				   crash if you try to modify the tree) */
    XML_PARSE_OLD10	= 1<<17,/* parse using XML-1.0 before update 5 */
    XML_PARSE_NOBASEFIX = 1<<18,/* do not fixup XINCLUDE xml:base uris */
    XML_PARSE_HUGE      = 1<<19,/* relax any hardcoded limit from the parser */
    XML_PARSE_OLDSAX    = 1<<20,/* parse using SAX2 interface before 2.7.0 */
    XML_PARSE_IGNORE_ENC= 1<<21,/* ignore internal document encoding hint */
    XML_PARSE_BIG_LINES = 1<<22 /* Store big lines numbers in text PSVI field */
} xmlParserOption;

XMLPUBFUN void XMLCALL
		xmlCtxtReset		(xmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
		xmlCtxtResetPush	(xmlParserCtxtPtr ctxt,
					 const char *chunk,
					 int size,
					 const char *filename,
					 const char *encoding);
XMLPUBFUN int XMLCALL
		xmlCtxtUseOptions	(xmlParserCtxtPtr ctxt,
					 int options);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlReadDoc		(const xmlChar *cur,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlReadFile		(const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlReadMemory		(const char *buffer,
					 int size,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlReadFd		(int fd,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlReadIO		(xmlInputReadCallback ioread,
					 xmlInputCloseCallback ioclose,
					 void *ioctx,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlCtxtReadDoc		(xmlParserCtxtPtr ctxt,
					 const xmlChar *cur,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlCtxtReadFile		(xmlParserCtxtPtr ctxt,
					 const char *filename,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlCtxtReadMemory		(xmlParserCtxtPtr ctxt,
					 const char *buffer,
					 int size,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlCtxtReadFd		(xmlParserCtxtPtr ctxt,
					 int fd,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlCtxtReadIO		(xmlParserCtxtPtr ctxt,
					 xmlInputReadCallback ioread,
					 xmlInputCloseCallback ioclose,
					 void *ioctx,
					 const char *URL,
					 const char *encoding,
					 int options);

/*
 * Library wide options
 */
/**
 * xmlFeature:
 *
 * Used to examine the existance of features that can be enabled
 * or disabled at compile-time.
 * They used to be called XML_FEATURE_xxx but this clashed with Expat
 */
typedef enum {
    XML_WITH_THREAD = 1,
    XML_WITH_TREE = 2,
    XML_WITH_OUTPUT = 3,
    XML_WITH_PUSH = 4,
    XML_WITH_READER = 5,
    XML_WITH_PATTERN = 6,
    XML_WITH_WRITER = 7,
    XML_WITH_SAX1 = 8,
    XML_WITH_FTP = 9,
    XML_WITH_HTTP = 10,
    XML_WITH_VALID = 11,
    XML_WITH_HTML = 12,
    XML_WITH_LEGACY = 13,
    XML_WITH_C14N = 14,
    XML_WITH_CATALOG = 15,
    XML_WITH_XPATH = 16,
    XML_WITH_XPTR = 17,
    XML_WITH_XINCLUDE = 18,
    XML_WITH_ICONV = 19,
    XML_WITH_ISO8859X = 20,
    XML_WITH_UNICODE = 21,
    XML_WITH_REGEXP = 22,
    XML_WITH_AUTOMATA = 23,
    XML_WITH_EXPR = 24,
    XML_WITH_SCHEMAS = 25,
    XML_WITH_SCHEMATRON = 26,
    XML_WITH_MODULES = 27,
    XML_WITH_DEBUG = 28,
    XML_WITH_DEBUG_MEM = 29,
    XML_WITH_DEBUG_RUN = 30,
    XML_WITH_ZLIB = 31,
    XML_WITH_ICU = 32,
    XML_WITH_LZMA = 33,
    XML_WITH_NONE = 99999 /* just to be sure of allocation size */
} xmlFeature;

XMLPUBFUN int XMLCALL
		xmlHasFeature		(xmlFeature feature);

#ifdef __cplusplus
}
#endif
#endif /* __XML_PARSER_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/tree.h
/*
 * Summary: interfaces for tree manipulation
 * Description: this module describes the structures found in an tree resulting
 *              from an XML or HTML parsing, as well as the API provided for
 *              various processing on that tree
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_TREE_H__
#define __XML_TREE_H__

#include <stdio.h>
#include <limits.h>
#include <libxml/xmlversion.h>
#include <libxml/xmlstring.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Some of the basic types pointer to structures:
 */
/* xmlIO.h */
typedef struct _xmlParserInputBuffer xmlParserInputBuffer;
typedef xmlParserInputBuffer *xmlParserInputBufferPtr;

typedef struct _xmlOutputBuffer xmlOutputBuffer;
typedef xmlOutputBuffer *xmlOutputBufferPtr;

/* parser.h */
typedef struct _xmlParserInput xmlParserInput;
typedef xmlParserInput *xmlParserInputPtr;

typedef struct _xmlParserCtxt xmlParserCtxt;
typedef xmlParserCtxt *xmlParserCtxtPtr;

typedef struct _xmlSAXLocator xmlSAXLocator;
typedef xmlSAXLocator *xmlSAXLocatorPtr;

typedef struct _xmlSAXHandler xmlSAXHandler;
typedef xmlSAXHandler *xmlSAXHandlerPtr;

/* entities.h */
typedef struct _xmlEntity xmlEntity;
typedef xmlEntity *xmlEntityPtr;

/**
 * BASE_BUFFER_SIZE:
 *
 * default buffer size 4000.
 */
#define BASE_BUFFER_SIZE 4096

/**
 * LIBXML_NAMESPACE_DICT:
 *
 * Defines experimental behaviour:
 * 1) xmlNs gets an additional field @context (a xmlDoc)
 * 2) when creating a tree, xmlNs->href is stored in the dict of xmlDoc.
 */
/* #define LIBXML_NAMESPACE_DICT */

/**
 * xmlBufferAllocationScheme:
 *
 * A buffer allocation scheme can be defined to either match exactly the
 * need or double it's allocated size each time it is found too small.
 */

typedef enum {
    XML_BUFFER_ALLOC_DOUBLEIT,	/* double each time one need to grow */
    XML_BUFFER_ALLOC_EXACT,	/* grow only to the minimal size */
    XML_BUFFER_ALLOC_IMMUTABLE, /* immutable buffer */
    XML_BUFFER_ALLOC_IO,	/* special allocation scheme used for I/O */
    XML_BUFFER_ALLOC_HYBRID	/* exact up to a threshold, and doubleit thereafter */
} xmlBufferAllocationScheme;

/**
 * xmlBuffer:
 *
 * A buffer structure, this old construct is limited to 2GB and
 * is being deprecated, use API with xmlBuf instead
 */
typedef struct _xmlBuffer xmlBuffer;
typedef xmlBuffer *xmlBufferPtr;
struct _xmlBuffer {
    xmlChar *content;		/* The buffer content UTF8 */
    unsigned int use;		/* The buffer size used */
    unsigned int size;		/* The buffer size */
    xmlBufferAllocationScheme alloc; /* The realloc method */
    xmlChar *contentIO;		/* in IO mode we may have a different base */
};

/**
 * xmlBuf:
 *
 * A buffer structure, new one, the actual structure internals are not public
 */

typedef struct _xmlBuf xmlBuf;

/**
 * xmlBufPtr:
 *
 * A pointer to a buffer structure, the actual structure internals are not
 * public
 */

typedef xmlBuf *xmlBufPtr;

/*
 * A few public routines for xmlBuf. As those are expected to be used
 * mostly internally the bulk of the routines are internal in buf.h
 */
XMLPUBFUN xmlChar* XMLCALL       xmlBufContent	(const xmlBufPtr buf);
XMLPUBFUN xmlChar* XMLCALL       xmlBufEnd      (const xmlBufPtr buf);
XMLPUBFUN size_t XMLCALL         xmlBufUse      (const xmlBufPtr buf);
XMLPUBFUN size_t XMLCALL         xmlBufShrink	(xmlBufPtr buf, size_t len);

/*
 * LIBXML2_NEW_BUFFER:
 *
 * Macro used to express that the API use the new buffers for
 * xmlParserInputBuffer and xmlOutputBuffer. The change was
 * introduced in 2.9.0.
 */
#define LIBXML2_NEW_BUFFER

/**
 * XML_XML_NAMESPACE:
 *
 * This is the namespace for the special xml: prefix predefined in the
 * XML Namespace specification.
 */
#define XML_XML_NAMESPACE \
    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"

/**
 * XML_XML_ID:
 *
 * This is the name for the special xml:id attribute
 */
#define XML_XML_ID (const xmlChar *) "xml:id"

/*
 * The different element types carried by an XML tree.
 *
 * NOTE: This is synchronized with DOM Level1 values
 *       See http://www.w3.org/TR/REC-DOM-Level-1/
 *
 * Actually this had diverged a bit, and now XML_DOCUMENT_TYPE_NODE should
 * be deprecated to use an XML_DTD_NODE.
 */
typedef enum {
    XML_ELEMENT_NODE=		1,
    XML_ATTRIBUTE_NODE=		2,
    XML_TEXT_NODE=		3,
    XML_CDATA_SECTION_NODE=	4,
    XML_ENTITY_REF_NODE=	5,
    XML_ENTITY_NODE=		6,
    XML_PI_NODE=		7,
    XML_COMMENT_NODE=		8,
    XML_DOCUMENT_NODE=		9,
    XML_DOCUMENT_TYPE_NODE=	10,
    XML_DOCUMENT_FRAG_NODE=	11,
    XML_NOTATION_NODE=		12,
    XML_HTML_DOCUMENT_NODE=	13,
    XML_DTD_NODE=		14,
    XML_ELEMENT_DECL=		15,
    XML_ATTRIBUTE_DECL=		16,
    XML_ENTITY_DECL=		17,
    XML_NAMESPACE_DECL=		18,
    XML_XINCLUDE_START=		19,
    XML_XINCLUDE_END=		20
#ifdef LIBXML_DOCB_ENABLED
   ,XML_DOCB_DOCUMENT_NODE=	21
#endif
} xmlElementType;


/**
 * xmlNotation:
 *
 * A DTD Notation definition.
 */

typedef struct _xmlNotation xmlNotation;
typedef xmlNotation *xmlNotationPtr;
struct _xmlNotation {
    const xmlChar               *name;	        /* Notation name */
    const xmlChar               *PublicID;	/* Public identifier, if any */
    const xmlChar               *SystemID;	/* System identifier, if any */
};

/**
 * xmlAttributeType:
 *
 * A DTD Attribute type definition.
 */

typedef enum {
    XML_ATTRIBUTE_CDATA = 1,
    XML_ATTRIBUTE_ID,
    XML_ATTRIBUTE_IDREF	,
    XML_ATTRIBUTE_IDREFS,
    XML_ATTRIBUTE_ENTITY,
    XML_ATTRIBUTE_ENTITIES,
    XML_ATTRIBUTE_NMTOKEN,
    XML_ATTRIBUTE_NMTOKENS,
    XML_ATTRIBUTE_ENUMERATION,
    XML_ATTRIBUTE_NOTATION
} xmlAttributeType;

/**
 * xmlAttributeDefault:
 *
 * A DTD Attribute default definition.
 */

typedef enum {
    XML_ATTRIBUTE_NONE = 1,
    XML_ATTRIBUTE_REQUIRED,
    XML_ATTRIBUTE_IMPLIED,
    XML_ATTRIBUTE_FIXED
} xmlAttributeDefault;

/**
 * xmlEnumeration:
 *
 * List structure used when there is an enumeration in DTDs.
 */

typedef struct _xmlEnumeration xmlEnumeration;
typedef xmlEnumeration *xmlEnumerationPtr;
struct _xmlEnumeration {
    struct _xmlEnumeration    *next;	/* next one */
    const xmlChar            *name;	/* Enumeration name */
};

/**
 * xmlAttribute:
 *
 * An Attribute declaration in a DTD.
 */

typedef struct _xmlAttribute xmlAttribute;
typedef xmlAttribute *xmlAttributePtr;
struct _xmlAttribute {
    void           *_private;	        /* application data */
    xmlElementType          type;       /* XML_ATTRIBUTE_DECL, must be second ! */
    const xmlChar          *name;	/* Attribute name */
    struct _xmlNode    *children;	/* NULL */
    struct _xmlNode        *last;	/* NULL */
    struct _xmlDtd       *parent;	/* -> DTD */
    struct _xmlNode        *next;	/* next sibling link  */
    struct _xmlNode        *prev;	/* previous sibling link  */
    struct _xmlDoc          *doc;       /* the containing document */

    struct _xmlAttribute  *nexth;	/* next in hash table */
    xmlAttributeType       atype;	/* The attribute type */
    xmlAttributeDefault      def;	/* the default */
    const xmlChar  *defaultValue;	/* or the default value */
    xmlEnumerationPtr       tree;       /* or the enumeration tree if any */
    const xmlChar        *prefix;	/* the namespace prefix if any */
    const xmlChar          *elem;	/* Element holding the attribute */
};

/**
 * xmlElementContentType:
 *
 * Possible definitions of element content types.
 */
typedef enum {
    XML_ELEMENT_CONTENT_PCDATA = 1,
    XML_ELEMENT_CONTENT_ELEMENT,
    XML_ELEMENT_CONTENT_SEQ,
    XML_ELEMENT_CONTENT_OR
} xmlElementContentType;

/**
 * xmlElementContentOccur:
 *
 * Possible definitions of element content occurrences.
 */
typedef enum {
    XML_ELEMENT_CONTENT_ONCE = 1,
    XML_ELEMENT_CONTENT_OPT,
    XML_ELEMENT_CONTENT_MULT,
    XML_ELEMENT_CONTENT_PLUS
} xmlElementContentOccur;

/**
 * xmlElementContent:
 *
 * An XML Element content as stored after parsing an element definition
 * in a DTD.
 */

typedef struct _xmlElementContent xmlElementContent;
typedef xmlElementContent *xmlElementContentPtr;
struct _xmlElementContent {
    xmlElementContentType     type;	/* PCDATA, ELEMENT, SEQ or OR */
    xmlElementContentOccur    ocur;	/* ONCE, OPT, MULT or PLUS */
    const xmlChar             *name;	/* Element name */
    struct _xmlElementContent *c1;	/* first child */
    struct _xmlElementContent *c2;	/* second child */
    struct _xmlElementContent *parent;	/* parent */
    const xmlChar             *prefix;	/* Namespace prefix */
};

/**
 * xmlElementTypeVal:
 *
 * The different possibilities for an element content type.
 */

typedef enum {
    XML_ELEMENT_TYPE_UNDEFINED = 0,
    XML_ELEMENT_TYPE_EMPTY = 1,
    XML_ELEMENT_TYPE_ANY,
    XML_ELEMENT_TYPE_MIXED,
    XML_ELEMENT_TYPE_ELEMENT
} xmlElementTypeVal;

#ifdef __cplusplus
}
#endif
#include <libxml/xmlregexp.h>
#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlElement:
 *
 * An XML Element declaration from a DTD.
 */

typedef struct _xmlElement xmlElement;
typedef xmlElement *xmlElementPtr;
struct _xmlElement {
    void           *_private;	        /* application data */
    xmlElementType          type;       /* XML_ELEMENT_DECL, must be second ! */
    const xmlChar          *name;	/* Element name */
    struct _xmlNode    *children;	/* NULL */
    struct _xmlNode        *last;	/* NULL */
    struct _xmlDtd       *parent;	/* -> DTD */
    struct _xmlNode        *next;	/* next sibling link  */
    struct _xmlNode        *prev;	/* previous sibling link  */
    struct _xmlDoc          *doc;       /* the containing document */

    xmlElementTypeVal      etype;	/* The type */
    xmlElementContentPtr content;	/* the allowed element content */
    xmlAttributePtr   attributes;	/* List of the declared attributes */
    const xmlChar        *prefix;	/* the namespace prefix if any */
#ifdef LIBXML_REGEXP_ENABLED
    xmlRegexpPtr       contModel;	/* the validating regexp */
#else
    void	      *contModel;
#endif
};


/**
 * XML_LOCAL_NAMESPACE:
 *
 * A namespace declaration node.
 */
#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
typedef xmlElementType xmlNsType;

/**
 * xmlNs:
 *
 * An XML namespace.
 * Note that prefix == NULL is valid, it defines the default namespace
 * within the subtree (until overridden).
 *
 * xmlNsType is unified with xmlElementType.
 */

typedef struct _xmlNs xmlNs;
typedef xmlNs *xmlNsPtr;
struct _xmlNs {
    struct _xmlNs  *next;	/* next Ns link for this node  */
    xmlNsType      type;	/* global or local */
    const xmlChar *href;	/* URL for the namespace */
    const xmlChar *prefix;	/* prefix for the namespace */
    void           *_private;   /* application data */
    struct _xmlDoc *context;		/* normally an xmlDoc */
};

/**
 * xmlDtd:
 *
 * An XML DTD, as defined by <!DOCTYPE ... There is actually one for
 * the internal subset and for the external subset.
 */
typedef struct _xmlDtd xmlDtd;
typedef xmlDtd *xmlDtdPtr;
struct _xmlDtd {
    void           *_private;	/* application data */
    xmlElementType  type;       /* XML_DTD_NODE, must be second ! */
    const xmlChar *name;	/* Name of the DTD */
    struct _xmlNode *children;	/* the value of the property link */
    struct _xmlNode *last;	/* last child link */
    struct _xmlDoc  *parent;	/* child->parent link */
    struct _xmlNode *next;	/* next sibling link  */
    struct _xmlNode *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* the containing document */

    /* End of common part */
    void          *notations;   /* Hash table for notations if any */
    void          *elements;    /* Hash table for elements if any */
    void          *attributes;  /* Hash table for attributes if any */
    void          *entities;    /* Hash table for entities if any */
    const xmlChar *ExternalID;	/* External identifier for PUBLIC DTD */
    const xmlChar *SystemID;	/* URI for a SYSTEM or PUBLIC DTD */
    void          *pentities;   /* Hash table for param entities if any */
};

/**
 * xmlAttr:
 *
 * An attribute on an XML node.
 */
typedef struct _xmlAttr xmlAttr;
typedef xmlAttr *xmlAttrPtr;
struct _xmlAttr {
    void           *_private;	/* application data */
    xmlElementType   type;      /* XML_ATTRIBUTE_NODE, must be second ! */
    const xmlChar   *name;      /* the name of the property */
    struct _xmlNode *children;	/* the value of the property */
    struct _xmlNode *last;	/* NULL */
    struct _xmlNode *parent;	/* child->parent link */
    struct _xmlAttr *next;	/* next sibling link  */
    struct _xmlAttr *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* the containing document */
    xmlNs           *ns;        /* pointer to the associated namespace */
    xmlAttributeType atype;     /* the attribute type if validating */
    void            *psvi;	/* for type/PSVI informations */
};

/**
 * xmlID:
 *
 * An XML ID instance.
 */

typedef struct _xmlID xmlID;
typedef xmlID *xmlIDPtr;
struct _xmlID {
    struct _xmlID    *next;	/* next ID */
    const xmlChar    *value;	/* The ID name */
    xmlAttrPtr        attr;	/* The attribute holding it */
    const xmlChar    *name;	/* The attribute if attr is not available */
    int               lineno;	/* The line number if attr is not available */
    struct _xmlDoc   *doc;	/* The document holding the ID */
};

/**
 * xmlRef:
 *
 * An XML IDREF instance.
 */

typedef struct _xmlRef xmlRef;
typedef xmlRef *xmlRefPtr;
struct _xmlRef {
    struct _xmlRef    *next;	/* next Ref */
    const xmlChar     *value;	/* The Ref name */
    xmlAttrPtr        attr;	/* The attribute holding it */
    const xmlChar    *name;	/* The attribute if attr is not available */
    int               lineno;	/* The line number if attr is not available */
};

/**
 * xmlNode:
 *
 * A node in an XML tree.
 */
typedef struct _xmlNode xmlNode;
typedef xmlNode *xmlNodePtr;
struct _xmlNode {
    void           *_private;	/* application data */
    xmlElementType   type;	/* type number, must be second ! */
    const xmlChar   *name;      /* the name of the node, or the entity */
    struct _xmlNode *children;	/* parent->childs link */
    struct _xmlNode *last;	/* last child link */
    struct _xmlNode *parent;	/* child->parent link */
    struct _xmlNode *next;	/* next sibling link  */
    struct _xmlNode *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* the containing document */

    /* End of common part */
    xmlNs           *ns;        /* pointer to the associated namespace */
    xmlChar         *content;   /* the content */
    struct _xmlAttr *properties;/* properties list */
    xmlNs           *nsDef;     /* namespace definitions on this node */
    void            *psvi;	/* for type/PSVI informations */
    unsigned short   line;	/* line number */
    unsigned short   extra;	/* extra data for XPath/XSLT */
};

/**
 * XML_GET_CONTENT:
 *
 * Macro to extract the content pointer of a node.
 */
#define XML_GET_CONTENT(n)					\
    ((n)->type == XML_ELEMENT_NODE ? NULL : (n)->content)

/**
 * XML_GET_LINE:
 *
 * Macro to extract the line number of an element node.
 */
#define XML_GET_LINE(n)						\
    (xmlGetLineNo(n))

/**
 * xmlDocProperty
 *
 * Set of properties of the document as found by the parser
 * Some of them are linked to similary named xmlParserOption
 */
typedef enum {
    XML_DOC_WELLFORMED		= 1<<0, /* document is XML well formed */
    XML_DOC_NSVALID		= 1<<1, /* document is Namespace valid */
    XML_DOC_OLD10		= 1<<2, /* parsed with old XML-1.0 parser */
    XML_DOC_DTDVALID		= 1<<3, /* DTD validation was successful */
    XML_DOC_XINCLUDE		= 1<<4, /* XInclude substitution was done */
    XML_DOC_USERBUILT		= 1<<5, /* Document was built using the API
                                           and not by parsing an instance */
    XML_DOC_INTERNAL		= 1<<6, /* built for internal processing */
    XML_DOC_HTML		= 1<<7  /* parsed or built HTML document */
} xmlDocProperties;

/**
 * xmlDoc:
 *
 * An XML document.
 */
typedef struct _xmlDoc xmlDoc;
typedef xmlDoc *xmlDocPtr;
struct _xmlDoc {
    void           *_private;	/* application data */
    xmlElementType  type;       /* XML_DOCUMENT_NODE, must be second ! */
    char           *name;	/* name/filename/URI of the document */
    struct _xmlNode *children;	/* the document tree */
    struct _xmlNode *last;	/* last child link */
    struct _xmlNode *parent;	/* child->parent link */
    struct _xmlNode *next;	/* next sibling link  */
    struct _xmlNode *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* autoreference to itself */

    /* End of common part */
    int             compression;/* level of zlib compression */
    int             standalone; /* standalone document (no external refs)
				     1 if standalone="yes"
				     0 if standalone="no"
				    -1 if there is no XML declaration
				    -2 if there is an XML declaration, but no
					standalone attribute was specified */
    struct _xmlDtd  *intSubset;	/* the document internal subset */
    struct _xmlDtd  *extSubset;	/* the document external subset */
    struct _xmlNs   *oldNs;	/* Global namespace, the old way */
    const xmlChar  *version;	/* the XML version string */
    const xmlChar  *encoding;   /* external initial encoding, if any */
    void           *ids;        /* Hash table for ID attributes if any */
    void           *refs;       /* Hash table for IDREFs attributes if any */
    const xmlChar  *URL;	/* The URI for that document */
    int             charset;    /* encoding of the in-memory content
				   actually an xmlCharEncoding */
    struct _xmlDict *dict;      /* dict used to allocate names or NULL */
    void           *psvi;	/* for type/PSVI informations */
    int             parseFlags;	/* set of xmlParserOption used to parse the
				   document */
    int             properties;	/* set of xmlDocProperties for this document
				   set at the end of parsing */
};


typedef struct _xmlDOMWrapCtxt xmlDOMWrapCtxt;
typedef xmlDOMWrapCtxt *xmlDOMWrapCtxtPtr;

/**
 * xmlDOMWrapAcquireNsFunction:
 * @ctxt:  a DOM wrapper context
 * @node:  the context node (element or attribute)
 * @nsName:  the requested namespace name
 * @nsPrefix:  the requested namespace prefix
 *
 * A function called to acquire namespaces (xmlNs) from the wrapper.
 *
 * Returns an xmlNsPtr or NULL in case of an error.
 */
typedef xmlNsPtr (*xmlDOMWrapAcquireNsFunction) (xmlDOMWrapCtxtPtr ctxt,
						 xmlNodePtr node,
						 const xmlChar *nsName,
						 const xmlChar *nsPrefix);

/**
 * xmlDOMWrapCtxt:
 *
 * Context for DOM wrapper-operations.
 */
struct _xmlDOMWrapCtxt {
    void * _private;
    /*
    * The type of this context, just in case we need specialized
    * contexts in the future.
    */
    int type;
    /*
    * Internal namespace map used for various operations.
    */
    void * namespaceMap;
    /*
    * Use this one to acquire an xmlNsPtr intended for node->ns.
    * (Note that this is not intended for elem->nsDef).
    */
    xmlDOMWrapAcquireNsFunction getNsForNodeFunc;
};

/**
 * xmlChildrenNode:
 *
 * Macro for compatibility naming layer with libxml1. Maps
 * to "children."
 */
#ifndef xmlChildrenNode
#define xmlChildrenNode children
#endif

/**
 * xmlRootNode:
 *
 * Macro for compatibility naming layer with libxml1. Maps
 * to "children".
 */
#ifndef xmlRootNode
#define xmlRootNode children
#endif

/*
 * Variables.
 */

/*
 * Some helper functions
 */
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_DEBUG_ENABLED) || defined (LIBXML_HTML_ENABLED) || defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED)
XMLPUBFUN int XMLCALL
		xmlValidateNCName	(const xmlChar *value,
					 int space);
#endif

#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
XMLPUBFUN int XMLCALL
		xmlValidateQName	(const xmlChar *value,
					 int space);
XMLPUBFUN int XMLCALL
		xmlValidateName		(const xmlChar *value,
					 int space);
XMLPUBFUN int XMLCALL
		xmlValidateNMToken	(const xmlChar *value,
					 int space);
#endif

XMLPUBFUN xmlChar * XMLCALL
		xmlBuildQName		(const xmlChar *ncname,
					 const xmlChar *prefix,
					 xmlChar *memory,
					 int len);
XMLPUBFUN xmlChar * XMLCALL
		xmlSplitQName2		(const xmlChar *name,
					 xmlChar **prefix);
XMLPUBFUN const xmlChar * XMLCALL
		xmlSplitQName3		(const xmlChar *name,
					 int *len);

/*
 * Handling Buffers, the old ones see @xmlBuf for the new ones.
 */

XMLPUBFUN void XMLCALL
		xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme);
XMLPUBFUN xmlBufferAllocationScheme XMLCALL
		xmlGetBufferAllocationScheme(void);

XMLPUBFUN xmlBufferPtr XMLCALL
		xmlBufferCreate		(void);
XMLPUBFUN xmlBufferPtr XMLCALL
		xmlBufferCreateSize	(size_t size);
XMLPUBFUN xmlBufferPtr XMLCALL
		xmlBufferCreateStatic	(void *mem,
					 size_t size);
XMLPUBFUN int XMLCALL
		xmlBufferResize		(xmlBufferPtr buf,
					 unsigned int size);
XMLPUBFUN void XMLCALL
		xmlBufferFree		(xmlBufferPtr buf);
XMLPUBFUN int XMLCALL
		xmlBufferDump		(FILE *file,
					 xmlBufferPtr buf);
XMLPUBFUN int XMLCALL
		xmlBufferAdd		(xmlBufferPtr buf,
					 const xmlChar *str,
					 int len);
XMLPUBFUN int XMLCALL
		xmlBufferAddHead	(xmlBufferPtr buf,
					 const xmlChar *str,
					 int len);
XMLPUBFUN int XMLCALL
		xmlBufferCat		(xmlBufferPtr buf,
					 const xmlChar *str);
XMLPUBFUN int XMLCALL
		xmlBufferCCat		(xmlBufferPtr buf,
					 const char *str);
XMLPUBFUN int XMLCALL
		xmlBufferShrink		(xmlBufferPtr buf,
					 unsigned int len);
XMLPUBFUN int XMLCALL
		xmlBufferGrow		(xmlBufferPtr buf,
					 unsigned int len);
XMLPUBFUN void XMLCALL
		xmlBufferEmpty		(xmlBufferPtr buf);
XMLPUBFUN const xmlChar* XMLCALL
		xmlBufferContent	(const xmlBufferPtr buf);
XMLPUBFUN xmlChar* XMLCALL
		xmlBufferDetach         (xmlBufferPtr buf);
XMLPUBFUN void XMLCALL
		xmlBufferSetAllocationScheme(xmlBufferPtr buf,
					 xmlBufferAllocationScheme scheme);
XMLPUBFUN int XMLCALL
		xmlBufferLength		(const xmlBufferPtr buf);

/*
 * Creating/freeing new structures.
 */
XMLPUBFUN xmlDtdPtr XMLCALL
		xmlCreateIntSubset	(xmlDocPtr doc,
					 const xmlChar *name,
					 const xmlChar *ExternalID,
					 const xmlChar *SystemID);
XMLPUBFUN xmlDtdPtr XMLCALL
		xmlNewDtd		(xmlDocPtr doc,
					 const xmlChar *name,
					 const xmlChar *ExternalID,
					 const xmlChar *SystemID);
XMLPUBFUN xmlDtdPtr XMLCALL
		xmlGetIntSubset		(xmlDocPtr doc);
XMLPUBFUN void XMLCALL
		xmlFreeDtd		(xmlDtdPtr cur);
#ifdef LIBXML_LEGACY_ENABLED
XMLPUBFUN xmlNsPtr XMLCALL
		xmlNewGlobalNs		(xmlDocPtr doc,
					 const xmlChar *href,
					 const xmlChar *prefix);
#endif /* LIBXML_LEGACY_ENABLED */
XMLPUBFUN xmlNsPtr XMLCALL
		xmlNewNs		(xmlNodePtr node,
					 const xmlChar *href,
					 const xmlChar *prefix);
XMLPUBFUN void XMLCALL
		xmlFreeNs		(xmlNsPtr cur);
XMLPUBFUN void XMLCALL
		xmlFreeNsList		(xmlNsPtr cur);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlNewDoc		(const xmlChar *version);
XMLPUBFUN void XMLCALL
		xmlFreeDoc		(xmlDocPtr cur);
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlNewDocProp		(xmlDocPtr doc,
					 const xmlChar *name,
					 const xmlChar *value);
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
    defined(LIBXML_SCHEMAS_ENABLED)
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlNewProp		(xmlNodePtr node,
					 const xmlChar *name,
					 const xmlChar *value);
#endif
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlNewNsProp		(xmlNodePtr node,
					 xmlNsPtr ns,
					 const xmlChar *name,
					 const xmlChar *value);
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlNewNsPropEatName	(xmlNodePtr node,
					 xmlNsPtr ns,
					 xmlChar *name,
					 const xmlChar *value);
XMLPUBFUN void XMLCALL
		xmlFreePropList		(xmlAttrPtr cur);
XMLPUBFUN void XMLCALL
		xmlFreeProp		(xmlAttrPtr cur);
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlCopyProp		(xmlNodePtr target,
					 xmlAttrPtr cur);
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlCopyPropList		(xmlNodePtr target,
					 xmlAttrPtr cur);
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN xmlDtdPtr XMLCALL
		xmlCopyDtd		(xmlDtdPtr dtd);
#endif /* LIBXML_TREE_ENABLED */
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
XMLPUBFUN xmlDocPtr XMLCALL
		xmlCopyDoc		(xmlDocPtr doc,
					 int recursive);
#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/*
 * Creating new nodes.
 */
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewDocNode		(xmlDocPtr doc,
					 xmlNsPtr ns,
					 const xmlChar *name,
					 const xmlChar *content);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewDocNodeEatName	(xmlDocPtr doc,
					 xmlNsPtr ns,
					 xmlChar *name,
					 const xmlChar *content);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewNode		(xmlNsPtr ns,
					 const xmlChar *name);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewNodeEatName	(xmlNsPtr ns,
					 xmlChar *name);
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewChild		(xmlNodePtr parent,
					 xmlNsPtr ns,
					 const xmlChar *name,
					 const xmlChar *content);
#endif
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewDocText		(xmlDocPtr doc,
					 const xmlChar *content);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewText		(const xmlChar *content);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewDocPI		(xmlDocPtr doc,
					 const xmlChar *name,
					 const xmlChar *content);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewPI		(const xmlChar *name,
					 const xmlChar *content);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewDocTextLen	(xmlDocPtr doc,
					 const xmlChar *content,
					 int len);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewTextLen		(const xmlChar *content,
					 int len);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewDocComment	(xmlDocPtr doc,
					 const xmlChar *content);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewComment		(const xmlChar *content);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewCDataBlock	(xmlDocPtr doc,
					 const xmlChar *content,
					 int len);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewCharRef		(xmlDocPtr doc,
					 const xmlChar *name);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewReference		(xmlDocPtr doc,
					 const xmlChar *name);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlCopyNode		(const xmlNodePtr node,
					 int recursive);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlDocCopyNode		(const xmlNodePtr node,
					 xmlDocPtr doc,
					 int recursive);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlDocCopyNodeList	(xmlDocPtr doc,
					 const xmlNodePtr node);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlCopyNodeList		(const xmlNodePtr node);
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewTextChild		(xmlNodePtr parent,
					 xmlNsPtr ns,
					 const xmlChar *name,
					 const xmlChar *content);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewDocRawNode	(xmlDocPtr doc,
					 xmlNsPtr ns,
					 const xmlChar *name,
					 const xmlChar *content);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlNewDocFragment	(xmlDocPtr doc);
#endif /* LIBXML_TREE_ENABLED */

/*
 * Navigating.
 */
XMLPUBFUN long XMLCALL
		xmlGetLineNo		(xmlNodePtr node);
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)
XMLPUBFUN xmlChar * XMLCALL
		xmlGetNodePath		(xmlNodePtr node);
#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */
XMLPUBFUN xmlNodePtr XMLCALL
		xmlDocGetRootElement	(xmlDocPtr doc);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlGetLastChild		(xmlNodePtr parent);
XMLPUBFUN int XMLCALL
		xmlNodeIsText		(xmlNodePtr node);
XMLPUBFUN int XMLCALL
		xmlIsBlankNode		(xmlNodePtr node);

/*
 * Changing the structure.
 */
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
XMLPUBFUN xmlNodePtr XMLCALL
		xmlDocSetRootElement	(xmlDocPtr doc,
					 xmlNodePtr root);
#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN void XMLCALL
		xmlNodeSetName		(xmlNodePtr cur,
					 const xmlChar *name);
#endif /* LIBXML_TREE_ENABLED */
XMLPUBFUN xmlNodePtr XMLCALL
		xmlAddChild		(xmlNodePtr parent,
					 xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlAddChildList		(xmlNodePtr parent,
					 xmlNodePtr cur);
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
XMLPUBFUN xmlNodePtr XMLCALL
		xmlReplaceNode		(xmlNodePtr old,
					 xmlNodePtr cur);
#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
    defined(LIBXML_SCHEMAS_ENABLED)
XMLPUBFUN xmlNodePtr XMLCALL
		xmlAddPrevSibling	(xmlNodePtr cur,
					 xmlNodePtr elem);
#endif /* LIBXML_TREE_ENABLED || LIBXML_HTML_ENABLED || LIBXML_SCHEMAS_ENABLED */
XMLPUBFUN xmlNodePtr XMLCALL
		xmlAddSibling		(xmlNodePtr cur,
					 xmlNodePtr elem);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlAddNextSibling	(xmlNodePtr cur,
					 xmlNodePtr elem);
XMLPUBFUN void XMLCALL
		xmlUnlinkNode		(xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlTextMerge		(xmlNodePtr first,
					 xmlNodePtr second);
XMLPUBFUN int XMLCALL
		xmlTextConcat		(xmlNodePtr node,
					 const xmlChar *content,
					 int len);
XMLPUBFUN void XMLCALL
		xmlFreeNodeList		(xmlNodePtr cur);
XMLPUBFUN void XMLCALL
		xmlFreeNode		(xmlNodePtr cur);
XMLPUBFUN void XMLCALL
		xmlSetTreeDoc		(xmlNodePtr tree,
					 xmlDocPtr doc);
XMLPUBFUN void XMLCALL
		xmlSetListDoc		(xmlNodePtr list,
					 xmlDocPtr doc);
/*
 * Namespaces.
 */
XMLPUBFUN xmlNsPtr XMLCALL
		xmlSearchNs		(xmlDocPtr doc,
					 xmlNodePtr node,
					 const xmlChar *nameSpace);
XMLPUBFUN xmlNsPtr XMLCALL
		xmlSearchNsByHref	(xmlDocPtr doc,
					 xmlNodePtr node,
					 const xmlChar *href);
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
XMLPUBFUN xmlNsPtr * XMLCALL
		xmlGetNsList		(xmlDocPtr doc,
					 xmlNodePtr node);
#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) */

XMLPUBFUN void XMLCALL
		xmlSetNs		(xmlNodePtr node,
					 xmlNsPtr ns);
XMLPUBFUN xmlNsPtr XMLCALL
		xmlCopyNamespace	(xmlNsPtr cur);
XMLPUBFUN xmlNsPtr XMLCALL
		xmlCopyNamespaceList	(xmlNsPtr cur);

/*
 * Changing the content.
 */
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlSetProp		(xmlNodePtr node,
					 const xmlChar *name,
					 const xmlChar *value);
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlSetNsProp		(xmlNodePtr node,
					 xmlNsPtr ns,
					 const xmlChar *name,
					 const xmlChar *value);
#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
XMLPUBFUN xmlChar * XMLCALL
		xmlGetNoNsProp		(xmlNodePtr node,
					 const xmlChar *name);
XMLPUBFUN xmlChar * XMLCALL
		xmlGetProp		(xmlNodePtr node,
					 const xmlChar *name);
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlHasProp		(xmlNodePtr node,
					 const xmlChar *name);
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlHasNsProp		(xmlNodePtr node,
					 const xmlChar *name,
					 const xmlChar *nameSpace);
XMLPUBFUN xmlChar * XMLCALL
		xmlGetNsProp		(xmlNodePtr node,
					 const xmlChar *name,
					 const xmlChar *nameSpace);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlStringGetNodeList	(xmlDocPtr doc,
					 const xmlChar *value);
XMLPUBFUN xmlNodePtr XMLCALL
		xmlStringLenGetNodeList	(xmlDocPtr doc,
					 const xmlChar *value,
					 int len);
XMLPUBFUN xmlChar * XMLCALL
		xmlNodeListGetString	(xmlDocPtr doc,
					 xmlNodePtr list,
					 int inLine);
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN xmlChar * XMLCALL
		xmlNodeListGetRawString	(xmlDocPtr doc,
					 xmlNodePtr list,
					 int inLine);
#endif /* LIBXML_TREE_ENABLED */
XMLPUBFUN void XMLCALL
		xmlNodeSetContent	(xmlNodePtr cur,
					 const xmlChar *content);
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN void XMLCALL
		xmlNodeSetContentLen	(xmlNodePtr cur,
					 const xmlChar *content,
					 int len);
#endif /* LIBXML_TREE_ENABLED */
XMLPUBFUN void XMLCALL
		xmlNodeAddContent	(xmlNodePtr cur,
					 const xmlChar *content);
XMLPUBFUN void XMLCALL
		xmlNodeAddContentLen	(xmlNodePtr cur,
					 const xmlChar *content,
					 int len);
XMLPUBFUN xmlChar * XMLCALL
		xmlNodeGetContent	(xmlNodePtr cur);

XMLPUBFUN int XMLCALL
		xmlNodeBufGetContent	(xmlBufferPtr buffer,
					 xmlNodePtr cur);
XMLPUBFUN int XMLCALL
		xmlBufGetNodeContent	(xmlBufPtr buf,
					 xmlNodePtr cur);

XMLPUBFUN xmlChar * XMLCALL
		xmlNodeGetLang		(xmlNodePtr cur);
XMLPUBFUN int XMLCALL
		xmlNodeGetSpacePreserve	(xmlNodePtr cur);
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN void XMLCALL
		xmlNodeSetLang		(xmlNodePtr cur,
					 const xmlChar *lang);
XMLPUBFUN void XMLCALL
		xmlNodeSetSpacePreserve (xmlNodePtr cur,
					 int val);
#endif /* LIBXML_TREE_ENABLED */
XMLPUBFUN xmlChar * XMLCALL
		xmlNodeGetBase		(xmlDocPtr doc,
					 xmlNodePtr cur);
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
XMLPUBFUN void XMLCALL
		xmlNodeSetBase		(xmlNodePtr cur,
					 const xmlChar *uri);
#endif

/*
 * Removing content.
 */
XMLPUBFUN int XMLCALL
		xmlRemoveProp		(xmlAttrPtr cur);
#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
XMLPUBFUN int XMLCALL
		xmlUnsetNsProp		(xmlNodePtr node,
					 xmlNsPtr ns,
					 const xmlChar *name);
XMLPUBFUN int XMLCALL
		xmlUnsetProp		(xmlNodePtr node,
					 const xmlChar *name);
#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */

/*
 * Internal, don't use.
 */
XMLPUBFUN void XMLCALL
		xmlBufferWriteCHAR	(xmlBufferPtr buf,
					 const xmlChar *string);
XMLPUBFUN void XMLCALL
		xmlBufferWriteChar	(xmlBufferPtr buf,
					 const char *string);
XMLPUBFUN void XMLCALL
		xmlBufferWriteQuotedString(xmlBufferPtr buf,
					 const xmlChar *string);

#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void xmlAttrSerializeTxtContent(xmlBufferPtr buf,
					 xmlDocPtr doc,
					 xmlAttrPtr attr,
					 const xmlChar *string);
#endif /* LIBXML_OUTPUT_ENABLED */

#ifdef LIBXML_TREE_ENABLED
/*
 * Namespace handling.
 */
XMLPUBFUN int XMLCALL
		xmlReconciliateNs	(xmlDocPtr doc,
					 xmlNodePtr tree);
#endif

#ifdef LIBXML_OUTPUT_ENABLED
/*
 * Saving.
 */
XMLPUBFUN void XMLCALL
		xmlDocDumpFormatMemory	(xmlDocPtr cur,
					 xmlChar **mem,
					 int *size,
					 int format);
XMLPUBFUN void XMLCALL
		xmlDocDumpMemory	(xmlDocPtr cur,
					 xmlChar **mem,
					 int *size);
XMLPUBFUN void XMLCALL
		xmlDocDumpMemoryEnc	(xmlDocPtr out_doc,
					 xmlChar **doc_txt_ptr,
					 int * doc_txt_len,
					 const char *txt_encoding);
XMLPUBFUN void XMLCALL
		xmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc,
					 xmlChar **doc_txt_ptr,
					 int * doc_txt_len,
					 const char *txt_encoding,
					 int format);
XMLPUBFUN int XMLCALL
		xmlDocFormatDump	(FILE *f,
					 xmlDocPtr cur,
					 int format);
XMLPUBFUN int XMLCALL
		xmlDocDump		(FILE *f,
					 xmlDocPtr cur);
XMLPUBFUN void XMLCALL
		xmlElemDump		(FILE *f,
					 xmlDocPtr doc,
					 xmlNodePtr cur);
XMLPUBFUN int XMLCALL
		xmlSaveFile		(const char *filename,
					 xmlDocPtr cur);
XMLPUBFUN int XMLCALL
		xmlSaveFormatFile	(const char *filename,
					 xmlDocPtr cur,
					 int format);
XMLPUBFUN size_t XMLCALL
		xmlBufNodeDump		(xmlBufPtr buf,
					 xmlDocPtr doc,
					 xmlNodePtr cur,
					 int level,
					 int format);
XMLPUBFUN int XMLCALL
		xmlNodeDump		(xmlBufferPtr buf,
					 xmlDocPtr doc,
					 xmlNodePtr cur,
					 int level,
					 int format);

XMLPUBFUN int XMLCALL
		xmlSaveFileTo		(xmlOutputBufferPtr buf,
					 xmlDocPtr cur,
					 const char *encoding);
XMLPUBFUN int XMLCALL
		xmlSaveFormatFileTo     (xmlOutputBufferPtr buf,
					 xmlDocPtr cur,
				         const char *encoding,
				         int format);
XMLPUBFUN void XMLCALL
		xmlNodeDumpOutput	(xmlOutputBufferPtr buf,
					 xmlDocPtr doc,
					 xmlNodePtr cur,
					 int level,
					 int format,
					 const char *encoding);

XMLPUBFUN int XMLCALL
		xmlSaveFormatFileEnc    (const char *filename,
					 xmlDocPtr cur,
					 const char *encoding,
					 int format);

XMLPUBFUN int XMLCALL
		xmlSaveFileEnc		(const char *filename,
					 xmlDocPtr cur,
					 const char *encoding);

#endif /* LIBXML_OUTPUT_ENABLED */
/*
 * XHTML
 */
XMLPUBFUN int XMLCALL
		xmlIsXHTML		(const xmlChar *systemID,
					 const xmlChar *publicID);

/*
 * Compression.
 */
XMLPUBFUN int XMLCALL
		xmlGetDocCompressMode	(xmlDocPtr doc);
XMLPUBFUN void XMLCALL
		xmlSetDocCompressMode	(xmlDocPtr doc,
					 int mode);
XMLPUBFUN int XMLCALL
		xmlGetCompressMode	(void);
XMLPUBFUN void XMLCALL
		xmlSetCompressMode	(int mode);

/*
* DOM-wrapper helper functions.
*/
XMLPUBFUN xmlDOMWrapCtxtPtr XMLCALL
		xmlDOMWrapNewCtxt	(void);
XMLPUBFUN void XMLCALL
		xmlDOMWrapFreeCtxt	(xmlDOMWrapCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
	    xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt,
					 xmlNodePtr elem,
					 int options);
XMLPUBFUN int XMLCALL
	    xmlDOMWrapAdoptNode		(xmlDOMWrapCtxtPtr ctxt,
					 xmlDocPtr sourceDoc,
					 xmlNodePtr node,
					 xmlDocPtr destDoc,
					 xmlNodePtr destParent,
					 int options);
XMLPUBFUN int XMLCALL
	    xmlDOMWrapRemoveNode	(xmlDOMWrapCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlNodePtr node,
					 int options);
XMLPUBFUN int XMLCALL
	    xmlDOMWrapCloneNode		(xmlDOMWrapCtxtPtr ctxt,
					 xmlDocPtr sourceDoc,
					 xmlNodePtr node,
					 xmlNodePtr *clonedNode,
					 xmlDocPtr destDoc,
					 xmlNodePtr destParent,
					 int deep,
					 int options);

#ifdef LIBXML_TREE_ENABLED
/*
 * 5 interfaces from DOM ElementTraversal, but different in entities
 * traversal.
 */
XMLPUBFUN unsigned long XMLCALL
            xmlChildElementCount        (xmlNodePtr parent);
XMLPUBFUN xmlNodePtr XMLCALL
            xmlNextElementSibling       (xmlNodePtr node);
XMLPUBFUN xmlNodePtr XMLCALL
            xmlFirstElementChild        (xmlNodePtr parent);
XMLPUBFUN xmlNodePtr XMLCALL
            xmlLastElementChild         (xmlNodePtr parent);
XMLPUBFUN xmlNodePtr XMLCALL
            xmlPreviousElementSibling   (xmlNodePtr node);
#endif
#ifdef __cplusplus
}
#endif
#ifndef __XML_PARSER_H__
#include <libxml/xmlmemory.h>
#endif

#endif /* __XML_TREE_H__ */

**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlexports.h
/*
 * Summary: macros for marking symbols as exportable/importable.
 * Description: macros for marking symbols as exportable/importable.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Igor Zlatovic <igor@zlatkovic.com>
 */

#ifndef __XML_EXPORTS_H__
#define __XML_EXPORTS_H__

/**
 * XMLPUBFUN, XMLPUBVAR, XMLCALL
 *
 * Macros which declare an exportable function, an exportable variable and
 * the calling convention used for functions.
 *
 * Please use an extra block for every platform/compiler combination when
 * modifying this, rather than overlong #ifdef lines. This helps
 * readability as well as the fact that different compilers on the same
 * platform might need different definitions.
 */

/**
 * XMLPUBFUN:
 *
 * Macros which declare an exportable function
 */
#define XMLPUBFUN
/**
 * XMLPUBVAR:
 *
 * Macros which declare an exportable variable
 */
#define XMLPUBVAR extern
/**
 * XMLCALL:
 *
 * Macros which declare the called convention for exported functions
 */
#define XMLCALL
/**
 * XMLCDECL:
 *
 * Macro which declares the calling convention for exported functions that
 * use '...'.
 */
#define XMLCDECL

/** DOC_DISABLE */

/* Windows platform with MS compiler */
#if defined(_WIN32) && defined(_MSC_VER)
  #undef XMLPUBFUN
  #undef XMLPUBVAR
  #undef XMLCALL
  #undef XMLCDECL
  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
    #define XMLPUBFUN __declspec(dllexport)
    #define XMLPUBVAR __declspec(dllexport)
  #else
    #define XMLPUBFUN
    #if !defined(LIBXML_STATIC)
      #define XMLPUBVAR __declspec(dllimport) extern
    #else
      #define XMLPUBVAR extern
    #endif
  #endif
  #if defined(LIBXML_FASTCALL)
    #define XMLCALL __fastcall
  #else
    #define XMLCALL __cdecl
  #endif
  #define XMLCDECL __cdecl
  #if !defined _REENTRANT
    #define _REENTRANT
  #endif
#endif

/* Windows platform with Borland compiler */
#if defined(_WIN32) && defined(__BORLANDC__)
  #undef XMLPUBFUN
  #undef XMLPUBVAR
  #undef XMLCALL
  #undef XMLCDECL
  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
    #define XMLPUBFUN __declspec(dllexport)
    #define XMLPUBVAR __declspec(dllexport) extern
  #else
    #define XMLPUBFUN
    #if !defined(LIBXML_STATIC)
      #define XMLPUBVAR __declspec(dllimport) extern
    #else
      #define XMLPUBVAR extern
    #endif
  #endif
  #define XMLCALL __cdecl
  #define XMLCDECL __cdecl
  #if !defined _REENTRANT
    #define _REENTRANT
  #endif
#endif

/* Windows platform with GNU compiler (Mingw) */
#if defined(_WIN32) && defined(__MINGW32__)
  #undef XMLPUBFUN
  #undef XMLPUBVAR
  #undef XMLCALL
  #undef XMLCDECL
  /*
   * if defined(IN_LIBXML) this raises problems on mingw with msys
   * _imp__xmlFree listed as missing. Try to workaround the problem
   * by also making that declaration when compiling client code.
   */
  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
    #define XMLPUBFUN __declspec(dllexport)
    #define XMLPUBVAR __declspec(dllexport) extern
  #else
    #define XMLPUBFUN
    #if !defined(LIBXML_STATIC)
      #define XMLPUBVAR __declspec(dllimport) extern
    #else
      #define XMLPUBVAR extern
    #endif
  #endif
  #define XMLCALL __cdecl
  #define XMLCDECL __cdecl
  #if !defined _REENTRANT
    #define _REENTRANT
  #endif
#endif

/* Cygwin platform, GNU compiler */
#if defined(_WIN32) && defined(__CYGWIN__)
  #undef XMLPUBFUN
  #undef XMLPUBVAR
  #undef XMLCALL
  #undef XMLCDECL
  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
    #define XMLPUBFUN __declspec(dllexport)
    #define XMLPUBVAR __declspec(dllexport)
  #else
    #define XMLPUBFUN
    #if !defined(LIBXML_STATIC)
      #define XMLPUBVAR __declspec(dllimport) extern
    #else
      #define XMLPUBVAR
    #endif
  #endif
  #define XMLCALL __cdecl
  #define XMLCDECL __cdecl
#endif

/* Compatibility */
#if !defined(LIBXML_DLL_IMPORT)
#define LIBXML_DLL_IMPORT XMLPUBVAR
#endif

#endif /* __XML_EXPORTS_H__ */


**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlschemas.h
/*
 * Summary: incomplete XML Schemas structure implementation
 * Description: interface to the XML Schemas handling and schema validity
 *              checking, it is incomplete right now.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */


#ifndef __XML_SCHEMA_H__
#define __XML_SCHEMA_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_SCHEMAS_ENABLED

#include <libxml/tree.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * This error codes are obsolete; not used any more.
 */
typedef enum {
    XML_SCHEMAS_ERR_OK		= 0,
    XML_SCHEMAS_ERR_NOROOT	= 1,
    XML_SCHEMAS_ERR_UNDECLAREDELEM,
    XML_SCHEMAS_ERR_NOTTOPLEVEL,
    XML_SCHEMAS_ERR_MISSING,
    XML_SCHEMAS_ERR_WRONGELEM,
    XML_SCHEMAS_ERR_NOTYPE,
    XML_SCHEMAS_ERR_NOROLLBACK,
    XML_SCHEMAS_ERR_ISABSTRACT,
    XML_SCHEMAS_ERR_NOTEMPTY,
    XML_SCHEMAS_ERR_ELEMCONT,
    XML_SCHEMAS_ERR_HAVEDEFAULT,
    XML_SCHEMAS_ERR_NOTNILLABLE,
    XML_SCHEMAS_ERR_EXTRACONTENT,
    XML_SCHEMAS_ERR_INVALIDATTR,
    XML_SCHEMAS_ERR_INVALIDELEM,
    XML_SCHEMAS_ERR_NOTDETERMINIST,
    XML_SCHEMAS_ERR_CONSTRUCT,
    XML_SCHEMAS_ERR_INTERNAL,
    XML_SCHEMAS_ERR_NOTSIMPLE,
    XML_SCHEMAS_ERR_ATTRUNKNOWN,
    XML_SCHEMAS_ERR_ATTRINVALID,
    XML_SCHEMAS_ERR_VALUE,
    XML_SCHEMAS_ERR_FACET,
    XML_SCHEMAS_ERR_,
    XML_SCHEMAS_ERR_XXX
} xmlSchemaValidError;

/*
* ATTENTION: Change xmlSchemaSetValidOptions's check
* for invalid values, if adding to the validation
* options below.
*/
/**
 * xmlSchemaValidOption:
 *
 * This is the set of XML Schema validation options.
 */
typedef enum {
    XML_SCHEMA_VAL_VC_I_CREATE			= 1<<0
	/* Default/fixed: create an attribute node
	* or an element's text node on the instance.
	*/
} xmlSchemaValidOption;

/*
    XML_SCHEMA_VAL_XSI_ASSEMBLE			= 1<<1,
	* assemble schemata using
	* xsi:schemaLocation and
	* xsi:noNamespaceSchemaLocation
*/

/**
 * The schemas related types are kept internal
 */
typedef struct _xmlSchema xmlSchema;
typedef xmlSchema *xmlSchemaPtr;

/**
 * xmlSchemaValidityErrorFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of an error callback from an XSD validation
 */
typedef void (XMLCDECL *xmlSchemaValidityErrorFunc)
                 (void *ctx, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);

/**
 * xmlSchemaValidityWarningFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of a warning callback from an XSD validation
 */
typedef void (XMLCDECL *xmlSchemaValidityWarningFunc)
                 (void *ctx, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);

/**
 * A schemas validation context
 */
typedef struct _xmlSchemaParserCtxt xmlSchemaParserCtxt;
typedef xmlSchemaParserCtxt *xmlSchemaParserCtxtPtr;

typedef struct _xmlSchemaValidCtxt xmlSchemaValidCtxt;
typedef xmlSchemaValidCtxt *xmlSchemaValidCtxtPtr;

/**
 * xmlSchemaValidityLocatorFunc:
 * @ctx: user provided context
 * @file: returned file information
 * @line: returned line information
 *
 * A schemas validation locator, a callback called by the validator.
 * This is used when file or node informations are not available
 * to find out what file and line number are affected
 *
 * Returns: 0 in case of success and -1 in case of error
 */

typedef int (XMLCDECL *xmlSchemaValidityLocatorFunc) (void *ctx,
                           const char **file, unsigned long *line);

/*
 * Interfaces for parsing.
 */
XMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL
	    xmlSchemaNewParserCtxt	(const char *URL);
XMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL
	    xmlSchemaNewMemParserCtxt	(const char *buffer,
					 int size);
XMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL
	    xmlSchemaNewDocParserCtxt	(xmlDocPtr doc);
XMLPUBFUN void XMLCALL
	    xmlSchemaFreeParserCtxt	(xmlSchemaParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
	    xmlSchemaSetParserErrors	(xmlSchemaParserCtxtPtr ctxt,
					 xmlSchemaValidityErrorFunc err,
					 xmlSchemaValidityWarningFunc warn,
					 void *ctx);
XMLPUBFUN void XMLCALL
	    xmlSchemaSetParserStructuredErrors(xmlSchemaParserCtxtPtr ctxt,
					 xmlStructuredErrorFunc serror,
					 void *ctx);
XMLPUBFUN int XMLCALL
		xmlSchemaGetParserErrors(xmlSchemaParserCtxtPtr ctxt,
					xmlSchemaValidityErrorFunc * err,
					xmlSchemaValidityWarningFunc * warn,
					void **ctx);
XMLPUBFUN int XMLCALL
		xmlSchemaIsValid	(xmlSchemaValidCtxtPtr ctxt);

XMLPUBFUN xmlSchemaPtr XMLCALL
	    xmlSchemaParse		(xmlSchemaParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
	    xmlSchemaFree		(xmlSchemaPtr schema);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void XMLCALL
	    xmlSchemaDump		(FILE *output,
					 xmlSchemaPtr schema);
#endif /* LIBXML_OUTPUT_ENABLED */
/*
 * Interfaces for validating
 */
XMLPUBFUN void XMLCALL
	    xmlSchemaSetValidErrors	(xmlSchemaValidCtxtPtr ctxt,
					 xmlSchemaValidityErrorFunc err,
					 xmlSchemaValidityWarningFunc warn,
					 void *ctx);
XMLPUBFUN void XMLCALL
	    xmlSchemaSetValidStructuredErrors(xmlSchemaValidCtxtPtr ctxt,
					 xmlStructuredErrorFunc serror,
					 void *ctx);
XMLPUBFUN int XMLCALL
	    xmlSchemaGetValidErrors	(xmlSchemaValidCtxtPtr ctxt,
					 xmlSchemaValidityErrorFunc *err,
					 xmlSchemaValidityWarningFunc *warn,
					 void **ctx);
XMLPUBFUN int XMLCALL
	    xmlSchemaSetValidOptions	(xmlSchemaValidCtxtPtr ctxt,
					 int options);
XMLPUBFUN void XMLCALL
            xmlSchemaValidateSetFilename(xmlSchemaValidCtxtPtr vctxt,
	                                 const char *filename);
XMLPUBFUN int XMLCALL
	    xmlSchemaValidCtxtGetOptions(xmlSchemaValidCtxtPtr ctxt);

XMLPUBFUN xmlSchemaValidCtxtPtr XMLCALL
	    xmlSchemaNewValidCtxt	(xmlSchemaPtr schema);
XMLPUBFUN void XMLCALL
	    xmlSchemaFreeValidCtxt	(xmlSchemaValidCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
	    xmlSchemaValidateDoc	(xmlSchemaValidCtxtPtr ctxt,
					 xmlDocPtr instance);
XMLPUBFUN int XMLCALL
            xmlSchemaValidateOneElement (xmlSchemaValidCtxtPtr ctxt,
			                 xmlNodePtr elem);
XMLPUBFUN int XMLCALL
	    xmlSchemaValidateStream	(xmlSchemaValidCtxtPtr ctxt,
					 xmlParserInputBufferPtr input,
					 xmlCharEncoding enc,
					 xmlSAXHandlerPtr sax,
					 void *user_data);
XMLPUBFUN int XMLCALL
	    xmlSchemaValidateFile	(xmlSchemaValidCtxtPtr ctxt,
					 const char * filename,
					 int options);

XMLPUBFUN xmlParserCtxtPtr XMLCALL
	    xmlSchemaValidCtxtGetParserCtxt(xmlSchemaValidCtxtPtr ctxt);

/*
 * Interface to insert Schemas SAX validation in a SAX stream
 */
typedef struct _xmlSchemaSAXPlug xmlSchemaSAXPlugStruct;
typedef xmlSchemaSAXPlugStruct *xmlSchemaSAXPlugPtr;

XMLPUBFUN xmlSchemaSAXPlugPtr XMLCALL
            xmlSchemaSAXPlug		(xmlSchemaValidCtxtPtr ctxt,
					 xmlSAXHandlerPtr *sax,
					 void **user_data);
XMLPUBFUN int XMLCALL
            xmlSchemaSAXUnplug		(xmlSchemaSAXPlugPtr plug);


XMLPUBFUN void XMLCALL
            xmlSchemaValidateSetLocator	(xmlSchemaValidCtxtPtr vctxt,
					 xmlSchemaValidityLocatorFunc f,
					 void *ctxt);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_SCHEMAS_ENABLED */
#endif /* __XML_SCHEMA_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/SAX.h
/*
 * Summary: Old SAX version 1 handler, deprecated
 * Description: DEPRECATED set of SAX version 1 interfaces used to
 *              build the DOM tree.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */


#ifndef __XML_SAX_H__
#define __XML_SAX_H__

#include <stdio.h>
#include <stdlib.h>
#include <libxml/xmlversion.h>
#include <libxml/parser.h>
#include <libxml/xlink.h>

#ifdef LIBXML_LEGACY_ENABLED

#ifdef __cplusplus
extern "C" {
#endif
XMLPUBFUN const xmlChar * XMLCALL
		getPublicId			(void *ctx);
XMLPUBFUN const xmlChar * XMLCALL
		getSystemId			(void *ctx);
XMLPUBFUN void XMLCALL
		setDocumentLocator		(void *ctx,
						 xmlSAXLocatorPtr loc);

XMLPUBFUN int XMLCALL
		getLineNumber			(void *ctx);
XMLPUBFUN int XMLCALL
		getColumnNumber			(void *ctx);

XMLPUBFUN int XMLCALL
		isStandalone			(void *ctx);
XMLPUBFUN int XMLCALL
		hasInternalSubset		(void *ctx);
XMLPUBFUN int XMLCALL
		hasExternalSubset		(void *ctx);

XMLPUBFUN void XMLCALL
		internalSubset			(void *ctx,
						 const xmlChar *name,
						 const xmlChar *ExternalID,
						 const xmlChar *SystemID);
XMLPUBFUN void XMLCALL
		externalSubset			(void *ctx,
						 const xmlChar *name,
						 const xmlChar *ExternalID,
						 const xmlChar *SystemID);
XMLPUBFUN xmlEntityPtr XMLCALL
		getEntity			(void *ctx,
						 const xmlChar *name);
XMLPUBFUN xmlEntityPtr XMLCALL
		getParameterEntity		(void *ctx,
						 const xmlChar *name);
XMLPUBFUN xmlParserInputPtr XMLCALL
		resolveEntity			(void *ctx,
						 const xmlChar *publicId,
						 const xmlChar *systemId);

XMLPUBFUN void XMLCALL
		entityDecl			(void *ctx,
						 const xmlChar *name,
						 int type,
						 const xmlChar *publicId,
						 const xmlChar *systemId,
						 xmlChar *content);
XMLPUBFUN void XMLCALL
		attributeDecl			(void *ctx,
						 const xmlChar *elem,
						 const xmlChar *fullname,
						 int type,
						 int def,
						 const xmlChar *defaultValue,
						 xmlEnumerationPtr tree);
XMLPUBFUN void XMLCALL
		elementDecl			(void *ctx,
						 const xmlChar *name,
						 int type,
						 xmlElementContentPtr content);
XMLPUBFUN void XMLCALL
		notationDecl			(void *ctx,
						 const xmlChar *name,
						 const xmlChar *publicId,
						 const xmlChar *systemId);
XMLPUBFUN void XMLCALL
		unparsedEntityDecl		(void *ctx,
						 const xmlChar *name,
						 const xmlChar *publicId,
						 const xmlChar *systemId,
						 const xmlChar *notationName);

XMLPUBFUN void XMLCALL
		startDocument			(void *ctx);
XMLPUBFUN void XMLCALL
		endDocument			(void *ctx);
XMLPUBFUN void XMLCALL
		attribute			(void *ctx,
						 const xmlChar *fullname,
						 const xmlChar *value);
XMLPUBFUN void XMLCALL
		startElement			(void *ctx,
						 const xmlChar *fullname,
						 const xmlChar **atts);
XMLPUBFUN void XMLCALL
		endElement			(void *ctx,
						 const xmlChar *name);
XMLPUBFUN void XMLCALL
		reference			(void *ctx,
						 const xmlChar *name);
XMLPUBFUN void XMLCALL
		characters			(void *ctx,
						 const xmlChar *ch,
						 int len);
XMLPUBFUN void XMLCALL
		ignorableWhitespace		(void *ctx,
						 const xmlChar *ch,
						 int len);
XMLPUBFUN void XMLCALL
		processingInstruction		(void *ctx,
						 const xmlChar *target,
						 const xmlChar *data);
XMLPUBFUN void XMLCALL
		globalNamespace			(void *ctx,
						 const xmlChar *href,
						 const xmlChar *prefix);
XMLPUBFUN void XMLCALL
		setNamespace			(void *ctx,
						 const xmlChar *name);
XMLPUBFUN xmlNsPtr XMLCALL
		getNamespace			(void *ctx);
XMLPUBFUN int XMLCALL
		checkNamespace			(void *ctx,
						 xmlChar *nameSpace);
XMLPUBFUN void XMLCALL
		namespaceDecl			(void *ctx,
						 const xmlChar *href,
						 const xmlChar *prefix);
XMLPUBFUN void XMLCALL
		comment				(void *ctx,
						 const xmlChar *value);
XMLPUBFUN void XMLCALL
		cdataBlock			(void *ctx,
						 const xmlChar *value,
						 int len);

#ifdef LIBXML_SAX1_ENABLED
XMLPUBFUN void XMLCALL
		initxmlDefaultSAXHandler	(xmlSAXHandlerV1 *hdlr,
						 int warning);
#ifdef LIBXML_HTML_ENABLED
XMLPUBFUN void XMLCALL
		inithtmlDefaultSAXHandler	(xmlSAXHandlerV1 *hdlr);
#endif
#ifdef LIBXML_DOCB_ENABLED
XMLPUBFUN void XMLCALL
		initdocbDefaultSAXHandler	(xmlSAXHandlerV1 *hdlr);
#endif
#endif /* LIBXML_SAX1_ENABLED */

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_LEGACY_ENABLED */

#endif /* __XML_SAX_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlIO.h
/*
 * Summary: interface for the I/O interfaces used by the parser
 * Description: interface for the I/O interfaces used by the parser
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_IO_H__
#define __XML_IO_H__

#include <stdio.h>
#include <libxml/xmlversion.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Those are the functions and datatypes for the parser input
 * I/O structures.
 */

/**
 * xmlInputMatchCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Input API to detect if the current handler
 * can provide input fonctionnalities for this resource.
 *
 * Returns 1 if yes and 0 if another Input module should be used
 */
typedef int (XMLCALL *xmlInputMatchCallback) (char const *filename);
/**
 * xmlInputOpenCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Input API to open the resource
 *
 * Returns an Input context or NULL in case or error
 */
typedef void * (XMLCALL *xmlInputOpenCallback) (char const *filename);
/**
 * xmlInputReadCallback:
 * @context:  an Input context
 * @buffer:  the buffer to store data read
 * @len:  the length of the buffer in bytes
 *
 * Callback used in the I/O Input API to read the resource
 *
 * Returns the number of bytes read or -1 in case of error
 */
typedef int (XMLCALL *xmlInputReadCallback) (void * context, char * buffer, int len);
/**
 * xmlInputCloseCallback:
 * @context:  an Input context
 *
 * Callback used in the I/O Input API to close the resource
 *
 * Returns 0 or -1 in case of error
 */
typedef int (XMLCALL *xmlInputCloseCallback) (void * context);

#ifdef LIBXML_OUTPUT_ENABLED
/*
 * Those are the functions and datatypes for the library output
 * I/O structures.
 */

/**
 * xmlOutputMatchCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Output API to detect if the current handler
 * can provide output fonctionnalities for this resource.
 *
 * Returns 1 if yes and 0 if another Output module should be used
 */
typedef int (XMLCALL *xmlOutputMatchCallback) (char const *filename);
/**
 * xmlOutputOpenCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Output API to open the resource
 *
 * Returns an Output context or NULL in case or error
 */
typedef void * (XMLCALL *xmlOutputOpenCallback) (char const *filename);
/**
 * xmlOutputWriteCallback:
 * @context:  an Output context
 * @buffer:  the buffer of data to write
 * @len:  the length of the buffer in bytes
 *
 * Callback used in the I/O Output API to write to the resource
 *
 * Returns the number of bytes written or -1 in case of error
 */
typedef int (XMLCALL *xmlOutputWriteCallback) (void * context, const char * buffer,
                                       int len);
/**
 * xmlOutputCloseCallback:
 * @context:  an Output context
 *
 * Callback used in the I/O Output API to close the resource
 *
 * Returns 0 or -1 in case of error
 */
typedef int (XMLCALL *xmlOutputCloseCallback) (void * context);
#endif /* LIBXML_OUTPUT_ENABLED */

#ifdef __cplusplus
}
#endif

#include <libxml/globals.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <libxml/encoding.h>

#ifdef __cplusplus
extern "C" {
#endif
struct _xmlParserInputBuffer {
    void*                  context;
    xmlInputReadCallback   readcallback;
    xmlInputCloseCallback  closecallback;

    xmlCharEncodingHandlerPtr encoder; /* I18N conversions to UTF-8 */

    xmlBufPtr buffer;    /* Local buffer encoded in UTF-8 */
    xmlBufPtr raw;       /* if encoder != NULL buffer for raw input */
    int	compressed;	    /* -1=unknown, 0=not compressed, 1=compressed */
    int error;
    unsigned long rawconsumed;/* amount consumed from raw */
};


#ifdef LIBXML_OUTPUT_ENABLED
struct _xmlOutputBuffer {
    void*                   context;
    xmlOutputWriteCallback  writecallback;
    xmlOutputCloseCallback  closecallback;

    xmlCharEncodingHandlerPtr encoder; /* I18N conversions to UTF-8 */

    xmlBufPtr buffer;    /* Local buffer encoded in UTF-8 or ISOLatin */
    xmlBufPtr conv;      /* if encoder != NULL buffer for output */
    int written;            /* total number of byte written */
    int error;
};
#endif /* LIBXML_OUTPUT_ENABLED */

/*
 * Interfaces for input
 */
XMLPUBFUN void XMLCALL
	xmlCleanupInputCallbacks		(void);

XMLPUBFUN int XMLCALL
	xmlPopInputCallbacks			(void);

XMLPUBFUN void XMLCALL
	xmlRegisterDefaultInputCallbacks	(void);
XMLPUBFUN xmlParserInputBufferPtr XMLCALL
	xmlAllocParserInputBuffer		(xmlCharEncoding enc);

XMLPUBFUN xmlParserInputBufferPtr XMLCALL
	xmlParserInputBufferCreateFilename	(const char *URI,
                                                 xmlCharEncoding enc);
XMLPUBFUN xmlParserInputBufferPtr XMLCALL
	xmlParserInputBufferCreateFile		(FILE *file,
                                                 xmlCharEncoding enc);
XMLPUBFUN xmlParserInputBufferPtr XMLCALL
	xmlParserInputBufferCreateFd		(int fd,
	                                         xmlCharEncoding enc);
XMLPUBFUN xmlParserInputBufferPtr XMLCALL
	xmlParserInputBufferCreateMem		(const char *mem, int size,
	                                         xmlCharEncoding enc);
XMLPUBFUN xmlParserInputBufferPtr XMLCALL
	xmlParserInputBufferCreateStatic	(const char *mem, int size,
	                                         xmlCharEncoding enc);
XMLPUBFUN xmlParserInputBufferPtr XMLCALL
	xmlParserInputBufferCreateIO		(xmlInputReadCallback   ioread,
						 xmlInputCloseCallback  ioclose,
						 void *ioctx,
	                                         xmlCharEncoding enc);
XMLPUBFUN int XMLCALL
	xmlParserInputBufferRead		(xmlParserInputBufferPtr in,
						 int len);
XMLPUBFUN int XMLCALL
	xmlParserInputBufferGrow		(xmlParserInputBufferPtr in,
						 int len);
XMLPUBFUN int XMLCALL
	xmlParserInputBufferPush		(xmlParserInputBufferPtr in,
						 int len,
						 const char *buf);
XMLPUBFUN void XMLCALL
	xmlFreeParserInputBuffer		(xmlParserInputBufferPtr in);
XMLPUBFUN char * XMLCALL
	xmlParserGetDirectory			(const char *filename);

XMLPUBFUN int XMLCALL
	xmlRegisterInputCallbacks		(xmlInputMatchCallback matchFunc,
						 xmlInputOpenCallback openFunc,
						 xmlInputReadCallback readFunc,
						 xmlInputCloseCallback closeFunc);

xmlParserInputBufferPtr
	__xmlParserInputBufferCreateFilename(const char *URI,
										xmlCharEncoding enc);

#ifdef LIBXML_OUTPUT_ENABLED
/*
 * Interfaces for output
 */
XMLPUBFUN void XMLCALL
	xmlCleanupOutputCallbacks		(void);
XMLPUBFUN void XMLCALL
	xmlRegisterDefaultOutputCallbacks(void);
XMLPUBFUN xmlOutputBufferPtr XMLCALL
	xmlAllocOutputBuffer		(xmlCharEncodingHandlerPtr encoder);

XMLPUBFUN xmlOutputBufferPtr XMLCALL
	xmlOutputBufferCreateFilename	(const char *URI,
					 xmlCharEncodingHandlerPtr encoder,
					 int compression);

XMLPUBFUN xmlOutputBufferPtr XMLCALL
	xmlOutputBufferCreateFile	(FILE *file,
					 xmlCharEncodingHandlerPtr encoder);

XMLPUBFUN xmlOutputBufferPtr XMLCALL
	xmlOutputBufferCreateBuffer	(xmlBufferPtr buffer,
					 xmlCharEncodingHandlerPtr encoder);

XMLPUBFUN xmlOutputBufferPtr XMLCALL
	xmlOutputBufferCreateFd		(int fd,
					 xmlCharEncodingHandlerPtr encoder);

XMLPUBFUN xmlOutputBufferPtr XMLCALL
	xmlOutputBufferCreateIO		(xmlOutputWriteCallback   iowrite,
					 xmlOutputCloseCallback  ioclose,
					 void *ioctx,
					 xmlCharEncodingHandlerPtr encoder);

/* Couple of APIs to get the output without digging into the buffers */
XMLPUBFUN const xmlChar * XMLCALL
        xmlOutputBufferGetContent       (xmlOutputBufferPtr out);
XMLPUBFUN size_t XMLCALL
        xmlOutputBufferGetSize          (xmlOutputBufferPtr out);

XMLPUBFUN int XMLCALL
	xmlOutputBufferWrite		(xmlOutputBufferPtr out,
					 int len,
					 const char *buf);
XMLPUBFUN int XMLCALL
	xmlOutputBufferWriteString	(xmlOutputBufferPtr out,
					 const char *str);
XMLPUBFUN int XMLCALL
	xmlOutputBufferWriteEscape	(xmlOutputBufferPtr out,
					 const xmlChar *str,
					 xmlCharEncodingOutputFunc escaping);

XMLPUBFUN int XMLCALL
	xmlOutputBufferFlush		(xmlOutputBufferPtr out);
XMLPUBFUN int XMLCALL
	xmlOutputBufferClose		(xmlOutputBufferPtr out);

XMLPUBFUN int XMLCALL
	xmlRegisterOutputCallbacks	(xmlOutputMatchCallback matchFunc,
					 xmlOutputOpenCallback openFunc,
					 xmlOutputWriteCallback writeFunc,
					 xmlOutputCloseCallback closeFunc);

xmlOutputBufferPtr
	__xmlOutputBufferCreateFilename(const char *URI,
                              xmlCharEncodingHandlerPtr encoder,
                              int compression);

#ifdef LIBXML_HTTP_ENABLED
/*  This function only exists if HTTP support built into the library  */
XMLPUBFUN void XMLCALL
	xmlRegisterHTTPPostCallbacks	(void );
#endif /* LIBXML_HTTP_ENABLED */

#endif /* LIBXML_OUTPUT_ENABLED */

XMLPUBFUN xmlParserInputPtr XMLCALL
	xmlCheckHTTPInput		(xmlParserCtxtPtr ctxt,
					 xmlParserInputPtr ret);

/*
 * A predefined entity loader disabling network accesses
 */
XMLPUBFUN xmlParserInputPtr XMLCALL
	xmlNoNetExternalEntityLoader	(const char *URL,
					 const char *ID,
					 xmlParserCtxtPtr ctxt);

/*
 * xmlNormalizeWindowsPath is obsolete, don't use it.
 * Check xmlCanonicPath in uri.h for a better alternative.
 */
XMLPUBFUN xmlChar * XMLCALL
	xmlNormalizeWindowsPath		(const xmlChar *path);

XMLPUBFUN int XMLCALL
	xmlCheckFilename		(const char *path);
/**
 * Default 'file://' protocol callbacks
 */
XMLPUBFUN int XMLCALL
	xmlFileMatch			(const char *filename);
XMLPUBFUN void * XMLCALL
	xmlFileOpen			(const char *filename);
XMLPUBFUN int XMLCALL
	xmlFileRead			(void * context,
					 char * buffer,
					 int len);
XMLPUBFUN int XMLCALL
	xmlFileClose			(void * context);

/**
 * Default 'http://' protocol callbacks
 */
#ifdef LIBXML_HTTP_ENABLED
XMLPUBFUN int XMLCALL
	xmlIOHTTPMatch			(const char *filename);
XMLPUBFUN void * XMLCALL
	xmlIOHTTPOpen			(const char *filename);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void * XMLCALL
	xmlIOHTTPOpenW			(const char * post_uri,
					 int   compression );
#endif /* LIBXML_OUTPUT_ENABLED */
XMLPUBFUN int XMLCALL
	xmlIOHTTPRead			(void * context,
					 char * buffer,
					 int len);
XMLPUBFUN int XMLCALL
	xmlIOHTTPClose			(void * context);
#endif /* LIBXML_HTTP_ENABLED */

/**
 * Default 'ftp://' protocol callbacks
 */
#ifdef LIBXML_FTP_ENABLED
XMLPUBFUN int XMLCALL
	xmlIOFTPMatch			(const char *filename);
XMLPUBFUN void * XMLCALL
	xmlIOFTPOpen			(const char *filename);
XMLPUBFUN int XMLCALL
	xmlIOFTPRead			(void * context,
					 char * buffer,
					 int len);
XMLPUBFUN int XMLCALL
	xmlIOFTPClose			(void * context);
#endif /* LIBXML_FTP_ENABLED */

#ifdef __cplusplus
}
#endif

#endif /* __XML_IO_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/relaxng.h
/*
 * Summary: implementation of the Relax-NG validation
 * Description: implementation of the Relax-NG validation
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_RELAX_NG__
#define __XML_RELAX_NG__

#include <libxml/xmlversion.h>
#include <libxml/hash.h>
#include <libxml/xmlstring.h>

#ifdef LIBXML_SCHEMAS_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _xmlRelaxNG xmlRelaxNG;
typedef xmlRelaxNG *xmlRelaxNGPtr;


/**
 * xmlRelaxNGValidityErrorFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of an error callback from a Relax-NG validation
 */
typedef void (XMLCDECL *xmlRelaxNGValidityErrorFunc) (void *ctx, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);

/**
 * xmlRelaxNGValidityWarningFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of a warning callback from a Relax-NG validation
 */
typedef void (XMLCDECL *xmlRelaxNGValidityWarningFunc) (void *ctx, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);

/**
 * A schemas validation context
 */
typedef struct _xmlRelaxNGParserCtxt xmlRelaxNGParserCtxt;
typedef xmlRelaxNGParserCtxt *xmlRelaxNGParserCtxtPtr;

typedef struct _xmlRelaxNGValidCtxt xmlRelaxNGValidCtxt;
typedef xmlRelaxNGValidCtxt *xmlRelaxNGValidCtxtPtr;

/*
 * xmlRelaxNGValidErr:
 *
 * List of possible Relax NG validation errors
 */
typedef enum {
    XML_RELAXNG_OK = 0,
    XML_RELAXNG_ERR_MEMORY,
    XML_RELAXNG_ERR_TYPE,
    XML_RELAXNG_ERR_TYPEVAL,
    XML_RELAXNG_ERR_DUPID,
    XML_RELAXNG_ERR_TYPECMP,
    XML_RELAXNG_ERR_NOSTATE,
    XML_RELAXNG_ERR_NODEFINE,
    XML_RELAXNG_ERR_LISTEXTRA,
    XML_RELAXNG_ERR_LISTEMPTY,
    XML_RELAXNG_ERR_INTERNODATA,
    XML_RELAXNG_ERR_INTERSEQ,
    XML_RELAXNG_ERR_INTEREXTRA,
    XML_RELAXNG_ERR_ELEMNAME,
    XML_RELAXNG_ERR_ATTRNAME,
    XML_RELAXNG_ERR_ELEMNONS,
    XML_RELAXNG_ERR_ATTRNONS,
    XML_RELAXNG_ERR_ELEMWRONGNS,
    XML_RELAXNG_ERR_ATTRWRONGNS,
    XML_RELAXNG_ERR_ELEMEXTRANS,
    XML_RELAXNG_ERR_ATTREXTRANS,
    XML_RELAXNG_ERR_ELEMNOTEMPTY,
    XML_RELAXNG_ERR_NOELEM,
    XML_RELAXNG_ERR_NOTELEM,
    XML_RELAXNG_ERR_ATTRVALID,
    XML_RELAXNG_ERR_CONTENTVALID,
    XML_RELAXNG_ERR_EXTRACONTENT,
    XML_RELAXNG_ERR_INVALIDATTR,
    XML_RELAXNG_ERR_DATAELEM,
    XML_RELAXNG_ERR_VALELEM,
    XML_RELAXNG_ERR_LISTELEM,
    XML_RELAXNG_ERR_DATATYPE,
    XML_RELAXNG_ERR_VALUE,
    XML_RELAXNG_ERR_LIST,
    XML_RELAXNG_ERR_NOGRAMMAR,
    XML_RELAXNG_ERR_EXTRADATA,
    XML_RELAXNG_ERR_LACKDATA,
    XML_RELAXNG_ERR_INTERNAL,
    XML_RELAXNG_ERR_ELEMWRONG,
    XML_RELAXNG_ERR_TEXTWRONG
} xmlRelaxNGValidErr;

/*
 * xmlRelaxNGParserFlags:
 *
 * List of possible Relax NG Parser flags
 */
typedef enum {
    XML_RELAXNGP_NONE = 0,
    XML_RELAXNGP_FREE_DOC = 1,
    XML_RELAXNGP_CRNG = 2
} xmlRelaxNGParserFlag;

XMLPUBFUN int XMLCALL
		    xmlRelaxNGInitTypes		(void);
XMLPUBFUN void XMLCALL
		    xmlRelaxNGCleanupTypes	(void);

/*
 * Interfaces for parsing.
 */
XMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL
		    xmlRelaxNGNewParserCtxt	(const char *URL);
XMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL
		    xmlRelaxNGNewMemParserCtxt	(const char *buffer,
						 int size);
XMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL
		    xmlRelaxNGNewDocParserCtxt	(xmlDocPtr doc);

XMLPUBFUN int XMLCALL
		    xmlRelaxParserSetFlag	(xmlRelaxNGParserCtxtPtr ctxt,
						 int flag);

XMLPUBFUN void XMLCALL
		    xmlRelaxNGFreeParserCtxt	(xmlRelaxNGParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
		    xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,
					 xmlRelaxNGValidityErrorFunc err,
					 xmlRelaxNGValidityWarningFunc warn,
					 void *ctx);
XMLPUBFUN int XMLCALL
		    xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,
					 xmlRelaxNGValidityErrorFunc *err,
					 xmlRelaxNGValidityWarningFunc *warn,
					 void **ctx);
XMLPUBFUN void XMLCALL
		    xmlRelaxNGSetParserStructuredErrors(
					 xmlRelaxNGParserCtxtPtr ctxt,
					 xmlStructuredErrorFunc serror,
					 void *ctx);
XMLPUBFUN xmlRelaxNGPtr XMLCALL
		    xmlRelaxNGParse		(xmlRelaxNGParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
		    xmlRelaxNGFree		(xmlRelaxNGPtr schema);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void XMLCALL
		    xmlRelaxNGDump		(FILE *output,
					 xmlRelaxNGPtr schema);
XMLPUBFUN void XMLCALL
		    xmlRelaxNGDumpTree	(FILE * output,
					 xmlRelaxNGPtr schema);
#endif /* LIBXML_OUTPUT_ENABLED */
/*
 * Interfaces for validating
 */
XMLPUBFUN void XMLCALL
		    xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,
					 xmlRelaxNGValidityErrorFunc err,
					 xmlRelaxNGValidityWarningFunc warn,
					 void *ctx);
XMLPUBFUN int XMLCALL
		    xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,
					 xmlRelaxNGValidityErrorFunc *err,
					 xmlRelaxNGValidityWarningFunc *warn,
					 void **ctx);
XMLPUBFUN void XMLCALL
			xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt,
					  xmlStructuredErrorFunc serror, void *ctx);
XMLPUBFUN xmlRelaxNGValidCtxtPtr XMLCALL
		    xmlRelaxNGNewValidCtxt	(xmlRelaxNGPtr schema);
XMLPUBFUN void XMLCALL
		    xmlRelaxNGFreeValidCtxt	(xmlRelaxNGValidCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
		    xmlRelaxNGValidateDoc	(xmlRelaxNGValidCtxtPtr ctxt,
						 xmlDocPtr doc);
/*
 * Interfaces for progressive validation when possible
 */
XMLPUBFUN int XMLCALL
		    xmlRelaxNGValidatePushElement	(xmlRelaxNGValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlNodePtr elem);
XMLPUBFUN int XMLCALL
		    xmlRelaxNGValidatePushCData	(xmlRelaxNGValidCtxtPtr ctxt,
					 const xmlChar *data,
					 int len);
XMLPUBFUN int XMLCALL
		    xmlRelaxNGValidatePopElement	(xmlRelaxNGValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlNodePtr elem);
XMLPUBFUN int XMLCALL
		    xmlRelaxNGValidateFullElement	(xmlRelaxNGValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlNodePtr elem);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_SCHEMAS_ENABLED */

#endif /* __XML_RELAX_NG__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/hash.h
/*
 * Summary: Chained hash tables
 * Description: This module implements the hash table support used in
 *		various places in the library.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Bjorn Reese <bjorn.reese@systematic.dk>
 */

#ifndef __XML_HASH_H__
#define __XML_HASH_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The hash table.
 */
typedef struct _xmlHashTable xmlHashTable;
typedef xmlHashTable *xmlHashTablePtr;

#ifdef __cplusplus
}
#endif

#include <libxml/xmlversion.h>
#include <libxml/parser.h>
#include <libxml/dict.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Recent version of gcc produce a warning when a function pointer is assigned
 * to an object pointer, or vice versa.  The following macro is a dirty hack
 * to allow suppression of the warning.  If your architecture has function
 * pointers which are a different size than a void pointer, there may be some
 * serious trouble within the library.
 */
/**
 * XML_CAST_FPTR:
 * @fptr:  pointer to a function
 *
 * Macro to do a casting from an object pointer to a
 * function pointer without encountering a warning from
 * gcc
 *
 * #define XML_CAST_FPTR(fptr) (*(void **)(&fptr))
 * This macro violated ISO C aliasing rules (gcc4 on s390 broke)
 * so it is disabled now
 */

#define XML_CAST_FPTR(fptr) fptr


/*
 * function types:
 */
/**
 * xmlHashDeallocator:
 * @payload:  the data in the hash
 * @name:  the name associated
 *
 * Callback to free data from a hash.
 */
typedef void (*xmlHashDeallocator)(void *payload, xmlChar *name);
/**
 * xmlHashCopier:
 * @payload:  the data in the hash
 * @name:  the name associated
 *
 * Callback to copy data from a hash.
 *
 * Returns a copy of the data or NULL in case of error.
 */
typedef void *(*xmlHashCopier)(void *payload, xmlChar *name);
/**
 * xmlHashScanner:
 * @payload:  the data in the hash
 * @data:  extra scannner data
 * @name:  the name associated
 *
 * Callback when scanning data in a hash with the simple scanner.
 */
typedef void (*xmlHashScanner)(void *payload, void *data, xmlChar *name);
/**
 * xmlHashScannerFull:
 * @payload:  the data in the hash
 * @data:  extra scannner data
 * @name:  the name associated
 * @name2:  the second name associated
 * @name3:  the third name associated
 *
 * Callback when scanning data in a hash with the full scanner.
 */
typedef void (*xmlHashScannerFull)(void *payload, void *data,
				   const xmlChar *name, const xmlChar *name2,
				   const xmlChar *name3);

/*
 * Constructor and destructor.
 */
XMLPUBFUN xmlHashTablePtr XMLCALL
			xmlHashCreate	(int size);
XMLPUBFUN xmlHashTablePtr XMLCALL
			xmlHashCreateDict(int size,
					 xmlDictPtr dict);
XMLPUBFUN void XMLCALL
			xmlHashFree	(xmlHashTablePtr table,
					 xmlHashDeallocator f);

/*
 * Add a new entry to the hash table.
 */
XMLPUBFUN int XMLCALL
			xmlHashAddEntry	(xmlHashTablePtr table,
		                         const xmlChar *name,
		                         void *userdata);
XMLPUBFUN int XMLCALL
			xmlHashUpdateEntry(xmlHashTablePtr table,
		                         const xmlChar *name,
		                         void *userdata,
					 xmlHashDeallocator f);
XMLPUBFUN int XMLCALL
			xmlHashAddEntry2(xmlHashTablePtr table,
		                         const xmlChar *name,
		                         const xmlChar *name2,
		                         void *userdata);
XMLPUBFUN int XMLCALL
			xmlHashUpdateEntry2(xmlHashTablePtr table,
		                         const xmlChar *name,
		                         const xmlChar *name2,
		                         void *userdata,
					 xmlHashDeallocator f);
XMLPUBFUN int XMLCALL
			xmlHashAddEntry3(xmlHashTablePtr table,
		                         const xmlChar *name,
		                         const xmlChar *name2,
		                         const xmlChar *name3,
		                         void *userdata);
XMLPUBFUN int XMLCALL
			xmlHashUpdateEntry3(xmlHashTablePtr table,
		                         const xmlChar *name,
		                         const xmlChar *name2,
		                         const xmlChar *name3,
		                         void *userdata,
					 xmlHashDeallocator f);

/*
 * Remove an entry from the hash table.
 */
XMLPUBFUN int XMLCALL
			xmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name,
                           xmlHashDeallocator f);
XMLPUBFUN int XMLCALL
			xmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name,
                            const xmlChar *name2, xmlHashDeallocator f);
XMLPUBFUN int  XMLCALL
			xmlHashRemoveEntry3(xmlHashTablePtr table, const xmlChar *name,
                            const xmlChar *name2, const xmlChar *name3,
                            xmlHashDeallocator f);

/*
 * Retrieve the userdata.
 */
XMLPUBFUN void * XMLCALL
			xmlHashLookup	(xmlHashTablePtr table,
					 const xmlChar *name);
XMLPUBFUN void * XMLCALL
			xmlHashLookup2	(xmlHashTablePtr table,
					 const xmlChar *name,
					 const xmlChar *name2);
XMLPUBFUN void * XMLCALL
			xmlHashLookup3	(xmlHashTablePtr table,
					 const xmlChar *name,
					 const xmlChar *name2,
					 const xmlChar *name3);
XMLPUBFUN void * XMLCALL
			xmlHashQLookup	(xmlHashTablePtr table,
					 const xmlChar *name,
					 const xmlChar *prefix);
XMLPUBFUN void * XMLCALL
			xmlHashQLookup2	(xmlHashTablePtr table,
					 const xmlChar *name,
					 const xmlChar *prefix,
					 const xmlChar *name2,
					 const xmlChar *prefix2);
XMLPUBFUN void * XMLCALL
			xmlHashQLookup3	(xmlHashTablePtr table,
					 const xmlChar *name,
					 const xmlChar *prefix,
					 const xmlChar *name2,
					 const xmlChar *prefix2,
					 const xmlChar *name3,
					 const xmlChar *prefix3);

/*
 * Helpers.
 */
XMLPUBFUN xmlHashTablePtr XMLCALL
			xmlHashCopy	(xmlHashTablePtr table,
					 xmlHashCopier f);
XMLPUBFUN int XMLCALL
			xmlHashSize	(xmlHashTablePtr table);
XMLPUBFUN void XMLCALL
			xmlHashScan	(xmlHashTablePtr table,
					 xmlHashScanner f,
					 void *data);
XMLPUBFUN void XMLCALL
			xmlHashScan3	(xmlHashTablePtr table,
					 const xmlChar *name,
					 const xmlChar *name2,
					 const xmlChar *name3,
					 xmlHashScanner f,
					 void *data);
XMLPUBFUN void XMLCALL
			xmlHashScanFull	(xmlHashTablePtr table,
					 xmlHashScannerFull f,
					 void *data);
XMLPUBFUN void XMLCALL
			xmlHashScanFull3(xmlHashTablePtr table,
					 const xmlChar *name,
					 const xmlChar *name2,
					 const xmlChar *name3,
					 xmlHashScannerFull f,
					 void *data);
#ifdef __cplusplus
}
#endif
#endif /* ! __XML_HASH_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlstring.h
/*
 * Summary: set of routines to process strings
 * Description: type and interfaces needed for the internal string handling
 *              of the library, especially UTF8 processing.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_STRING_H__
#define __XML_STRING_H__

#include <stdarg.h>
#include <libxml/xmlversion.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlChar:
 *
 * This is a basic byte in an UTF-8 encoded string.
 * It's unsigned allowing to pinpoint case where char * are assigned
 * to xmlChar * (possibly making serialization back impossible).
 */
typedef unsigned char xmlChar;

/**
 * BAD_CAST:
 *
 * Macro to cast a string to an xmlChar * when one know its safe.
 */
#define BAD_CAST (xmlChar *)

/*
 * xmlChar handling
 */
XMLPUBFUN xmlChar * XMLCALL
                xmlStrdup                (const xmlChar *cur);
XMLPUBFUN xmlChar * XMLCALL
                xmlStrndup               (const xmlChar *cur,
                                         int len);
XMLPUBFUN xmlChar * XMLCALL
                xmlCharStrndup           (const char *cur,
                                         int len);
XMLPUBFUN xmlChar * XMLCALL
                xmlCharStrdup            (const char *cur);
XMLPUBFUN xmlChar * XMLCALL
                xmlStrsub                (const xmlChar *str,
                                         int start,
                                         int len);
XMLPUBFUN const xmlChar * XMLCALL
                xmlStrchr                (const xmlChar *str,
                                         xmlChar val);
XMLPUBFUN const xmlChar * XMLCALL
                xmlStrstr                (const xmlChar *str,
                                         const xmlChar *val);
XMLPUBFUN const xmlChar * XMLCALL
                xmlStrcasestr            (const xmlChar *str,
                                         const xmlChar *val);
XMLPUBFUN int XMLCALL
                xmlStrcmp                (const xmlChar *str1,
                                         const xmlChar *str2);
XMLPUBFUN int XMLCALL
                xmlStrncmp               (const xmlChar *str1,
                                         const xmlChar *str2,
                                         int len);
XMLPUBFUN int XMLCALL
                xmlStrcasecmp            (const xmlChar *str1,
                                         const xmlChar *str2);
XMLPUBFUN int XMLCALL
                xmlStrncasecmp           (const xmlChar *str1,
                                         const xmlChar *str2,
                                         int len);
XMLPUBFUN int XMLCALL
                xmlStrEqual              (const xmlChar *str1,
                                         const xmlChar *str2);
XMLPUBFUN int XMLCALL
                xmlStrQEqual             (const xmlChar *pref,
                                         const xmlChar *name,
                                         const xmlChar *str);
XMLPUBFUN int XMLCALL
                xmlStrlen                (const xmlChar *str);
XMLPUBFUN xmlChar * XMLCALL
                xmlStrcat                (xmlChar *cur,
                                         const xmlChar *add);
XMLPUBFUN xmlChar * XMLCALL
                xmlStrncat               (xmlChar *cur,
                                         const xmlChar *add,
                                         int len);
XMLPUBFUN xmlChar * XMLCALL
                xmlStrncatNew            (const xmlChar *str1,
                                         const xmlChar *str2,
                                         int len);
XMLPUBFUN int XMLCALL
                xmlStrPrintf             (xmlChar *buf,
                                         int len,
                                         const xmlChar *msg,
                                         ...);
XMLPUBFUN int XMLCALL
                xmlStrVPrintf                (xmlChar *buf,
                                         int len,
                                         const xmlChar *msg,
                                         va_list ap);

XMLPUBFUN int XMLCALL
        xmlGetUTF8Char                   (const unsigned char *utf,
                                         int *len);
XMLPUBFUN int XMLCALL
        xmlCheckUTF8                     (const unsigned char *utf);
XMLPUBFUN int XMLCALL
        xmlUTF8Strsize                   (const xmlChar *utf,
                                         int len);
XMLPUBFUN xmlChar * XMLCALL
        xmlUTF8Strndup                   (const xmlChar *utf,
                                         int len);
XMLPUBFUN const xmlChar * XMLCALL
        xmlUTF8Strpos                    (const xmlChar *utf,
                                         int pos);
XMLPUBFUN int XMLCALL
        xmlUTF8Strloc                    (const xmlChar *utf,
                                         const xmlChar *utfchar);
XMLPUBFUN xmlChar * XMLCALL
        xmlUTF8Strsub                    (const xmlChar *utf,
                                         int start,
                                         int len);
XMLPUBFUN int XMLCALL
        xmlUTF8Strlen                    (const xmlChar *utf);
XMLPUBFUN int XMLCALL
        xmlUTF8Size                      (const xmlChar *utf);
XMLPUBFUN int XMLCALL
        xmlUTF8Charcmp                   (const xmlChar *utf1,
                                         const xmlChar *utf2);

#ifdef __cplusplus
}
#endif
#endif /* __XML_STRING_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/catalog.h
/**
 * Summary: interfaces to the Catalog handling system
 * Description: the catalog module implements the support for
 * XML Catalogs and SGML catalogs
 *
 * SGML Open Technical Resolution TR9401:1997.
 * http://www.jclark.com/sp/catalog.htm
 *
 * XML Catalogs Working Draft 06 August 2001
 * http://www.oasis-open.org/committees/entity/spec-2001-08-06.html
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_CATALOG_H__
#define __XML_CATALOG_H__

#include <stdio.h>

#include <libxml/xmlversion.h>
#include <libxml/xmlstring.h>
#include <libxml/tree.h>

#ifdef LIBXML_CATALOG_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

/**
 * XML_CATALOGS_NAMESPACE:
 *
 * The namespace for the XML Catalogs elements.
 */
#define XML_CATALOGS_NAMESPACE					\
    (const xmlChar *) "urn:oasis:names:tc:entity:xmlns:xml:catalog"
/**
 * XML_CATALOG_PI:
 *
 * The specific XML Catalog Processing Instuction name.
 */
#define XML_CATALOG_PI						\
    (const xmlChar *) "oasis-xml-catalog"

/*
 * The API is voluntarily limited to general cataloging.
 */
typedef enum {
    XML_CATA_PREFER_NONE = 0,
    XML_CATA_PREFER_PUBLIC = 1,
    XML_CATA_PREFER_SYSTEM
} xmlCatalogPrefer;

typedef enum {
    XML_CATA_ALLOW_NONE = 0,
    XML_CATA_ALLOW_GLOBAL = 1,
    XML_CATA_ALLOW_DOCUMENT = 2,
    XML_CATA_ALLOW_ALL = 3
} xmlCatalogAllow;

typedef struct _xmlCatalog xmlCatalog;
typedef xmlCatalog *xmlCatalogPtr;

/*
 * Operations on a given catalog.
 */
XMLPUBFUN xmlCatalogPtr XMLCALL
		xmlNewCatalog		(int sgml);
XMLPUBFUN xmlCatalogPtr XMLCALL
		xmlLoadACatalog		(const char *filename);
XMLPUBFUN xmlCatalogPtr XMLCALL
		xmlLoadSGMLSuperCatalog	(const char *filename);
XMLPUBFUN int XMLCALL
		xmlConvertSGMLCatalog	(xmlCatalogPtr catal);
XMLPUBFUN int XMLCALL
		xmlACatalogAdd		(xmlCatalogPtr catal,
					 const xmlChar *type,
					 const xmlChar *orig,
					 const xmlChar *replace);
XMLPUBFUN int XMLCALL
		xmlACatalogRemove	(xmlCatalogPtr catal,
					 const xmlChar *value);
XMLPUBFUN xmlChar * XMLCALL
		xmlACatalogResolve	(xmlCatalogPtr catal,
					 const xmlChar *pubID,
	                                 const xmlChar *sysID);
XMLPUBFUN xmlChar * XMLCALL
		xmlACatalogResolveSystem(xmlCatalogPtr catal,
					 const xmlChar *sysID);
XMLPUBFUN xmlChar * XMLCALL
		xmlACatalogResolvePublic(xmlCatalogPtr catal,
					 const xmlChar *pubID);
XMLPUBFUN xmlChar * XMLCALL
		xmlACatalogResolveURI	(xmlCatalogPtr catal,
					 const xmlChar *URI);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void XMLCALL
		xmlACatalogDump		(xmlCatalogPtr catal,
					 FILE *out);
#endif /* LIBXML_OUTPUT_ENABLED */
XMLPUBFUN void XMLCALL
		xmlFreeCatalog		(xmlCatalogPtr catal);
XMLPUBFUN int XMLCALL
		xmlCatalogIsEmpty	(xmlCatalogPtr catal);

/*
 * Global operations.
 */
XMLPUBFUN void XMLCALL
		xmlInitializeCatalog	(void);
XMLPUBFUN int XMLCALL
		xmlLoadCatalog		(const char *filename);
XMLPUBFUN void XMLCALL
		xmlLoadCatalogs		(const char *paths);
XMLPUBFUN void XMLCALL
		xmlCatalogCleanup	(void);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void XMLCALL
		xmlCatalogDump		(FILE *out);
#endif /* LIBXML_OUTPUT_ENABLED */
XMLPUBFUN xmlChar * XMLCALL
		xmlCatalogResolve	(const xmlChar *pubID,
	                                 const xmlChar *sysID);
XMLPUBFUN xmlChar * XMLCALL
		xmlCatalogResolveSystem	(const xmlChar *sysID);
XMLPUBFUN xmlChar * XMLCALL
		xmlCatalogResolvePublic	(const xmlChar *pubID);
XMLPUBFUN xmlChar * XMLCALL
		xmlCatalogResolveURI	(const xmlChar *URI);
XMLPUBFUN int XMLCALL
		xmlCatalogAdd		(const xmlChar *type,
					 const xmlChar *orig,
					 const xmlChar *replace);
XMLPUBFUN int XMLCALL
		xmlCatalogRemove	(const xmlChar *value);
XMLPUBFUN xmlDocPtr XMLCALL
		xmlParseCatalogFile	(const char *filename);
XMLPUBFUN int XMLCALL
		xmlCatalogConvert	(void);

/*
 * Strictly minimal interfaces for per-document catalogs used
 * by the parser.
 */
XMLPUBFUN void XMLCALL
		xmlCatalogFreeLocal	(void *catalogs);
XMLPUBFUN void * XMLCALL
		xmlCatalogAddLocal	(void *catalogs,
					 const xmlChar *URL);
XMLPUBFUN xmlChar * XMLCALL
		xmlCatalogLocalResolve	(void *catalogs,
					 const xmlChar *pubID,
	                                 const xmlChar *sysID);
XMLPUBFUN xmlChar * XMLCALL
		xmlCatalogLocalResolveURI(void *catalogs,
					 const xmlChar *URI);
/*
 * Preference settings.
 */
XMLPUBFUN int XMLCALL
		xmlCatalogSetDebug	(int level);
XMLPUBFUN xmlCatalogPrefer XMLCALL
		xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer);
XMLPUBFUN void XMLCALL
		xmlCatalogSetDefaults	(xmlCatalogAllow allow);
XMLPUBFUN xmlCatalogAllow XMLCALL
		xmlCatalogGetDefaults	(void);


/* DEPRECATED interfaces */
XMLPUBFUN const xmlChar * XMLCALL
		xmlCatalogGetSystem	(const xmlChar *sysID);
XMLPUBFUN const xmlChar * XMLCALL
		xmlCatalogGetPublic	(const xmlChar *pubID);

#ifdef __cplusplus
}
#endif
#endif /* LIBXML_CATALOG_ENABLED */
#endif /* __XML_CATALOG_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlregexp.h
/*
 * Summary: regular expressions handling
 * Description: basic API for libxml regular expressions handling used
 *              for XML Schemas and validation.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_REGEXP_H__
#define __XML_REGEXP_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_REGEXP_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlRegexpPtr:
 *
 * A libxml regular expression, they can actually be far more complex
 * thank the POSIX regex expressions.
 */
typedef struct _xmlRegexp xmlRegexp;
typedef xmlRegexp *xmlRegexpPtr;

/**
 * xmlRegExecCtxtPtr:
 *
 * A libxml progressive regular expression evaluation context
 */
typedef struct _xmlRegExecCtxt xmlRegExecCtxt;
typedef xmlRegExecCtxt *xmlRegExecCtxtPtr;

#ifdef __cplusplus
}
#endif
#include <libxml/tree.h>
#include <libxml/dict.h>
#ifdef __cplusplus
extern "C" {
#endif

/*
 * The POSIX like API
 */
XMLPUBFUN xmlRegexpPtr XMLCALL
		    xmlRegexpCompile	(const xmlChar *regexp);
XMLPUBFUN void XMLCALL			 xmlRegFreeRegexp(xmlRegexpPtr regexp);
XMLPUBFUN int XMLCALL
		    xmlRegexpExec	(xmlRegexpPtr comp,
					 const xmlChar *value);
XMLPUBFUN void XMLCALL
		    xmlRegexpPrint	(FILE *output,
					 xmlRegexpPtr regexp);
XMLPUBFUN int XMLCALL
		    xmlRegexpIsDeterminist(xmlRegexpPtr comp);

/**
 * xmlRegExecCallbacks:
 * @exec: the regular expression context
 * @token: the current token string
 * @transdata: transition data
 * @inputdata: input data
 *
 * Callback function when doing a transition in the automata
 */
typedef void (*xmlRegExecCallbacks) (xmlRegExecCtxtPtr exec,
	                             const xmlChar *token,
				     void *transdata,
				     void *inputdata);

/*
 * The progressive API
 */
XMLPUBFUN xmlRegExecCtxtPtr XMLCALL
		    xmlRegNewExecCtxt	(xmlRegexpPtr comp,
					 xmlRegExecCallbacks callback,
					 void *data);
XMLPUBFUN void XMLCALL
		    xmlRegFreeExecCtxt	(xmlRegExecCtxtPtr exec);
XMLPUBFUN int XMLCALL
		    xmlRegExecPushString(xmlRegExecCtxtPtr exec,
					 const xmlChar *value,
					 void *data);
XMLPUBFUN int XMLCALL
		    xmlRegExecPushString2(xmlRegExecCtxtPtr exec,
					 const xmlChar *value,
					 const xmlChar *value2,
					 void *data);

XMLPUBFUN int XMLCALL
		    xmlRegExecNextValues(xmlRegExecCtxtPtr exec,
					 int *nbval,
					 int *nbneg,
					 xmlChar **values,
					 int *terminal);
XMLPUBFUN int XMLCALL
		    xmlRegExecErrInfo	(xmlRegExecCtxtPtr exec,
					 const xmlChar **string,
					 int *nbval,
					 int *nbneg,
					 xmlChar **values,
					 int *terminal);
#ifdef LIBXML_EXPR_ENABLED
/*
 * Formal regular expression handling
 * Its goal is to do some formal work on content models
 */

/* expressions are used within a context */
typedef struct _xmlExpCtxt xmlExpCtxt;
typedef xmlExpCtxt *xmlExpCtxtPtr;

XMLPUBFUN void XMLCALL
			xmlExpFreeCtxt	(xmlExpCtxtPtr ctxt);
XMLPUBFUN xmlExpCtxtPtr XMLCALL
			xmlExpNewCtxt	(int maxNodes,
					 xmlDictPtr dict);

XMLPUBFUN int XMLCALL
			xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
			xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt);

/* Expressions are trees but the tree is opaque */
typedef struct _xmlExpNode xmlExpNode;
typedef xmlExpNode *xmlExpNodePtr;

typedef enum {
    XML_EXP_EMPTY = 0,
    XML_EXP_FORBID = 1,
    XML_EXP_ATOM = 2,
    XML_EXP_SEQ = 3,
    XML_EXP_OR = 4,
    XML_EXP_COUNT = 5
} xmlExpNodeType;

/*
 * 2 core expressions shared by all for the empty language set
 * and for the set with just the empty token
 */
XMLPUBVAR xmlExpNodePtr forbiddenExp;
XMLPUBVAR xmlExpNodePtr emptyExp;

/*
 * Expressions are reference counted internally
 */
XMLPUBFUN void XMLCALL
			xmlExpFree	(xmlExpCtxtPtr ctxt,
					 xmlExpNodePtr expr);
XMLPUBFUN void XMLCALL
			xmlExpRef	(xmlExpNodePtr expr);

/*
 * constructors can be either manual or from a string
 */
XMLPUBFUN xmlExpNodePtr XMLCALL
			xmlExpParse	(xmlExpCtxtPtr ctxt,
					 const char *expr);
XMLPUBFUN xmlExpNodePtr XMLCALL
			xmlExpNewAtom	(xmlExpCtxtPtr ctxt,
					 const xmlChar *name,
					 int len);
XMLPUBFUN xmlExpNodePtr XMLCALL
			xmlExpNewOr	(xmlExpCtxtPtr ctxt,
					 xmlExpNodePtr left,
					 xmlExpNodePtr right);
XMLPUBFUN xmlExpNodePtr XMLCALL
			xmlExpNewSeq	(xmlExpCtxtPtr ctxt,
					 xmlExpNodePtr left,
					 xmlExpNodePtr right);
XMLPUBFUN xmlExpNodePtr XMLCALL
			xmlExpNewRange	(xmlExpCtxtPtr ctxt,
					 xmlExpNodePtr subset,
					 int min,
					 int max);
/*
 * The really interesting APIs
 */
XMLPUBFUN int XMLCALL
			xmlExpIsNillable(xmlExpNodePtr expr);
XMLPUBFUN int XMLCALL
			xmlExpMaxToken	(xmlExpNodePtr expr);
XMLPUBFUN int XMLCALL
			xmlExpGetLanguage(xmlExpCtxtPtr ctxt,
					 xmlExpNodePtr expr,
					 const xmlChar**langList,
					 int len);
XMLPUBFUN int XMLCALL
			xmlExpGetStart	(xmlExpCtxtPtr ctxt,
					 xmlExpNodePtr expr,
					 const xmlChar**tokList,
					 int len);
XMLPUBFUN xmlExpNodePtr XMLCALL
			xmlExpStringDerive(xmlExpCtxtPtr ctxt,
					 xmlExpNodePtr expr,
					 const xmlChar *str,
					 int len);
XMLPUBFUN xmlExpNodePtr XMLCALL
			xmlExpExpDerive	(xmlExpCtxtPtr ctxt,
					 xmlExpNodePtr expr,
					 xmlExpNodePtr sub);
XMLPUBFUN int XMLCALL
			xmlExpSubsume	(xmlExpCtxtPtr ctxt,
					 xmlExpNodePtr expr,
					 xmlExpNodePtr sub);
XMLPUBFUN void XMLCALL
			xmlExpDump	(xmlBufferPtr buf,
					 xmlExpNodePtr expr);
#endif /* LIBXML_EXPR_ENABLED */
#ifdef __cplusplus
}
#endif

#endif /* LIBXML_REGEXP_ENABLED */

#endif /*__XML_REGEXP_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/threads.h
/**
 * Summary: interfaces for thread handling
 * Description: set of generic threading related routines
 *              should work with pthreads, Windows native or TLS threads
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_THREADS_H__
#define __XML_THREADS_H__

#include <libxml/xmlversion.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * xmlMutex are a simple mutual exception locks.
 */
typedef struct _xmlMutex xmlMutex;
typedef xmlMutex *xmlMutexPtr;

/*
 * xmlRMutex are reentrant mutual exception locks.
 */
typedef struct _xmlRMutex xmlRMutex;
typedef xmlRMutex *xmlRMutexPtr;

#ifdef __cplusplus
}
#endif
#include <libxml/globals.h>
#ifdef __cplusplus
extern "C" {
#endif
XMLPUBFUN xmlMutexPtr XMLCALL
			xmlNewMutex	(void);
XMLPUBFUN void XMLCALL
			xmlMutexLock	(xmlMutexPtr tok);
XMLPUBFUN void XMLCALL
			xmlMutexUnlock	(xmlMutexPtr tok);
XMLPUBFUN void XMLCALL
			xmlFreeMutex	(xmlMutexPtr tok);

XMLPUBFUN xmlRMutexPtr XMLCALL
			xmlNewRMutex	(void);
XMLPUBFUN void XMLCALL
			xmlRMutexLock	(xmlRMutexPtr tok);
XMLPUBFUN void XMLCALL
			xmlRMutexUnlock	(xmlRMutexPtr tok);
XMLPUBFUN void XMLCALL
			xmlFreeRMutex	(xmlRMutexPtr tok);

/*
 * Library wide APIs.
 */
XMLPUBFUN void XMLCALL
			xmlInitThreads	(void);
XMLPUBFUN void XMLCALL
			xmlLockLibrary	(void);
XMLPUBFUN void XMLCALL
			xmlUnlockLibrary(void);
XMLPUBFUN int XMLCALL
			xmlGetThreadId	(void);
XMLPUBFUN int XMLCALL
			xmlIsMainThread	(void);
XMLPUBFUN void XMLCALL
			xmlCleanupThreads(void);
XMLPUBFUN xmlGlobalStatePtr XMLCALL
			xmlGetGlobalState(void);

#if defined(HAVE_WIN32_THREADS) && !defined(HAVE_COMPILER_TLS) && defined(LIBXML_STATIC_FOR_DLL)
int XMLCALL xmlDllMain(void *hinstDLL, unsigned long fdwReason, void *lpvReserved);
#endif

#ifdef __cplusplus
}
#endif


#endif /* __XML_THREADS_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/dict.h
/*
 * Summary: string dictionnary
 * Description: dictionary of reusable strings, just used to avoid allocation
 *         and freeing operations.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_DICT_H__
#define __XML_DICT_H__

#include <limits.h>
#include <libxml/xmlversion.h>
#include <libxml/tree.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The dictionnary.
 */
typedef struct _xmlDict xmlDict;
typedef xmlDict *xmlDictPtr;

/*
 * Initializer
 */
XMLPUBFUN int XMLCALL  xmlInitializeDict(void);

/*
 * Constructor and destructor.
 */
XMLPUBFUN xmlDictPtr XMLCALL
			xmlDictCreate	(void);
XMLPUBFUN size_t XMLCALL
			xmlDictSetLimit	(xmlDictPtr dict,
                                         size_t limit);
XMLPUBFUN size_t XMLCALL
			xmlDictGetUsage (xmlDictPtr dict);
XMLPUBFUN xmlDictPtr XMLCALL
			xmlDictCreateSub(xmlDictPtr sub);
XMLPUBFUN int XMLCALL
			xmlDictReference(xmlDictPtr dict);
XMLPUBFUN void XMLCALL
			xmlDictFree	(xmlDictPtr dict);

/*
 * Lookup of entry in the dictionnary.
 */
XMLPUBFUN const xmlChar * XMLCALL
			xmlDictLookup	(xmlDictPtr dict,
		                         const xmlChar *name,
		                         int len);
XMLPUBFUN const xmlChar * XMLCALL
			xmlDictExists	(xmlDictPtr dict,
		                         const xmlChar *name,
		                         int len);
XMLPUBFUN const xmlChar * XMLCALL
			xmlDictQLookup	(xmlDictPtr dict,
		                         const xmlChar *prefix,
		                         const xmlChar *name);
XMLPUBFUN int XMLCALL
			xmlDictOwns	(xmlDictPtr dict,
					 const xmlChar *str);
XMLPUBFUN int XMLCALL
			xmlDictSize	(xmlDictPtr dict);

/*
 * Cleanup function
 */
XMLPUBFUN void XMLCALL
                        xmlDictCleanup  (void);

#ifdef __cplusplus
}
#endif
#endif /* ! __XML_DICT_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xpath.h
/*
 * Summary: XML Path Language implementation
 * Description: API for the XML Path Language implementation
 *
 * XML Path Language implementation
 * XPath is a language for addressing parts of an XML document,
 * designed to be used by both XSLT and XPointer
 *     http://www.w3.org/TR/xpath
 *
 * Implements
 * W3C Recommendation 16 November 1999
 *     http://www.w3.org/TR/1999/REC-xpath-19991116
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_XPATH_H__
#define __XML_XPATH_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_XPATH_ENABLED

#include <libxml/xmlerror.h>
#include <libxml/tree.h>
#include <libxml/hash.h>
#endif /* LIBXML_XPATH_ENABLED */

#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
#ifdef __cplusplus
extern "C" {
#endif
#endif /* LIBXML_XPATH_ENABLED or LIBXML_SCHEMAS_ENABLED */

#ifdef LIBXML_XPATH_ENABLED

typedef struct _xmlXPathContext xmlXPathContext;
typedef xmlXPathContext *xmlXPathContextPtr;
typedef struct _xmlXPathParserContext xmlXPathParserContext;
typedef xmlXPathParserContext *xmlXPathParserContextPtr;

/**
 * The set of XPath error codes.
 */

typedef enum {
    XPATH_EXPRESSION_OK = 0,
    XPATH_NUMBER_ERROR,
    XPATH_UNFINISHED_LITERAL_ERROR,
    XPATH_START_LITERAL_ERROR,
    XPATH_VARIABLE_REF_ERROR,
    XPATH_UNDEF_VARIABLE_ERROR,
    XPATH_INVALID_PREDICATE_ERROR,
    XPATH_EXPR_ERROR,
    XPATH_UNCLOSED_ERROR,
    XPATH_UNKNOWN_FUNC_ERROR,
    XPATH_INVALID_OPERAND,
    XPATH_INVALID_TYPE,
    XPATH_INVALID_ARITY,
    XPATH_INVALID_CTXT_SIZE,
    XPATH_INVALID_CTXT_POSITION,
    XPATH_MEMORY_ERROR,
    XPTR_SYNTAX_ERROR,
    XPTR_RESOURCE_ERROR,
    XPTR_SUB_RESOURCE_ERROR,
    XPATH_UNDEF_PREFIX_ERROR,
    XPATH_ENCODING_ERROR,
    XPATH_INVALID_CHAR_ERROR,
    XPATH_INVALID_CTXT,
    XPATH_STACK_ERROR,
    XPATH_FORBID_VARIABLE_ERROR
} xmlXPathError;

/*
 * A node-set (an unordered collection of nodes without duplicates).
 */
typedef struct _xmlNodeSet xmlNodeSet;
typedef xmlNodeSet *xmlNodeSetPtr;
struct _xmlNodeSet {
    int nodeNr;			/* number of nodes in the set */
    int nodeMax;		/* size of the array as allocated */
    xmlNodePtr *nodeTab;	/* array of nodes in no particular order */
    /* @@ with_ns to check wether namespace nodes should be looked at @@ */
};

/*
 * An expression is evaluated to yield an object, which
 * has one of the following four basic types:
 *   - node-set
 *   - boolean
 *   - number
 *   - string
 *
 * @@ XPointer will add more types !
 */

typedef enum {
    XPATH_UNDEFINED = 0,
    XPATH_NODESET = 1,
    XPATH_BOOLEAN = 2,
    XPATH_NUMBER = 3,
    XPATH_STRING = 4,
    XPATH_POINT = 5,
    XPATH_RANGE = 6,
    XPATH_LOCATIONSET = 7,
    XPATH_USERS = 8,
    XPATH_XSLT_TREE = 9  /* An XSLT value tree, non modifiable */
} xmlXPathObjectType;

typedef struct _xmlXPathObject xmlXPathObject;
typedef xmlXPathObject *xmlXPathObjectPtr;
struct _xmlXPathObject {
    xmlXPathObjectType type;
    xmlNodeSetPtr nodesetval;
    int boolval;
    double floatval;
    xmlChar *stringval;
    void *user;
    int index;
    void *user2;
    int index2;
};

/**
 * xmlXPathConvertFunc:
 * @obj:  an XPath object
 * @type:  the number of the target type
 *
 * A conversion function is associated to a type and used to cast
 * the new type to primitive values.
 *
 * Returns -1 in case of error, 0 otherwise
 */
typedef int (*xmlXPathConvertFunc) (xmlXPathObjectPtr obj, int type);

/*
 * Extra type: a name and a conversion function.
 */

typedef struct _xmlXPathType xmlXPathType;
typedef xmlXPathType *xmlXPathTypePtr;
struct _xmlXPathType {
    const xmlChar         *name;		/* the type name */
    xmlXPathConvertFunc func;		/* the conversion function */
};

/*
 * Extra variable: a name and a value.
 */

typedef struct _xmlXPathVariable xmlXPathVariable;
typedef xmlXPathVariable *xmlXPathVariablePtr;
struct _xmlXPathVariable {
    const xmlChar       *name;		/* the variable name */
    xmlXPathObjectPtr value;		/* the value */
};

/**
 * xmlXPathEvalFunc:
 * @ctxt: an XPath parser context
 * @nargs: the number of arguments passed to the function
 *
 * An XPath evaluation function, the parameters are on the XPath context stack.
 */

typedef void (*xmlXPathEvalFunc)(xmlXPathParserContextPtr ctxt,
	                         int nargs);

/*
 * Extra function: a name and a evaluation function.
 */

typedef struct _xmlXPathFunct xmlXPathFunct;
typedef xmlXPathFunct *xmlXPathFuncPtr;
struct _xmlXPathFunct {
    const xmlChar      *name;		/* the function name */
    xmlXPathEvalFunc func;		/* the evaluation function */
};

/**
 * xmlXPathAxisFunc:
 * @ctxt:  the XPath interpreter context
 * @cur:  the previous node being explored on that axis
 *
 * An axis traversal function. To traverse an axis, the engine calls
 * the first time with cur == NULL and repeat until the function returns
 * NULL indicating the end of the axis traversal.
 *
 * Returns the next node in that axis or NULL if at the end of the axis.
 */

typedef xmlXPathObjectPtr (*xmlXPathAxisFunc) (xmlXPathParserContextPtr ctxt,
				 xmlXPathObjectPtr cur);

/*
 * Extra axis: a name and an axis function.
 */

typedef struct _xmlXPathAxis xmlXPathAxis;
typedef xmlXPathAxis *xmlXPathAxisPtr;
struct _xmlXPathAxis {
    const xmlChar      *name;		/* the axis name */
    xmlXPathAxisFunc func;		/* the search function */
};

/**
 * xmlXPathFunction:
 * @ctxt:  the XPath interprestation context
 * @nargs:  the number of arguments
 *
 * An XPath function.
 * The arguments (if any) are popped out from the context stack
 * and the result is pushed on the stack.
 */

typedef void (*xmlXPathFunction) (xmlXPathParserContextPtr ctxt, int nargs);

/*
 * Function and Variable Lookup.
 */

/**
 * xmlXPathVariableLookupFunc:
 * @ctxt:  an XPath context
 * @name:  name of the variable
 * @ns_uri:  the namespace name hosting this variable
 *
 * Prototype for callbacks used to plug variable lookup in the XPath
 * engine.
 *
 * Returns the XPath object value or NULL if not found.
 */
typedef xmlXPathObjectPtr (*xmlXPathVariableLookupFunc) (void *ctxt,
                                         const xmlChar *name,
                                         const xmlChar *ns_uri);

/**
 * xmlXPathFuncLookupFunc:
 * @ctxt:  an XPath context
 * @name:  name of the function
 * @ns_uri:  the namespace name hosting this function
 *
 * Prototype for callbacks used to plug function lookup in the XPath
 * engine.
 *
 * Returns the XPath function or NULL if not found.
 */
typedef xmlXPathFunction (*xmlXPathFuncLookupFunc) (void *ctxt,
					 const xmlChar *name,
					 const xmlChar *ns_uri);

/**
 * xmlXPathFlags:
 * Flags for XPath engine compilation and runtime
 */
/**
 * XML_XPATH_CHECKNS:
 *
 * check namespaces at compilation
 */
#define XML_XPATH_CHECKNS (1<<0)
/**
 * XML_XPATH_NOVAR:
 *
 * forbid variables in expression
 */
#define XML_XPATH_NOVAR	  (1<<1)

/**
 * xmlXPathContext:
 *
 * Expression evaluation occurs with respect to a context.
 * he context consists of:
 *    - a node (the context node)
 *    - a node list (the context node list)
 *    - a set of variable bindings
 *    - a function library
 *    - the set of namespace declarations in scope for the expression
 * Following the switch to hash tables, this need to be trimmed up at
 * the next binary incompatible release.
 * The node may be modified when the context is passed to libxml2
 * for an XPath evaluation so you may need to initialize it again
 * before the next call.
 */

struct _xmlXPathContext {
    xmlDocPtr doc;			/* The current document */
    xmlNodePtr node;			/* The current node */

    int nb_variables_unused;		/* unused (hash table) */
    int max_variables_unused;		/* unused (hash table) */
    xmlHashTablePtr varHash;		/* Hash table of defined variables */

    int nb_types;			/* number of defined types */
    int max_types;			/* max number of types */
    xmlXPathTypePtr types;		/* Array of defined types */

    int nb_funcs_unused;		/* unused (hash table) */
    int max_funcs_unused;		/* unused (hash table) */
    xmlHashTablePtr funcHash;		/* Hash table of defined funcs */

    int nb_axis;			/* number of defined axis */
    int max_axis;			/* max number of axis */
    xmlXPathAxisPtr axis;		/* Array of defined axis */

    /* the namespace nodes of the context node */
    xmlNsPtr *namespaces;		/* Array of namespaces */
    int nsNr;				/* number of namespace in scope */
    void *user;				/* function to free */

    /* extra variables */
    int contextSize;			/* the context size */
    int proximityPosition;		/* the proximity position */

    /* extra stuff for XPointer */
    int xptr;				/* is this an XPointer context? */
    xmlNodePtr here;			/* for here() */
    xmlNodePtr origin;			/* for origin() */

    /* the set of namespace declarations in scope for the expression */
    xmlHashTablePtr nsHash;		/* The namespaces hash table */
    xmlXPathVariableLookupFunc varLookupFunc;/* variable lookup func */
    void *varLookupData;		/* variable lookup data */

    /* Possibility to link in an extra item */
    void *extra;                        /* needed for XSLT */

    /* The function name and URI when calling a function */
    const xmlChar *function;
    const xmlChar *functionURI;

    /* function lookup function and data */
    xmlXPathFuncLookupFunc funcLookupFunc;/* function lookup func */
    void *funcLookupData;		/* function lookup data */

    /* temporary namespace lists kept for walking the namespace axis */
    xmlNsPtr *tmpNsList;		/* Array of namespaces */
    int tmpNsNr;			/* number of namespaces in scope */

    /* error reporting mechanism */
    void *userData;                     /* user specific data block */
    xmlStructuredErrorFunc error;       /* the callback in case of errors */
    xmlError lastError;			/* the last error */
    xmlNodePtr debugNode;		/* the source node XSLT */

    /* dictionary */
    xmlDictPtr dict;			/* dictionary if any */

    int flags;				/* flags to control compilation */

    /* Cache for reusal of XPath objects */
    void *cache;
};

/*
 * The structure of a compiled expression form is not public.
 */

typedef struct _xmlXPathCompExpr xmlXPathCompExpr;
typedef xmlXPathCompExpr *xmlXPathCompExprPtr;

/**
 * xmlXPathParserContext:
 *
 * An XPath parser context. It contains pure parsing informations,
 * an xmlXPathContext, and the stack of objects.
 */
struct _xmlXPathParserContext {
    const xmlChar *cur;			/* the current char being parsed */
    const xmlChar *base;			/* the full expression */

    int error;				/* error code */

    xmlXPathContextPtr  context;	/* the evaluation context */
    xmlXPathObjectPtr     value;	/* the current value */
    int                 valueNr;	/* number of values stacked */
    int                valueMax;	/* max number of values stacked */
    xmlXPathObjectPtr *valueTab;	/* stack of values */

    xmlXPathCompExprPtr comp;		/* the precompiled expression */
    int xptr;				/* it this an XPointer expression */
    xmlNodePtr         ancestor;	/* used for walking preceding axis */

    int              valueFrame;        /* used to limit Pop on the stack */
};

/************************************************************************
 *									*
 *			Public API					*
 *									*
 ************************************************************************/

/**
 * Objects and Nodesets handling
 */

XMLPUBVAR double xmlXPathNAN;
XMLPUBVAR double xmlXPathPINF;
XMLPUBVAR double xmlXPathNINF;

/* These macros may later turn into functions */
/**
 * xmlXPathNodeSetGetLength:
 * @ns:  a node-set
 *
 * Implement a functionality similar to the DOM NodeList.length.
 *
 * Returns the number of nodes in the node-set.
 */
#define xmlXPathNodeSetGetLength(ns) ((ns) ? (ns)->nodeNr : 0)
/**
 * xmlXPathNodeSetItem:
 * @ns:  a node-set
 * @index:  index of a node in the set
 *
 * Implements a functionality similar to the DOM NodeList.item().
 *
 * Returns the xmlNodePtr at the given @index in @ns or NULL if
 *         @index is out of range (0 to length-1)
 */
#define xmlXPathNodeSetItem(ns, index)				\
		((((ns) != NULL) &&				\
		  ((index) >= 0) && ((index) < (ns)->nodeNr)) ?	\
		 (ns)->nodeTab[(index)]				\
		 : NULL)
/**
 * xmlXPathNodeSetIsEmpty:
 * @ns: a node-set
 *
 * Checks whether @ns is empty or not.
 *
 * Returns %TRUE if @ns is an empty node-set.
 */
#define xmlXPathNodeSetIsEmpty(ns)                                      \
    (((ns) == NULL) || ((ns)->nodeNr == 0) || ((ns)->nodeTab == NULL))


XMLPUBFUN void XMLCALL
		    xmlXPathFreeObject		(xmlXPathObjectPtr obj);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		    xmlXPathNodeSetCreate	(xmlNodePtr val);
XMLPUBFUN void XMLCALL
		    xmlXPathFreeNodeSetList	(xmlXPathObjectPtr obj);
XMLPUBFUN void XMLCALL
		    xmlXPathFreeNodeSet		(xmlNodeSetPtr obj);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPathObjectCopy		(xmlXPathObjectPtr val);
XMLPUBFUN int XMLCALL
		    xmlXPathCmpNodes		(xmlNodePtr node1,
						 xmlNodePtr node2);
/**
 * Conversion functions to basic types.
 */
XMLPUBFUN int XMLCALL
		    xmlXPathCastNumberToBoolean	(double val);
XMLPUBFUN int XMLCALL
		    xmlXPathCastStringToBoolean	(const xmlChar * val);
XMLPUBFUN int XMLCALL
		    xmlXPathCastNodeSetToBoolean(xmlNodeSetPtr ns);
XMLPUBFUN int XMLCALL
		    xmlXPathCastToBoolean	(xmlXPathObjectPtr val);

XMLPUBFUN double XMLCALL
		    xmlXPathCastBooleanToNumber	(int val);
XMLPUBFUN double XMLCALL
		    xmlXPathCastStringToNumber	(const xmlChar * val);
XMLPUBFUN double XMLCALL
		    xmlXPathCastNodeToNumber	(xmlNodePtr node);
XMLPUBFUN double XMLCALL
		    xmlXPathCastNodeSetToNumber	(xmlNodeSetPtr ns);
XMLPUBFUN double XMLCALL
		    xmlXPathCastToNumber	(xmlXPathObjectPtr val);

XMLPUBFUN xmlChar * XMLCALL
		    xmlXPathCastBooleanToString	(int val);
XMLPUBFUN xmlChar * XMLCALL
		    xmlXPathCastNumberToString	(double val);
XMLPUBFUN xmlChar * XMLCALL
		    xmlXPathCastNodeToString	(xmlNodePtr node);
XMLPUBFUN xmlChar * XMLCALL
		    xmlXPathCastNodeSetToString	(xmlNodeSetPtr ns);
XMLPUBFUN xmlChar * XMLCALL
		    xmlXPathCastToString	(xmlXPathObjectPtr val);

XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPathConvertBoolean	(xmlXPathObjectPtr val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPathConvertNumber	(xmlXPathObjectPtr val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPathConvertString	(xmlXPathObjectPtr val);

/**
 * Context handling.
 */
XMLPUBFUN xmlXPathContextPtr XMLCALL
		    xmlXPathNewContext		(xmlDocPtr doc);
XMLPUBFUN void XMLCALL
		    xmlXPathFreeContext		(xmlXPathContextPtr ctxt);
XMLPUBFUN int XMLCALL
		    xmlXPathContextSetCache(xmlXPathContextPtr ctxt,
				            int active,
					    int value,
					    int options);
/**
 * Evaluation functions.
 */
XMLPUBFUN long XMLCALL
		    xmlXPathOrderDocElems	(xmlDocPtr doc);
XMLPUBFUN int XMLCALL
		    xmlXPathSetContextNode	(xmlNodePtr node,
						 xmlXPathContextPtr ctx);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPathNodeEval		(xmlNodePtr node,
						 const xmlChar *str,
						 xmlXPathContextPtr ctx);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPathEval		(const xmlChar *str,
						 xmlXPathContextPtr ctx);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPathEvalExpression	(const xmlChar *str,
						 xmlXPathContextPtr ctxt);
XMLPUBFUN int XMLCALL
		    xmlXPathEvalPredicate	(xmlXPathContextPtr ctxt,
						 xmlXPathObjectPtr res);
/**
 * Separate compilation/evaluation entry points.
 */
XMLPUBFUN xmlXPathCompExprPtr XMLCALL
		    xmlXPathCompile		(const xmlChar *str);
XMLPUBFUN xmlXPathCompExprPtr XMLCALL
		    xmlXPathCtxtCompile		(xmlXPathContextPtr ctxt,
						 const xmlChar *str);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		    xmlXPathCompiledEval	(xmlXPathCompExprPtr comp,
						 xmlXPathContextPtr ctx);
XMLPUBFUN int XMLCALL
		    xmlXPathCompiledEvalToBoolean(xmlXPathCompExprPtr comp,
						 xmlXPathContextPtr ctxt);
XMLPUBFUN void XMLCALL
		    xmlXPathFreeCompExpr	(xmlXPathCompExprPtr comp);
#endif /* LIBXML_XPATH_ENABLED */
#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
XMLPUBFUN void XMLCALL
		    xmlXPathInit		(void);
XMLPUBFUN int XMLCALL
		xmlXPathIsNaN	(double val);
XMLPUBFUN int XMLCALL
		xmlXPathIsInf	(double val);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_XPATH_ENABLED or LIBXML_SCHEMAS_ENABLED*/
#endif /* ! __XML_XPATH_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/valid.h
/*
 * Summary: The DTD validation
 * Description: API for the DTD handling and the validity checking
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */


#ifndef __XML_VALID_H__
#define __XML_VALID_H__

#include <libxml/xmlversion.h>
#include <libxml/xmlerror.h>
#include <libxml/tree.h>
#include <libxml/list.h>
#include <libxml/xmlautomata.h>
#include <libxml/xmlregexp.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Validation state added for non-determinist content model.
 */
typedef struct _xmlValidState xmlValidState;
typedef xmlValidState *xmlValidStatePtr;

/**
 * xmlValidityErrorFunc:
 * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
 *        but comes from ctxt->userData (which normally contains such
 *        a pointer); ctxt->userData can be changed by the user.
 * @msg:  the string to format *printf like vararg
 * @...:  remaining arguments to the format
 *
 * Callback called when a validity error is found. This is a message
 * oriented function similar to an *printf function.
 */
typedef void (XMLCDECL *xmlValidityErrorFunc) (void *ctx,
			     const char *msg,
			     ...) LIBXML_ATTR_FORMAT(2,3);

/**
 * xmlValidityWarningFunc:
 * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
 *        but comes from ctxt->userData (which normally contains such
 *        a pointer); ctxt->userData can be changed by the user.
 * @msg:  the string to format *printf like vararg
 * @...:  remaining arguments to the format
 *
 * Callback called when a validity warning is found. This is a message
 * oriented function similar to an *printf function.
 */
typedef void (XMLCDECL *xmlValidityWarningFunc) (void *ctx,
			       const char *msg,
			       ...) LIBXML_ATTR_FORMAT(2,3);

#ifdef IN_LIBXML
/**
 * XML_CTXT_FINISH_DTD_0:
 *
 * Special value for finishDtd field when embedded in an xmlParserCtxt
 */
#define XML_CTXT_FINISH_DTD_0 0xabcd1234
/**
 * XML_CTXT_FINISH_DTD_1:
 *
 * Special value for finishDtd field when embedded in an xmlParserCtxt
 */
#define XML_CTXT_FINISH_DTD_1 0xabcd1235
#endif

/*
 * xmlValidCtxt:
 * An xmlValidCtxt is used for error reporting when validating.
 */
typedef struct _xmlValidCtxt xmlValidCtxt;
typedef xmlValidCtxt *xmlValidCtxtPtr;
struct _xmlValidCtxt {
    void *userData;			/* user specific data block */
    xmlValidityErrorFunc error;		/* the callback in case of errors */
    xmlValidityWarningFunc warning;	/* the callback in case of warning */

    /* Node analysis stack used when validating within entities */
    xmlNodePtr         node;          /* Current parsed Node */
    int                nodeNr;        /* Depth of the parsing stack */
    int                nodeMax;       /* Max depth of the parsing stack */
    xmlNodePtr        *nodeTab;       /* array of nodes */

    unsigned int     finishDtd;       /* finished validating the Dtd ? */
    xmlDocPtr              doc;       /* the document */
    int                  valid;       /* temporary validity check result */

    /* state state used for non-determinist content validation */
    xmlValidState     *vstate;        /* current state */
    int                vstateNr;      /* Depth of the validation stack */
    int                vstateMax;     /* Max depth of the validation stack */
    xmlValidState     *vstateTab;     /* array of validation states */

#ifdef LIBXML_REGEXP_ENABLED
    xmlAutomataPtr            am;     /* the automata */
    xmlAutomataStatePtr    state;     /* used to build the automata */
#else
    void                     *am;
    void                  *state;
#endif
};

/*
 * ALL notation declarations are stored in a table.
 * There is one table per DTD.
 */

typedef struct _xmlHashTable xmlNotationTable;
typedef xmlNotationTable *xmlNotationTablePtr;

/*
 * ALL element declarations are stored in a table.
 * There is one table per DTD.
 */

typedef struct _xmlHashTable xmlElementTable;
typedef xmlElementTable *xmlElementTablePtr;

/*
 * ALL attribute declarations are stored in a table.
 * There is one table per DTD.
 */

typedef struct _xmlHashTable xmlAttributeTable;
typedef xmlAttributeTable *xmlAttributeTablePtr;

/*
 * ALL IDs attributes are stored in a table.
 * There is one table per document.
 */

typedef struct _xmlHashTable xmlIDTable;
typedef xmlIDTable *xmlIDTablePtr;

/*
 * ALL Refs attributes are stored in a table.
 * There is one table per document.
 */

typedef struct _xmlHashTable xmlRefTable;
typedef xmlRefTable *xmlRefTablePtr;

/* Notation */
XMLPUBFUN xmlNotationPtr XMLCALL
		xmlAddNotationDecl	(xmlValidCtxtPtr ctxt,
					 xmlDtdPtr dtd,
					 const xmlChar *name,
					 const xmlChar *PublicID,
					 const xmlChar *SystemID);
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN xmlNotationTablePtr XMLCALL
		xmlCopyNotationTable	(xmlNotationTablePtr table);
#endif /* LIBXML_TREE_ENABLED */
XMLPUBFUN void XMLCALL
		xmlFreeNotationTable	(xmlNotationTablePtr table);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void XMLCALL
		xmlDumpNotationDecl	(xmlBufferPtr buf,
					 xmlNotationPtr nota);
XMLPUBFUN void XMLCALL
		xmlDumpNotationTable	(xmlBufferPtr buf,
					 xmlNotationTablePtr table);
#endif /* LIBXML_OUTPUT_ENABLED */

/* Element Content */
/* the non Doc version are being deprecated */
XMLPUBFUN xmlElementContentPtr XMLCALL
		xmlNewElementContent	(const xmlChar *name,
					 xmlElementContentType type);
XMLPUBFUN xmlElementContentPtr XMLCALL
		xmlCopyElementContent	(xmlElementContentPtr content);
XMLPUBFUN void XMLCALL
		xmlFreeElementContent	(xmlElementContentPtr cur);
/* the new versions with doc argument */
XMLPUBFUN xmlElementContentPtr XMLCALL
		xmlNewDocElementContent	(xmlDocPtr doc,
					 const xmlChar *name,
					 xmlElementContentType type);
XMLPUBFUN xmlElementContentPtr XMLCALL
		xmlCopyDocElementContent(xmlDocPtr doc,
					 xmlElementContentPtr content);
XMLPUBFUN void XMLCALL
		xmlFreeDocElementContent(xmlDocPtr doc,
					 xmlElementContentPtr cur);
XMLPUBFUN void XMLCALL
		xmlSnprintfElementContent(char *buf,
					 int size,
	                                 xmlElementContentPtr content,
					 int englob);
#ifdef LIBXML_OUTPUT_ENABLED
/* DEPRECATED */
XMLPUBFUN void XMLCALL
		xmlSprintfElementContent(char *buf,
	                                 xmlElementContentPtr content,
					 int englob);
#endif /* LIBXML_OUTPUT_ENABLED */
/* DEPRECATED */

/* Element */
XMLPUBFUN xmlElementPtr XMLCALL
		xmlAddElementDecl	(xmlValidCtxtPtr ctxt,
					 xmlDtdPtr dtd,
					 const xmlChar *name,
					 xmlElementTypeVal type,
					 xmlElementContentPtr content);
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN xmlElementTablePtr XMLCALL
		xmlCopyElementTable	(xmlElementTablePtr table);
#endif /* LIBXML_TREE_ENABLED */
XMLPUBFUN void XMLCALL
		xmlFreeElementTable	(xmlElementTablePtr table);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void XMLCALL
		xmlDumpElementTable	(xmlBufferPtr buf,
					 xmlElementTablePtr table);
XMLPUBFUN void XMLCALL
		xmlDumpElementDecl	(xmlBufferPtr buf,
					 xmlElementPtr elem);
#endif /* LIBXML_OUTPUT_ENABLED */

/* Enumeration */
XMLPUBFUN xmlEnumerationPtr XMLCALL
		xmlCreateEnumeration	(const xmlChar *name);
XMLPUBFUN void XMLCALL
		xmlFreeEnumeration	(xmlEnumerationPtr cur);
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN xmlEnumerationPtr XMLCALL
		xmlCopyEnumeration	(xmlEnumerationPtr cur);
#endif /* LIBXML_TREE_ENABLED */

/* Attribute */
XMLPUBFUN xmlAttributePtr XMLCALL
		xmlAddAttributeDecl	(xmlValidCtxtPtr ctxt,
					 xmlDtdPtr dtd,
					 const xmlChar *elem,
					 const xmlChar *name,
					 const xmlChar *ns,
					 xmlAttributeType type,
					 xmlAttributeDefault def,
					 const xmlChar *defaultValue,
					 xmlEnumerationPtr tree);
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN xmlAttributeTablePtr XMLCALL
		xmlCopyAttributeTable  (xmlAttributeTablePtr table);
#endif /* LIBXML_TREE_ENABLED */
XMLPUBFUN void XMLCALL
		xmlFreeAttributeTable  (xmlAttributeTablePtr table);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void XMLCALL
		xmlDumpAttributeTable  (xmlBufferPtr buf,
					xmlAttributeTablePtr table);
XMLPUBFUN void XMLCALL
		xmlDumpAttributeDecl   (xmlBufferPtr buf,
					xmlAttributePtr attr);
#endif /* LIBXML_OUTPUT_ENABLED */

/* IDs */
XMLPUBFUN xmlIDPtr XMLCALL
		xmlAddID	       (xmlValidCtxtPtr ctxt,
					xmlDocPtr doc,
					const xmlChar *value,
					xmlAttrPtr attr);
XMLPUBFUN void XMLCALL
		xmlFreeIDTable	       (xmlIDTablePtr table);
XMLPUBFUN xmlAttrPtr XMLCALL
		xmlGetID	       (xmlDocPtr doc,
					const xmlChar *ID);
XMLPUBFUN int XMLCALL
		xmlIsID		       (xmlDocPtr doc,
					xmlNodePtr elem,
					xmlAttrPtr attr);
XMLPUBFUN int XMLCALL
		xmlRemoveID	       (xmlDocPtr doc,
					xmlAttrPtr attr);

/* IDREFs */
XMLPUBFUN xmlRefPtr XMLCALL
		xmlAddRef	       (xmlValidCtxtPtr ctxt,
					xmlDocPtr doc,
					const xmlChar *value,
					xmlAttrPtr attr);
XMLPUBFUN void XMLCALL
		xmlFreeRefTable	       (xmlRefTablePtr table);
XMLPUBFUN int XMLCALL
		xmlIsRef	       (xmlDocPtr doc,
					xmlNodePtr elem,
					xmlAttrPtr attr);
XMLPUBFUN int XMLCALL
		xmlRemoveRef	       (xmlDocPtr doc,
					xmlAttrPtr attr);
XMLPUBFUN xmlListPtr XMLCALL
		xmlGetRefs	       (xmlDocPtr doc,
					const xmlChar *ID);

/**
 * The public function calls related to validity checking.
 */
#ifdef LIBXML_VALID_ENABLED
/* Allocate/Release Validation Contexts */
XMLPUBFUN xmlValidCtxtPtr XMLCALL
		xmlNewValidCtxt(void);
XMLPUBFUN void XMLCALL
		xmlFreeValidCtxt(xmlValidCtxtPtr);

XMLPUBFUN int XMLCALL
		xmlValidateRoot		(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc);
XMLPUBFUN int XMLCALL
		xmlValidateElementDecl	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
		                         xmlElementPtr elem);
XMLPUBFUN xmlChar * XMLCALL
		xmlValidNormalizeAttributeValue(xmlDocPtr doc,
					 xmlNodePtr elem,
					 const xmlChar *name,
					 const xmlChar *value);
XMLPUBFUN xmlChar * XMLCALL
		xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlNodePtr elem,
					 const xmlChar *name,
					 const xmlChar *value);
XMLPUBFUN int XMLCALL
		xmlValidateAttributeDecl(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
		                         xmlAttributePtr attr);
XMLPUBFUN int XMLCALL
		xmlValidateAttributeValue(xmlAttributeType type,
					 const xmlChar *value);
XMLPUBFUN int XMLCALL
		xmlValidateNotationDecl	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
		                         xmlNotationPtr nota);
XMLPUBFUN int XMLCALL
		xmlValidateDtd		(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlDtdPtr dtd);
XMLPUBFUN int XMLCALL
		xmlValidateDtdFinal	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc);
XMLPUBFUN int XMLCALL
		xmlValidateDocument	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc);
XMLPUBFUN int XMLCALL
		xmlValidateElement	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlNodePtr elem);
XMLPUBFUN int XMLCALL
		xmlValidateOneElement	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
		                         xmlNodePtr elem);
XMLPUBFUN int XMLCALL
		xmlValidateOneAttribute	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlNodePtr	elem,
					 xmlAttrPtr attr,
					 const xmlChar *value);
XMLPUBFUN int XMLCALL
		xmlValidateOneNamespace	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlNodePtr elem,
					 const xmlChar *prefix,
					 xmlNsPtr ns,
					 const xmlChar *value);
XMLPUBFUN int XMLCALL
		xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc);
#endif /* LIBXML_VALID_ENABLED */

#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
XMLPUBFUN int XMLCALL
		xmlValidateNotationUse	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 const xmlChar *notationName);
#endif /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */

XMLPUBFUN int XMLCALL
		xmlIsMixedElement	(xmlDocPtr doc,
					 const xmlChar *name);
XMLPUBFUN xmlAttributePtr XMLCALL
		xmlGetDtdAttrDesc	(xmlDtdPtr dtd,
					 const xmlChar *elem,
					 const xmlChar *name);
XMLPUBFUN xmlAttributePtr XMLCALL
		xmlGetDtdQAttrDesc	(xmlDtdPtr dtd,
					 const xmlChar *elem,
					 const xmlChar *name,
					 const xmlChar *prefix);
XMLPUBFUN xmlNotationPtr XMLCALL
		xmlGetDtdNotationDesc	(xmlDtdPtr dtd,
					 const xmlChar *name);
XMLPUBFUN xmlElementPtr XMLCALL
		xmlGetDtdQElementDesc	(xmlDtdPtr dtd,
					 const xmlChar *name,
					 const xmlChar *prefix);
XMLPUBFUN xmlElementPtr XMLCALL
		xmlGetDtdElementDesc	(xmlDtdPtr dtd,
					 const xmlChar *name);

#ifdef LIBXML_VALID_ENABLED

XMLPUBFUN int XMLCALL
		xmlValidGetPotentialChildren(xmlElementContent *ctree,
					 const xmlChar **names,
					 int *len,
					 int max);

XMLPUBFUN int XMLCALL
		xmlValidGetValidElements(xmlNode *prev,
					 xmlNode *next,
					 const xmlChar **names,
					 int max);
XMLPUBFUN int XMLCALL
		xmlValidateNameValue	(const xmlChar *value);
XMLPUBFUN int XMLCALL
		xmlValidateNamesValue	(const xmlChar *value);
XMLPUBFUN int XMLCALL
		xmlValidateNmtokenValue	(const xmlChar *value);
XMLPUBFUN int XMLCALL
		xmlValidateNmtokensValue(const xmlChar *value);

#ifdef LIBXML_REGEXP_ENABLED
/*
 * Validation based on the regexp support
 */
XMLPUBFUN int XMLCALL
		xmlValidBuildContentModel(xmlValidCtxtPtr ctxt,
					 xmlElementPtr elem);

XMLPUBFUN int XMLCALL
		xmlValidatePushElement	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlNodePtr elem,
					 const xmlChar *qname);
XMLPUBFUN int XMLCALL
		xmlValidatePushCData	(xmlValidCtxtPtr ctxt,
					 const xmlChar *data,
					 int len);
XMLPUBFUN int XMLCALL
		xmlValidatePopElement	(xmlValidCtxtPtr ctxt,
					 xmlDocPtr doc,
					 xmlNodePtr elem,
					 const xmlChar *qname);
#endif /* LIBXML_REGEXP_ENABLED */
#endif /* LIBXML_VALID_ENABLED */
#ifdef __cplusplus
}
#endif
#endif /* __XML_VALID_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/entities.h
/*
 * Summary: interface for the XML entities handling
 * Description: this module provides some of the entity API needed
 *              for the parser and applications.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_ENTITIES_H__
#define __XML_ENTITIES_H__

#include <libxml/xmlversion.h>
#include <libxml/tree.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The different valid entity types.
 */
typedef enum {
    XML_INTERNAL_GENERAL_ENTITY = 1,
    XML_EXTERNAL_GENERAL_PARSED_ENTITY = 2,
    XML_EXTERNAL_GENERAL_UNPARSED_ENTITY = 3,
    XML_INTERNAL_PARAMETER_ENTITY = 4,
    XML_EXTERNAL_PARAMETER_ENTITY = 5,
    XML_INTERNAL_PREDEFINED_ENTITY = 6
} xmlEntityType;

/*
 * An unit of storage for an entity, contains the string, the value
 * and the linkind data needed for the linking in the hash table.
 */

struct _xmlEntity {
    void           *_private;	        /* application data */
    xmlElementType          type;       /* XML_ENTITY_DECL, must be second ! */
    const xmlChar          *name;	/* Entity name */
    struct _xmlNode    *children;	/* First child link */
    struct _xmlNode        *last;	/* Last child link */
    struct _xmlDtd       *parent;	/* -> DTD */
    struct _xmlNode        *next;	/* next sibling link  */
    struct _xmlNode        *prev;	/* previous sibling link  */
    struct _xmlDoc          *doc;       /* the containing document */

    xmlChar                *orig;	/* content without ref substitution */
    xmlChar             *content;	/* content or ndata if unparsed */
    int                   length;	/* the content length */
    xmlEntityType          etype;	/* The entity type */
    const xmlChar    *ExternalID;	/* External identifier for PUBLIC */
    const xmlChar      *SystemID;	/* URI for a SYSTEM or PUBLIC Entity */

    struct _xmlEntity     *nexte;	/* unused */
    const xmlChar           *URI;	/* the full URI as computed */
    int                    owner;	/* does the entity own the childrens */
    int			 checked;	/* was the entity content checked */
					/* this is also used to count entites
					 * references done from that entity
					 * and if it contains '<' */
};

/*
 * All entities are stored in an hash table.
 * There is 2 separate hash tables for global and parameter entities.
 */

typedef struct _xmlHashTable xmlEntitiesTable;
typedef xmlEntitiesTable *xmlEntitiesTablePtr;

/*
 * External functions:
 */

#ifdef LIBXML_LEGACY_ENABLED
XMLPUBFUN void XMLCALL
		xmlInitializePredefinedEntities	(void);
#endif /* LIBXML_LEGACY_ENABLED */

XMLPUBFUN xmlEntityPtr XMLCALL
			xmlNewEntity		(xmlDocPtr doc,
						 const xmlChar *name,
						 int type,
						 const xmlChar *ExternalID,
						 const xmlChar *SystemID,
						 const xmlChar *content);
XMLPUBFUN xmlEntityPtr XMLCALL
			xmlAddDocEntity		(xmlDocPtr doc,
						 const xmlChar *name,
						 int type,
						 const xmlChar *ExternalID,
						 const xmlChar *SystemID,
						 const xmlChar *content);
XMLPUBFUN xmlEntityPtr XMLCALL
			xmlAddDtdEntity		(xmlDocPtr doc,
						 const xmlChar *name,
						 int type,
						 const xmlChar *ExternalID,
						 const xmlChar *SystemID,
						 const xmlChar *content);
XMLPUBFUN xmlEntityPtr XMLCALL
			xmlGetPredefinedEntity	(const xmlChar *name);
XMLPUBFUN xmlEntityPtr XMLCALL
			xmlGetDocEntity		(xmlDocPtr doc,
						 const xmlChar *name);
XMLPUBFUN xmlEntityPtr XMLCALL
			xmlGetDtdEntity		(xmlDocPtr doc,
						 const xmlChar *name);
XMLPUBFUN xmlEntityPtr XMLCALL
			xmlGetParameterEntity	(xmlDocPtr doc,
						 const xmlChar *name);
#ifdef LIBXML_LEGACY_ENABLED
XMLPUBFUN const xmlChar * XMLCALL
			xmlEncodeEntities	(xmlDocPtr doc,
						 const xmlChar *input);
#endif /* LIBXML_LEGACY_ENABLED */
XMLPUBFUN xmlChar * XMLCALL
			xmlEncodeEntitiesReentrant(xmlDocPtr doc,
						 const xmlChar *input);
XMLPUBFUN xmlChar * XMLCALL
			xmlEncodeSpecialChars	(xmlDocPtr doc,
						 const xmlChar *input);
XMLPUBFUN xmlEntitiesTablePtr XMLCALL
			xmlCreateEntitiesTable	(void);
#ifdef LIBXML_TREE_ENABLED
XMLPUBFUN xmlEntitiesTablePtr XMLCALL
			xmlCopyEntitiesTable	(xmlEntitiesTablePtr table);
#endif /* LIBXML_TREE_ENABLED */
XMLPUBFUN void XMLCALL
			xmlFreeEntitiesTable	(xmlEntitiesTablePtr table);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void XMLCALL
			xmlDumpEntitiesTable	(xmlBufferPtr buf,
						 xmlEntitiesTablePtr table);
XMLPUBFUN void XMLCALL
			xmlDumpEntityDecl	(xmlBufferPtr buf,
						 xmlEntityPtr ent);
#endif /* LIBXML_OUTPUT_ENABLED */
#ifdef LIBXML_LEGACY_ENABLED
XMLPUBFUN void XMLCALL
			xmlCleanupPredefinedEntities(void);
#endif /* LIBXML_LEGACY_ENABLED */


#ifdef __cplusplus
}
#endif

# endif /* __XML_ENTITIES_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/schemasInternals.h
/*
 * Summary: internal interfaces for XML Schemas
 * Description: internal interfaces for the XML Schemas handling
 *              and schema validity checking
 *		The Schemas development is a Work In Progress.
 *              Some of those interfaces are not garanteed to be API or ABI stable !
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */


#ifndef __XML_SCHEMA_INTERNALS_H__
#define __XML_SCHEMA_INTERNALS_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_SCHEMAS_ENABLED

#include <libxml/xmlregexp.h>
#include <libxml/hash.h>
#include <libxml/dict.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    XML_SCHEMAS_UNKNOWN = 0,
    XML_SCHEMAS_STRING,
    XML_SCHEMAS_NORMSTRING,
    XML_SCHEMAS_DECIMAL,
    XML_SCHEMAS_TIME,
    XML_SCHEMAS_GDAY,
    XML_SCHEMAS_GMONTH,
    XML_SCHEMAS_GMONTHDAY,
    XML_SCHEMAS_GYEAR,
    XML_SCHEMAS_GYEARMONTH,
    XML_SCHEMAS_DATE,
    XML_SCHEMAS_DATETIME,
    XML_SCHEMAS_DURATION,
    XML_SCHEMAS_FLOAT,
    XML_SCHEMAS_DOUBLE,
    XML_SCHEMAS_BOOLEAN,
    XML_SCHEMAS_TOKEN,
    XML_SCHEMAS_LANGUAGE,
    XML_SCHEMAS_NMTOKEN,
    XML_SCHEMAS_NMTOKENS,
    XML_SCHEMAS_NAME,
    XML_SCHEMAS_QNAME,
    XML_SCHEMAS_NCNAME,
    XML_SCHEMAS_ID,
    XML_SCHEMAS_IDREF,
    XML_SCHEMAS_IDREFS,
    XML_SCHEMAS_ENTITY,
    XML_SCHEMAS_ENTITIES,
    XML_SCHEMAS_NOTATION,
    XML_SCHEMAS_ANYURI,
    XML_SCHEMAS_INTEGER,
    XML_SCHEMAS_NPINTEGER,
    XML_SCHEMAS_NINTEGER,
    XML_SCHEMAS_NNINTEGER,
    XML_SCHEMAS_PINTEGER,
    XML_SCHEMAS_INT,
    XML_SCHEMAS_UINT,
    XML_SCHEMAS_LONG,
    XML_SCHEMAS_ULONG,
    XML_SCHEMAS_SHORT,
    XML_SCHEMAS_USHORT,
    XML_SCHEMAS_BYTE,
    XML_SCHEMAS_UBYTE,
    XML_SCHEMAS_HEXBINARY,
    XML_SCHEMAS_BASE64BINARY,
    XML_SCHEMAS_ANYTYPE,
    XML_SCHEMAS_ANYSIMPLETYPE
} xmlSchemaValType;

/*
 * XML Schemas defines multiple type of types.
 */
typedef enum {
    XML_SCHEMA_TYPE_BASIC = 1, /* A built-in datatype */
    XML_SCHEMA_TYPE_ANY,
    XML_SCHEMA_TYPE_FACET,
    XML_SCHEMA_TYPE_SIMPLE,
    XML_SCHEMA_TYPE_COMPLEX,
    XML_SCHEMA_TYPE_SEQUENCE = 6,
    XML_SCHEMA_TYPE_CHOICE,
    XML_SCHEMA_TYPE_ALL,
    XML_SCHEMA_TYPE_SIMPLE_CONTENT,
    XML_SCHEMA_TYPE_COMPLEX_CONTENT,
    XML_SCHEMA_TYPE_UR,
    XML_SCHEMA_TYPE_RESTRICTION,
    XML_SCHEMA_TYPE_EXTENSION,
    XML_SCHEMA_TYPE_ELEMENT,
    XML_SCHEMA_TYPE_ATTRIBUTE,
    XML_SCHEMA_TYPE_ATTRIBUTEGROUP,
    XML_SCHEMA_TYPE_GROUP,
    XML_SCHEMA_TYPE_NOTATION,
    XML_SCHEMA_TYPE_LIST,
    XML_SCHEMA_TYPE_UNION,
    XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
    XML_SCHEMA_TYPE_IDC_UNIQUE,
    XML_SCHEMA_TYPE_IDC_KEY,
    XML_SCHEMA_TYPE_IDC_KEYREF,
    XML_SCHEMA_TYPE_PARTICLE = 25,
    XML_SCHEMA_TYPE_ATTRIBUTE_USE,
    XML_SCHEMA_FACET_MININCLUSIVE = 1000,
    XML_SCHEMA_FACET_MINEXCLUSIVE,
    XML_SCHEMA_FACET_MAXINCLUSIVE,
    XML_SCHEMA_FACET_MAXEXCLUSIVE,
    XML_SCHEMA_FACET_TOTALDIGITS,
    XML_SCHEMA_FACET_FRACTIONDIGITS,
    XML_SCHEMA_FACET_PATTERN,
    XML_SCHEMA_FACET_ENUMERATION,
    XML_SCHEMA_FACET_WHITESPACE,
    XML_SCHEMA_FACET_LENGTH,
    XML_SCHEMA_FACET_MAXLENGTH,
    XML_SCHEMA_FACET_MINLENGTH,
    XML_SCHEMA_EXTRA_QNAMEREF = 2000,
    XML_SCHEMA_EXTRA_ATTR_USE_PROHIB
} xmlSchemaTypeType;

typedef enum {
    XML_SCHEMA_CONTENT_UNKNOWN = 0,
    XML_SCHEMA_CONTENT_EMPTY = 1,
    XML_SCHEMA_CONTENT_ELEMENTS,
    XML_SCHEMA_CONTENT_MIXED,
    XML_SCHEMA_CONTENT_SIMPLE,
    XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS, /* Obsolete */
    XML_SCHEMA_CONTENT_BASIC,
    XML_SCHEMA_CONTENT_ANY
} xmlSchemaContentType;

typedef struct _xmlSchemaVal xmlSchemaVal;
typedef xmlSchemaVal *xmlSchemaValPtr;

typedef struct _xmlSchemaType xmlSchemaType;
typedef xmlSchemaType *xmlSchemaTypePtr;

typedef struct _xmlSchemaFacet xmlSchemaFacet;
typedef xmlSchemaFacet *xmlSchemaFacetPtr;

/**
 * Annotation
 */
typedef struct _xmlSchemaAnnot xmlSchemaAnnot;
typedef xmlSchemaAnnot *xmlSchemaAnnotPtr;
struct _xmlSchemaAnnot {
    struct _xmlSchemaAnnot *next;
    xmlNodePtr content;         /* the annotation */
};

/**
 * XML_SCHEMAS_ANYATTR_SKIP:
 *
 * Skip unknown attribute from validation
 * Obsolete, not used anymore.
 */
#define XML_SCHEMAS_ANYATTR_SKIP        1
/**
 * XML_SCHEMAS_ANYATTR_LAX:
 *
 * Ignore validation non definition on attributes
 * Obsolete, not used anymore.
 */
#define XML_SCHEMAS_ANYATTR_LAX                2
/**
 * XML_SCHEMAS_ANYATTR_STRICT:
 *
 * Apply strict validation rules on attributes
 * Obsolete, not used anymore.
 */
#define XML_SCHEMAS_ANYATTR_STRICT        3
/**
 * XML_SCHEMAS_ANY_SKIP:
 *
 * Skip unknown attribute from validation
 */
#define XML_SCHEMAS_ANY_SKIP        1
/**
 * XML_SCHEMAS_ANY_LAX:
 *
 * Used by wildcards.
 * Validate if type found, don't worry if not found
 */
#define XML_SCHEMAS_ANY_LAX                2
/**
 * XML_SCHEMAS_ANY_STRICT:
 *
 * Used by wildcards.
 * Apply strict validation rules
 */
#define XML_SCHEMAS_ANY_STRICT        3
/**
 * XML_SCHEMAS_ATTR_USE_PROHIBITED:
 *
 * Used by wildcards.
 * The attribute is prohibited.
 */
#define XML_SCHEMAS_ATTR_USE_PROHIBITED 0
/**
 * XML_SCHEMAS_ATTR_USE_REQUIRED:
 *
 * The attribute is required.
 */
#define XML_SCHEMAS_ATTR_USE_REQUIRED 1
/**
 * XML_SCHEMAS_ATTR_USE_OPTIONAL:
 *
 * The attribute is optional.
 */
#define XML_SCHEMAS_ATTR_USE_OPTIONAL 2
/**
 * XML_SCHEMAS_ATTR_GLOBAL:
 *
 * allow elements in no namespace
 */
#define XML_SCHEMAS_ATTR_GLOBAL        1 << 0
/**
 * XML_SCHEMAS_ATTR_NSDEFAULT:
 *
 * allow elements in no namespace
 */
#define XML_SCHEMAS_ATTR_NSDEFAULT        1 << 7
/**
 * XML_SCHEMAS_ATTR_INTERNAL_RESOLVED:
 *
 * this is set when the "type" and "ref" references
 * have been resolved.
 */
#define XML_SCHEMAS_ATTR_INTERNAL_RESOLVED        1 << 8
/**
 * XML_SCHEMAS_ATTR_FIXED:
 *
 * the attribute has a fixed value
 */
#define XML_SCHEMAS_ATTR_FIXED        1 << 9

/**
 * xmlSchemaAttribute:
 * An attribute definition.
 */

typedef struct _xmlSchemaAttribute xmlSchemaAttribute;
typedef xmlSchemaAttribute *xmlSchemaAttributePtr;
struct _xmlSchemaAttribute {
    xmlSchemaTypeType type;
    struct _xmlSchemaAttribute *next; /* the next attribute (not used?) */
    const xmlChar *name; /* the name of the declaration */
    const xmlChar *id; /* Deprecated; not used */
    const xmlChar *ref; /* Deprecated; not used */
    const xmlChar *refNs; /* Deprecated; not used */
    const xmlChar *typeName; /* the local name of the type definition */
    const xmlChar *typeNs; /* the ns URI of the type definition */
    xmlSchemaAnnotPtr annot;

    xmlSchemaTypePtr base; /* Deprecated; not used */
    int occurs; /* Deprecated; not used */
    const xmlChar *defValue; /* The initial value of the value constraint */
    xmlSchemaTypePtr subtypes; /* the type definition */
    xmlNodePtr node;
    const xmlChar *targetNamespace;
    int flags;
    const xmlChar *refPrefix; /* Deprecated; not used */
    xmlSchemaValPtr defVal; /* The compiled value constraint */
    xmlSchemaAttributePtr refDecl; /* Deprecated; not used */
};

/**
 * xmlSchemaAttributeLink:
 * Used to build a list of attribute uses on complexType definitions.
 * WARNING: Deprecated; not used.
 */
typedef struct _xmlSchemaAttributeLink xmlSchemaAttributeLink;
typedef xmlSchemaAttributeLink *xmlSchemaAttributeLinkPtr;
struct _xmlSchemaAttributeLink {
    struct _xmlSchemaAttributeLink *next;/* the next attribute link ... */
    struct _xmlSchemaAttribute *attr;/* the linked attribute */
};

/**
 * XML_SCHEMAS_WILDCARD_COMPLETE:
 *
 * If the wildcard is complete.
 */
#define XML_SCHEMAS_WILDCARD_COMPLETE 1 << 0

/**
 * xmlSchemaCharValueLink:
 * Used to build a list of namespaces on wildcards.
 */
typedef struct _xmlSchemaWildcardNs xmlSchemaWildcardNs;
typedef xmlSchemaWildcardNs *xmlSchemaWildcardNsPtr;
struct _xmlSchemaWildcardNs {
    struct _xmlSchemaWildcardNs *next;/* the next constraint link ... */
    const xmlChar *value;/* the value */
};

/**
 * xmlSchemaWildcard.
 * A wildcard.
 */
typedef struct _xmlSchemaWildcard xmlSchemaWildcard;
typedef xmlSchemaWildcard *xmlSchemaWildcardPtr;
struct _xmlSchemaWildcard {
    xmlSchemaTypeType type;        /* The kind of type */
    const xmlChar *id; /* Deprecated; not used */
    xmlSchemaAnnotPtr annot;
    xmlNodePtr node;
    int minOccurs; /* Deprecated; not used */
    int maxOccurs; /* Deprecated; not used */
    int processContents;
    int any; /* Indicates if the ns constraint is of ##any */
    xmlSchemaWildcardNsPtr nsSet; /* The list of allowed namespaces */
    xmlSchemaWildcardNsPtr negNsSet; /* The negated namespace */
    int flags;
};

/**
 * XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED:
 *
 * The attribute wildcard has been already builded.
 */
#define XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED 1 << 0
/**
 * XML_SCHEMAS_ATTRGROUP_GLOBAL:
 *
 * The attribute wildcard has been already builded.
 */
#define XML_SCHEMAS_ATTRGROUP_GLOBAL 1 << 1
/**
 * XML_SCHEMAS_ATTRGROUP_MARKED:
 *
 * Marks the attr group as marked; used for circular checks.
 */
#define XML_SCHEMAS_ATTRGROUP_MARKED 1 << 2

/**
 * XML_SCHEMAS_ATTRGROUP_REDEFINED:
 *
 * The attr group was redefined.
 */
#define XML_SCHEMAS_ATTRGROUP_REDEFINED 1 << 3
/**
 * XML_SCHEMAS_ATTRGROUP_HAS_REFS:
 *
 * Whether this attr. group contains attr. group references.
 */
#define XML_SCHEMAS_ATTRGROUP_HAS_REFS 1 << 4

/**
 * An attribute group definition.
 *
 * xmlSchemaAttribute and xmlSchemaAttributeGroup start of structures
 * must be kept similar
 */
typedef struct _xmlSchemaAttributeGroup xmlSchemaAttributeGroup;
typedef xmlSchemaAttributeGroup *xmlSchemaAttributeGroupPtr;
struct _xmlSchemaAttributeGroup {
    xmlSchemaTypeType type;        /* The kind of type */
    struct _xmlSchemaAttribute *next;/* the next attribute if in a group ... */
    const xmlChar *name;
    const xmlChar *id;
    const xmlChar *ref; /* Deprecated; not used */
    const xmlChar *refNs; /* Deprecated; not used */
    xmlSchemaAnnotPtr annot;

    xmlSchemaAttributePtr attributes; /* Deprecated; not used */
    xmlNodePtr node;
    int flags;
    xmlSchemaWildcardPtr attributeWildcard;
    const xmlChar *refPrefix; /* Deprecated; not used */
    xmlSchemaAttributeGroupPtr refItem; /* Deprecated; not used */
    const xmlChar *targetNamespace;
    void *attrUses;
};

/**
 * xmlSchemaTypeLink:
 * Used to build a list of types (e.g. member types of
 * simpleType with variety "union").
 */
typedef struct _xmlSchemaTypeLink xmlSchemaTypeLink;
typedef xmlSchemaTypeLink *xmlSchemaTypeLinkPtr;
struct _xmlSchemaTypeLink {
    struct _xmlSchemaTypeLink *next;/* the next type link ... */
    xmlSchemaTypePtr type;/* the linked type */
};

/**
 * xmlSchemaFacetLink:
 * Used to build a list of facets.
 */
typedef struct _xmlSchemaFacetLink xmlSchemaFacetLink;
typedef xmlSchemaFacetLink *xmlSchemaFacetLinkPtr;
struct _xmlSchemaFacetLink {
    struct _xmlSchemaFacetLink *next;/* the next facet link ... */
    xmlSchemaFacetPtr facet;/* the linked facet */
};

/**
 * XML_SCHEMAS_TYPE_MIXED:
 *
 * the element content type is mixed
 */
#define XML_SCHEMAS_TYPE_MIXED                1 << 0
/**
 * XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION:
 *
 * the simple or complex type has a derivation method of "extension".
 */
#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
/**
 * XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION:
 *
 * the simple or complex type has a derivation method of "restriction".
 */
#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
/**
 * XML_SCHEMAS_TYPE_GLOBAL:
 *
 * the type is global
 */
#define XML_SCHEMAS_TYPE_GLOBAL                1 << 3
/**
 * XML_SCHEMAS_TYPE_OWNED_ATTR_WILDCARD:
 *
 * the complexType owns an attribute wildcard, i.e.
 * it can be freed by the complexType
 */
#define XML_SCHEMAS_TYPE_OWNED_ATTR_WILDCARD    1 << 4 /* Obsolete. */
/**
 * XML_SCHEMAS_TYPE_VARIETY_ABSENT:
 *
 * the simpleType has a variety of "absent".
 * TODO: Actually not necessary :-/, since if
 * none of the variety flags occur then it's
 * automatically absent.
 */
#define XML_SCHEMAS_TYPE_VARIETY_ABSENT    1 << 5
/**
 * XML_SCHEMAS_TYPE_VARIETY_LIST:
 *
 * the simpleType has a variety of "list".
 */
#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
/**
 * XML_SCHEMAS_TYPE_VARIETY_UNION:
 *
 * the simpleType has a variety of "union".
 */
#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
/**
 * XML_SCHEMAS_TYPE_VARIETY_ATOMIC:
 *
 * the simpleType has a variety of "union".
 */
#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
/**
 * XML_SCHEMAS_TYPE_FINAL_EXTENSION:
 *
 * the complexType has a final of "extension".
 */
#define XML_SCHEMAS_TYPE_FINAL_EXTENSION    1 << 9
/**
 * XML_SCHEMAS_TYPE_FINAL_RESTRICTION:
 *
 * the simpleType/complexType has a final of "restriction".
 */
#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
/**
 * XML_SCHEMAS_TYPE_FINAL_LIST:
 *
 * the simpleType has a final of "list".
 */
#define XML_SCHEMAS_TYPE_FINAL_LIST    1 << 11
/**
 * XML_SCHEMAS_TYPE_FINAL_UNION:
 *
 * the simpleType has a final of "union".
 */
#define XML_SCHEMAS_TYPE_FINAL_UNION    1 << 12
/**
 * XML_SCHEMAS_TYPE_FINAL_DEFAULT:
 *
 * the simpleType has a final of "default".
 */
#define XML_SCHEMAS_TYPE_FINAL_DEFAULT    1 << 13
/**
 * XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE:
 *
 * Marks the item as a builtin primitive.
 */
#define XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE    1 << 14
/**
 * XML_SCHEMAS_TYPE_MARKED:
 *
 * Marks the item as marked; used for circular checks.
 */
#define XML_SCHEMAS_TYPE_MARKED        1 << 16
/**
 * XML_SCHEMAS_TYPE_BLOCK_DEFAULT:
 *
 * the complexType did not specify 'block' so use the default of the
 * <schema> item.
 */
#define XML_SCHEMAS_TYPE_BLOCK_DEFAULT    1 << 17
/**
 * XML_SCHEMAS_TYPE_BLOCK_EXTENSION:
 *
 * the complexType has a 'block' of "extension".
 */
#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
/**
 * XML_SCHEMAS_TYPE_BLOCK_RESTRICTION:
 *
 * the complexType has a 'block' of "restriction".
 */
#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
/**
 * XML_SCHEMAS_TYPE_ABSTRACT:
 *
 * the simple/complexType is abstract.
 */
#define XML_SCHEMAS_TYPE_ABSTRACT    1 << 20
/**
 * XML_SCHEMAS_TYPE_FACETSNEEDVALUE:
 *
 * indicates if the facets need a computed value
 */
#define XML_SCHEMAS_TYPE_FACETSNEEDVALUE    1 << 21
/**
 * XML_SCHEMAS_TYPE_INTERNAL_RESOLVED:
 *
 * indicates that the type was typefixed
 */
#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
/**
 * XML_SCHEMAS_TYPE_INTERNAL_INVALID:
 *
 * indicates that the type is invalid
 */
#define XML_SCHEMAS_TYPE_INTERNAL_INVALID    1 << 23
/**
 * XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE:
 *
 * a whitespace-facet value of "preserve"
 */
#define XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE    1 << 24
/**
 * XML_SCHEMAS_TYPE_WHITESPACE_REPLACE:
 *
 * a whitespace-facet value of "replace"
 */
#define XML_SCHEMAS_TYPE_WHITESPACE_REPLACE    1 << 25
/**
 * XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE:
 *
 * a whitespace-facet value of "collapse"
 */
#define XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE    1 << 26
/**
 * XML_SCHEMAS_TYPE_HAS_FACETS:
 *
 * has facets
 */
#define XML_SCHEMAS_TYPE_HAS_FACETS    1 << 27
/**
 * XML_SCHEMAS_TYPE_NORMVALUENEEDED:
 *
 * indicates if the facets (pattern) need a normalized value
 */
#define XML_SCHEMAS_TYPE_NORMVALUENEEDED    1 << 28

/**
 * XML_SCHEMAS_TYPE_FIXUP_1:
 *
 * First stage of fixup was done.
 */
#define XML_SCHEMAS_TYPE_FIXUP_1    1 << 29

/**
 * XML_SCHEMAS_TYPE_REDEFINED:
 *
 * The type was redefined.
 */
#define XML_SCHEMAS_TYPE_REDEFINED    1 << 30
/**
 * XML_SCHEMAS_TYPE_REDEFINING:
 *
 * The type redefines an other type.
 */
/* #define XML_SCHEMAS_TYPE_REDEFINING    1 << 31 */

/**
 * _xmlSchemaType:
 *
 * Schemas type definition.
 */
struct _xmlSchemaType {
    xmlSchemaTypeType type; /* The kind of type */
    struct _xmlSchemaType *next; /* the next type if in a sequence ... */
    const xmlChar *name;
    const xmlChar *id ; /* Deprecated; not used */
    const xmlChar *ref; /* Deprecated; not used */
    const xmlChar *refNs; /* Deprecated; not used */
    xmlSchemaAnnotPtr annot;
    xmlSchemaTypePtr subtypes;
    xmlSchemaAttributePtr attributes; /* Deprecated; not used */
    xmlNodePtr node;
    int minOccurs; /* Deprecated; not used */
    int maxOccurs; /* Deprecated; not used */

    int flags;
    xmlSchemaContentType contentType;
    const xmlChar *base; /* Base type's local name */
    const xmlChar *baseNs; /* Base type's target namespace */
    xmlSchemaTypePtr baseType; /* The base type component */
    xmlSchemaFacetPtr facets; /* Local facets */
    struct _xmlSchemaType *redef; /* Deprecated; not used */
    int recurse; /* Obsolete */
    xmlSchemaAttributeLinkPtr *attributeUses; /* Deprecated; not used */
    xmlSchemaWildcardPtr attributeWildcard;
    int builtInType; /* Type of built-in types. */
    xmlSchemaTypeLinkPtr memberTypes; /* member-types if a union type. */
    xmlSchemaFacetLinkPtr facetSet; /* All facets (incl. inherited) */
    const xmlChar *refPrefix; /* Deprecated; not used */
    xmlSchemaTypePtr contentTypeDef; /* Used for the simple content of complex types.
                                        Could we use @subtypes for this? */
    xmlRegexpPtr contModel; /* Holds the automaton of the content model */
    const xmlChar *targetNamespace;
    void *attrUses;
};

/*
 * xmlSchemaElement:
 * An element definition.
 *
 * xmlSchemaType, xmlSchemaFacet and xmlSchemaElement start of
 * structures must be kept similar
 */
/**
 * XML_SCHEMAS_ELEM_NILLABLE:
 *
 * the element is nillable
 */
#define XML_SCHEMAS_ELEM_NILLABLE        1 << 0
/**
 * XML_SCHEMAS_ELEM_GLOBAL:
 *
 * the element is global
 */
#define XML_SCHEMAS_ELEM_GLOBAL                1 << 1
/**
 * XML_SCHEMAS_ELEM_DEFAULT:
 *
 * the element has a default value
 */
#define XML_SCHEMAS_ELEM_DEFAULT        1 << 2
/**
 * XML_SCHEMAS_ELEM_FIXED:
 *
 * the element has a fixed value
 */
#define XML_SCHEMAS_ELEM_FIXED                1 << 3
/**
 * XML_SCHEMAS_ELEM_ABSTRACT:
 *
 * the element is abstract
 */
#define XML_SCHEMAS_ELEM_ABSTRACT        1 << 4
/**
 * XML_SCHEMAS_ELEM_TOPLEVEL:
 *
 * the element is top level
 * obsolete: use XML_SCHEMAS_ELEM_GLOBAL instead
 */
#define XML_SCHEMAS_ELEM_TOPLEVEL        1 << 5
/**
 * XML_SCHEMAS_ELEM_REF:
 *
 * the element is a reference to a type
 */
#define XML_SCHEMAS_ELEM_REF                1 << 6
/**
 * XML_SCHEMAS_ELEM_NSDEFAULT:
 *
 * allow elements in no namespace
 * Obsolete, not used anymore.
 */
#define XML_SCHEMAS_ELEM_NSDEFAULT        1 << 7
/**
 * XML_SCHEMAS_ELEM_INTERNAL_RESOLVED:
 *
 * this is set when "type", "ref", "substitutionGroup"
 * references have been resolved.
 */
#define XML_SCHEMAS_ELEM_INTERNAL_RESOLVED        1 << 8
 /**
 * XML_SCHEMAS_ELEM_CIRCULAR:
 *
 * a helper flag for the search of circular references.
 */
#define XML_SCHEMAS_ELEM_CIRCULAR        1 << 9
/**
 * XML_SCHEMAS_ELEM_BLOCK_ABSENT:
 *
 * the "block" attribute is absent
 */
#define XML_SCHEMAS_ELEM_BLOCK_ABSENT        1 << 10
/**
 * XML_SCHEMAS_ELEM_BLOCK_EXTENSION:
 *
 * disallowed substitutions are absent
 */
#define XML_SCHEMAS_ELEM_BLOCK_EXTENSION        1 << 11
/**
 * XML_SCHEMAS_ELEM_BLOCK_RESTRICTION:
 *
 * disallowed substitutions: "restriction"
 */
#define XML_SCHEMAS_ELEM_BLOCK_RESTRICTION        1 << 12
/**
 * XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION:
 *
 * disallowed substitutions: "substituion"
 */
#define XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION        1 << 13
/**
 * XML_SCHEMAS_ELEM_FINAL_ABSENT:
 *
 * substitution group exclusions are absent
 */
#define XML_SCHEMAS_ELEM_FINAL_ABSENT        1 << 14
/**
 * XML_SCHEMAS_ELEM_FINAL_EXTENSION:
 *
 * substitution group exclusions: "extension"
 */
#define XML_SCHEMAS_ELEM_FINAL_EXTENSION        1 << 15
/**
 * XML_SCHEMAS_ELEM_FINAL_RESTRICTION:
 *
 * substitution group exclusions: "restriction"
 */
#define XML_SCHEMAS_ELEM_FINAL_RESTRICTION        1 << 16
/**
 * XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD:
 *
 * the declaration is a substitution group head
 */
#define XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD        1 << 17
/**
 * XML_SCHEMAS_ELEM_INTERNAL_CHECKED:
 *
 * this is set when the elem decl has been checked against
 * all constraints
 */
#define XML_SCHEMAS_ELEM_INTERNAL_CHECKED        1 << 18

typedef struct _xmlSchemaElement xmlSchemaElement;
typedef xmlSchemaElement *xmlSchemaElementPtr;
struct _xmlSchemaElement {
    xmlSchemaTypeType type; /* The kind of type */
    struct _xmlSchemaType *next; /* Not used? */
    const xmlChar *name;
    const xmlChar *id; /* Deprecated; not used */
    const xmlChar *ref; /* Deprecated; not used */
    const xmlChar *refNs; /* Deprecated; not used */
    xmlSchemaAnnotPtr annot;
    xmlSchemaTypePtr subtypes; /* the type definition */
    xmlSchemaAttributePtr attributes;
    xmlNodePtr node;
    int minOccurs; /* Deprecated; not used */
    int maxOccurs; /* Deprecated; not used */

    int flags;
    const xmlChar *targetNamespace;
    const xmlChar *namedType;
    const xmlChar *namedTypeNs;
    const xmlChar *substGroup;
    const xmlChar *substGroupNs;
    const xmlChar *scope;
    const xmlChar *value; /* The original value of the value constraint. */
    struct _xmlSchemaElement *refDecl; /* This will now be used for the
                                          substitution group affiliation */
    xmlRegexpPtr contModel; /* Obsolete for WXS, maybe used for RelaxNG */
    xmlSchemaContentType contentType;
    const xmlChar *refPrefix; /* Deprecated; not used */
    xmlSchemaValPtr defVal; /* The compiled value contraint. */
    void *idcs; /* The identity-constraint defs */
};

/*
 * XML_SCHEMAS_FACET_UNKNOWN:
 *
 * unknown facet handling
 */
#define XML_SCHEMAS_FACET_UNKNOWN        0
/*
 * XML_SCHEMAS_FACET_PRESERVE:
 *
 * preserve the type of the facet
 */
#define XML_SCHEMAS_FACET_PRESERVE        1
/*
 * XML_SCHEMAS_FACET_REPLACE:
 *
 * replace the type of the facet
 */
#define XML_SCHEMAS_FACET_REPLACE        2
/*
 * XML_SCHEMAS_FACET_COLLAPSE:
 *
 * collapse the types of the facet
 */
#define XML_SCHEMAS_FACET_COLLAPSE        3
/**
 * A facet definition.
 */
struct _xmlSchemaFacet {
    xmlSchemaTypeType type;        /* The kind of type */
    struct _xmlSchemaFacet *next;/* the next type if in a sequence ... */
    const xmlChar *value; /* The original value */
    const xmlChar *id; /* Obsolete */
    xmlSchemaAnnotPtr annot;
    xmlNodePtr node;
    int fixed; /* XML_SCHEMAS_FACET_PRESERVE, etc. */
    int whitespace;
    xmlSchemaValPtr val; /* The compiled value */
    xmlRegexpPtr    regexp; /* The regex for patterns */
};

/**
 * A notation definition.
 */
typedef struct _xmlSchemaNotation xmlSchemaNotation;
typedef xmlSchemaNotation *xmlSchemaNotationPtr;
struct _xmlSchemaNotation {
    xmlSchemaTypeType type; /* The kind of type */
    const xmlChar *name;
    xmlSchemaAnnotPtr annot;
    const xmlChar *identifier;
    const xmlChar *targetNamespace;
};

/*
* TODO: Actually all those flags used for the schema should sit
* on the schema parser context, since they are used only
* during parsing an XML schema document, and not available
* on the component level as per spec.
*/
/**
 * XML_SCHEMAS_QUALIF_ELEM:
 *
 * Reflects elementFormDefault == qualified in
 * an XML schema document.
 */
#define XML_SCHEMAS_QUALIF_ELEM                1 << 0
/**
 * XML_SCHEMAS_QUALIF_ATTR:
 *
 * Reflects attributeFormDefault == qualified in
 * an XML schema document.
 */
#define XML_SCHEMAS_QUALIF_ATTR            1 << 1
/**
 * XML_SCHEMAS_FINAL_DEFAULT_EXTENSION:
 *
 * the schema has "extension" in the set of finalDefault.
 */
#define XML_SCHEMAS_FINAL_DEFAULT_EXTENSION        1 << 2
/**
 * XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION:
 *
 * the schema has "restriction" in the set of finalDefault.
 */
#define XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION            1 << 3
/**
 * XML_SCHEMAS_FINAL_DEFAULT_LIST:
 *
 * the cshema has "list" in the set of finalDefault.
 */
#define XML_SCHEMAS_FINAL_DEFAULT_LIST            1 << 4
/**
 * XML_SCHEMAS_FINAL_DEFAULT_UNION:
 *
 * the schema has "union" in the set of finalDefault.
 */
#define XML_SCHEMAS_FINAL_DEFAULT_UNION            1 << 5
/**
 * XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION:
 *
 * the schema has "extension" in the set of blockDefault.
 */
#define XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION            1 << 6
/**
 * XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION:
 *
 * the schema has "restriction" in the set of blockDefault.
 */
#define XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION            1 << 7
/**
 * XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION:
 *
 * the schema has "substitution" in the set of blockDefault.
 */
#define XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION            1 << 8
/**
 * XML_SCHEMAS_INCLUDING_CONVERT_NS:
 *
 * the schema is currently including an other schema with
 * no target namespace.
 */
#define XML_SCHEMAS_INCLUDING_CONVERT_NS            1 << 9
/**
 * _xmlSchema:
 *
 * A Schemas definition
 */
struct _xmlSchema {
    const xmlChar *name; /* schema name */
    const xmlChar *targetNamespace; /* the target namespace */
    const xmlChar *version;
    const xmlChar *id; /* Obsolete */
    xmlDocPtr doc;
    xmlSchemaAnnotPtr annot;
    int flags;

    xmlHashTablePtr typeDecl;
    xmlHashTablePtr attrDecl;
    xmlHashTablePtr attrgrpDecl;
    xmlHashTablePtr elemDecl;
    xmlHashTablePtr notaDecl;

    xmlHashTablePtr schemasImports;

    void *_private;        /* unused by the library for users or bindings */
    xmlHashTablePtr groupDecl;
    xmlDictPtr      dict;
    void *includes;     /* the includes, this is opaque for now */
    int preserve;        /* whether to free the document */
    int counter; /* used to give ononymous components unique names */
    xmlHashTablePtr idcDef; /* All identity-constraint defs. */
    void *volatiles; /* Obsolete */
};

XMLPUBFUN void XMLCALL         xmlSchemaFreeType        (xmlSchemaTypePtr type);
XMLPUBFUN void XMLCALL         xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_SCHEMAS_ENABLED */
#endif /* __XML_SCHEMA_INTERNALS_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xpathInternals.h
/*
 * Summary: internal interfaces for XML Path Language implementation
 * Description: internal interfaces for XML Path Language implementation
 *              used to build new modules on top of XPath like XPointer and
 *              XSLT
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_XPATH_INTERNALS_H__
#define __XML_XPATH_INTERNALS_H__

#include <libxml/xmlversion.h>
#include <libxml/xpath.h>

#ifdef LIBXML_XPATH_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************
 *									*
 *			Helpers						*
 *									*
 ************************************************************************/

/*
 * Many of these macros may later turn into functions. They
 * shouldn't be used in #ifdef's preprocessor instructions.
 */
/**
 * xmlXPathSetError:
 * @ctxt:  an XPath parser context
 * @err:  an xmlXPathError code
 *
 * Raises an error.
 */
#define xmlXPathSetError(ctxt, err)					\
    { xmlXPatherror((ctxt), __FILE__, __LINE__, (err));			\
      if ((ctxt) != NULL) (ctxt)->error = (err); }

/**
 * xmlXPathSetArityError:
 * @ctxt:  an XPath parser context
 *
 * Raises an XPATH_INVALID_ARITY error.
 */
#define xmlXPathSetArityError(ctxt)					\
    xmlXPathSetError((ctxt), XPATH_INVALID_ARITY)

/**
 * xmlXPathSetTypeError:
 * @ctxt:  an XPath parser context
 *
 * Raises an XPATH_INVALID_TYPE error.
 */
#define xmlXPathSetTypeError(ctxt)					\
    xmlXPathSetError((ctxt), XPATH_INVALID_TYPE)

/**
 * xmlXPathGetError:
 * @ctxt:  an XPath parser context
 *
 * Get the error code of an XPath context.
 *
 * Returns the context error.
 */
#define xmlXPathGetError(ctxt)	  ((ctxt)->error)

/**
 * xmlXPathCheckError:
 * @ctxt:  an XPath parser context
 *
 * Check if an XPath error was raised.
 *
 * Returns true if an error has been raised, false otherwise.
 */
#define xmlXPathCheckError(ctxt)  ((ctxt)->error != XPATH_EXPRESSION_OK)

/**
 * xmlXPathGetDocument:
 * @ctxt:  an XPath parser context
 *
 * Get the document of an XPath context.
 *
 * Returns the context document.
 */
#define xmlXPathGetDocument(ctxt)	((ctxt)->context->doc)

/**
 * xmlXPathGetContextNode:
 * @ctxt: an XPath parser context
 *
 * Get the context node of an XPath context.
 *
 * Returns the context node.
 */
#define xmlXPathGetContextNode(ctxt)	((ctxt)->context->node)

XMLPUBFUN int XMLCALL
		xmlXPathPopBoolean	(xmlXPathParserContextPtr ctxt);
XMLPUBFUN double XMLCALL
		xmlXPathPopNumber	(xmlXPathParserContextPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
		xmlXPathPopString	(xmlXPathParserContextPtr ctxt);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathPopNodeSet	(xmlXPathParserContextPtr ctxt);
XMLPUBFUN void * XMLCALL
		xmlXPathPopExternal	(xmlXPathParserContextPtr ctxt);

/**
 * xmlXPathReturnBoolean:
 * @ctxt:  an XPath parser context
 * @val:  a boolean
 *
 * Pushes the boolean @val on the context stack.
 */
#define xmlXPathReturnBoolean(ctxt, val)				\
    valuePush((ctxt), xmlXPathNewBoolean(val))

/**
 * xmlXPathReturnTrue:
 * @ctxt:  an XPath parser context
 *
 * Pushes true on the context stack.
 */
#define xmlXPathReturnTrue(ctxt)   xmlXPathReturnBoolean((ctxt), 1)

/**
 * xmlXPathReturnFalse:
 * @ctxt:  an XPath parser context
 *
 * Pushes false on the context stack.
 */
#define xmlXPathReturnFalse(ctxt)  xmlXPathReturnBoolean((ctxt), 0)

/**
 * xmlXPathReturnNumber:
 * @ctxt:  an XPath parser context
 * @val:  a double
 *
 * Pushes the double @val on the context stack.
 */
#define xmlXPathReturnNumber(ctxt, val)					\
    valuePush((ctxt), xmlXPathNewFloat(val))

/**
 * xmlXPathReturnString:
 * @ctxt:  an XPath parser context
 * @str:  a string
 *
 * Pushes the string @str on the context stack.
 */
#define xmlXPathReturnString(ctxt, str)					\
    valuePush((ctxt), xmlXPathWrapString(str))

/**
 * xmlXPathReturnEmptyString:
 * @ctxt:  an XPath parser context
 *
 * Pushes an empty string on the stack.
 */
#define xmlXPathReturnEmptyString(ctxt)					\
    valuePush((ctxt), xmlXPathNewCString(""))

/**
 * xmlXPathReturnNodeSet:
 * @ctxt:  an XPath parser context
 * @ns:  a node-set
 *
 * Pushes the node-set @ns on the context stack.
 */
#define xmlXPathReturnNodeSet(ctxt, ns)					\
    valuePush((ctxt), xmlXPathWrapNodeSet(ns))

/**
 * xmlXPathReturnEmptyNodeSet:
 * @ctxt:  an XPath parser context
 *
 * Pushes an empty node-set on the context stack.
 */
#define xmlXPathReturnEmptyNodeSet(ctxt)				\
    valuePush((ctxt), xmlXPathNewNodeSet(NULL))

/**
 * xmlXPathReturnExternal:
 * @ctxt:  an XPath parser context
 * @val:  user data
 *
 * Pushes user data on the context stack.
 */
#define xmlXPathReturnExternal(ctxt, val)				\
    valuePush((ctxt), xmlXPathWrapExternal(val))

/**
 * xmlXPathStackIsNodeSet:
 * @ctxt: an XPath parser context
 *
 * Check if the current value on the XPath stack is a node set or
 * an XSLT value tree.
 *
 * Returns true if the current object on the stack is a node-set.
 */
#define xmlXPathStackIsNodeSet(ctxt)					\
    (((ctxt)->value != NULL)						\
     && (((ctxt)->value->type == XPATH_NODESET)				\
         || ((ctxt)->value->type == XPATH_XSLT_TREE)))

/**
 * xmlXPathStackIsExternal:
 * @ctxt: an XPath parser context
 *
 * Checks if the current value on the XPath stack is an external
 * object.
 *
 * Returns true if the current object on the stack is an external
 * object.
 */
#define xmlXPathStackIsExternal(ctxt)					\
	((ctxt->value != NULL) && (ctxt->value->type == XPATH_USERS))

/**
 * xmlXPathEmptyNodeSet:
 * @ns:  a node-set
 *
 * Empties a node-set.
 */
#define xmlXPathEmptyNodeSet(ns)					\
    { while ((ns)->nodeNr > 0) (ns)->nodeTab[(ns)->nodeNr--] = NULL; }

/**
 * CHECK_ERROR:
 *
 * Macro to return from the function if an XPath error was detected.
 */
#define CHECK_ERROR							\
    if (ctxt->error != XPATH_EXPRESSION_OK) return

/**
 * CHECK_ERROR0:
 *
 * Macro to return 0 from the function if an XPath error was detected.
 */
#define CHECK_ERROR0							\
    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)

/**
 * XP_ERROR:
 * @X:  the error code
 *
 * Macro to raise an XPath error and return.
 */
#define XP_ERROR(X)							\
    { xmlXPathErr(ctxt, X); return; }

/**
 * XP_ERROR0:
 * @X:  the error code
 *
 * Macro to raise an XPath error and return 0.
 */
#define XP_ERROR0(X)							\
    { xmlXPathErr(ctxt, X); return(0); }

/**
 * CHECK_TYPE:
 * @typeval:  the XPath type
 *
 * Macro to check that the value on top of the XPath stack is of a given
 * type.
 */
#define CHECK_TYPE(typeval)						\
    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
        XP_ERROR(XPATH_INVALID_TYPE)

/**
 * CHECK_TYPE0:
 * @typeval:  the XPath type
 *
 * Macro to check that the value on top of the XPath stack is of a given
 * type. Return(0) in case of failure
 */
#define CHECK_TYPE0(typeval)						\
    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
        XP_ERROR0(XPATH_INVALID_TYPE)

/**
 * CHECK_ARITY:
 * @x:  the number of expected args
 *
 * Macro to check that the number of args passed to an XPath function matches.
 */
#define CHECK_ARITY(x)							\
    if (ctxt == NULL) return;						\
    if (nargs != (x))							\
        XP_ERROR(XPATH_INVALID_ARITY);					\
    if (ctxt->valueNr < ctxt->valueFrame + (x))				\
        XP_ERROR(XPATH_STACK_ERROR);

/**
 * CAST_TO_STRING:
 *
 * Macro to try to cast the value on the top of the XPath stack to a string.
 */
#define CAST_TO_STRING							\
    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
        xmlXPathStringFunction(ctxt, 1);

/**
 * CAST_TO_NUMBER:
 *
 * Macro to try to cast the value on the top of the XPath stack to a number.
 */
#define CAST_TO_NUMBER							\
    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
        xmlXPathNumberFunction(ctxt, 1);

/**
 * CAST_TO_BOOLEAN:
 *
 * Macro to try to cast the value on the top of the XPath stack to a boolean.
 */
#define CAST_TO_BOOLEAN							\
    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_BOOLEAN))	\
        xmlXPathBooleanFunction(ctxt, 1);

/*
 * Variable Lookup forwarding.
 */

XMLPUBFUN void XMLCALL
	xmlXPathRegisterVariableLookup	(xmlXPathContextPtr ctxt,
					 xmlXPathVariableLookupFunc f,
					 void *data);

/*
 * Function Lookup forwarding.
 */

XMLPUBFUN void XMLCALL
	    xmlXPathRegisterFuncLookup	(xmlXPathContextPtr ctxt,
					 xmlXPathFuncLookupFunc f,
					 void *funcCtxt);

/*
 * Error reporting.
 */
XMLPUBFUN void XMLCALL
		xmlXPatherror	(xmlXPathParserContextPtr ctxt,
				 const char *file,
				 int line,
				 int no);

XMLPUBFUN void XMLCALL
		xmlXPathErr	(xmlXPathParserContextPtr ctxt,
				 int error);

#ifdef LIBXML_DEBUG_ENABLED
XMLPUBFUN void XMLCALL
		xmlXPathDebugDumpObject	(FILE *output,
					 xmlXPathObjectPtr cur,
					 int depth);
XMLPUBFUN void XMLCALL
	    xmlXPathDebugDumpCompExpr(FILE *output,
					 xmlXPathCompExprPtr comp,
					 int depth);
#endif
/**
 * NodeSet handling.
 */
XMLPUBFUN int XMLCALL
		xmlXPathNodeSetContains		(xmlNodeSetPtr cur,
						 xmlNodePtr val);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathDifference		(xmlNodeSetPtr nodes1,
						 xmlNodeSetPtr nodes2);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathIntersection		(xmlNodeSetPtr nodes1,
						 xmlNodeSetPtr nodes2);

XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathDistinctSorted		(xmlNodeSetPtr nodes);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathDistinct		(xmlNodeSetPtr nodes);

XMLPUBFUN int XMLCALL
		xmlXPathHasSameNodes		(xmlNodeSetPtr nodes1,
						 xmlNodeSetPtr nodes2);

XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathNodeLeadingSorted	(xmlNodeSetPtr nodes,
						 xmlNodePtr node);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathLeadingSorted		(xmlNodeSetPtr nodes1,
						 xmlNodeSetPtr nodes2);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathNodeLeading		(xmlNodeSetPtr nodes,
						 xmlNodePtr node);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathLeading			(xmlNodeSetPtr nodes1,
						 xmlNodeSetPtr nodes2);

XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathNodeTrailingSorted	(xmlNodeSetPtr nodes,
						 xmlNodePtr node);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathTrailingSorted		(xmlNodeSetPtr nodes1,
						 xmlNodeSetPtr nodes2);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathNodeTrailing		(xmlNodeSetPtr nodes,
						 xmlNodePtr node);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathTrailing		(xmlNodeSetPtr nodes1,
						 xmlNodeSetPtr nodes2);


/**
 * Extending a context.
 */

XMLPUBFUN int XMLCALL
		xmlXPathRegisterNs		(xmlXPathContextPtr ctxt,
						 const xmlChar *prefix,
						 const xmlChar *ns_uri);
XMLPUBFUN const xmlChar * XMLCALL
		xmlXPathNsLookup		(xmlXPathContextPtr ctxt,
						 const xmlChar *prefix);
XMLPUBFUN void XMLCALL
		xmlXPathRegisteredNsCleanup	(xmlXPathContextPtr ctxt);

XMLPUBFUN int XMLCALL
		xmlXPathRegisterFunc		(xmlXPathContextPtr ctxt,
						 const xmlChar *name,
						 xmlXPathFunction f);
XMLPUBFUN int XMLCALL
		xmlXPathRegisterFuncNS		(xmlXPathContextPtr ctxt,
						 const xmlChar *name,
						 const xmlChar *ns_uri,
						 xmlXPathFunction f);
XMLPUBFUN int XMLCALL
		xmlXPathRegisterVariable	(xmlXPathContextPtr ctxt,
						 const xmlChar *name,
						 xmlXPathObjectPtr value);
XMLPUBFUN int XMLCALL
		xmlXPathRegisterVariableNS	(xmlXPathContextPtr ctxt,
						 const xmlChar *name,
						 const xmlChar *ns_uri,
						 xmlXPathObjectPtr value);
XMLPUBFUN xmlXPathFunction XMLCALL
		xmlXPathFunctionLookup		(xmlXPathContextPtr ctxt,
						 const xmlChar *name);
XMLPUBFUN xmlXPathFunction XMLCALL
		xmlXPathFunctionLookupNS	(xmlXPathContextPtr ctxt,
						 const xmlChar *name,
						 const xmlChar *ns_uri);
XMLPUBFUN void XMLCALL
		xmlXPathRegisteredFuncsCleanup	(xmlXPathContextPtr ctxt);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathVariableLookup		(xmlXPathContextPtr ctxt,
						 const xmlChar *name);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathVariableLookupNS	(xmlXPathContextPtr ctxt,
						 const xmlChar *name,
						 const xmlChar *ns_uri);
XMLPUBFUN void XMLCALL
		xmlXPathRegisteredVariablesCleanup(xmlXPathContextPtr ctxt);

/**
 * Utilities to extend XPath.
 */
XMLPUBFUN xmlXPathParserContextPtr XMLCALL
		  xmlXPathNewParserContext	(const xmlChar *str,
						 xmlXPathContextPtr ctxt);
XMLPUBFUN void XMLCALL
		xmlXPathFreeParserContext	(xmlXPathParserContextPtr ctxt);

/* TODO: remap to xmlXPathValuePop and Push. */
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		valuePop			(xmlXPathParserContextPtr ctxt);
XMLPUBFUN int XMLCALL
		valuePush			(xmlXPathParserContextPtr ctxt,
						 xmlXPathObjectPtr value);

XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathNewString		(const xmlChar *val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathNewCString		(const char *val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathWrapString		(xmlChar *val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathWrapCString		(char * val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathNewFloat		(double val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathNewBoolean		(int val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathNewNodeSet		(xmlNodePtr val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathNewValueTree		(xmlNodePtr val);
XMLPUBFUN int XMLCALL
		xmlXPathNodeSetAdd		(xmlNodeSetPtr cur,
						 xmlNodePtr val);
XMLPUBFUN int XMLCALL
		xmlXPathNodeSetAddUnique	(xmlNodeSetPtr cur,
						 xmlNodePtr val);
XMLPUBFUN int XMLCALL
		xmlXPathNodeSetAddNs		(xmlNodeSetPtr cur,
						 xmlNodePtr node,
						 xmlNsPtr ns);
XMLPUBFUN void XMLCALL
		xmlXPathNodeSetSort		(xmlNodeSetPtr set);

XMLPUBFUN void XMLCALL
		xmlXPathRoot			(xmlXPathParserContextPtr ctxt);
XMLPUBFUN void XMLCALL
		xmlXPathEvalExpr		(xmlXPathParserContextPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
		xmlXPathParseName		(xmlXPathParserContextPtr ctxt);
XMLPUBFUN xmlChar * XMLCALL
		xmlXPathParseNCName		(xmlXPathParserContextPtr ctxt);

/*
 * Existing functions.
 */
XMLPUBFUN double XMLCALL
		xmlXPathStringEvalNumber	(const xmlChar *str);
XMLPUBFUN int XMLCALL
		xmlXPathEvaluatePredicateResult (xmlXPathParserContextPtr ctxt,
						 xmlXPathObjectPtr res);
XMLPUBFUN void XMLCALL
		xmlXPathRegisterAllFunctions	(xmlXPathContextPtr ctxt);
XMLPUBFUN xmlNodeSetPtr XMLCALL
		xmlXPathNodeSetMerge		(xmlNodeSetPtr val1,
						 xmlNodeSetPtr val2);
XMLPUBFUN void XMLCALL
		xmlXPathNodeSetDel		(xmlNodeSetPtr cur,
						 xmlNodePtr val);
XMLPUBFUN void XMLCALL
		xmlXPathNodeSetRemove		(xmlNodeSetPtr cur,
						 int val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathNewNodeSetList		(xmlNodeSetPtr val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathWrapNodeSet		(xmlNodeSetPtr val);
XMLPUBFUN xmlXPathObjectPtr XMLCALL
		xmlXPathWrapExternal		(void *val);

XMLPUBFUN int XMLCALL xmlXPathEqualValues(xmlXPathParserContextPtr ctxt);
XMLPUBFUN int XMLCALL xmlXPathNotEqualValues(xmlXPathParserContextPtr ctxt);
XMLPUBFUN int XMLCALL xmlXPathCompareValues(xmlXPathParserContextPtr ctxt, int inf, int strict);
XMLPUBFUN void XMLCALL xmlXPathValueFlipSign(xmlXPathParserContextPtr ctxt);
XMLPUBFUN void XMLCALL xmlXPathAddValues(xmlXPathParserContextPtr ctxt);
XMLPUBFUN void XMLCALL xmlXPathSubValues(xmlXPathParserContextPtr ctxt);
XMLPUBFUN void XMLCALL xmlXPathMultValues(xmlXPathParserContextPtr ctxt);
XMLPUBFUN void XMLCALL xmlXPathDivValues(xmlXPathParserContextPtr ctxt);
XMLPUBFUN void XMLCALL xmlXPathModValues(xmlXPathParserContextPtr ctxt);

XMLPUBFUN int XMLCALL xmlXPathIsNodeType(const xmlChar *name);

/*
 * Some of the axis navigation routines.
 */
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextSelf(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextChild(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextDescendantOrSelf(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextParent(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextAncestorOrSelf(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextFollowingSibling(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextNamespace(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextAttribute(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextPreceding(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextAncestor(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextPrecedingSibling(xmlXPathParserContextPtr ctxt,
			xmlNodePtr cur);
/*
 * The official core of XPath functions.
 */
XMLPUBFUN void XMLCALL xmlXPathLastFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathPositionFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathCountFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathLocalNameFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathNamespaceURIFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathStringFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathStringLengthFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathConcatFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathContainsFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathStartsWithFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathSubstringBeforeFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathSubstringAfterFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathNormalizeFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathTranslateFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathNotFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathTrueFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathFalseFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathLangFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathNumberFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathSumFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathFloorFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathCeilingFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathRoundFunction(xmlXPathParserContextPtr ctxt, int nargs);
XMLPUBFUN void XMLCALL xmlXPathBooleanFunction(xmlXPathParserContextPtr ctxt, int nargs);

/**
 * Really internal functions
 */
XMLPUBFUN void XMLCALL xmlXPathNodeSetFreeNs(xmlNsPtr ns);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_XPATH_ENABLED */
#endif /* ! __XML_XPATH_INTERNALS_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/debugXML.h
/*
 * Summary: Tree debugging APIs
 * Description: Interfaces to a set of routines used for debugging the tree
 *              produced by the XML parser.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __DEBUG_XML__
#define __DEBUG_XML__
#include <stdio.h>
#include <libxml/xmlversion.h>
#include <libxml/tree.h>

#ifdef LIBXML_DEBUG_ENABLED

#include <libxml/xpath.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The standard Dump routines.
 */
XMLPUBFUN void XMLCALL
	xmlDebugDumpString	(FILE *output,
				 const xmlChar *str);
XMLPUBFUN void XMLCALL
	xmlDebugDumpAttr	(FILE *output,
				 xmlAttrPtr attr,
				 int depth);
XMLPUBFUN void XMLCALL
	xmlDebugDumpAttrList	(FILE *output,
				 xmlAttrPtr attr,
				 int depth);
XMLPUBFUN void XMLCALL
	xmlDebugDumpOneNode	(FILE *output,
				 xmlNodePtr node,
				 int depth);
XMLPUBFUN void XMLCALL
	xmlDebugDumpNode	(FILE *output,
				 xmlNodePtr node,
				 int depth);
XMLPUBFUN void XMLCALL
	xmlDebugDumpNodeList	(FILE *output,
				 xmlNodePtr node,
				 int depth);
XMLPUBFUN void XMLCALL
	xmlDebugDumpDocumentHead(FILE *output,
				 xmlDocPtr doc);
XMLPUBFUN void XMLCALL
	xmlDebugDumpDocument	(FILE *output,
				 xmlDocPtr doc);
XMLPUBFUN void XMLCALL
	xmlDebugDumpDTD		(FILE *output,
				 xmlDtdPtr dtd);
XMLPUBFUN void XMLCALL
	xmlDebugDumpEntities	(FILE *output,
				 xmlDocPtr doc);

/****************************************************************
 *								*
 *			Checking routines			*
 *								*
 ****************************************************************/

XMLPUBFUN int XMLCALL
	xmlDebugCheckDocument	(FILE * output,
				 xmlDocPtr doc);

/****************************************************************
 *								*
 *			XML shell helpers			*
 *								*
 ****************************************************************/

XMLPUBFUN void XMLCALL
	xmlLsOneNode		(FILE *output, xmlNodePtr node);
XMLPUBFUN int XMLCALL
	xmlLsCountNode		(xmlNodePtr node);

XMLPUBFUN const char * XMLCALL
	xmlBoolToText		(int boolval);

/****************************************************************
 *								*
 *	 The XML shell related structures and functions		*
 *								*
 ****************************************************************/

#ifdef LIBXML_XPATH_ENABLED
/**
 * xmlShellReadlineFunc:
 * @prompt:  a string prompt
 *
 * This is a generic signature for the XML shell input function.
 *
 * Returns a string which will be freed by the Shell.
 */
typedef char * (* xmlShellReadlineFunc)(char *prompt);

/**
 * xmlShellCtxt:
 *
 * A debugging shell context.
 * TODO: add the defined function tables.
 */
typedef struct _xmlShellCtxt xmlShellCtxt;
typedef xmlShellCtxt *xmlShellCtxtPtr;
struct _xmlShellCtxt {
    char *filename;
    xmlDocPtr doc;
    xmlNodePtr node;
    xmlXPathContextPtr pctxt;
    int loaded;
    FILE *output;
    xmlShellReadlineFunc input;
};

/**
 * xmlShellCmd:
 * @ctxt:  a shell context
 * @arg:  a string argument
 * @node:  a first node
 * @node2:  a second node
 *
 * This is a generic signature for the XML shell functions.
 *
 * Returns an int, negative returns indicating errors.
 */
typedef int (* xmlShellCmd) (xmlShellCtxtPtr ctxt,
                             char *arg,
			     xmlNodePtr node,
			     xmlNodePtr node2);

XMLPUBFUN void XMLCALL
	xmlShellPrintXPathError	(int errorType,
				 const char *arg);
XMLPUBFUN void XMLCALL
	xmlShellPrintXPathResult(xmlXPathObjectPtr list);
XMLPUBFUN int XMLCALL
	xmlShellList		(xmlShellCtxtPtr ctxt,
				 char *arg,
				 xmlNodePtr node,
				 xmlNodePtr node2);
XMLPUBFUN int XMLCALL
	xmlShellBase		(xmlShellCtxtPtr ctxt,
				 char *arg,
				 xmlNodePtr node,
				 xmlNodePtr node2);
XMLPUBFUN int XMLCALL
	xmlShellDir		(xmlShellCtxtPtr ctxt,
				 char *arg,
				 xmlNodePtr node,
				 xmlNodePtr node2);
XMLPUBFUN int XMLCALL
	xmlShellLoad		(xmlShellCtxtPtr ctxt,
				 char *filename,
				 xmlNodePtr node,
				 xmlNodePtr node2);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void XMLCALL
	xmlShellPrintNode	(xmlNodePtr node);
XMLPUBFUN int XMLCALL
	xmlShellCat		(xmlShellCtxtPtr ctxt,
				 char *arg,
				 xmlNodePtr node,
				 xmlNodePtr node2);
XMLPUBFUN int XMLCALL
	xmlShellWrite		(xmlShellCtxtPtr ctxt,
				 char *filename,
				 xmlNodePtr node,
				 xmlNodePtr node2);
XMLPUBFUN int XMLCALL
	xmlShellSave		(xmlShellCtxtPtr ctxt,
				 char *filename,
				 xmlNodePtr node,
				 xmlNodePtr node2);
#endif /* LIBXML_OUTPUT_ENABLED */
#ifdef LIBXML_VALID_ENABLED
XMLPUBFUN int XMLCALL
	xmlShellValidate	(xmlShellCtxtPtr ctxt,
				 char *dtd,
				 xmlNodePtr node,
				 xmlNodePtr node2);
#endif /* LIBXML_VALID_ENABLED */
XMLPUBFUN int XMLCALL
	xmlShellDu		(xmlShellCtxtPtr ctxt,
				 char *arg,
				 xmlNodePtr tree,
				 xmlNodePtr node2);
XMLPUBFUN int XMLCALL
	xmlShellPwd		(xmlShellCtxtPtr ctxt,
				 char *buffer,
				 xmlNodePtr node,
				 xmlNodePtr node2);

/*
 * The Shell interface.
 */
XMLPUBFUN void XMLCALL
	xmlShell		(xmlDocPtr doc,
				 char *filename,
				 xmlShellReadlineFunc input,
				 FILE *output);

#endif /* LIBXML_XPATH_ENABLED */

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_DEBUG_ENABLED */
#endif /* __DEBUG_XML__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/globals.h
/*
 * Summary: interface for all global variables of the library
 * Description: all the global variables and thread handling for
 *              those variables is handled by this module.
 *
 * The bottom of this file is automatically generated by build_glob.py
 * based on the description file global.data
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard
 */

#ifndef __XML_GLOBALS_H
#define __XML_GLOBALS_H

#include <libxml/xmlversion.h>
#include <libxml/parser.h>
#include <libxml/xmlerror.h>
#include <libxml/SAX.h>
#include <libxml/SAX2.h>
#include <libxml/xmlmemory.h>

#ifdef __cplusplus
extern "C" {
#endif

XMLPUBFUN void XMLCALL xmlInitGlobals(void);
XMLPUBFUN void XMLCALL xmlCleanupGlobals(void);

/**
 * xmlParserInputBufferCreateFilenameFunc:
 * @URI: the URI to read from
 * @enc: the requested source encoding
 *
 * Signature for the function doing the lookup for a suitable input method
 * corresponding to an URI.
 *
 * Returns the new xmlParserInputBufferPtr in case of success or NULL if no
 *         method was found.
 */
typedef xmlParserInputBufferPtr (*xmlParserInputBufferCreateFilenameFunc) (const char *URI, xmlCharEncoding enc);

/**
 * xmlOutputBufferCreateFilenameFunc:
 * @URI: the URI to write to
 * @enc: the requested target encoding
 *
 * Signature for the function doing the lookup for a suitable output method
 * corresponding to an URI.
 *
 * Returns the new xmlOutputBufferPtr in case of success or NULL if no
 *         method was found.
 */
typedef xmlOutputBufferPtr (*xmlOutputBufferCreateFilenameFunc) (const char *URI, xmlCharEncodingHandlerPtr encoder, int compression);

XMLPUBFUN xmlParserInputBufferCreateFilenameFunc
XMLCALL xmlParserInputBufferCreateFilenameDefault (xmlParserInputBufferCreateFilenameFunc func);
XMLPUBFUN xmlOutputBufferCreateFilenameFunc
XMLCALL xmlOutputBufferCreateFilenameDefault (xmlOutputBufferCreateFilenameFunc func);

/*
 * Externally global symbols which need to be protected for backwards
 * compatibility support.
 */

#undef	docbDefaultSAXHandler
#undef	htmlDefaultSAXHandler
#undef	oldXMLWDcompatibility
#undef	xmlBufferAllocScheme
#undef	xmlDefaultBufferSize
#undef	xmlDefaultSAXHandler
#undef	xmlDefaultSAXLocator
#undef	xmlDoValidityCheckingDefaultValue
#undef	xmlFree
#undef	xmlGenericError
#undef	xmlStructuredError
#undef	xmlGenericErrorContext
#undef	xmlStructuredErrorContext
#undef	xmlGetWarningsDefaultValue
#undef	xmlIndentTreeOutput
#undef  xmlTreeIndentString
#undef	xmlKeepBlanksDefaultValue
#undef	xmlLineNumbersDefaultValue
#undef	xmlLoadExtDtdDefaultValue
#undef	xmlMalloc
#undef	xmlMallocAtomic
#undef	xmlMemStrdup
#undef	xmlParserDebugEntities
#undef	xmlParserVersion
#undef	xmlPedanticParserDefaultValue
#undef	xmlRealloc
#undef	xmlSaveNoEmptyTags
#undef	xmlSubstituteEntitiesDefaultValue
#undef  xmlRegisterNodeDefaultValue
#undef  xmlDeregisterNodeDefaultValue
#undef  xmlLastError
#undef  xmlParserInputBufferCreateFilenameValue
#undef  xmlOutputBufferCreateFilenameValue

/**
 * xmlRegisterNodeFunc:
 * @node: the current node
 *
 * Signature for the registration callback of a created node
 */
typedef void (*xmlRegisterNodeFunc) (xmlNodePtr node);
/**
 * xmlDeregisterNodeFunc:
 * @node: the current node
 *
 * Signature for the deregistration callback of a discarded node
 */
typedef void (*xmlDeregisterNodeFunc) (xmlNodePtr node);

typedef struct _xmlGlobalState xmlGlobalState;
typedef xmlGlobalState *xmlGlobalStatePtr;
struct _xmlGlobalState
{
	const char *xmlParserVersion;

	xmlSAXLocator xmlDefaultSAXLocator;
	xmlSAXHandlerV1 xmlDefaultSAXHandler;
	xmlSAXHandlerV1 docbDefaultSAXHandler;
	xmlSAXHandlerV1 htmlDefaultSAXHandler;

	xmlFreeFunc xmlFree;
	xmlMallocFunc xmlMalloc;
	xmlStrdupFunc xmlMemStrdup;
	xmlReallocFunc xmlRealloc;

	xmlGenericErrorFunc xmlGenericError;
	xmlStructuredErrorFunc xmlStructuredError;
	void *xmlGenericErrorContext;

	int oldXMLWDcompatibility;

	xmlBufferAllocationScheme xmlBufferAllocScheme;
	int xmlDefaultBufferSize;

	int xmlSubstituteEntitiesDefaultValue;
	int xmlDoValidityCheckingDefaultValue;
	int xmlGetWarningsDefaultValue;
	int xmlKeepBlanksDefaultValue;
	int xmlLineNumbersDefaultValue;
	int xmlLoadExtDtdDefaultValue;
	int xmlParserDebugEntities;
	int xmlPedanticParserDefaultValue;

	int xmlSaveNoEmptyTags;
	int xmlIndentTreeOutput;
	const char *xmlTreeIndentString;

	xmlRegisterNodeFunc xmlRegisterNodeDefaultValue;
	xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;

	xmlMallocFunc xmlMallocAtomic;
	xmlError xmlLastError;

	xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;
	xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;

	void *xmlStructuredErrorContext;
};

#ifdef __cplusplus
}
#endif
#include <libxml/threads.h>
#ifdef __cplusplus
extern "C" {
#endif

XMLPUBFUN void XMLCALL	xmlInitializeGlobalState(xmlGlobalStatePtr gs);

XMLPUBFUN void XMLCALL xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler);

XMLPUBFUN void XMLCALL xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler);

XMLPUBFUN xmlRegisterNodeFunc XMLCALL xmlRegisterNodeDefault(xmlRegisterNodeFunc func);
XMLPUBFUN xmlRegisterNodeFunc XMLCALL xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func);
XMLPUBFUN xmlDeregisterNodeFunc XMLCALL xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func);
XMLPUBFUN xmlDeregisterNodeFunc XMLCALL xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func);

XMLPUBFUN xmlOutputBufferCreateFilenameFunc XMLCALL
	xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func);
XMLPUBFUN xmlParserInputBufferCreateFilenameFunc XMLCALL
	xmlThrDefParserInputBufferCreateFilenameDefault(xmlParserInputBufferCreateFilenameFunc func);

/** DOC_DISABLE */
/*
 * In general the memory allocation entry points are not kept
 * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED
 *    - xmlMalloc
 *    - xmlMallocAtomic
 *    - xmlRealloc
 *    - xmlMemStrdup
 *    - xmlFree
 */

#ifdef LIBXML_THREAD_ALLOC_ENABLED
#ifdef LIBXML_THREAD_ENABLED
XMLPUBFUN  xmlMallocFunc * XMLCALL __xmlMalloc(void);
#define xmlMalloc \
(*(__xmlMalloc()))
#else
XMLPUBVAR xmlMallocFunc xmlMalloc;
#endif

#ifdef LIBXML_THREAD_ENABLED
XMLPUBFUN  xmlMallocFunc * XMLCALL __xmlMallocAtomic(void);
#define xmlMallocAtomic \
(*(__xmlMallocAtomic()))
#else
XMLPUBVAR xmlMallocFunc xmlMallocAtomic;
#endif

#ifdef LIBXML_THREAD_ENABLED
XMLPUBFUN  xmlReallocFunc * XMLCALL __xmlRealloc(void);
#define xmlRealloc \
(*(__xmlRealloc()))
#else
XMLPUBVAR xmlReallocFunc xmlRealloc;
#endif

#ifdef LIBXML_THREAD_ENABLED
XMLPUBFUN  xmlFreeFunc * XMLCALL __xmlFree(void);
#define xmlFree \
(*(__xmlFree()))
#else
XMLPUBVAR xmlFreeFunc xmlFree;
#endif

#ifdef LIBXML_THREAD_ENABLED
XMLPUBFUN  xmlStrdupFunc * XMLCALL __xmlMemStrdup(void);
#define xmlMemStrdup \
(*(__xmlMemStrdup()))
#else
XMLPUBVAR xmlStrdupFunc xmlMemStrdup;
#endif

#else /* !LIBXML_THREAD_ALLOC_ENABLED */
XMLPUBVAR xmlMallocFunc xmlMalloc;
XMLPUBVAR xmlMallocFunc xmlMallocAtomic;
XMLPUBVAR xmlReallocFunc xmlRealloc;
XMLPUBVAR xmlFreeFunc xmlFree;
XMLPUBVAR xmlStrdupFunc xmlMemStrdup;
#endif /* LIBXML_THREAD_ALLOC_ENABLED */

#ifdef LIBXML_DOCB_ENABLED
XMLPUBFUN  xmlSAXHandlerV1 * XMLCALL __docbDefaultSAXHandler(void);
#ifdef LIBXML_THREAD_ENABLED
#define docbDefaultSAXHandler \
(*(__docbDefaultSAXHandler()))
#else
XMLPUBVAR xmlSAXHandlerV1 docbDefaultSAXHandler;
#endif
#endif

#ifdef LIBXML_HTML_ENABLED
XMLPUBFUN xmlSAXHandlerV1 * XMLCALL __htmlDefaultSAXHandler(void);
#ifdef LIBXML_THREAD_ENABLED
#define htmlDefaultSAXHandler \
(*(__htmlDefaultSAXHandler()))
#else
XMLPUBVAR xmlSAXHandlerV1 htmlDefaultSAXHandler;
#endif
#endif

XMLPUBFUN xmlError * XMLCALL __xmlLastError(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlLastError \
(*(__xmlLastError()))
#else
XMLPUBVAR xmlError xmlLastError;
#endif

/*
 * Everything starting from the line below is
 * Automatically generated by build_glob.py.
 * Do not modify the previous line.
 */


XMLPUBFUN int * XMLCALL __oldXMLWDcompatibility(void);
#ifdef LIBXML_THREAD_ENABLED
#define oldXMLWDcompatibility \
(*(__oldXMLWDcompatibility()))
#else
XMLPUBVAR int oldXMLWDcompatibility;
#endif

XMLPUBFUN xmlBufferAllocationScheme * XMLCALL __xmlBufferAllocScheme(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlBufferAllocScheme \
(*(__xmlBufferAllocScheme()))
#else
XMLPUBVAR xmlBufferAllocationScheme xmlBufferAllocScheme;
#endif
XMLPUBFUN xmlBufferAllocationScheme XMLCALL xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v);

XMLPUBFUN int * XMLCALL __xmlDefaultBufferSize(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlDefaultBufferSize \
(*(__xmlDefaultBufferSize()))
#else
XMLPUBVAR int xmlDefaultBufferSize;
#endif
XMLPUBFUN int XMLCALL xmlThrDefDefaultBufferSize(int v);

XMLPUBFUN xmlSAXHandlerV1 * XMLCALL __xmlDefaultSAXHandler(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlDefaultSAXHandler \
(*(__xmlDefaultSAXHandler()))
#else
XMLPUBVAR xmlSAXHandlerV1 xmlDefaultSAXHandler;
#endif

XMLPUBFUN xmlSAXLocator * XMLCALL __xmlDefaultSAXLocator(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlDefaultSAXLocator \
(*(__xmlDefaultSAXLocator()))
#else
XMLPUBVAR xmlSAXLocator xmlDefaultSAXLocator;
#endif

XMLPUBFUN int * XMLCALL __xmlDoValidityCheckingDefaultValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlDoValidityCheckingDefaultValue \
(*(__xmlDoValidityCheckingDefaultValue()))
#else
XMLPUBVAR int xmlDoValidityCheckingDefaultValue;
#endif
XMLPUBFUN int XMLCALL xmlThrDefDoValidityCheckingDefaultValue(int v);

XMLPUBFUN xmlGenericErrorFunc * XMLCALL __xmlGenericError(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlGenericError \
(*(__xmlGenericError()))
#else
XMLPUBVAR xmlGenericErrorFunc xmlGenericError;
#endif

XMLPUBFUN xmlStructuredErrorFunc * XMLCALL __xmlStructuredError(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlStructuredError \
(*(__xmlStructuredError()))
#else
XMLPUBVAR xmlStructuredErrorFunc xmlStructuredError;
#endif

XMLPUBFUN void * * XMLCALL __xmlGenericErrorContext(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlGenericErrorContext \
(*(__xmlGenericErrorContext()))
#else
XMLPUBVAR void * xmlGenericErrorContext;
#endif

XMLPUBFUN void * * XMLCALL __xmlStructuredErrorContext(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlStructuredErrorContext \
(*(__xmlStructuredErrorContext()))
#else
XMLPUBVAR void * xmlStructuredErrorContext;
#endif

XMLPUBFUN int * XMLCALL __xmlGetWarningsDefaultValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlGetWarningsDefaultValue \
(*(__xmlGetWarningsDefaultValue()))
#else
XMLPUBVAR int xmlGetWarningsDefaultValue;
#endif
XMLPUBFUN int XMLCALL xmlThrDefGetWarningsDefaultValue(int v);

XMLPUBFUN int * XMLCALL __xmlIndentTreeOutput(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlIndentTreeOutput \
(*(__xmlIndentTreeOutput()))
#else
XMLPUBVAR int xmlIndentTreeOutput;
#endif
XMLPUBFUN int XMLCALL xmlThrDefIndentTreeOutput(int v);

XMLPUBFUN const char * * XMLCALL __xmlTreeIndentString(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlTreeIndentString \
(*(__xmlTreeIndentString()))
#else
XMLPUBVAR const char * xmlTreeIndentString;
#endif
XMLPUBFUN const char * XMLCALL xmlThrDefTreeIndentString(const char * v);

XMLPUBFUN int * XMLCALL __xmlKeepBlanksDefaultValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlKeepBlanksDefaultValue \
(*(__xmlKeepBlanksDefaultValue()))
#else
XMLPUBVAR int xmlKeepBlanksDefaultValue;
#endif
XMLPUBFUN int XMLCALL xmlThrDefKeepBlanksDefaultValue(int v);

XMLPUBFUN int * XMLCALL __xmlLineNumbersDefaultValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlLineNumbersDefaultValue \
(*(__xmlLineNumbersDefaultValue()))
#else
XMLPUBVAR int xmlLineNumbersDefaultValue;
#endif
XMLPUBFUN int XMLCALL xmlThrDefLineNumbersDefaultValue(int v);

XMLPUBFUN int * XMLCALL __xmlLoadExtDtdDefaultValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlLoadExtDtdDefaultValue \
(*(__xmlLoadExtDtdDefaultValue()))
#else
XMLPUBVAR int xmlLoadExtDtdDefaultValue;
#endif
XMLPUBFUN int XMLCALL xmlThrDefLoadExtDtdDefaultValue(int v);

XMLPUBFUN int * XMLCALL __xmlParserDebugEntities(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlParserDebugEntities \
(*(__xmlParserDebugEntities()))
#else
XMLPUBVAR int xmlParserDebugEntities;
#endif
XMLPUBFUN int XMLCALL xmlThrDefParserDebugEntities(int v);

XMLPUBFUN const char * * XMLCALL __xmlParserVersion(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlParserVersion \
(*(__xmlParserVersion()))
#else
XMLPUBVAR const char * xmlParserVersion;
#endif

XMLPUBFUN int * XMLCALL __xmlPedanticParserDefaultValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlPedanticParserDefaultValue \
(*(__xmlPedanticParserDefaultValue()))
#else
XMLPUBVAR int xmlPedanticParserDefaultValue;
#endif
XMLPUBFUN int XMLCALL xmlThrDefPedanticParserDefaultValue(int v);

XMLPUBFUN int * XMLCALL __xmlSaveNoEmptyTags(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlSaveNoEmptyTags \
(*(__xmlSaveNoEmptyTags()))
#else
XMLPUBVAR int xmlSaveNoEmptyTags;
#endif
XMLPUBFUN int XMLCALL xmlThrDefSaveNoEmptyTags(int v);

XMLPUBFUN int * XMLCALL __xmlSubstituteEntitiesDefaultValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlSubstituteEntitiesDefaultValue \
(*(__xmlSubstituteEntitiesDefaultValue()))
#else
XMLPUBVAR int xmlSubstituteEntitiesDefaultValue;
#endif
XMLPUBFUN int XMLCALL xmlThrDefSubstituteEntitiesDefaultValue(int v);

XMLPUBFUN xmlRegisterNodeFunc * XMLCALL __xmlRegisterNodeDefaultValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlRegisterNodeDefaultValue \
(*(__xmlRegisterNodeDefaultValue()))
#else
XMLPUBVAR xmlRegisterNodeFunc xmlRegisterNodeDefaultValue;
#endif

XMLPUBFUN xmlDeregisterNodeFunc * XMLCALL __xmlDeregisterNodeDefaultValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlDeregisterNodeDefaultValue \
(*(__xmlDeregisterNodeDefaultValue()))
#else
XMLPUBVAR xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;
#endif

XMLPUBFUN xmlParserInputBufferCreateFilenameFunc * XMLCALL __xmlParserInputBufferCreateFilenameValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlParserInputBufferCreateFilenameValue \
(*(__xmlParserInputBufferCreateFilenameValue()))
#else
XMLPUBVAR xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;
#endif

XMLPUBFUN xmlOutputBufferCreateFilenameFunc * XMLCALL __xmlOutputBufferCreateFilenameValue(void);
#ifdef LIBXML_THREAD_ENABLED
#define xmlOutputBufferCreateFilenameValue \
(*(__xmlOutputBufferCreateFilenameValue()))
#else
XMLPUBVAR xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;
#endif

#ifdef __cplusplus
}
#endif

#endif /* __XML_GLOBALS_H */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/HTMLparser.h
/*
 * Summary: interface for an HTML 4.0 non-verifying parser
 * Description: this module implements an HTML 4.0 non-verifying parser
 *              with API compatible with the XML parser ones. It should
 *              be able to parse "real world" HTML, even if severely
 *              broken from a specification point of view.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __HTML_PARSER_H__
#define __HTML_PARSER_H__
#include <libxml/xmlversion.h>
#include <libxml/parser.h>

#ifdef LIBXML_HTML_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Most of the back-end structures from XML and HTML are shared.
 */
typedef xmlParserCtxt htmlParserCtxt;
typedef xmlParserCtxtPtr htmlParserCtxtPtr;
typedef xmlParserNodeInfo htmlParserNodeInfo;
typedef xmlSAXHandler htmlSAXHandler;
typedef xmlSAXHandlerPtr htmlSAXHandlerPtr;
typedef xmlParserInput htmlParserInput;
typedef xmlParserInputPtr htmlParserInputPtr;
typedef xmlDocPtr htmlDocPtr;
typedef xmlNodePtr htmlNodePtr;

/*
 * Internal description of an HTML element, representing HTML 4.01
 * and XHTML 1.0 (which share the same structure).
 */
typedef struct _htmlElemDesc htmlElemDesc;
typedef htmlElemDesc *htmlElemDescPtr;
struct _htmlElemDesc {
    const char *name;	/* The tag name */
    char startTag;      /* Whether the start tag can be implied */
    char endTag;        /* Whether the end tag can be implied */
    char saveEndTag;    /* Whether the end tag should be saved */
    char empty;         /* Is this an empty element ? */
    char depr;          /* Is this a deprecated element ? */
    char dtd;           /* 1: only in Loose DTD, 2: only Frameset one */
    char isinline;      /* is this a block 0 or inline 1 element */
    const char *desc;   /* the description */

/* NRK Jan.2003
 * New fields encapsulating HTML structure
 *
 * Bugs:
 *	This is a very limited representation.  It fails to tell us when
 *	an element *requires* subelements (we only have whether they're
 *	allowed or not), and it doesn't tell us where CDATA and PCDATA
 *	are allowed.  Some element relationships are not fully represented:
 *	these are flagged with the word MODIFIER
 */
    const char** subelts;		/* allowed sub-elements of this element */
    const char* defaultsubelt;	/* subelement for suggested auto-repair
					   if necessary or NULL */
    const char** attrs_opt;		/* Optional Attributes */
    const char** attrs_depr;		/* Additional deprecated attributes */
    const char** attrs_req;		/* Required attributes */
};

/*
 * Internal description of an HTML entity.
 */
typedef struct _htmlEntityDesc htmlEntityDesc;
typedef htmlEntityDesc *htmlEntityDescPtr;
struct _htmlEntityDesc {
    unsigned int value;	/* the UNICODE value for the character */
    const char *name;	/* The entity name */
    const char *desc;   /* the description */
};

/*
 * There is only few public functions.
 */
XMLPUBFUN const htmlElemDesc * XMLCALL
			htmlTagLookup	(const xmlChar *tag);
XMLPUBFUN const htmlEntityDesc * XMLCALL
			htmlEntityLookup(const xmlChar *name);
XMLPUBFUN const htmlEntityDesc * XMLCALL
			htmlEntityValueLookup(unsigned int value);

XMLPUBFUN int XMLCALL
			htmlIsAutoClosed(htmlDocPtr doc,
					 htmlNodePtr elem);
XMLPUBFUN int XMLCALL
			htmlAutoCloseTag(htmlDocPtr doc,
					 const xmlChar *name,
					 htmlNodePtr elem);
XMLPUBFUN const htmlEntityDesc * XMLCALL
			htmlParseEntityRef(htmlParserCtxtPtr ctxt,
					 const xmlChar **str);
XMLPUBFUN int XMLCALL
			htmlParseCharRef(htmlParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
			htmlParseElement(htmlParserCtxtPtr ctxt);

XMLPUBFUN htmlParserCtxtPtr XMLCALL
			htmlNewParserCtxt(void);

XMLPUBFUN htmlParserCtxtPtr XMLCALL
			htmlCreateMemoryParserCtxt(const char *buffer,
						   int size);

XMLPUBFUN int XMLCALL
			htmlParseDocument(htmlParserCtxtPtr ctxt);
XMLPUBFUN htmlDocPtr XMLCALL
			htmlSAXParseDoc	(xmlChar *cur,
					 const char *encoding,
					 htmlSAXHandlerPtr sax,
					 void *userData);
XMLPUBFUN htmlDocPtr XMLCALL
			htmlParseDoc	(xmlChar *cur,
					 const char *encoding);
XMLPUBFUN htmlDocPtr XMLCALL
			htmlSAXParseFile(const char *filename,
					 const char *encoding,
					 htmlSAXHandlerPtr sax,
					 void *userData);
XMLPUBFUN htmlDocPtr XMLCALL
			htmlParseFile	(const char *filename,
					 const char *encoding);
XMLPUBFUN int XMLCALL
			UTF8ToHtml	(unsigned char *out,
					 int *outlen,
					 const unsigned char *in,
					 int *inlen);
XMLPUBFUN int XMLCALL
			htmlEncodeEntities(unsigned char *out,
					 int *outlen,
					 const unsigned char *in,
					 int *inlen, int quoteChar);
XMLPUBFUN int XMLCALL
			htmlIsScriptAttribute(const xmlChar *name);
XMLPUBFUN int XMLCALL
			htmlHandleOmittedElem(int val);

#ifdef LIBXML_PUSH_ENABLED
/**
 * Interfaces for the Push mode.
 */
XMLPUBFUN htmlParserCtxtPtr XMLCALL
			htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax,
						 void *user_data,
						 const char *chunk,
						 int size,
						 const char *filename,
						 xmlCharEncoding enc);
XMLPUBFUN int XMLCALL
			htmlParseChunk		(htmlParserCtxtPtr ctxt,
						 const char *chunk,
						 int size,
						 int terminate);
#endif /* LIBXML_PUSH_ENABLED */

XMLPUBFUN void XMLCALL
			htmlFreeParserCtxt	(htmlParserCtxtPtr ctxt);

/*
 * New set of simpler/more flexible APIs
 */
/**
 * xmlParserOption:
 *
 * This is the set of XML parser options that can be passed down
 * to the xmlReadDoc() and similar calls.
 */
typedef enum {
    HTML_PARSE_RECOVER  = 1<<0, /* Relaxed parsing */
    HTML_PARSE_NODEFDTD = 1<<2, /* do not default a doctype if not found */
    HTML_PARSE_NOERROR	= 1<<5,	/* suppress error reports */
    HTML_PARSE_NOWARNING= 1<<6,	/* suppress warning reports */
    HTML_PARSE_PEDANTIC	= 1<<7,	/* pedantic error reporting */
    HTML_PARSE_NOBLANKS	= 1<<8,	/* remove blank nodes */
    HTML_PARSE_NONET	= 1<<11,/* Forbid network access */
    HTML_PARSE_NOIMPLIED= 1<<13,/* Do not add implied html/body... elements */
    HTML_PARSE_COMPACT  = 1<<16,/* compact small text nodes */
    HTML_PARSE_IGNORE_ENC=1<<21 /* ignore internal document encoding hint */
} htmlParserOption;

XMLPUBFUN void XMLCALL
		htmlCtxtReset		(htmlParserCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
		htmlCtxtUseOptions	(htmlParserCtxtPtr ctxt,
					 int options);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlReadDoc		(const xmlChar *cur,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlReadFile		(const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlReadMemory		(const char *buffer,
					 int size,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlReadFd		(int fd,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlReadIO		(xmlInputReadCallback ioread,
					 xmlInputCloseCallback ioclose,
					 void *ioctx,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlCtxtReadDoc		(xmlParserCtxtPtr ctxt,
					 const xmlChar *cur,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlCtxtReadFile		(xmlParserCtxtPtr ctxt,
					 const char *filename,
					 const char *encoding,
					 int options);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlCtxtReadMemory		(xmlParserCtxtPtr ctxt,
					 const char *buffer,
					 int size,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlCtxtReadFd		(xmlParserCtxtPtr ctxt,
					 int fd,
					 const char *URL,
					 const char *encoding,
					 int options);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlCtxtReadIO		(xmlParserCtxtPtr ctxt,
					 xmlInputReadCallback ioread,
					 xmlInputCloseCallback ioclose,
					 void *ioctx,
					 const char *URL,
					 const char *encoding,
					 int options);

/* NRK/Jan2003: further knowledge of HTML structure
 */
typedef enum {
  HTML_NA = 0 ,		/* something we don't check at all */
  HTML_INVALID = 0x1 ,
  HTML_DEPRECATED = 0x2 ,
  HTML_VALID = 0x4 ,
  HTML_REQUIRED = 0xc /* VALID bit set so ( & HTML_VALID ) is TRUE */
} htmlStatus ;

/* Using htmlElemDesc rather than name here, to emphasise the fact
   that otherwise there's a lookup overhead
*/
XMLPUBFUN htmlStatus XMLCALL htmlAttrAllowed(const htmlElemDesc*, const xmlChar*, int) ;
XMLPUBFUN int XMLCALL htmlElementAllowedHere(const htmlElemDesc*, const xmlChar*) ;
XMLPUBFUN htmlStatus XMLCALL htmlElementStatusHere(const htmlElemDesc*, const htmlElemDesc*) ;
XMLPUBFUN htmlStatus XMLCALL htmlNodeStatus(const htmlNodePtr, int) ;
/**
 * htmlDefaultSubelement:
 * @elt: HTML element
 *
 * Returns the default subelement for this element
 */
#define htmlDefaultSubelement(elt) elt->defaultsubelt
/**
 * htmlElementAllowedHereDesc:
 * @parent: HTML parent element
 * @elt: HTML element
 *
 * Checks whether an HTML element description may be a
 * direct child of the specified element.
 *
 * Returns 1 if allowed; 0 otherwise.
 */
#define htmlElementAllowedHereDesc(parent,elt) \
	htmlElementAllowedHere((parent), (elt)->name)
/**
 * htmlRequiredAttrs:
 * @elt: HTML element
 *
 * Returns the attributes required for the specified element.
 */
#define htmlRequiredAttrs(elt) (elt)->attrs_req


#ifdef __cplusplus
}
#endif

#endif /* LIBXML_HTML_ENABLED */
#endif /* __HTML_PARSER_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/schematron.h
/*
 * Summary: XML Schemastron implementation
 * Description: interface to the XML Schematron validity checking.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */


#ifndef __XML_SCHEMATRON_H__
#define __XML_SCHEMATRON_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_SCHEMATRON_ENABLED

#include <libxml/tree.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    XML_SCHEMATRON_OUT_QUIET = 1 << 0,	/* quiet no report */
    XML_SCHEMATRON_OUT_TEXT = 1 << 1,	/* build a textual report */
    XML_SCHEMATRON_OUT_XML = 1 << 2,	/* output SVRL */
    XML_SCHEMATRON_OUT_ERROR = 1 << 3,  /* output via xmlStructuredErrorFunc */
    XML_SCHEMATRON_OUT_FILE = 1 << 8,	/* output to a file descriptor */
    XML_SCHEMATRON_OUT_BUFFER = 1 << 9,	/* output to a buffer */
    XML_SCHEMATRON_OUT_IO = 1 << 10	/* output to I/O mechanism */
} xmlSchematronValidOptions;

/**
 * The schemas related types are kept internal
 */
typedef struct _xmlSchematron xmlSchematron;
typedef xmlSchematron *xmlSchematronPtr;

/**
 * xmlSchematronValidityErrorFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of an error callback from a Schematron validation
 */
typedef void (*xmlSchematronValidityErrorFunc) (void *ctx, const char *msg, ...);

/**
 * xmlSchematronValidityWarningFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of a warning callback from a Schematron validation
 */
typedef void (*xmlSchematronValidityWarningFunc) (void *ctx, const char *msg, ...);

/**
 * A schemas validation context
 */
typedef struct _xmlSchematronParserCtxt xmlSchematronParserCtxt;
typedef xmlSchematronParserCtxt *xmlSchematronParserCtxtPtr;

typedef struct _xmlSchematronValidCtxt xmlSchematronValidCtxt;
typedef xmlSchematronValidCtxt *xmlSchematronValidCtxtPtr;

/*
 * Interfaces for parsing.
 */
XMLPUBFUN xmlSchematronParserCtxtPtr XMLCALL
	    xmlSchematronNewParserCtxt	(const char *URL);
XMLPUBFUN xmlSchematronParserCtxtPtr XMLCALL
	    xmlSchematronNewMemParserCtxt(const char *buffer,
					 int size);
XMLPUBFUN xmlSchematronParserCtxtPtr XMLCALL
	    xmlSchematronNewDocParserCtxt(xmlDocPtr doc);
XMLPUBFUN void XMLCALL
	    xmlSchematronFreeParserCtxt	(xmlSchematronParserCtxtPtr ctxt);
/*****
XMLPUBFUN void XMLCALL
	    xmlSchematronSetParserErrors(xmlSchematronParserCtxtPtr ctxt,
					 xmlSchematronValidityErrorFunc err,
					 xmlSchematronValidityWarningFunc warn,
					 void *ctx);
XMLPUBFUN int XMLCALL
		xmlSchematronGetParserErrors(xmlSchematronParserCtxtPtr ctxt,
					xmlSchematronValidityErrorFunc * err,
					xmlSchematronValidityWarningFunc * warn,
					void **ctx);
XMLPUBFUN int XMLCALL
		xmlSchematronIsValid	(xmlSchematronValidCtxtPtr ctxt);
 *****/
XMLPUBFUN xmlSchematronPtr XMLCALL
	    xmlSchematronParse		(xmlSchematronParserCtxtPtr ctxt);
XMLPUBFUN void XMLCALL
	    xmlSchematronFree		(xmlSchematronPtr schema);
/*
 * Interfaces for validating
 */
XMLPUBFUN void XMLCALL
	    xmlSchematronSetValidStructuredErrors(
	                                  xmlSchematronValidCtxtPtr ctxt,
					  xmlStructuredErrorFunc serror,
					  void *ctx);
/******
XMLPUBFUN void XMLCALL
	    xmlSchematronSetValidErrors	(xmlSchematronValidCtxtPtr ctxt,
					 xmlSchematronValidityErrorFunc err,
					 xmlSchematronValidityWarningFunc warn,
					 void *ctx);
XMLPUBFUN int XMLCALL
	    xmlSchematronGetValidErrors	(xmlSchematronValidCtxtPtr ctxt,
					 xmlSchematronValidityErrorFunc *err,
					 xmlSchematronValidityWarningFunc *warn,
					 void **ctx);
XMLPUBFUN int XMLCALL
	    xmlSchematronSetValidOptions(xmlSchematronValidCtxtPtr ctxt,
					 int options);
XMLPUBFUN int XMLCALL
	    xmlSchematronValidCtxtGetOptions(xmlSchematronValidCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
            xmlSchematronValidateOneElement (xmlSchematronValidCtxtPtr ctxt,
			                 xmlNodePtr elem);
 *******/

XMLPUBFUN xmlSchematronValidCtxtPtr XMLCALL
	    xmlSchematronNewValidCtxt	(xmlSchematronPtr schema,
					 int options);
XMLPUBFUN void XMLCALL
	    xmlSchematronFreeValidCtxt	(xmlSchematronValidCtxtPtr ctxt);
XMLPUBFUN int XMLCALL
	    xmlSchematronValidateDoc	(xmlSchematronValidCtxtPtr ctxt,
					 xmlDocPtr instance);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_SCHEMATRON_ENABLED */
#endif /* __XML_SCHEMATRON_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlwriter.h
/*
 * Summary: text writing API for XML
 * Description: text writing API for XML
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Alfred Mickautsch <alfred@mickautsch.de>
 */

#ifndef __XML_XMLWRITER_H__
#define __XML_XMLWRITER_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_WRITER_ENABLED

#include <stdarg.h>
#include <libxml/xmlIO.h>
#include <libxml/list.h>
#include <libxml/xmlstring.h>

#ifdef __cplusplus
extern "C" {
#endif

    typedef struct _xmlTextWriter xmlTextWriter;
    typedef xmlTextWriter *xmlTextWriterPtr;

/*
 * Constructors & Destructor
 */
    XMLPUBFUN xmlTextWriterPtr XMLCALL
        xmlNewTextWriter(xmlOutputBufferPtr out);
    XMLPUBFUN xmlTextWriterPtr XMLCALL
        xmlNewTextWriterFilename(const char *uri, int compression);
    XMLPUBFUN xmlTextWriterPtr XMLCALL
        xmlNewTextWriterMemory(xmlBufferPtr buf, int compression);
    XMLPUBFUN xmlTextWriterPtr XMLCALL
        xmlNewTextWriterPushParser(xmlParserCtxtPtr ctxt, int compression);
    XMLPUBFUN xmlTextWriterPtr XMLCALL
        xmlNewTextWriterDoc(xmlDocPtr * doc, int compression);
    XMLPUBFUN xmlTextWriterPtr XMLCALL
        xmlNewTextWriterTree(xmlDocPtr doc, xmlNodePtr node,
                             int compression);
    XMLPUBFUN void XMLCALL xmlFreeTextWriter(xmlTextWriterPtr writer);

/*
 * Functions
 */


/*
 * Document
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterStartDocument(xmlTextWriterPtr writer,
                                   const char *version,
                                   const char *encoding,
                                   const char *standalone);
    XMLPUBFUN int XMLCALL xmlTextWriterEndDocument(xmlTextWriterPtr
                                                   writer);

/*
 * Comments
 */
    XMLPUBFUN int XMLCALL xmlTextWriterStartComment(xmlTextWriterPtr
                                                    writer);
    XMLPUBFUN int XMLCALL xmlTextWriterEndComment(xmlTextWriterPtr writer);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatComment(xmlTextWriterPtr writer,
                                        const char *format, ...)
					LIBXML_ATTR_FORMAT(2,3);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatComment(xmlTextWriterPtr writer,
                                         const char *format,
                                         va_list argptr)
					 LIBXML_ATTR_FORMAT(2,0);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteComment(xmlTextWriterPtr
                                                    writer,
                                                    const xmlChar *
                                                    content);

/*
 * Elements
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterStartElement(xmlTextWriterPtr writer,
                                  const xmlChar * name);
    XMLPUBFUN int XMLCALL xmlTextWriterStartElementNS(xmlTextWriterPtr
                                                      writer,
                                                      const xmlChar *
                                                      prefix,
                                                      const xmlChar * name,
                                                      const xmlChar *
                                                      namespaceURI);
    XMLPUBFUN int XMLCALL xmlTextWriterEndElement(xmlTextWriterPtr writer);
    XMLPUBFUN int XMLCALL xmlTextWriterFullEndElement(xmlTextWriterPtr
                                                      writer);

/*
 * Elements conveniency functions
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatElement(xmlTextWriterPtr writer,
                                        const xmlChar * name,
                                        const char *format, ...)
					LIBXML_ATTR_FORMAT(3,4);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatElement(xmlTextWriterPtr writer,
                                         const xmlChar * name,
                                         const char *format,
                                         va_list argptr)
					 LIBXML_ATTR_FORMAT(3,0);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteElement(xmlTextWriterPtr
                                                    writer,
                                                    const xmlChar * name,
                                                    const xmlChar *
                                                    content);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatElementNS(xmlTextWriterPtr writer,
                                          const xmlChar * prefix,
                                          const xmlChar * name,
                                          const xmlChar * namespaceURI,
                                          const char *format, ...)
					  LIBXML_ATTR_FORMAT(5,6);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatElementNS(xmlTextWriterPtr writer,
                                           const xmlChar * prefix,
                                           const xmlChar * name,
                                           const xmlChar * namespaceURI,
                                           const char *format,
                                           va_list argptr)
					   LIBXML_ATTR_FORMAT(5,0);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteElementNS(xmlTextWriterPtr
                                                      writer,
                                                      const xmlChar *
                                                      prefix,
                                                      const xmlChar * name,
                                                      const xmlChar *
                                                      namespaceURI,
                                                      const xmlChar *
                                                      content);

/*
 * Text
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatRaw(xmlTextWriterPtr writer,
                                    const char *format, ...)
				    LIBXML_ATTR_FORMAT(2,3);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatRaw(xmlTextWriterPtr writer,
                                     const char *format, va_list argptr)
				     LIBXML_ATTR_FORMAT(2,0);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteRawLen(xmlTextWriterPtr writer,
                                 const xmlChar * content, int len);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteRaw(xmlTextWriterPtr writer,
                              const xmlChar * content);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteFormatString(xmlTextWriterPtr
                                                         writer,
                                                         const char
                                                         *format, ...)
							 LIBXML_ATTR_FORMAT(2,3);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteVFormatString(xmlTextWriterPtr
                                                          writer,
                                                          const char
                                                          *format,
                                                          va_list argptr)
							  LIBXML_ATTR_FORMAT(2,0);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteString(xmlTextWriterPtr writer,
                                                   const xmlChar *
                                                   content);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteBase64(xmlTextWriterPtr writer,
                                                   const char *data,
                                                   int start, int len);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteBinHex(xmlTextWriterPtr writer,
                                                   const char *data,
                                                   int start, int len);

/*
 * Attributes
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterStartAttribute(xmlTextWriterPtr writer,
                                    const xmlChar * name);
    XMLPUBFUN int XMLCALL xmlTextWriterStartAttributeNS(xmlTextWriterPtr
                                                        writer,
                                                        const xmlChar *
                                                        prefix,
                                                        const xmlChar *
                                                        name,
                                                        const xmlChar *
                                                        namespaceURI);
    XMLPUBFUN int XMLCALL xmlTextWriterEndAttribute(xmlTextWriterPtr
                                                    writer);

/*
 * Attributes conveniency functions
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatAttribute(xmlTextWriterPtr writer,
                                          const xmlChar * name,
                                          const char *format, ...)
					  LIBXML_ATTR_FORMAT(3,4);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatAttribute(xmlTextWriterPtr writer,
                                           const xmlChar * name,
                                           const char *format,
                                           va_list argptr)
					   LIBXML_ATTR_FORMAT(3,0);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteAttribute(xmlTextWriterPtr
                                                      writer,
                                                      const xmlChar * name,
                                                      const xmlChar *
                                                      content);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatAttributeNS(xmlTextWriterPtr writer,
                                            const xmlChar * prefix,
                                            const xmlChar * name,
                                            const xmlChar * namespaceURI,
                                            const char *format, ...)
					    LIBXML_ATTR_FORMAT(5,6);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatAttributeNS(xmlTextWriterPtr writer,
                                             const xmlChar * prefix,
                                             const xmlChar * name,
                                             const xmlChar * namespaceURI,
                                             const char *format,
                                             va_list argptr)
					     LIBXML_ATTR_FORMAT(5,0);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteAttributeNS(xmlTextWriterPtr
                                                        writer,
                                                        const xmlChar *
                                                        prefix,
                                                        const xmlChar *
                                                        name,
                                                        const xmlChar *
                                                        namespaceURI,
                                                        const xmlChar *
                                                        content);

/*
 * PI's
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterStartPI(xmlTextWriterPtr writer,
                             const xmlChar * target);
    XMLPUBFUN int XMLCALL xmlTextWriterEndPI(xmlTextWriterPtr writer);

/*
 * PI conveniency functions
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatPI(xmlTextWriterPtr writer,
                                   const xmlChar * target,
                                   const char *format, ...)
				   LIBXML_ATTR_FORMAT(3,4);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatPI(xmlTextWriterPtr writer,
                                    const xmlChar * target,
                                    const char *format, va_list argptr)
				    LIBXML_ATTR_FORMAT(3,0);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWritePI(xmlTextWriterPtr writer,
                             const xmlChar * target,
                             const xmlChar * content);

/**
 * xmlTextWriterWriteProcessingInstruction:
 *
 * This macro maps to xmlTextWriterWritePI
 */
#define xmlTextWriterWriteProcessingInstruction xmlTextWriterWritePI

/*
 * CDATA
 */
    XMLPUBFUN int XMLCALL xmlTextWriterStartCDATA(xmlTextWriterPtr writer);
    XMLPUBFUN int XMLCALL xmlTextWriterEndCDATA(xmlTextWriterPtr writer);

/*
 * CDATA conveniency functions
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatCDATA(xmlTextWriterPtr writer,
                                      const char *format, ...)
				      LIBXML_ATTR_FORMAT(2,3);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatCDATA(xmlTextWriterPtr writer,
                                       const char *format, va_list argptr)
				       LIBXML_ATTR_FORMAT(2,0);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteCDATA(xmlTextWriterPtr writer,
                                const xmlChar * content);

/*
 * DTD
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterStartDTD(xmlTextWriterPtr writer,
                              const xmlChar * name,
                              const xmlChar * pubid,
                              const xmlChar * sysid);
    XMLPUBFUN int XMLCALL xmlTextWriterEndDTD(xmlTextWriterPtr writer);

/*
 * DTD conveniency functions
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatDTD(xmlTextWriterPtr writer,
                                    const xmlChar * name,
                                    const xmlChar * pubid,
                                    const xmlChar * sysid,
                                    const char *format, ...)
				    LIBXML_ATTR_FORMAT(5,6);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatDTD(xmlTextWriterPtr writer,
                                     const xmlChar * name,
                                     const xmlChar * pubid,
                                     const xmlChar * sysid,
                                     const char *format, va_list argptr)
				     LIBXML_ATTR_FORMAT(5,0);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteDTD(xmlTextWriterPtr writer,
                              const xmlChar * name,
                              const xmlChar * pubid,
                              const xmlChar * sysid,
                              const xmlChar * subset);

/**
 * xmlTextWriterWriteDocType:
 *
 * this macro maps to xmlTextWriterWriteDTD
 */
#define xmlTextWriterWriteDocType xmlTextWriterWriteDTD

/*
 * DTD element definition
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterStartDTDElement(xmlTextWriterPtr writer,
                                     const xmlChar * name);
    XMLPUBFUN int XMLCALL xmlTextWriterEndDTDElement(xmlTextWriterPtr
                                                     writer);

/*
 * DTD element definition conveniency functions
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatDTDElement(xmlTextWriterPtr writer,
                                           const xmlChar * name,
                                           const char *format, ...)
					   LIBXML_ATTR_FORMAT(3,4);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatDTDElement(xmlTextWriterPtr writer,
                                            const xmlChar * name,
                                            const char *format,
                                            va_list argptr)
					    LIBXML_ATTR_FORMAT(3,0);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteDTDElement(xmlTextWriterPtr
                                                       writer,
                                                       const xmlChar *
                                                       name,
                                                       const xmlChar *
                                                       content);

/*
 * DTD attribute list definition
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterStartDTDAttlist(xmlTextWriterPtr writer,
                                     const xmlChar * name);
    XMLPUBFUN int XMLCALL xmlTextWriterEndDTDAttlist(xmlTextWriterPtr
                                                     writer);

/*
 * DTD attribute list definition conveniency functions
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatDTDAttlist(xmlTextWriterPtr writer,
                                           const xmlChar * name,
                                           const char *format, ...)
					   LIBXML_ATTR_FORMAT(3,4);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatDTDAttlist(xmlTextWriterPtr writer,
                                            const xmlChar * name,
                                            const char *format,
                                            va_list argptr)
					    LIBXML_ATTR_FORMAT(3,0);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteDTDAttlist(xmlTextWriterPtr
                                                       writer,
                                                       const xmlChar *
                                                       name,
                                                       const xmlChar *
                                                       content);

/*
 * DTD entity definition
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterStartDTDEntity(xmlTextWriterPtr writer,
                                    int pe, const xmlChar * name);
    XMLPUBFUN int XMLCALL xmlTextWriterEndDTDEntity(xmlTextWriterPtr
                                                    writer);

/*
 * DTD entity definition conveniency functions
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteFormatDTDInternalEntity(xmlTextWriterPtr writer,
                                                  int pe,
                                                  const xmlChar * name,
                                                  const char *format, ...)
						  LIBXML_ATTR_FORMAT(4,5);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteVFormatDTDInternalEntity(xmlTextWriterPtr writer,
                                                   int pe,
                                                   const xmlChar * name,
                                                   const char *format,
                                                   va_list argptr)
						   LIBXML_ATTR_FORMAT(4,0);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteDTDInternalEntity(xmlTextWriterPtr writer,
                                            int pe,
                                            const xmlChar * name,
                                            const xmlChar * content);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteDTDExternalEntity(xmlTextWriterPtr writer,
                                            int pe,
                                            const xmlChar * name,
                                            const xmlChar * pubid,
                                            const xmlChar * sysid,
                                            const xmlChar * ndataid);
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteDTDExternalEntityContents(xmlTextWriterPtr
                                                    writer,
                                                    const xmlChar * pubid,
                                                    const xmlChar * sysid,
                                                    const xmlChar *
                                                    ndataid);
    XMLPUBFUN int XMLCALL xmlTextWriterWriteDTDEntity(xmlTextWriterPtr
                                                      writer, int pe,
                                                      const xmlChar * name,
                                                      const xmlChar *
                                                      pubid,
                                                      const xmlChar *
                                                      sysid,
                                                      const xmlChar *
                                                      ndataid,
                                                      const xmlChar *
                                                      content);

/*
 * DTD notation definition
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterWriteDTDNotation(xmlTextWriterPtr writer,
                                      const xmlChar * name,
                                      const xmlChar * pubid,
                                      const xmlChar * sysid);

/*
 * Indentation
 */
    XMLPUBFUN int XMLCALL
        xmlTextWriterSetIndent(xmlTextWriterPtr writer, int indent);
    XMLPUBFUN int XMLCALL
        xmlTextWriterSetIndentString(xmlTextWriterPtr writer,
                                     const xmlChar * str);

    XMLPUBFUN int XMLCALL
        xmlTextWriterSetQuoteChar(xmlTextWriterPtr writer, xmlChar quotechar);


/*
 * misc
 */
    XMLPUBFUN int XMLCALL xmlTextWriterFlush(xmlTextWriterPtr writer);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_WRITER_ENABLED */

#endif                          /* __XML_XMLWRITER_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/c14n.h
/*
 * Summary: Provide Canonical XML and Exclusive XML Canonicalization
 * Description: the c14n modules provides a
 *
 * "Canonical XML" implementation
 * http://www.w3.org/TR/xml-c14n
 *
 * and an
 *
 * "Exclusive XML Canonicalization" implementation
 * http://www.w3.org/TR/xml-exc-c14n

 * Copy: See Copyright for the status of this software.
 *
 * Author: Aleksey Sanin <aleksey@aleksey.com>
 */
#ifndef __XML_C14N_H__
#define __XML_C14N_H__
#ifdef LIBXML_C14N_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <libxml/xmlversion.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>

/*
 * XML Canonicazation
 * http://www.w3.org/TR/xml-c14n
 *
 * Exclusive XML Canonicazation
 * http://www.w3.org/TR/xml-exc-c14n
 *
 * Canonical form of an XML document could be created if and only if
 *  a) default attributes (if any) are added to all nodes
 *  b) all character and parsed entity references are resolved
 * In order to achive this in libxml2 the document MUST be loaded with
 * following global setings:
 *
 *    xmlLoadExtDtdDefaultValue = XML_DETECT_IDS | XML_COMPLETE_ATTRS;
 *    xmlSubstituteEntitiesDefault(1);
 *
 * or corresponding parser context setting:
 *    xmlParserCtxtPtr ctxt;
 *
 *    ...
 *    ctxt->loadsubset = XML_DETECT_IDS | XML_COMPLETE_ATTRS;
 *    ctxt->replaceEntities = 1;
 *    ...
 */

/*
 * xmlC14NMode:
 *
 * Predefined values for C14N modes
 *
 */
typedef enum {
    XML_C14N_1_0            = 0,    /* Origianal C14N 1.0 spec */
    XML_C14N_EXCLUSIVE_1_0  = 1,    /* Exclusive C14N 1.0 spec */
    XML_C14N_1_1            = 2     /* C14N 1.1 spec */
} xmlC14NMode;

XMLPUBFUN int XMLCALL
		xmlC14NDocSaveTo	(xmlDocPtr doc,
					 xmlNodeSetPtr nodes,
					 int mode, /* a xmlC14NMode */
					 xmlChar **inclusive_ns_prefixes,
					 int with_comments,
					 xmlOutputBufferPtr buf);

XMLPUBFUN int XMLCALL
		xmlC14NDocDumpMemory	(xmlDocPtr doc,
					 xmlNodeSetPtr nodes,
					 int mode, /* a xmlC14NMode */
					 xmlChar **inclusive_ns_prefixes,
					 int with_comments,
					 xmlChar **doc_txt_ptr);

XMLPUBFUN int XMLCALL
		xmlC14NDocSave		(xmlDocPtr doc,
					 xmlNodeSetPtr nodes,
					 int mode, /* a xmlC14NMode */
					 xmlChar **inclusive_ns_prefixes,
					 int with_comments,
					 const char* filename,
					 int compression);


/**
 * This is the core C14N function
 */
/**
 * xmlC14NIsVisibleCallback:
 * @user_data: user data
 * @node: the curent node
 * @parent: the parent node
 *
 * Signature for a C14N callback on visible nodes
 *
 * Returns 1 if the node should be included
 */
typedef int (*xmlC14NIsVisibleCallback)	(void* user_data,
					 xmlNodePtr node,
					 xmlNodePtr parent);

XMLPUBFUN int XMLCALL
		xmlC14NExecute		(xmlDocPtr doc,
					 xmlC14NIsVisibleCallback is_visible_callback,
					 void* user_data,
					 int mode, /* a xmlC14NMode */
					 xmlChar **inclusive_ns_prefixes,
					 int with_comments,
					 xmlOutputBufferPtr buf);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* LIBXML_OUTPUT_ENABLED */
#endif /* LIBXML_C14N_ENABLED */
#endif /* __XML_C14N_H__ */

**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xlink.h
/*
 * Summary: unfinished XLink detection module
 * Description: unfinished XLink detection module
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_XLINK_H__
#define __XML_XLINK_H__

#include <libxml/xmlversion.h>
#include <libxml/tree.h>

#ifdef LIBXML_XPTR_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Various defines for the various Link properties.
 *
 * NOTE: the link detection layer will try to resolve QName expansion
 *       of namespaces. If "foo" is the prefix for "http://foo.com/"
 *       then the link detection layer will expand role="foo:myrole"
 *       to "http://foo.com/:myrole".
 * NOTE: the link detection layer will expand URI-Refences found on
 *       href attributes by using the base mechanism if found.
 */
typedef xmlChar *xlinkHRef;
typedef xmlChar *xlinkRole;
typedef xmlChar *xlinkTitle;

typedef enum {
    XLINK_TYPE_NONE = 0,
    XLINK_TYPE_SIMPLE,
    XLINK_TYPE_EXTENDED,
    XLINK_TYPE_EXTENDED_SET
} xlinkType;

typedef enum {
    XLINK_SHOW_NONE = 0,
    XLINK_SHOW_NEW,
    XLINK_SHOW_EMBED,
    XLINK_SHOW_REPLACE
} xlinkShow;

typedef enum {
    XLINK_ACTUATE_NONE = 0,
    XLINK_ACTUATE_AUTO,
    XLINK_ACTUATE_ONREQUEST
} xlinkActuate;

/**
 * xlinkNodeDetectFunc:
 * @ctx:  user data pointer
 * @node:  the node to check
 *
 * This is the prototype for the link detection routine.
 * It calls the default link detection callbacks upon link detection.
 */
typedef void (*xlinkNodeDetectFunc) (void *ctx, xmlNodePtr node);

/*
 * The link detection module interact with the upper layers using
 * a set of callback registered at parsing time.
 */

/**
 * xlinkSimpleLinkFunk:
 * @ctx:  user data pointer
 * @node:  the node carrying the link
 * @href:  the target of the link
 * @role:  the role string
 * @title:  the link title
 *
 * This is the prototype for a simple link detection callback.
 */
typedef void
(*xlinkSimpleLinkFunk)	(void *ctx,
			 xmlNodePtr node,
			 const xlinkHRef href,
			 const xlinkRole role,
			 const xlinkTitle title);

/**
 * xlinkExtendedLinkFunk:
 * @ctx:  user data pointer
 * @node:  the node carrying the link
 * @nbLocators: the number of locators detected on the link
 * @hrefs:  pointer to the array of locator hrefs
 * @roles:  pointer to the array of locator roles
 * @nbArcs: the number of arcs detected on the link
 * @from:  pointer to the array of source roles found on the arcs
 * @to:  pointer to the array of target roles found on the arcs
 * @show:  array of values for the show attributes found on the arcs
 * @actuate:  array of values for the actuate attributes found on the arcs
 * @nbTitles: the number of titles detected on the link
 * @title:  array of titles detected on the link
 * @langs:  array of xml:lang values for the titles
 *
 * This is the prototype for a extended link detection callback.
 */
typedef void
(*xlinkExtendedLinkFunk)(void *ctx,
			 xmlNodePtr node,
			 int nbLocators,
			 const xlinkHRef *hrefs,
			 const xlinkRole *roles,
			 int nbArcs,
			 const xlinkRole *from,
			 const xlinkRole *to,
			 xlinkShow *show,
			 xlinkActuate *actuate,
			 int nbTitles,
			 const xlinkTitle *titles,
			 const xmlChar **langs);

/**
 * xlinkExtendedLinkSetFunk:
 * @ctx:  user data pointer
 * @node:  the node carrying the link
 * @nbLocators: the number of locators detected on the link
 * @hrefs:  pointer to the array of locator hrefs
 * @roles:  pointer to the array of locator roles
 * @nbTitles: the number of titles detected on the link
 * @title:  array of titles detected on the link
 * @langs:  array of xml:lang values for the titles
 *
 * This is the prototype for a extended link set detection callback.
 */
typedef void
(*xlinkExtendedLinkSetFunk)	(void *ctx,
				 xmlNodePtr node,
				 int nbLocators,
				 const xlinkHRef *hrefs,
				 const xlinkRole *roles,
				 int nbTitles,
				 const xlinkTitle *titles,
				 const xmlChar **langs);

/**
 * This is the structure containing a set of Links detection callbacks.
 *
 * There is no default xlink callbacks, if one want to get link
 * recognition activated, those call backs must be provided before parsing.
 */
typedef struct _xlinkHandler xlinkHandler;
typedef xlinkHandler *xlinkHandlerPtr;
struct _xlinkHandler {
    xlinkSimpleLinkFunk simple;
    xlinkExtendedLinkFunk extended;
    xlinkExtendedLinkSetFunk set;
};

/*
 * The default detection routine, can be overridden, they call the default
 * detection callbacks.
 */

XMLPUBFUN xlinkNodeDetectFunc XMLCALL
		xlinkGetDefaultDetect	(void);
XMLPUBFUN void XMLCALL
		xlinkSetDefaultDetect	(xlinkNodeDetectFunc func);

/*
 * Routines to set/get the default handlers.
 */
XMLPUBFUN xlinkHandlerPtr XMLCALL
		xlinkGetDefaultHandler	(void);
XMLPUBFUN void XMLCALL
		xlinkSetDefaultHandler	(xlinkHandlerPtr handler);

/*
 * Link detection module itself.
 */
XMLPUBFUN xlinkType XMLCALL
		xlinkIsLink		(xmlDocPtr doc,
					 xmlNodePtr node);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_XPTR_ENABLED */

#endif /* __XML_XLINK_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/HTMLtree.h
/*
 * Summary: specific APIs to process HTML tree, especially serialization
 * Description: this module implements a few function needed to process
 *              tree in an HTML specific way.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __HTML_TREE_H__
#define __HTML_TREE_H__

#include <stdio.h>
#include <libxml/xmlversion.h>
#include <libxml/tree.h>
#include <libxml/HTMLparser.h>

#ifdef LIBXML_HTML_ENABLED

#ifdef __cplusplus
extern "C" {
#endif


/**
 * HTML_TEXT_NODE:
 *
 * Macro. A text node in a HTML document is really implemented
 * the same way as a text node in an XML document.
 */
#define HTML_TEXT_NODE		XML_TEXT_NODE
/**
 * HTML_ENTITY_REF_NODE:
 *
 * Macro. An entity reference in a HTML document is really implemented
 * the same way as an entity reference in an XML document.
 */
#define HTML_ENTITY_REF_NODE	XML_ENTITY_REF_NODE
/**
 * HTML_COMMENT_NODE:
 *
 * Macro. A comment in a HTML document is really implemented
 * the same way as a comment in an XML document.
 */
#define HTML_COMMENT_NODE	XML_COMMENT_NODE
/**
 * HTML_PRESERVE_NODE:
 *
 * Macro. A preserved node in a HTML document is really implemented
 * the same way as a CDATA section in an XML document.
 */
#define HTML_PRESERVE_NODE	XML_CDATA_SECTION_NODE
/**
 * HTML_PI_NODE:
 *
 * Macro. A processing instruction in a HTML document is really implemented
 * the same way as a processing instruction in an XML document.
 */
#define HTML_PI_NODE		XML_PI_NODE

XMLPUBFUN htmlDocPtr XMLCALL
		htmlNewDoc		(const xmlChar *URI,
					 const xmlChar *ExternalID);
XMLPUBFUN htmlDocPtr XMLCALL
		htmlNewDocNoDtD		(const xmlChar *URI,
					 const xmlChar *ExternalID);
XMLPUBFUN const xmlChar * XMLCALL
		htmlGetMetaEncoding	(htmlDocPtr doc);
XMLPUBFUN int XMLCALL
		htmlSetMetaEncoding	(htmlDocPtr doc,
					 const xmlChar *encoding);
#ifdef LIBXML_OUTPUT_ENABLED
XMLPUBFUN void XMLCALL
		htmlDocDumpMemory	(xmlDocPtr cur,
					 xmlChar **mem,
					 int *size);
XMLPUBFUN void XMLCALL
		htmlDocDumpMemoryFormat	(xmlDocPtr cur,
					 xmlChar **mem,
					 int *size,
					 int format);
XMLPUBFUN int XMLCALL
		htmlDocDump		(FILE *f,
					 xmlDocPtr cur);
XMLPUBFUN int XMLCALL
		htmlSaveFile		(const char *filename,
					 xmlDocPtr cur);
XMLPUBFUN int XMLCALL
		htmlNodeDump		(xmlBufferPtr buf,
					 xmlDocPtr doc,
					 xmlNodePtr cur);
XMLPUBFUN void XMLCALL
		htmlNodeDumpFile	(FILE *out,
					 xmlDocPtr doc,
					 xmlNodePtr cur);
XMLPUBFUN int XMLCALL
		htmlNodeDumpFileFormat	(FILE *out,
					 xmlDocPtr doc,
					 xmlNodePtr cur,
					 const char *encoding,
					 int format);
XMLPUBFUN int XMLCALL
		htmlSaveFileEnc		(const char *filename,
					 xmlDocPtr cur,
					 const char *encoding);
XMLPUBFUN int XMLCALL
		htmlSaveFileFormat	(const char *filename,
					 xmlDocPtr cur,
					 const char *encoding,
					 int format);

XMLPUBFUN void XMLCALL
		htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf,
					 xmlDocPtr doc,
					 xmlNodePtr cur,
					 const char *encoding,
					 int format);
XMLPUBFUN void XMLCALL
		htmlDocContentDumpOutput(xmlOutputBufferPtr buf,
					 xmlDocPtr cur,
					 const char *encoding);
XMLPUBFUN void XMLCALL
		htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf,
					 xmlDocPtr cur,
					 const char *encoding,
					 int format);
XMLPUBFUN void XMLCALL
		htmlNodeDumpOutput	(xmlOutputBufferPtr buf,
					 xmlDocPtr doc,
					 xmlNodePtr cur,
					 const char *encoding);

#endif /* LIBXML_OUTPUT_ENABLED */

XMLPUBFUN int XMLCALL
		htmlIsBooleanAttr	(const xmlChar *name);


#ifdef __cplusplus
}
#endif

#endif /* LIBXML_HTML_ENABLED */

#endif /* __HTML_TREE_H__ */

**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlunicode.h
/*
 * Summary: Unicode character APIs
 * Description: API for the Unicode character APIs
 *
 * This file is automatically generated from the
 * UCS description files of the Unicode Character Database
 * http://www.unicode.org/Public/4.0-Update1/UCD-4.0.1.html
 * using the genUnicode.py Python script.
 *
 * Generation date: Mon Mar 27 11:09:52 2006
 * Sources: Blocks-4.0.1.txt UnicodeData-4.0.1.txt
 * Author: Daniel Veillard
 */

#ifndef __XML_UNICODE_H__
#define __XML_UNICODE_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_UNICODE_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

XMLPUBFUN int XMLCALL xmlUCSIsAegeanNumbers	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsAlphabeticPresentationForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArabic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArabicPresentationFormsA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArabicPresentationFormsB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArmenian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArrows	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBasicLatin	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBengali	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBlockElements	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBopomofo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBopomofoExtended	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBoxDrawing	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBraillePatterns	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBuhid	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsByzantineMusicalSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibility	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographsSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKRadicalsSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKSymbolsandPunctuation	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographsExtensionA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographsExtensionB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCherokee	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarks	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarksforSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningHalfMarks	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningMarksforSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsControlPictures	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCurrencySymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCypriotSyllabary	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCyrillic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCyrillicSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsDeseret	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsDevanagari	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsDingbats	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsEnclosedAlphanumerics	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsEnclosedCJKLettersandMonths	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsEthiopic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGeneralPunctuation	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGeometricShapes	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGeorgian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGothic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGreek	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGreekExtended	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGreekandCoptic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGujarati	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGurmukhi	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHalfwidthandFullwidthForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHangulCompatibilityJamo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHangulJamo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHangulSyllables	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHanunoo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHebrew	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHighPrivateUseSurrogates	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHighSurrogates	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHiragana	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsIPAExtensions	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsIdeographicDescriptionCharacters	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKanbun	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKangxiRadicals	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKannada	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKatakana	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKatakanaPhoneticExtensions	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKhmer	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKhmerSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLao	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatin1Supplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedAdditional	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLetterlikeSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLimbu	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLinearBIdeograms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLinearBSyllabary	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLowSurrogates	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMalayalam	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMathematicalAlphanumericSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMathematicalOperators	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousMathematicalSymbolsA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousMathematicalSymbolsB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbolsandArrows	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousTechnical	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMongolian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMusicalSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMyanmar	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsNumberForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOgham	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOldItalic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOpticalCharacterRecognition	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOriya	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOsmanya	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsPhoneticExtensions	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsPrivateUse	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsPrivateUseArea	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsRunic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsShavian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSinhala	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSmallFormVariants	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSpacingModifierLetters	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSpecials	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSuperscriptsandSubscripts	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementalMathematicalOperators	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSyriac	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTagalog	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTagbanwa	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTags	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTaiLe	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTaiXuanJingSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTamil	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTelugu	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsThaana	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsThai	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTibetan	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsUgaritic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsUnifiedCanadianAboriginalSyllabics	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectors	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectorsSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsYiRadicals	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsYiSyllables	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsYijingHexagramSymbols	(int code);

XMLPUBFUN int XMLCALL xmlUCSIsBlock	(int code, const char *block);

XMLPUBFUN int XMLCALL xmlUCSIsCatC	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCf	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatL	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLl	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLm	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLt	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLu	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatM	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatMc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatMe	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatMn	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatN	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatNd	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatNl	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatNo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatP	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPd	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPe	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPf	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPi	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatS	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSk	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSm	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZ	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZl	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZp	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZs	(int code);

XMLPUBFUN int XMLCALL xmlUCSIsCat	(int code, const char *cat);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_UNICODE_ENABLED */

#endif /* __XML_UNICODE_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/xmlautomata.h
/*
 * Summary: API to build regexp automata
 * Description: the API to build regexp automata
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_AUTOMATA_H__
#define __XML_AUTOMATA_H__

#include <libxml/xmlversion.h>
#include <libxml/tree.h>

#ifdef LIBXML_REGEXP_ENABLED
#ifdef LIBXML_AUTOMATA_ENABLED
#include <libxml/xmlregexp.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlAutomataPtr:
 *
 * A libxml automata description, It can be compiled into a regexp
 */
typedef struct _xmlAutomata xmlAutomata;
typedef xmlAutomata *xmlAutomataPtr;

/**
 * xmlAutomataStatePtr:
 *
 * A state int the automata description,
 */
typedef struct _xmlAutomataState xmlAutomataState;
typedef xmlAutomataState *xmlAutomataStatePtr;

/*
 * Building API
 */
XMLPUBFUN xmlAutomataPtr XMLCALL
		    xmlNewAutomata		(void);
XMLPUBFUN void XMLCALL
		    xmlFreeAutomata		(xmlAutomataPtr am);

XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataGetInitState	(xmlAutomataPtr am);
XMLPUBFUN int XMLCALL
		    xmlAutomataSetFinalState	(xmlAutomataPtr am,
						 xmlAutomataStatePtr state);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewState		(xmlAutomataPtr am);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewTransition	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to,
						 const xmlChar *token,
						 void *data);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewTransition2	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to,
						 const xmlChar *token,
						 const xmlChar *token2,
						 void *data);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
                    xmlAutomataNewNegTrans	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to,
						 const xmlChar *token,
						 const xmlChar *token2,
						 void *data);

XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewCountTrans	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to,
						 const xmlChar *token,
						 int min,
						 int max,
						 void *data);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewCountTrans2	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to,
						 const xmlChar *token,
						 const xmlChar *token2,
						 int min,
						 int max,
						 void *data);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewOnceTrans	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to,
						 const xmlChar *token,
						 int min,
						 int max,
						 void *data);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewOnceTrans2	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to,
						 const xmlChar *token,
						 const xmlChar *token2,
						 int min,
						 int max,
						 void *data);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewAllTrans	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to,
						 int lax);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewEpsilon	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewCountedTrans	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to,
						 int counter);
XMLPUBFUN xmlAutomataStatePtr XMLCALL
		    xmlAutomataNewCounterTrans	(xmlAutomataPtr am,
						 xmlAutomataStatePtr from,
						 xmlAutomataStatePtr to,
						 int counter);
XMLPUBFUN int XMLCALL
		    xmlAutomataNewCounter	(xmlAutomataPtr am,
						 int min,
						 int max);

XMLPUBFUN xmlRegexpPtr XMLCALL
		    xmlAutomataCompile		(xmlAutomataPtr am);
XMLPUBFUN int XMLCALL
		    xmlAutomataIsDeterminist	(xmlAutomataPtr am);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_AUTOMATA_ENABLED */
#endif /* LIBXML_REGEXP_ENABLED */

#endif /* __XML_AUTOMATA_H__ */
**************FILE************ ./source/0.9.0.0/include/libxml2/libxml/pattern.h
/*
 * Summary: pattern expression handling
 * Description: allows to compile and test pattern expressions for nodes
 *              either in a tree or based on a parser state.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */

#ifndef __XML_PATTERN_H__
#define __XML_PATTERN_H__

#include <libxml/xmlversion.h>
#include <libxml/tree.h>
#include <libxml/dict.h>

#ifdef LIBXML_PATTERN_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

/**
 * xmlPattern:
 *
 * A compiled (XPath based) pattern to select nodes
 */
typedef struct _xmlPattern xmlPattern;
typedef xmlPattern *xmlPatternPtr;

/**
 * xmlPatternFlags:
 *
 * This is the set of options affecting the behaviour of pattern
 * matching with this module
 *
 */
typedef enum {
    XML_PATTERN_DEFAULT		= 0,	/* simple pattern match */
    XML_PATTERN_XPATH		= 1<<0,	/* standard XPath pattern */
    XML_PATTERN_XSSEL		= 1<<1,	/* XPath subset for schema selector */
    XML_PATTERN_XSFIELD		= 1<<2	/* XPath subset for schema field */
} xmlPatternFlags;

XMLPUBFUN void XMLCALL
			xmlFreePattern		(xmlPatternPtr comp);

XMLPUBFUN void XMLCALL
			xmlFreePatternList	(xmlPatternPtr comp);

XMLPUBFUN xmlPatternPtr XMLCALL
			xmlPatterncompile	(const xmlChar *pattern,
						 xmlDict *dict,
						 int flags,
						 const xmlChar **namespaces);
XMLPUBFUN int XMLCALL
			xmlPatternMatch		(xmlPatternPtr comp,
						 xmlNodePtr node);

/* streaming interfaces */
typedef struct _xmlStreamCtxt xmlStreamCtxt;
typedef xmlStreamCtxt *xmlStreamCtxtPtr;

XMLPUBFUN int XMLCALL
			xmlPatternStreamable	(xmlPatternPtr comp);
XMLPUBFUN int XMLCALL
			xmlPatternMaxDepth	(xmlPatternPtr comp);
XMLPUBFUN int XMLCALL
			xmlPatternMinDepth	(xmlPatternPtr comp);
XMLPUBFUN int XMLCALL
			xmlPatternFromRoot	(xmlPatternPtr comp);
XMLPUBFUN xmlStreamCtxtPtr XMLCALL
			xmlPatternGetStreamCtxt	(xmlPatternPtr comp);
XMLPUBFUN void XMLCALL
			xmlFreeStreamCtxt	(xmlStreamCtxtPtr stream);
XMLPUBFUN int XMLCALL
			xmlStreamPushNode	(xmlStreamCtxtPtr stream,
						 const xmlChar *name,
						 const xmlChar *ns,
						 int nodeType);
XMLPUBFUN int XMLCALL
			xmlStreamPush		(xmlStreamCtxtPtr stream,
						 const xmlChar *name,
						 const xmlChar *ns);
XMLPUBFUN int XMLCALL
			xmlStreamPushAttr	(xmlStreamCtxtPtr stream,
						 const xmlChar *name,
						 const xmlChar *ns);
XMLPUBFUN int XMLCALL
			xmlStreamPop		(xmlStreamCtxtPtr stream);
XMLPUBFUN int XMLCALL
			xmlStreamWantsAnyNode	(xmlStreamCtxtPtr stream);
#ifdef __cplusplus
}
#endif

#endif /* LIBXML_PATTERN_ENABLED */

#endif /* __XML_PATTERN_H__ */
**************FILE************ ./source/0.9.0.0/base
**************FILE************ ./source/0.9.0.0/base/PriceLevel.h
#ifndef __PRICELEVELS_H__
#define __PRICELEVELS_H__

#include "base/Base.h"
#include "base/BaseCommon.h"

namespace base 
{
	class PriceLevel// : public Base
	{
		public:
			// Init the price level to this order
			PriceLevel(Order *);
			PriceLevel(double px, uint64_t size);
			void addOrder(Order *order);
			void addOrder(uint64_t size);
			void modifyOrder(Order *order);
			void modifyOrder(uint64_t size, uint64_t oldSize);
			void deleteOrder(Order *order);
			void deleteOrder(uint64_t oldSize);
			double _px;
			uint64_t _size;
			Order *_orders;
			uint64_t _numOrders;
	};
}

#endif //__PRICELEVELS_H__
**************FILE************ ./source/0.9.0.0/base/PacketData.h
#ifndef __PACKETDATA_H__
#define __PACKETDATA_H__

using namespace infra;

namespace base
{

#define PACKET_SIZE 1500
	enum PacketState
	{
		FREED 	= 0,
		WRITTEN = 1,
		READ	= 2,
		PacketStateMax	
	};
	

	enum ChannelType
	{
		UNKNOWN = 0,
		
		/**
		 * Primary/Secondary real time data MC line
		 */
		PRIM_MC_A = 1,
		PRIM_MC_B = 2,
		SEC_MC_A  = 3,	
		SEC_MC_B  = 4,	
		
		/**
		 * Primary/Secondary snapshot data MC line
		 */
		PRIM_MC_SNAP_A = 1,
		PRIM_MC_SNAP_B = 2,
		SEC_MC_SNAP_A  = 3,	
		SEC_MC_SNAP_B  = 4,	
		
		/**
		 * Primary/Secondary selective retranse data MC line
		 */
		PRIM_MC_RETRANSE_A = 1,
		PRIM_MC_RETRANSE_B = 2,
		SEC_MC_RETRANSE_A  = 3,	
		SEC_MC_RETRANSE_B  = 4,	

		/**
		 * GLOBAL Primary/Secondary snapshot data MC line
		 */
		GLOBAL_PRIM_MC_SNAP_A = 1,
		GLOBAL_PRIM_MC_SNAP_B = 2,
		GLOBAL_SEC_MC_SNAP_A  = 3,	
		GLOBAL_SEC_MC_SNAP_B  = 4,	

		/**
		 * GLOBAL Primary/Secondary selective retranse data MC line
		 */
		GLOBAL_PRIM_MC_RETRANSE_A = 1,
		GLOBAL_PRIM_MC_RETRANSE_B = 2,
		GLOBAL_SEC_MC_RETRANSE_A  = 3,	
		GLOBAL_SEC_MC_RETRANSE_B  = 4,	
	};

	class PacketQueueElement 
	{
		PacketState	_packetState;	//PacketState in the Queue
	};

	class PacketData
	{
		TimeStamp	_time; 			// Time when packet was recieved by market data server
		ChannelType	_channelType;	// If this is mc/tcp, main/retranse/snap channel		
		Connection* _connection;	// Connection to which PacketData belongs to, Initialised at constant time
		LineHandler* _lineHandler;	// LineHandler which gonna process this packet;
		size_t		_packetLen;		// Length of valid data in below char array
		char		_packetData[PACKET_SIZE]; // Actual contents of the packet
	};		
}
#endif // __PACKETDATA_H__
**************FILE************ ./source/0.9.0.0/base/PriceLevel.cpp
#include "base/PriceLevel.h"
#include "base/Order.h"

using namespace base;

/**
 * PriceLevel: constructor
 * 		construct the level with Order
 */
PriceLevel::PriceLevel(Order *order)
	: _px(order->_px)
	, _size(order->_size)
	, _orders(order)
	, _numOrders(1)
{
	// if modified px order added at new level 
	// still ->_next should be nullptr
	ASSERT(order->_next == nullptr, "order->_next : " << order->_next);
	order->_level = this;
}

PriceLevel::PriceLevel(double px, uint64_t size)
	: _px(px)
	, _size(size)
	, _orders(nullptr)
	, _numOrders(1)
{
}



/*
 *  Adding another order to existing level "
 */
void PriceLevel::addOrder(Order *order)
{
	ASSERT(_px == order->_px, "_px : " << _px << ", order->_px : " << order->_px);
	ASSERT(order->_size, "order->_size :" << order->_size);

	_size += order->_size; 
	order->_level = this;

	order->_next = _orders;
	_orders = order;

	++_numOrders;
}

void PriceLevel::addOrder(uint64_t size)
{
	_size += size; 
	++_numOrders;
}

// only modify size from order
void PriceLevel::modifyOrder(Order *order)
{
	//update(order->_msgType, order->_seqNum, order->_xt.tv_sec, order->_xt.tv_nsec);

	ASSERT(_px == order->_px, "_px : " << _px << ", order->_px" << order->_px);
	ASSERT(order->_size, "order->_size :" << order->_size);

	_size += order->_size - order->_oldSize; 
}

// only modify size from order
void PriceLevel::modifyOrder(uint64_t size, uint64_t oldSize)
{
	//update(order->_msgType, order->_seqNum, order->_xt.tv_sec, order->_xt.tv_nsec);

	_size += size - oldSize; 
}

/**
 * Delete the order from price Level
 * If no order remaining on level,  delete the level
 */
void PriceLevel::deleteOrder(Order *order)
{
	//update(order->_msgType, order->_seqNum, order->_xt.tv_sec, order->_xt.tv_nsec);

	_size -= order->_oldSize; 

	//@TODO: save order in the reverse order of addition
	//		ie. old order must be first one
	if(_orders == order)
	{
		_orders = order->_next;
	}
	else
	{
		Order *temp = _orders;
		while(temp->_next != order)
		{
			temp = temp->_next;
		}
		temp->_next = order->_next;
	}
	order->_next = nullptr;
	--_numOrders;
}

/**
 * Delete the order from price Level
 * If no order remaining on level,  delete the level
 */
void PriceLevel::deleteOrder(uint64_t oldSize)
{
	//update(order->_msgType, order->_seqNum, order->_xt.tv_sec, order->_xt.tv_nsec);

	_size -= oldSize; 
	--_numOrders;
}
**************FILE************ ./source/0.9.0.0/base/Packet.h
#ifndef __PACKET_H__
#define __PACKET_H__

#include <stdint.h>
#include <netinet/in.h> 
#include <unistd.h>
#include <sys/syscall.h>

#include "infra/containers/spsc/BoostSPSCQueue.h"

#include "base/BaseCommon.h"

using namespace base;
using namespace infra;

namespace base 
{
	#define	PACKET_DATA_SIZE 1500
	class Packet : public BoostSPSCQueueElement
	{
		public:
			const PacketAddress	*_packetAddress;

			Packet()
			: _packetAddress(nullptr)
			, _packetDataLen(0)
			, _rt{.tv_sec = 0, .tv_nsec = 0}
			, _recordTime{.tv_sec = 0, .tv_nsec = 0}
			{
			}
		
			~Packet()
			{
				//@TODO: below assignement is not compulsory as it will
				//		be alway over written
				//		and could be included only in debug builds.
				//		and could be removed from release build
				_packetAddress = nullptr;
				_packetDataLen = 0;
				_rt.tv_sec = 0;
				_rt.tv_nsec = 0;
				_recordTime.tv_sec = 0;
				_recordTime.tv_nsec = 0;
				//fprintf(stderr, "%ld deleting : %p \n", syscall(SYS_gettid), this);
				//Call the base BoostSPSCQueueElement destructor
			}

			void setPacketDataLen(uint32_t packetDataLen)
			{
				_packetDataLen = packetDataLen;
			}
			
			uint32_t packetDataLen()
			{
				return _packetDataLen;
			}

			char *packetData()
			{
				return _packetData;
			}

			timespec         _rt; //recieve time
			timespec			_recordTime;
		private:
			char			_packetData[PACKET_DATA_SIZE];
			uint32_t		_packetDataLen;
	};
}

#endif //__PACKET_H__
**************FILE************ ./source/0.9.0.0/base/ProductInfo.h
#ifndef __PRODUCTINFO_H_
#define __PRODUCTINFO_H__

#include "base/BaseCommon.h"
#include "base/Base.h"

namespace base
{
    enum Currency
    {
        UNKNOWN = 0,
        USD     = 1,	// US DOLLER
        EUR     = 2,	// EURO
        GBP     = 3,	// GB POUND
        CHF		= 4		// SWISS FRANK
    };

    enum ProductInfoFieldType
    {
        UKNOWN		= 0,
        SYMBOL		= 1,
        LOTSIZE		= 2,
        TICKSIZE	= 3,
        CURRENCY	= 4
    };

    class ProductInfo: public Base
    {
		public:
		ProductInfo(Line *line, Subscription *sub, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, const char *symbol);
		ProductInfo(Line *line, Subscription *sub, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t symbolID, const char *symbol, const char *isin);
        char		 _symbol[NAME_SIZE];
        uint64_t	 _symbolID;
        char		 _isin[12];
        uint32_t	 _lotSize;
        uint32_t	 _tickSize;
        Currency	 _currency;
    };
}
#endif //__PRODUCTINFO_H__
**************FILE************ ./source/0.9.0.0/base/ReferenceFileReader.h
#ifndef __REFERENCEFILEREADER_H__
#define __REFERENCEFILEREADER_H__

struct ReferenceFileRowField
{
    ProductInfoFieldType*	_pInfoFieldType;
    unsigned int            _length;
};

class ReferenceFileReader
{
    public:
        ReferenceFileReader() {}

        /**
         *  parse the REFERENCEFILE file.
         *  @input:
         *  @output:
         *  @return:
         */
        parse(ReferenceFileRowField *rowFields, unsigned int noOfFields, char delimeter, ProductInfos)
        {

            for (unsigned int i = 0; i < noOfFields; i++)
            {
                switch (rowFields[i].pInfoFieldType)
                {
                    case ProductInfoFieldType_Unknown:
                        break;

                    case ProductInfoFieldType_Symbol:
                        break;

                    case ProductInfoFieldType_LotSize:
                        break;

                    case ProductInfoFieldType_TickSize:
                        break;

                    case ProductInfoFieldType_Currency:
                        break;

                    case Default:
                        /**
                         * @TODO: Log an ERROR over here and Stop
                         * Something is wrong, Set the rowFields in array correctly
                         * "Line %d RowField [%d:%s], ProductInfoFieldType and Length [%d,%d]",
                         */
                        break;
                };
            }

            /**
             * @TODO: See if this is necessory, otherwise remove comment.
             * ProductInfo Created. Invoke Feed Specefic function to process product Info.
             * Currently leaving empty.
             */
        }
    private:
};
#endif //__REFERENCEFILEREADER_H__
**************FILE************ ./source/0.9.0.0/base/Book.cpp
#include "base/Line.h"
#include "base/Order.h"
#include "base/PriceLevel.h"
#include "base/Book.h"
#include "base/Quote.h"

using namespace base;
using namespace infra;

Book::Book(Subscription *sub)
	: Base(sub, BOOK_UPDATE)
	, _buyQuantity(0)
	, _sellQuantity(0)
	, _buys()
	, _sells()
{
	//new(&_priceLevels) std::map<double, PriceLevel *, std::less<double>, BookAlloc<std::pair<const double, PriceLevel *> > >();
}

/**
 * See if level exists in the book
 * if exists, 
 *		add order to that level
 * else
 *		create the new level with order
 *		insert new level in the book
 */
void Book::addOrder(Order *order, bool modifyOrder)
{
	if(order->_side == BUY)
	{
		if(!modifyOrder)
		{
			_sub->_quote.cacheBuySideQuote();
		}
		
		std::pair<PriceLevelMap::iterator, PriceLevelMap::iterator> itr = _buys.equal_range(order->_px);

		//level already exists, just append this order to level
		if(itr.first != _buys.end() && itr.first->second->_px == order->_px)
		{
			itr.first->second->addOrder(order);
		}
		else
		{
			//This is new level, create and insert into map
			PriceLevel *pl = _line->_priceLevelPool->malloc();	
			new(pl) PriceLevel(order);
			_buys.insert(itr.second, std::make_pair(order->_px, pl));
		}

		// increase the cumulative quantity of the order book side
		_buyQuantity += order->_size;
		_sub->_quote.checkBuySideQuote(this);
	}
	else
	{
		if(!modifyOrder)
		{
			_sub->_quote.cacheSellSideQuote();
		}
		std::pair<PriceLevelMap::iterator, PriceLevelMap::iterator> itr = _sells.equal_range(order->_px);

		//level already exists, just append this order to level
		if(itr.first != _sells.end() && itr.first->second->_px == order->_px)
		{
			itr.first->second->addOrder(order);
		}
		else
		{
			//This is new level, create and insert into map
			PriceLevel *pl = _line->_priceLevelPool->malloc();	
			new(pl) PriceLevel(order);
			_sells.insert(itr.second, std::make_pair(order->_px, pl));
		}

		// increase the cumulative quantity of the order book side
		_sellQuantity += order->_size;
		_sub->_quote.checkSellSideQuote(this);
	}
}

void Book::addOrder(Side side, double px, uint64_t size, bool modifyOrder)
{
	if(side == BUY)
	{
		if(!modifyOrder)
		{
			_sub->_quote.cacheBuySideQuote();
		}
		std::pair<PriceLevelMap::iterator, PriceLevelMap::iterator> itr = _buys.equal_range(px);

		//level already exists, just append this order to level
		if(itr.first != _buys.end() && itr.first->second->_px == px)
		{
			itr.first->second->addOrder(size);
		}
		else
		{
			//This is new level, create and insert into map
			PriceLevel *pl = _line->_priceLevelPool->malloc();	
			new(pl) PriceLevel(px, size);
			_buys.insert(itr.second, std::make_pair(px, pl));
		}

		// increase the cumulative quantity of the order book side
		_buyQuantity += size;
		_sub->_quote.checkBuySideQuote(this);
	}
	else
	{
		if(!modifyOrder)
		{
			_sub->_quote.cacheSellSideQuote();
		}
		std::pair<PriceLevelMap::iterator, PriceLevelMap::iterator> itr = _sells.equal_range(px);

		//level already exists, just append this order to level
		if(itr.first != _sells.end() && itr.first->second->_px == px)
		{
			itr.first->second->addOrder(size);
		}
		else
		{
			//This is new level, create and insert into map
			PriceLevel *pl = _line->_priceLevelPool->malloc();	
			new(pl) PriceLevel(px, size);
			_sells.insert(itr.second, std::make_pair(px, pl));
		}

		// increase the cumulative quantity of the order book side
		_sellQuantity += size;
		_sub->_quote.checkSellSideQuote(this);
	}
}

/**
 * Search level based on the _oldpx of the order
 * if Price of the order has changed
 *		remove order from the level and insert at new level
 *	else
 *		just change the size of level
 *
 */
void Book::modifyOrder(Order *order)
{
	if(order->_px == order->_oldPx)
	{
		ASSERT(order->_size == order->_oldSize, "Book::modifyOrder has same old and new, price size");
		if(order->_side == BUY)
		{
			_sub->_quote.cacheBuySideQuote();
			order->_level->modifyOrder(order);
			_buyQuantity += order->_size - order->_oldSize;
			_sub->_quote.checkBuySideQuote(this);
		}
		else
		{
			_sub->_quote.cacheSellSideQuote();
			order->_level->modifyOrder(order);
			_sellQuantity += order->_size - order->_oldSize;
			_sub->_quote.checkSellSideQuote(this);
		}
	}
	else
	{
		// remove order from the oldPx level
		// insert at new _px level
		deleteOrder(order, true);
		addOrder(order, true);
	}
}

void Book::modifyOrder(Side side, double px, double oldPx, uint64_t size, uint64_t oldSize)
{
	if(px == oldPx)
	{
		ASSERT(order->_size == order->_oldSize, "Book::modifyOrder has same old and new, price size");
		if(side == BUY)
		{
			_sub->_quote.cacheBuySideQuote();
			PriceLevel* level = _buys.find(px)->second;
			level->modifyOrder(size, oldSize);
			_buyQuantity += size - oldSize;
			_sub->_quote.checkBuySideQuote(this);
		}
		else
		{
			_sub->_quote.cacheSellSideQuote();
			PriceLevel* level = _sells.find(px)->second;
			level->modifyOrder(size, oldSize);
			_sellQuantity += size - oldSize;
			_sub->_quote.checkSellSideQuote(this);
		}
	}
	else
	{
		// remove order from the oldPx level
		// insert at new _px level
		deleteOrder(side, oldPx, oldSize);
		addOrder(side, px, size);
	}
}

/**
 * Delete the order from price Level
 * If no order remaining on level,  delete the level
 */
void Book::deleteOrder(Order *order, bool modifyOrder)
{
	order->_level->deleteOrder(order);

	// last order deleted, so remove complete level off the book
	// and free it back to the pool
	if(order->_side == BUY)
	{
		_sub->_quote.cacheBuySideQuote();
		if(!order->_level->_size)
		{
			_line->_priceLevelPool->free(order->_level);	
			_buys.erase(order->_oldPx);
		}
		order->_level = nullptr;
		_buyQuantity += order->_size - order->_oldSize;
		if(!modifyOrder)
		{
			_sub->_quote.checkBuySideQuote(this);
		}
	}
	else
	{
		_sub->_quote.cacheSellSideQuote();
		if(!order->_level->_size)
		{
			_line->_priceLevelPool->free(order->_level);	
			_sells.erase(order->_oldPx);
		}
		order->_level = nullptr;
		_sellQuantity += order->_size - order->_oldSize;
		if(!modifyOrder)
		{
			_sub->_quote.checkSellSideQuote(this);
		}
	}
}

void Book::deleteOrder(Side side, double oldPx, uint64_t oldSize, bool modifyOrder)
{
	if(side == BUY)
	{
		_sub->_quote.cacheBuySideQuote();
		PriceLevelMap::iterator itr = _buys.find(oldPx);
		itr->second->deleteOrder(oldSize);
		if(!itr->second->_size)
		{
			_line->_priceLevelPool->free(itr->second);	
			_buys.erase(itr);
		}
		_buyQuantity -= oldSize;
		if(!modifyOrder)
		{
			_sub->_quote.checkBuySideQuote(this);
		}
	}
	else
	{
		_sub->_quote.cacheSellSideQuote();
		PriceLevelMap::iterator itr = _sells.find(oldPx);
		itr->second->deleteOrder(oldSize);
		if(!itr->second->_size)
		{
			_line->_priceLevelPool->free(itr->second);	
			_sells.erase(itr);
		}
		_sellQuantity -= oldSize;
		if(!modifyOrder)
		{
			_sub->_quote.checkSellSideQuote(this);
		}
	}
}
**************FILE************ ./source/0.9.0.0/base/Base.h
#ifndef __BASE_H__
#define __BASE_H__

#include <stdint.h>
#include <sys/time.h>

#include "base/BaseCommon.h" 

namespace base 
{
	enum UpdateType
	{
		ORDER_UPDATE = 'O',
		TRADE_UPDATE = 'T',
		BOOK_UPDATE	= 'B',
		PRICELEVEL_UPDATE	= 'L',
		QUOTE_UPDATE = 'Q',
		CUSTOM_UPDATE = 'C',
		STATUS_UPDATE = 'S',
		PRODUCTINFO_UPDATE= 'P',
		UNKNOWN_UPDATE = 'U'
	};

	class Base
	{
		public:
			// Called when uniq object per Sub is created. 
			// I.e Trade, Order, Custom and Book in Sub
			inline Base(Subscription *sub, UpdateType type)
				: _line(nullptr)
				, _seqNum(0)
				, _xt{.tv_sec = 0, .tv_nsec = 0}
				, _sub(sub)
				, _type(type)
				, _msgType(0)
			{
			}

			//Order init, trade init
			// When dynamically allocated objects from pool are initialized
			// Or temporary offbook trades on function stack are constructed
			inline void update(Line *line, Subscription *sub, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, UpdateType type)
			{
				_line = line;
				_seqNum = seqNo;
				_xt.tv_sec = exSeconds;
				_xt.tv_nsec = exUSeconds;
				_sub = sub;
				_type = type;
				_msgType = msgType;
			}
			
			// When uniq object inside sub is modified
			// Uniq objects inside the sub are expted to arrive only on same line and same thread
			// Trade, status, custom, Order modify and remove
			inline void update(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds)
			{
				_line = line;
				_seqNum = seqNo;
				_xt.tv_sec = exSeconds;
				_xt.tv_nsec = exUSeconds;
				_msgType = msgType;
			}

			inline void update(uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds)
			{
				_seqNum = seqNo;
				_xt.tv_sec = exSeconds;
				_xt.tv_nsec = exUSeconds;
				_msgType = msgType;
			}

			// Or temporary offbook trades on function stack are constructed
			inline Base(Line *line, Subscription *sub, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, UpdateType type)
				: _line(line)
				, _seqNum(seqNo)
				, _xt{.tv_sec = exSeconds, .tv_nsec = exUSeconds}
				, _sub(sub)
				, _type(type)
				, _msgType(msgType)
			{
			}

			//dynamically allocated objects are freed
			// or subscription is deleted
			inline ~Base()
			{
				_seqNum = 0;
				_xt.tv_sec = 0;
				_xt.tv_nsec = 0;
				_sub = nullptr;
				_type = UNKNOWN_UPDATE;
				_msgType = 0;
			}

			Line *_line;
			uint64_t _seqNum;
			timespec  _xt;
			Subscription *_sub;
			UpdateType _type;
			uint32_t _msgType;
	};
}

#endif //__BASE_H__
**************FILE************ ./source/0.9.0.0/base/FeedHandler.h
#ifndef __FEEDMANAGER_H__
#define __FEEDMANAGER_H__

#include <set>
#include <map>
#include <mutex>
#include <unordered_map>
#include <regex>

#include "infra/InfraCommon.h"
#include "infra/judy/JudySArray.h"
#include "base/BaseCommon.h"

using namespace infra;

namespace base
{
	enum class FeedID
	{
		UNKNOWN_FEED = 0,
		MILLENIUM = 1,
		OMXNORDIC = 2,
		MAX_FEEDS
	};

    class FeedHandler
    {
        public:
			typedef LineGroup* (*LineGroupConstructor)(const MarketDataApplication *, FeedHandler *, const pugi::xml_node &, LineGroupAPI *);

			FeedHandler(const MarketDataApplication *, const pugi::xml_node &, FeedID, LineGroupConstructor, FeedAPI *);
			~FeedHandler();

			void start(const Thread *) const; 
			void stop(const Thread *) const; 
			void printStats(const Thread *) const;

			int32_t subscribe(const uint64_t symbolID, Subscription **sub);
			int32_t subscribe(const char *, Subscription **);

			Subscription* getIdSub(uint64_t );
			Subscription* _getIdSub(uint64_t );
			Subscription* getSymbolSub(const char *);
			Subscription* _getSymbolSub(const char *);


			ProductInfo* getProductInfo(Line *line, uint32_t, const char* symbol, uint64_t symbolID, const char *isin, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds);
			ProductInfo* _getProductInfo(Line *line, uint32_t, const char* symbol, uint64_t symbolID, const char *isin, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds);

			ProductInfo* getProductInfo(Line *line, uint32_t, uint64_t symbolID, const char* symbol, const char *isin, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds);
			ProductInfo* _getProductInfo(Line *line, uint32_t, uint64_t symbolID, const char* symbol, const char *isin, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds);

			Subscription* getValidIdIsinSymbolSub(uint64_t symbolID, const char* symbol, const char *isin);

			static FeedID getFeedID(const std::string& feedHandlerType);
			static const char* getFeedType(FeedID id);

			const FeedID	_feedID;
            const char 	_name[NAME_SIZE];
			const PlaybackMode _mode;
			const std::vector<std::string>	_playbackFilesVector;
			bool _reRecord;
			bool _maintainOrders;
			std::mutex _recordingMutex;
			Recording *_recording;

			void registerCallbacks(CallBacks );
			void registerCallbacks(std::string );

        private:

			void createLineGroups(const pugi::xml_node &configNode);

			const LineGroupConstructor _lineGroupConstructor;

			const MarketDataApplication   *_appInstance;
            typedef std::map<std::string , LineGroup *> NameToLineGroupMap;
			NameToLineGroupMap _lineGroupMap;
			LoggerClientHandle	*_logger;
			
			bool _recordPlayback;
			std::string _pbLocation;
				
			// Mutex covering _regexMap, _idSubMap, _symbolSubMap, _symbolProdInfoMap 
			std::mutex _subMapMutex;
			std::vector<std::regex>	_regexMap;
			std::unordered_map<uint64_t, Subscription *> _idSubMap;
			//@TODO: give a thought to replace with vector of char[20]
			// this will make the code slow as I think string will dynamically
			// allocate memory for characters
			//std::map<std::string, Subscription *> _symbolSubMap;
			judySArray<Subscription *> _symbolSubMap;
			judySArray<Subscription *> _isinSubMap;
			judySArray<ProductInfo *> _prodInfoMap;
			judySArray<ProductInfo *> _prodInfoMapISIN;
			// could be intentionally kept std::map instead of unordered_map
			// as it is not read/write for much time
			std::map<uint64_t, ProductInfo *> _prodInfoMapID;
			FeedAPI *_feedAPI;
    };
}

#endif //__FEEDMANAGER_H__
**************FILE************ ./source/0.9.0.0/base/BaseCommon.cpp
#include <stdexcept>  
#include <string.h>


#include "base/BaseCommon.h"

using namespace base;

const char *CLARICE_HEADER = "CLARICE_FEEDS__RECORD___";

ID::ID()
: _IDType(IDTYPE_UNKNOWN)
{
	_numericID = 0;
}

ID::ID(char *strID)
: _IDType(ALPHANUM)
{
	strncpy(_alphaNumID, strID, sizeof(_alphaNumID));
}

ID::ID(uint64_t numericID)
	: _numericID(numericID)
	  , _IDType(NUMERIC)
{
}

ID::~ID()
{
	_IDType = IDTYPE_UNKNOWN;
	_numericID = 0;
}

std::string ID::to_string() const
{
	if(_IDType == NUMERIC)
	{
		return std::to_string(_numericID); 
	}
	else
	{
		return std::string(_alphaNumID); 
	}
}

uint64_t ID::numeric() const 
{
	return _numericID;
}

const char* ID::alphanum() const
{
	return _alphaNumID;
}

/**
 * \brief: getPlaybackModeFromString
 *			Used to get enum PlaybackMode from string at the time of
 *			reading config for setting up the Feed Handler 
 *
 */
extern "C"
PlaybackMode playbackMode(const std::string &strMode)
{
	if(strMode == "file")
	{
		return PlaybackMode::FILE_PLAYBACK;
	}
	else if(strMode == "live")
	{
		return PlaybackMode::LIVE_PLAYBACK;
	}
}

/**
 * \brief: getPlaybackModeFromString
 *			Used to get enum PlaybackMode from string at the time of
 *			reading config for setting up the Feed Handler 
 *
 */
extern "C"
const char* playbackModeToStr(const PlaybackMode mode)
{
	switch(mode)
	{
		case PlaybackMode::FILE_PLAYBACK:
				return "file";

		case PlaybackMode::LIVE_PLAYBACK:
				return "live";
		
		default:
				///< Throw an error exception duplicate lineGroup name 
				char errorBuff[512];

				snprintf(errorBuff, sizeof(errorBuff), "Tried to convert invalid playback mode");
				std::string error(errorBuff);

				throw std::invalid_argument(error);
	}
}
**************FILE************ ./source/0.9.0.0/base/Order.h
#ifndef __ORDER_H__
#define __ORDER_H__

#include <stdint.h>
#include <string.h>
#include <string>

#include "base/BaseCommon.h"
#include "base/Base.h"

namespace base
{
	enum OrderType
	{
		ORDTYPE_UNKNOWN = 0,
		NORMAL_ORDER = 1,
		MARKET_ORDER = 2
	};

	enum OrderAction
	{
		ADDED = 'A',
		MODIFIED = 'M',
		DELETED = 'D',
		EXECUTED = 'E',
		ORDACT_UNKNOWN = 'U'
	};

    /*
     *  Order Class:
     *  Each order ID is uniq across exchange.
     *  So OrderPool contains uniq orders.
     *  Order Updates for existing order come on same line as of the line of order origin.
     *  So order pools are defined per thread.
     *
     */
    class Order : public Base
    {
        public:
            /*
             * Order Constructor
             * Input:   Price, size , order ID and IDType i.e numeric or alphanumeric
             * Output:  Order is constructed
             */
			 Order();
			static void Add(Line *line, Subscription *sub, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, double px, uint32_t size, Side side, uint64_t orderID);

			void init(Line *, Subscription *, OrderPool *orderPool, uint32_t, uint64_t , uint32_t , uint32_t , double , uint32_t , Side , uint64_t);
			static void ModifyPxSize(Line *, uint32_t, uint64_t , uint32_t , uint32_t , uint64_t, double , uint32_t);
			static void ModifyPx(Line *,  uint32_t, uint64_t , uint32_t , uint32_t , uint64_t, double );
			static void ModifySize(Line *,  uint32_t, uint64_t , uint32_t , uint32_t , uint64_t, uint32_t);
			static void CancelSize(Line *, uint32_t, uint64_t , uint32_t , uint32_t , uint64_t, uint32_t);

			static void Delete(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID);

			void remove(Line *, uint32_t, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds);

			// must be when order modify crosses the apposite side top of book;
			// Both order executed quantity and remaining display quantity;
			// are sent along with trade/execution price ;
			static void Execute(Line *, uint32_t, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID);
			static void ExecuteSize(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, uint64_t execSize, uint64_t remaining);
			static void ExecuteSize(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, uint64_t execSize);
			static void ExecutePxSize(Line *, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, double execPx, uint64_t execSize, uint64_t remaining);
			static void ExecutePxSize(Line *, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, double execPx, uint64_t execSize);
			void _execute(Line *, uint32_t, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, double execPx, uint64_t execSize, uint64_t remaining);
			~Order();

            double _px;
            uint32_t _size;
            double _oldPx;
            uint32_t _oldSize;
			Side _side;
			OrderType _orderType;
			OrderAction	_action;
            ID _orderID;
			OrderPool *_orderPool; // to which order belongs
			Order	*_next;	// Next order on the same level
			PriceLevel *_level; // level to which order belongs

		private:
			void _modify(Line *line, uint32_t, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, double px, uint32_t size);
    };
}

#include "base/MarketDataApplication.h"
#include "base/LineGroup.h"
#include "base/Line.h"
#include "base/Subscription.h"
#include "base/API.h"

using namespace base;

inline Order::Order()
	:Base(nullptr, ORDER_UPDATE)
	, _px(0.0)
	, _size(0)
	, _oldPx(0)
	, _oldSize(0)
	, _side(SIDE_UNKNOWN)
	, _action(OrderAction::ORDACT_UNKNOWN)
	, _orderID()
	, _orderType(ORDTYPE_UNKNOWN)
	, _orderPool(nullptr)
	, _next(nullptr)
	, _level(nullptr)
{
}

/*
 * Order Constructor
 * Input:   Price, size , order ID and IDType i.e numeric or alphanumeric
 * Output:  Order is constructed
 */
inline void Order::Add(Line *line, Subscription *sub, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, double px, uint32_t size, Side side, uint64_t orderID)
{
	OrderPool *orderPool = line->_orderPool;
#ifdef __ORDERPOOL_LATENCY__
	timespec mt = globalClock();
	Order *order = orderPool->malloc();
	getLatency(line->_lineGroup->_op, mt);
#else
	Order *order = orderPool->malloc();
#endif
	
	order->init(line
			, sub
			, orderPool 
			, msgType 
			, seqNo 
			, exSeconds 
			, exUSeconds 
			, px
			, size 
			, side 
			, orderID);
}

inline void Order::init(Line *line, Subscription *sub, OrderPool *orderPool, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, double px, uint32_t size, Side side, uint64_t orderID)
{
	Base::update(line, sub, msgType, seqNo, exSeconds, exUSeconds, ORDER_UPDATE);
	_px = px;
	_size = size;
	_oldPx = 0;
	_oldSize = 0;
	_side = side;
	_action = OrderAction::ADDED;
	_orderID = orderID;
	_orderType = px == 0.0 ? MARKET_ORDER : NORMAL_ORDER;
	_orderPool = orderPool;
	_next = nullptr;
	_level = nullptr;

	line->insert(orderID, this);

	LineAPI *api = line->_lineAPI;
	if(line->hasStrictInterest(BOOK))
	{
		sub->_book.update(line, msgType, seqNo, exSeconds, exUSeconds);
		if(_line->_maintainOrders)
		{
			sub->_book.addOrder(this);
		}
		else
		{
			sub->_book.addOrder(_side, _px, _size);
		}
	
		if(!line->hasStrictInterest(QUOTE))
		{
			(api->*(api->_onBook))(&_sub->_book);
		}
	}
	else
	{
		(api->*(api->_onOrder))(this);
	}
}

inline void Order::ModifyPxSize(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, double px, uint32_t size)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	Order *order = line->find(orderID);
	getLatency(line->_lineGroup->_om, mt);
#else
	Order *order = line->find(orderID);
#endif

	if (order)
	{
		order->_modify(line, msgType, seqNo, exSeconds, exUSeconds, px, size);
	}
}

inline void Order::ModifyPx(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, double px)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	Order *order = line->find(orderID);
	getLatency(line->_lineGroup->_om, mt);
#else
	Order *order = line->find(orderID);
#endif

	if (order)
	{
		order->_modify(line, msgType, seqNo, exSeconds, exUSeconds, px, order->_size);
	}
}

inline void Order::ModifySize(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, uint32_t newSize)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	Order *order = line->find(orderID);
	getLatency(line->_lineGroup->_om, mt);
#else
	Order *order = line->find(orderID);
#endif

	if (order)
	{
		order->_modify(line, msgType, seqNo, exSeconds, exUSeconds, order->_px, newSize);
	}
}

inline void Order::CancelSize(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, uint32_t cancelSize)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	Order *order = line->find(orderID);
	getLatency(line->_lineGroup->_om, mt);
#else
	Order *order = line->find(orderID);
#endif

	if (order)
	{
		order->_modify(line, msgType, seqNo, exSeconds, exUSeconds, order->_px, order->_size - cancelSize);
	}
}

inline void Order::_modify(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, double px, uint32_t size)
{
	Base::update(msgType, seqNo, exSeconds, exUSeconds);
	_oldPx = _px;
	_oldSize = _size;
	_px = px;
	_size = size;
	_orderType = (px == 0.0)? MARKET_ORDER : NORMAL_ORDER;
	_action = OrderAction::MODIFIED;
	
	LineAPI *api = line->_lineAPI;
	if(line->hasStrictInterest(BOOK))
	{
		_sub->_book.update(line, msgType, seqNo, exSeconds, exUSeconds);
		if(_line->_maintainOrders)
		{
			_sub->_book.modifyOrder(this);
		}
		else
		{
			_sub->_book.modifyOrder(_side, _px, _oldPx, _size, _oldSize);
		}
		
		if(!line->hasStrictInterest(QUOTE))
		{
			(api->*(api->_onBook))(&_sub->_book);
		}
	}
	else
	{
		(api->*(api->_onOrder))(this);
	}
}

inline void Order::Delete(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	Order *order = line->find(orderID);
	getLatency(line->_lineGroup->_om, mt);
#else
	Order *order = line->find(orderID);
#endif
	if (order)
	{
		order->remove(line, msgType, seqNo, exSeconds, exUSeconds);
		//delete order;
	}
}

inline void Order::remove(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds)
{
	Base::update(msgType, seqNo, exSeconds, exUSeconds);
	_oldPx = _px;
	_oldSize = _size;
	_px = 0.0;
	_size = 0;
	_action = OrderAction::DELETED;
	
	LineAPI *api = line->_lineAPI;
	if(line->hasStrictInterest(BOOK))
	{
		_sub->_book.update(line, msgType, seqNo, exSeconds, exUSeconds);
		if(_line->_maintainOrders)
		{
			_sub->_book.deleteOrder(this);
		}
		else
		{
			_sub->_book.deleteOrder(_side, _oldPx, _oldSize);
		}

		if(!line->hasStrictInterest(QUOTE))
		{
			(api->*(api->_onBook))(&_sub->_book);
		}
	}
	else
	{
		(api->*(api->_onOrder))(this);
	}
	
	line->erase(_orderID.numeric());
	// we do not delete the implicitly constructed order objects
	// we just free them from order pool
	_orderPool->free(this);
	_orderPool = nullptr;
}

/*
 * Whole Order executed at same price
 */
inline void Order::Execute(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	Order *order = line->find(orderID);
	getLatency(line->_lineGroup->_om, mt);
#else
	Order *order = line->find(orderID);
#endif

	if (order)
	{
		order->_execute(line
			, msgType 
			, seqNo
			, exSeconds 
			, exUSeconds
			, order->_px
			, order->_size
			, 0);
	}
}

/*
 * Order executed partly at same price
 */
inline void Order::ExecuteSize(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, uint64_t execSize, uint64_t remaining)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	Order *order = line->find(orderID);
	getLatency(line->_lineGroup->_om, mt);
#else
	Order *order = line->find(orderID);
#endif

	if (order)
	{
		order->_execute(line
			, msgType 
			, seqNo
			, exSeconds 
			, exUSeconds
			, order->_px
			, execSize 
			, remaining);
	}
}

inline void Order::ExecuteSize(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, uint64_t execSize)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	Order *order = line->find(orderID);
	getLatency(line->_lineGroup->_om, mt);
#else
	Order *order = line->find(orderID);
#endif

	if (order)
	{
		order->_execute(line
			, msgType 
			, seqNo
			, exSeconds 
			, exUSeconds
			, order->_px
			, execSize 
			, order->_size - execSize);

	}
}


/*
 * Order executed at different price
 */
inline void Order::ExecutePxSize(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, double execPx, uint64_t execSize, uint64_t remaining)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	Order *order = line->find(orderID);
	getLatency(line->_lineGroup->_om, mt);
#else
	Order *order = line->find(orderID);
#endif

	if (order)
	{
		order->_execute(line
			, msgType 
			, seqNo
			, exSeconds 
			, exUSeconds
			, execPx 
			, execSize 
			, remaining);
	}
}

inline void Order::ExecutePxSize(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t orderID, double execPx, uint64_t execSize)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	Order *order = line->find(orderID);
	getLatency(line->_lineGroup->_om, mt);
#else
	Order *order = line->find(orderID);
#endif

	if (order)
	{
		order->_execute(line
			, msgType 
			, seqNo
			, exSeconds 
			, exUSeconds
			, execPx 
			, execSize
			, order->_size - execSize);
	}
}

// must be when order modify crosses the apposite side top of book
// Both order executed quantity and remaining display quantity
// are sent along with trade/execution price 
inline void Order::_execute(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, double execPx, uint64_t execSize, uint64_t remaining)
{
	Base::update(msgType, seqNo, exSeconds, exUSeconds);

	// price of order has not changed, just Trade has happned at execPx
	_oldPx = _px;
	_oldSize = _size;
	_size = remaining;

	//Remaining qunaity is +ve nonzero and is equal to _oldSize - execSize
	ASSERT(execSize == (_oldSize - remaining), "execSize : " << execSize << ", _oldSize : " << _oldSize << ", remaining : " << remaining);

	_action = OrderAction::EXECUTED;
	
	LineAPI *api = line->_lineAPI;
	if(line->hasStrictInterest(BOOK))
	{
		if(remaining)
		{
			_sub->_book.update(line, msgType, seqNo, exSeconds, exUSeconds);
			if(_line->_maintainOrders)
			{
				_sub->_book.modifyOrder(this);
			}
			else
			{
				_sub->_book.modifyOrder(_side, _px, _oldPx, _size, _oldSize);
			}
			if(!line->hasStrictInterest(QUOTE))
			{
				(api->*(api->_onBook))(&_sub->_book);
			}
		}
		else
		{
			_sub->_book.update(line, msgType, seqNo, exSeconds, exUSeconds);
			if(_line->_maintainOrders)
			{
				_sub->_book.deleteOrder(this);
			}
			else
			{
				_sub->_book.deleteOrder(_side, _oldPx, _oldSize);
			}
			
			if(!line->hasStrictInterest(QUOTE))
			{
				(api->*(api->_onBook))(&_sub->_book);
			}
		}
	}
	else
	{
		(api->*(api->_onOrder))(this);
	}
	
	if(!remaining)
	{
		line->erase(_orderID.numeric());
		// free the order to order pool 
		_orderPool->free(this);
	}
}

inline Order::~Order()
{
	_px = 0.0;
	_size = 0;
	_oldPx = 0.0;
	_oldSize = 0;
	_side = SIDE_UNKNOWN;
	_action = ORDACT_UNKNOWN;
	_next = nullptr;
	_level = nullptr;
	// ~Base::Base
}

#endif// __ORDER_H__
**************FILE************ ./source/0.9.0.0/base/API.h
#ifndef __API_H__
#define __API_H__

#include <string>
#include "base/BaseCommon.h"

namespace base
{
	extern "C"
	CallBacks getCallback(const std::string updateType);

	class LineAPI
	{
		public:
			typedef void (LineAPI::*OnLineStarted)(const Line *pLine);
			typedef void (LineAPI::*OnLineStopped)(const Line *pLine);
			typedef void (LineAPI::*OnPacketStart)(const Line *pLine);
			typedef void (LineAPI::*OnPacketEnd)(const Line *pLine);
			typedef void (LineAPI::*OnOrder)(const Order *);
			typedef void (LineAPI::*OnBook)(const Book *);
			typedef void (LineAPI::*OnQuote)(const Quote *);
			typedef void (LineAPI::*OnTrade)(const Trade *, const Order *);
			typedef void (LineAPI::*OnStatus)(const Status *);
			typedef void (LineAPI::*OnCustom)(const Custom *);
			typedef void (LineAPI::*OnProductInfo)(const ProductInfo *);

			void onLineStarted(const Line *pLine);
			void onLineStopped(const Line *pLine);
			void onPacketStart(const Line *pLine);
			void onPacketEnd(const Line *pLine);

			void onOrder(const Order *);
			void onBook(const Book *);
			void onQuote(const Quote *);
			void onTrade(const Trade *, const Order *);
			void onStatus(const Status *);
			void onCustom(const Custom *);
			void onProductInfo(const ProductInfo *);

			LineAPI();
			LineAPI(OnLineStarted , OnLineStopped , OnPacketStart , OnPacketEnd, OnOrder, OnBook , OnQuote , OnTrade , OnStatus , OnCustom , OnProductInfo );
			
			OnLineStarted _onLineStarted;
			OnLineStopped _onLineStopped;
			OnPacketStart _onPacketStart;
			OnPacketEnd	  _onPacketEnd;

			OnOrder _onOrder;
			OnBook _onBook;
			OnQuote _onQuote;
			OnTrade	_onTrade;
			OnStatus _onStatus;
			OnCustom _onCustom;
			OnProductInfo _onProductInfo;
	};

	
	class LineGroupAPI: public LineAPI
	{
		public:
			typedef void (LineGroupAPI::*OnLineGroupStarted)(const LineGroup *lineGroup);
			typedef void (LineGroupAPI::*OnLineGroupStopped)(const LineGroup *lineGroup);

			void onLineGroupStarted(const LineGroup *lineGroup);
			void onLineGroupStopped(const LineGroup *lineGroup);

			LineGroupAPI();	
			LineGroupAPI(OnLineGroupStarted , OnLineGroupStopped , OnLineStarted , OnLineStopped , OnPacketStart , OnPacketEnd, OnOrder , OnBook , OnQuote , OnTrade , OnStatus , OnCustom , OnProductInfo);
			OnLineGroupStarted _onLineGroupStarted;
			OnLineGroupStopped _onLineGroupStopped;
	};
	
	class FeedAPI : public LineGroupAPI
	{
		public:
			typedef void (FeedAPI::*OnFeedStarted)(const FeedHandler *feedHandler);
			typedef void (FeedAPI::*OnFeedStopped)(const FeedHandler *feedHandler);
			
			void onFeedStarted(const FeedHandler *feedHandler);
			void onFeedStopped(const FeedHandler *feedHandler);

			FeedAPI();
			FeedAPI(OnFeedStarted , OnFeedStopped , OnLineGroupStarted , OnLineGroupStopped , OnLineStarted , OnLineStopped , OnPacketStart , OnPacketEnd, OnOrder , OnBook , OnQuote , OnTrade , OnStatus , OnCustom , OnProductInfo);
			OnFeedStarted _onFeedStarted;
			OnFeedStopped _onFeedStopped;
	};
}
#endif //__API_H__
**************FILE************ ./source/0.9.0.0/base/Trade.cpp

**************FILE************ ./source/0.9.0.0/base/Order.cpp

**************FILE************ ./source/0.9.0.0/base/Subscription.cpp
#include <string.h>
#include "base/Subscription.h"

using namespace base;

Subscription::Subscription(const uint64_t symbolID, bool activate)
	: _symbolID(symbolID)
	, _isActive(activate)
	, _isin()
	, _prodInfo(nullptr)
	, _status(this)
	, _trade(this)
	, _book(this)
	, _quote(this)
{
	strncpy(_symbol, "", sizeof(_symbol));
}

Subscription::Subscription(const char *symbol, bool activate)
	: _symbolID(0)
	, _isActive(activate)
	, _isin()
	, _prodInfo(nullptr)
	, _status(this)
	, _trade(this)
	, _book(this)
	, _quote(this)
{
	strncpy(const_cast<char *>(_symbol), symbol, sizeof(_symbol));
}

const char * InstrStateToString(InstrState state)
{
	switch(state)
	{
		case InstrState::UNKNOWN:
			return "UNKNOWN";

		case InstrState::PREOPEN :
			return "PREOPEN";

		case InstrState::AUCTION :
			return "AUCTION";

		case InstrState::AUCTION_OPEN :
			return "AUCTION_OPEN";

		case InstrState::AUCTION_INTRA :
			return "AUCTION_INTRA";

		case InstrState::AUCTION_VOLA :
			return "AUCTION_VOLA";

		case InstrState::AUCTION_CLOSE :
			return "AUCTION_CLOSE";

		case InstrState::OPEN :
			return "OPEN";

		case InstrState::CLOSED :
			return "CLOSED";

		case InstrState::SUSPENDED :
			return "SUSPENDED";

		case InstrState::HALTED :
			return "HALTED";

		default:
			return "INVALID";
	}
}
**************FILE************ ./source/0.9.0.0/base/MarketDataApplication.cpp
#include <dlfcn.h>
#include <atomic>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include <time.h>

#include "infra/pugixml/pugixml.h"
#include "infra/logger/Logger.h"

#include "base/BaseCommon.h"
#include "base/MarketDataApplication.h"
#include "base/FeedHandler.h"
#include "base/NetworkReader.h"
#include "base/Recorder.h"

using namespace base;
using namespace infra;

FeedHandlerConstructor* MarketDataApplication::feedHandlerConstructors = new FeedHandlerConstructor[FeedID::MAX_FEEDS];

bool MarketDataApplication::registerFeedConstructors(FeedID feedID, FeedHandlerConstructor feedHandlerConstructor)
{
	feedHandlerConstructors[static_cast<int>(feedID)] = feedHandlerConstructor;
}

void MarketDataApplication::refreshTime()
{
	clock_gettime(CLOCK_REALTIME, &_globalClock);
	_time.store( *(reinterpret_cast<__int128 *>(&_globalClock)), memory_order_release);
}

/**
 *	\brief: MarketDataApplication, 
 *			constructor
 *
 *	This is a hard coded starting routine for every market data application.
 *	Later only market data subscription will happen. There is no restriction on
 *	instances of market data created
 *	@input	: 
 				@configFile: Config file of the application
 *	@output	: Market data instance will be created, which inturn creates
 *				all the resources. All app->start() to run the app after this;
 *  @TODO: Think about returning the shared pointer
 *
 *	@algo:
 *		Get time of the day
 *		Parse the config file
 * 		if Config file is valid
 *				1> create and start the loger
 *				2> create the main thread
 *				3> create the NetworkReader threads.
 *				4> create the FeedHandlers
 *						create the LineGroup Threads
 *							create the lines
 *				
 *				
 *		else
 *			raise and exception
 */
MarketDataApplication::MarketDataApplication(std::string configFile, FeedAPI *feedAPI)
	: _appInstance(this)
	, _configFile(configFile)
	, _thread(nullptr)
	, _mutex()
	, _feedAPI(feedAPI)
	, _name()
	, _bindThreads(MANUALLY)
	, _lastcpu(1)
	, _recorder(nullptr)
{
	refreshTime();
	pugi::xml_document doc;
	pugi::xml_parse_result result = doc.load_file(_configFile.c_str());
	if(result)
	{
		pugi::xml_node configNode = doc.child("config");
		pugi::xml_node ApplicationHandlerNode = configNode.child("ApplicationManager");
		if(ApplicationHandlerNode)
		{
			strncpy(const_cast<char *>(_name), ApplicationHandlerNode.getAttributeAsCString("name" , "", false, ""), sizeof(_name));

			_bindThreads = getThreadMode(ApplicationHandlerNode.getAttributeAsCString("bind-threads", "manually", false, "automatically,manually,false"));
			_lastcpu = ApplicationHandlerNode.getAttributeAsUInt("first-cpu", 1) - 1;

			pugi::xml_node LoggerNode = configNode.child("Logger");
			if(LoggerNode)
			{
				_loggerInstance = new Logger(_name, this, LoggerNode);
				///< We immeidatly start the logger thread, Do not wait to start the app
				_loggerInstance->thread()->start();
			}
			else
			{
				/// Raise an exception that logger is not present
				std::string error("No Logger Node found !!!");
				throw std::invalid_argument(error);
			}

			/// create the main thread
			_thread = new Thread(this, ApplicationHandlerNode, _name, this, MarketDataApplication::start);	
			
			///< create the NetworkReader threads
			createNetworkReaders(configNode);

			///< create the FeedHandlers 
			createFeedHandlers(configNode);
		}
		else
		{
			std::string error("No Application Manager Node found !!!");
			throw std::invalid_argument(error);
		}
	}
	else
	{
		char errorBuff[512];

		///< Throw an error exception. Can not parse the file or file is not present
		snprintf(errorBuff, sizeof(errorBuff), "Could not parse the xml config file[%s]. Check if file exists or do xmllint on file to check if it is well formatted !!!", _configFile.c_str());
	
		std::string error = errorBuff;
		throw std::invalid_argument(error);
	}
}

/**
 * \brief: getRecorder
 *			get the Recorder thread
 */
Recorder* MarketDataApplication::getRecorder() const
{
	return _recorder;
}

/**
 *	\brief: createNetworkReaders 
 *			Creates difference threads whos job is just to read network packets
 *			And queueing the packets into the assigner threads queues
 */
void MarketDataApplication::createNetworkReaders(const pugi::xml_node &configNode)
{
	pugi::xml_node networkReaders = configNode.child("NetworkReaders");
	if(networkReaders)
	{
		for (pugi::xml_node_iterator it = networkReaders.begin(); it != networkReaders.end(); ++it)
		{
			pugi::xml_node readerNode = *it;
			std::string nameOfChildNode = readerNode.name();
			if(nameOfChildNode == "NetworkReader")
			{
				std::string readerName = readerNode.getAttributeAsString("name" , "", false, "");
				const NameToNetworkReaderMap::iterator itr = _networkReaderMap.find(readerName);
				if(itr == _networkReaderMap.end())
				{
					NetworkReader *networkReader = new NetworkReader(this, readerNode);
					_networkReaderMap.insert(std::make_pair(readerName, networkReader));
					logConsole(DEBUG, "Inserted network reader [ %s : %p ] into map", readerName.c_str(), networkReader);
				}
				else
				{
					///< Throw an error exception duplicate reader name 
					char errorBuff[512];
					
					snprintf(errorBuff, sizeof(errorBuff), "Duplicate NetworkReader Name found in config. NetworkReader is already present [ %s : %p ] into map", readerName.c_str(), itr->second);
					std::string error(errorBuff);

					throw std::invalid_argument(error);
				}
			}
			else
			{
				///< Unintended node specified in the config file, raise exception log 
				logConsole(WARN, "<NetworkReaders> config node has unexpected child node <%s>", nameOfChildNode.c_str());
			}
		}
	}
}

/**
 *	feedHandlerConstructor:	
 *			Calls the feed specific feedManger
 */
FeedHandler* MarketDataApplication::feedHandlerConstructor(const pugi::xml_node& feedHandlerNode, const std::string &feedHandlerName)
{
	std::string feedType = feedHandlerNode.getAttributeAsString("feed", "", false, "");
	FeedID	feedID = FeedHandler::getFeedID(feedType);
	const char *libName = "";
	switch(feedID)
	{
		case FeedID::MILLENIUM:
				libName="libcd-millenium.so";
				break;
			
		case FeedID::OMXNORDIC:
				libName="libcd-omxnordic.so";
				break;
			
		default:
			///Raise an exception:
			{
				///< Throw an error exception no network reader found 
				char errorBuff[512];

				snprintf(errorBuff, sizeof(errorBuff), "Can not create FeedHandler belonging to node <FeedHandler name=\"%s\"> as did not find library for FeedHandler [ %u : %s ]. Check \"feed\" argument", feedHandlerName.c_str(), feedID, feedType.c_str());

				std::string error(errorBuff);
				throw std::invalid_argument(error);
			}
	}

	///@TODO: Load the libarary
	void * handle = dlopen(libName, RTLD_LOCAL | RTLD_LAZY);
	if (!handle) 
	{
		char errorBuff[512];

		snprintf(errorBuff, sizeof(errorBuff), "Could not create FeedHandler belonging to node  <FeedHandler name=\"%s\"> as could not load library %s. Please check if libarary is compiled and included in the release: ", feedHandlerName.c_str(), libName);

		std::string error(errorBuff);
		error = error + dlerror();
		throw std::invalid_argument(error);
	}

	return feedHandlerConstructors[static_cast<int>(feedID)](_appInstance, feedHandlerNode, _feedAPI);
}

/**
 *	\brief: createFeedHandlers
 *			Creates all Feed managers. 
 */
void MarketDataApplication::createFeedHandlers(const pugi::xml_node &configNode)
{
	pugi::xml_node feedHandlers = configNode.child("FeedHandlers");
	bool createRecorder = false;
	if(feedHandlers)
	{
		int i = 0;
		for (pugi::xml_node_iterator it = feedHandlers.begin(); it != feedHandlers.end(); ++it)
		{
			pugi::xml_node feedHandlerNode = *it;
			std::string nameOfChildNode = feedHandlerNode.name();
			if(nameOfChildNode == "FeedHandler")
			{
				std::string feedHandlerName = feedHandlerNode.getAttributeAsString("name" , "", false, "");
				bool record = feedHandlerNode.getAttributeAsBool("record" , false);
				if(record)
				{
					_recorder = new Recorder(this, configNode);
				}

				const NameToFeedHandlerMap::iterator itr = _feedHandlerMap.find(feedHandlerName);
				if(itr == _feedHandlerMap.end())
				{
					FeedHandler *feedHandler = feedHandlerConstructor(feedHandlerNode, feedHandlerName);
					_feedHandlerMap.insert(std::make_pair(feedHandlerName, feedHandler));
					logConsole(DEBUG, "Inserted feedHandler [ %s : %p ] into map", feedHandlerName.c_str(), feedHandler);

					if(feedHandler->_recording)
					{
						createRecorder = true;
					}
				}
				else
				{
					///< Throw an error exception duplicate feedHandler name 
					char errorBuff[512];
					
					snprintf(errorBuff, sizeof(errorBuff), "Duplicate FeedHandler Name found in config. FeedHandler is already present [ %s : %p ] into map", feedHandlerName.c_str(), itr->second);
					std::string error(errorBuff);

					throw std::invalid_argument(error);
				}
			}
			else
			{
				///< Unintended node specified in the config file, raise exception log 
				logConsole(WARN, "<FeedHandlers> config node has unexpected child node <%s>", nameOfChildNode.c_str());
			}
		}
	}
}

/**
 *  \brief: getFeedHandler
 *						
 */
FeedHandler *MarketDataApplication::getFeedHandler(const char *feedHandlerName) const
{
	NameToFeedHandlerMap::const_iterator itr = _feedHandlerMap.find(feedHandlerName);
	if(itr != _feedHandlerMap.end())
	{
		return itr->second;
	}
	else
	{
		return nullptr;
	}
}

/**
 *  \brief: getNetworkReader
 *						
 */
NetworkReader *MarketDataApplication::getNetworkReader(const char *readerName, const pugi::xml_node &configNode) const
{
	NameToNetworkReaderMap::const_iterator itr = _networkReaderMap.find(readerName);
	if(itr != _networkReaderMap.end())
	{
		return itr->second;
	}
	else
	{
		if(strcmp(readerName, ""))
		{
			char errorBuff[512];

			///< Throw an error exception. Could not find the networkReader with valid name 
			snprintf(errorBuff, sizeof(errorBuff), "<%s name=\"%s\"> Could not find NetworkReader %s.", configNode.name(), configNode.getAttributeAsCString("name", ""), readerName);
			std::string error = errorBuff;
			throw std::invalid_argument(error);
		}
		return nullptr;
	}
}

/*
 * subscribe using symbol name
 */
int32_t MarketDataApplication::subscribe(const char *feedName, const char *symbol, Subscription **sub) const
{
	FeedHandler *fh = getFeedHandler(feedName);

	if(!fh)
	{
		return INVALID_FEEDNAME;
	}

	fh->subscribe(symbol, sub);
}

/*
 * subscribe using symbol id 
 */
int32_t MarketDataApplication::subscribe(const char *feedName, const uint64_t symbolID, Subscription **sub) const
{
	FeedHandler *fh = getFeedHandler(feedName);

	if(!fh)
	{
		return INVALID_FEEDNAME;
	}

	return fh->subscribe(symbolID, sub);
}

/**
 * Starts the actual OS thread instance
 */
void MarketDataApplication::start()
{
	_thread->start();
	return;
}

/**
 * Calls the main processing function
 */
void* MarketDataApplication::start(void *obj)
{
	static_cast<MarketDataApplication *>(obj)->MarketDataApplicationLoop();
	return nullptr;
}

/**
 * \brief: MarketDataApplicationLoop
 * 			First send start signal to all the components 	
 * 			And then run continuosly to check the App health. 
 *	@algo:	
 *			1> start all the feed managers, 
 *				ensures that consuming threads are ready to eat
 *			2> start all the network readers(producers)
 *			
 *			while(thread is active)
 *				Update Time
 *			 	keep checking health, and do the management work
 */
void  MarketDataApplication::MarketDataApplicationLoop()
{
	logMessage(INFO, "Starting the MarketDataApplication [ %s : %p ] thread [ %s : %p ] with MarketDataApplication: Will Startall FeedHandlers and NetworkReaders", _name, this, _thread->_name, _thread);

	if(_recorder)
	{
		_recorder->start();
	}

	startFeedHandlers();
	startNetworkReaders();

	uint64_t stopTime = 0;
	while(_thread->isActive())
	{
		refreshTime();
	}

	// stop has been called for this thread,
	// Call the recursive stop for all member resources(resources)
	stopComponents();

	// Print all the stats
	printStats();

	_thread->stop();
}

/**
 *	\brief: startFeedHandlers
 *		starts all the feed managers under this application
 */
void MarketDataApplication::startFeedHandlers() const
{
	logMessage(INFO, "MarketData Application [ %s : %p ] is starting FeedHandlers", _name, this);
	NameToFeedHandlerMap::const_iterator itr = _feedHandlerMap.begin();
	for( ; itr != _feedHandlerMap.end(); itr++)
	{
		itr->second->start(_thread);
	}
}

/**
 *	\brief: startNetworkReaders
 *		starts all the feed managers under this application
 */
void MarketDataApplication::startNetworkReaders() const
{
	logMessage(INFO, "MarketData Application [ %s : %p ] is starting NetworkReaders", _name, this);
	NameToNetworkReaderMap::const_iterator itr = _networkReaderMap.begin();
	for( ; itr != _networkReaderMap.end(); itr++)
	{
		itr->second->start();
	}
}

/**
 *	\brief: shouldStop 
 *			Check if atleast one network reader is reading from file.
 *			If all network readers have signled to stop application signal to stop via SIGINT 2.
 */
void MarketDataApplication::stopApp() const
{
	NameToNetworkReaderMap::const_iterator itr = _networkReaderMap.begin();
	for( ; itr != _networkReaderMap.end(); itr++)
	{
		if(!itr->second->_stopApp)
		{
			//network reader is active, do not stop app
			return;
		}
	}

	//All network readers are running empty, signal to stop the application in next 5 secs
	usleep(5 * 1000000);
	kill(getpid(), 15);
	return;
}

/**
 * Free the resources, stops the other threads 
 */
void MarketDataApplication::stopComponents()
{
	logMessage(INFO, "MarketData Application [ %s : %p ] is stopping", _name, this);
	//stop network readers
	logMessage(INFO, "MarketData Application [ %s : %p ] is stopping NetworkReaders", _name, this);
	NameToNetworkReaderMap::const_iterator nr = _networkReaderMap.begin();
	for( ; nr != _networkReaderMap.end(); nr++)
	{
		nr->second->stop();
	}

	//stop feed handlers
	logMessage(INFO, "MarketData Application [ %s : %p ] is stopping FeedHandlers", _name, this);

	NameToFeedHandlerMap::const_iterator feed = _feedHandlerMap.begin();
	for( ; feed != _feedHandlerMap.end(); feed++)
	{
		feed->second->stop(_thread);
	}

	if(_recorder)
	{
		_recorder->stop();
	}
}

/**
 * Print all the stats for resources 
 */
void MarketDataApplication::printStats()
{
	logMessage(INFO, "MarketData Application [ %s : %p ] is stats", _name, this);
	//Print network reader stats
	NameToNetworkReaderMap::const_iterator nr = _networkReaderMap.begin();
	for( ; nr != _networkReaderMap.end(); nr++)
	{
//		nr->second->printStats();
	}

	//print feed handlers stats
	NameToFeedHandlerMap::const_iterator feed = _feedHandlerMap.begin();
	for( ; feed != _feedHandlerMap.end(); feed++)
	{
		feed->second->printStats(_thread);
	}
}

/**
 * Get the logger server instance associated with the application 
 */
const Logger *MarketDataApplication::getLoggerInstance() const
{
	return _loggerInstance;
}

/**
 * Stops all the threads related with the application 
 */
void MarketDataApplication::stop()
{
	_thread->signalToStop();
	while(!_thread->isStopped());

	logMessage(INFO, "MarketDataApplication [ %s : %p ] is stopped", _name, this);
	return;
}

/**
 * Release all the resources(memory...) and threads(stop and delete)
 */
MarketDataApplication::~MarketDataApplication()
{
	//delete network readers
	NameToNetworkReaderMap::const_iterator netReader = _networkReaderMap.begin();
	for( ; netReader != _networkReaderMap.end(); netReader++)
	{
		NetworkReader *nr = netReader->second;
		delete nr;
	}
	_networkReaderMap.clear();

	//stop feed handlers
	NameToFeedHandlerMap::const_iterator feed = _feedHandlerMap.begin();
	for( ; feed != _feedHandlerMap.end(); feed++)
	{
		FeedHandler *fh = feed->second; 
		delete fh;
	}
	_feedHandlerMap.clear();

	if(_recorder)
	{
		delete _recorder;
	}
	
	delete _thread;

	_loggerInstance->stop();
	delete _loggerInstance;
}

/*
 * Get how to allocate cores to the threads
 * bind-threads : Default value manual.
 *				automatically:	Assign thread no automatically,
 *							Ensure that there are sufficient cores are available. Otherwise
 *							if all cores are allocated it will raise exception
 *				manually	 : consider core given with "cpu" config option on 
 *								respective config nodes to bind
 *				false		 : No thread binding and "cpu" config option on nodes is
 */
BindThreads MarketDataApplication::getThreadMode(const char *mode)
{
	if(!strcmp(mode, "automatically"))
	{
		return BindThreads::AUTOMATICALLY;
	}
	else if(!strcmp(mode, "manually"))
	{
		return BindThreads::MANUALLY;
	}
	else if(!strcmp(mode, "false"))
	{
		return BindThreads::FALSE;
	}

	ASSERT(false, mode << " : Thread bind mode is incorrect");
	return BindThreads::FALSE;
}
**************FILE************ ./source/0.9.0.0/base/Packet.cpp
#include "infra/logger/Logger.h"

#include "base/MarketDataApplication.h"
#include "base/LineGroup.h"
#include "base/Line.h"
#include "base/Packet.h"

using namespace base;
using namespace infra;


**************FILE************ ./source/0.9.0.0/base/Quote.h
#ifndef __QUOTE_H__
#define __QUOTE_H__

namespace base
{
	enum QuoteType 
	{
		QUOTE_UNKNOWN = 'U',
		NORMAL = 'N',
		WIDE = 'W',
		CROSSED = 'C'
	};

	enum QuoteFill
	{
		FILL_UNKNOWN = 0,
		BOTH_SIDE	= 1,
		EMPTY_ASK	= 2,
		EMPTY_BID	= 3
	};

	enum QuoteChange
	{
		CHANGE_UNKNOWN = 0,
		PRICE_CHANGE = 1,
		SIZE_CHANGE = 2
	};

	class Quote : public Base
	{
		public:
		Quote(Subscription *);
		void cacheBuySideQuote();
		void checkBuySideQuote(Book *book);
		void cacheSellSideQuote();
		void checkSellSideQuote(Book *book);

//		QuoteType _quoteType; // crossed, normal
//		QuoteFill _fill;
//		Side	  _side; // which side has changed
		QuoteChange _change; // Price/Size 
		PriceLevel *_buy;
		PriceLevel *_sell;
		double _lastBuyPx;
		uint64_t _lastBuySize;
		double _lastSellPx;
		uint64_t _lastSellSize;
	};
}

#include "base/Book.h"
#include "base/PriceLevel.h"
#include "base/Line.h"
#include "base/API.h"
using namespace base;

inline Quote::Quote(Subscription *sub)
	: Base(sub, QUOTE_UPDATE)
//	, _quoteType(QUOTE_UNKNOWN)
//	, _fill(FILL_UNKNOWN)
//	, _side(SIDE_UNKNOWN)
	, _change(CHANGE_UNKNOWN)
	, _buy(nullptr)
	, _sell(nullptr)
	, _lastBuyPx(0)
	, _lastBuySize(0)
	, _lastSellPx(0)
	, _lastSellSize(0)
{
}

inline void Quote::cacheBuySideQuote()
{
	if(_buy)
	{
		_lastBuyPx = _buy->_px;
		_lastBuySize = _buy->_size;
	}
}

inline void Quote::checkBuySideQuote(Book *book)
{
	PriceLevelMap::const_iterator itr = book->_buys.begin();
	if(itr == book->_buys.end())
	{
		update(book->_line, book->_msgType, book->_seqNum, book->_xt.tv_sec, book->_xt.tv_nsec);
		_buy = nullptr;

		LineAPI *api = _line->_lineAPI;
		(api->*(api->_onQuote))(this);
		return; 
	}

	PriceLevel *topBuyLevel = itr->second; 
	if(_lastBuyPx != topBuyLevel->_px)
	{
		update(book->_line, book->_msgType, book->_seqNum, book->_xt.tv_sec, book->_xt.tv_nsec);
		_buy = topBuyLevel;

		LineAPI *api = _line->_lineAPI;
		(api->*(api->_onQuote))(this);
	}
	else if (_lastBuySize != topBuyLevel->_size)
	{
		//raise the quote
		update(book->_line, book->_msgType, book->_seqNum, book->_xt.tv_sec, book->_xt.tv_nsec);
		LineAPI *api = _line->_lineAPI;
		(api->*(api->_onQuote))(this);
	}
}

inline void Quote::cacheSellSideQuote()
{
	if(_sell)
	{
		_lastSellPx = _sell->_px;
		_lastSellSize = _sell->_size;
	}
}

inline void Quote::checkSellSideQuote(Book *book)
{
	PriceLevelMap::const_iterator itr = book->_sells.begin();
	if(itr == book->_sells.end())
	{
		update(book->_line, book->_msgType, book->_seqNum, book->_xt.tv_sec, book->_xt.tv_nsec);
		_sell = nullptr;

		LineAPI *api = _line->_lineAPI;
		(api->*(api->_onQuote))(this);
		return; 
	}

	PriceLevel *topSellLevel = itr->second; 
	if(_lastSellPx != topSellLevel->_px)
	{
		update(book->_line, book->_msgType, book->_seqNum, book->_xt.tv_sec, book->_xt.tv_nsec);
		_sell = topSellLevel;

		LineAPI *api = _line->_lineAPI;
		(api->*(api->_onQuote))(this);
	}
	else if (_lastSellSize != topSellLevel->_size)
	{
		//raise the quote
		update(book->_line, book->_msgType, book->_seqNum, book->_xt.tv_sec, book->_xt.tv_nsec);
		LineAPI *api = _line->_lineAPI;
		(api->*(api->_onQuote))(this);
	}
}
#endif //__QUOTE_H__
**************FILE************ ./source/0.9.0.0/base/Line.cpp
#include "infra/logger/Logger.h"
#include "infra/thread/Thread.h"

#include "base/MarketDataApplication.h"
#include "base/NetworkReader.h"
#include "base/Subscription.h"
#include "base/API.h"
#include "base/FeedHandler.h"
#include "base/LineGroup.h"
#include "base/Line.h"
#include "base/PriceLevel.h"
#include "base/Order.h"
//#include "base/Packet.h"

using namespace base;
using namespace infra;

const char *IP::IPString[24] = {
		"primary-mc-line",
		"secondary-mc-line",
		"dr-primary-mc-line",
		"dr-secondary-mc-line",

		"primary-tcp-line",
		"secondary-tcp-line",
		"dr-primary-tcp-line",
		"dr-secondary-tcp-line",

		"primary-mc-snap-line",
		"secondary-mc-snap-line",
		"dr-primary-mc-snap-line",
		"dr-secondary-mc-snap-line",

		"primary-tcp-snap-line",
		"secondary-tcp-snap-line",
		"dr-primary-tcp-snap-line",
		"dr-secondary-tcp-snap-line",

		"primary-mc-retrans-line",
		"secondary-mc-retrans-line",
		"dr-primary-mc-retrans-line",
		"dr-secondary-mc-retrans-line",

		"primary-tcp-retrans-line",
		"secondary-tcp-retrans-line",
		"dr-primary-tcp-retrans-line",
		"dr-secondary-tcp-retrans-line",
	};

const char *base::getChannelString(base::ChannelType type)
{
	switch(type)
	{
		case base::ChannelType::MAIN :
			return "MAIN";

		case base::ChannelType::SNAP:
			return "SNAP";

		case base::ChannelType::RETRANS:
			return "RETRANS";

		default:
			//@TODO: Assert that this does not happen
			return "UNKNOWN";
	}
}

Line::Line(const MarketDataApplication *app, FeedHandler *feedHandler, LineGroup *lineGroup, Thread *thread, const pugi::xml_node &lineNode, LineAPI *lineAPI, Start start, ProcessPacket processFunc, GetPackStats getPacketStats, GetPackStatsSnap getPacketStatsSnap, ReRequestMissedPackets reRequestMissedPackets)
	: _lineAPI(lineAPI)
	, _appInstance(app)
	, _name()
	, _feedHandler(feedHandler)
	, _lineGroup(lineGroup)
	, _thread(thread)
	, _priceLevelPool(nullptr)
	, _orderPool(nullptr)
	, _maintainOrders(feedHandler->_maintainOrders)
	, _sub(nullptr)
	, _lastSeqNo(0)
	, _headerSeqNo(0)
	, _endSeqNo(0)
	, _currentMsg(nullptr)
	, _snapshotEnabled(false)
	, _isSnapStarted(false)
	, _isSnapshotEnd(false)
	, _lineState(LineState::JUST_STARTED)
	, _contentType(ContentType::HB)
	, _xtSecs(0)
	, _xtNanoSecs(0)
	, parseFuncMap{{nullptr, false, 0, 0, NO_CALLBACK}}
	, _processPacket(processFunc)
	, _nativGetPacketStats(getPacketStats)
	, _nativGetPacketStatsSnap(getPacketStatsSnap)
	, _nativReRequestMissedPackets(reRequestMissedPackets)
	, _packet(nullptr)
	, _nativStart(start)
	, _orderMap(nullptr)
{
	strncpy(const_cast<char *>(_name), lineNode.getAttributeAsCString("name", "", false, ""), sizeof(_name));
	logConsole(DEBUG, "Creating the Line [ %s : %p ]", _name, this);
	createLineIPs(lineNode);
		
	uint64_t buckets = lineNode.getAttributeAsLlong("order-map-size", 1024*1024);
	double loadFactor = lineNode.getAttributeAsDouble("order-map-load-factor", 10.0);
	_orderMap =  new std::unordered_map<uint64_t, Order *>(); 

	//change bucket size only after changing max load factor
	_orderMap->max_load_factor(loadFactor);
	_orderMap->rehash(buckets);

	// allocate PriceLevel pool with next size chunk and unlimited max size
	uint32_t size = lineNode.getAttributeAsUInt("pricelevel-pool-chunk-size", 1024*1024);
	uint32_t setNextSize = lineNode.getAttributeAsUInt("pricelevel-pool-set-next-size", 1024 *1024);
	_priceLevelPool =  new PriceLevelPool(size); 
	_priceLevelPool->set_next_size(setNextSize);

	// allocate order pool with next size chunk  and unlimited max size
	size = lineNode.getAttributeAsUInt("order-pool-chunk-size", 1024*1024);
	setNextSize = lineNode.getAttributeAsUInt("set-next-size", 1024 *1024);
	_orderPool =  new OrderPool(size); 
	_orderPool->set_next_size(setNextSize);
}

void Line::registerCallbacks(CallBacks callbacks)
{
	_callbacks = callbacks;
}

bool Line::hasInterest(CallBacks callback) const
{
	return _callbacks & callback;
}

bool Line::hasStrictInterest(CallBacks callback) const
{
	return (_callbacks & callback) == callback;
}

void Line::createLineIPs(const pugi::xml_node &lineNode)
{
	for(uint32_t i = 0; i < static_cast<uint32_t>(IPType::IPTYPE_MAX); i++)
	{
		_IPs[i] = PacketAddress(IP::getParsedIPPort(_appInstance, lineNode, IP::IPString[i]), static_cast<IPType>(i), static_cast<ChannelType>(i/8), this, _lineGroup); 

		IP zeroIP;
		if(zeroIP != _IPs[i])
		{
			_lineGroup->networkReader()->addIPToNetworkReader(&_IPs[i]);
		}
	}
}

void Line::reset()
{
	_lastSeqNo = 0; 
	_headerSeqNo = 0;
	_endSeqNo = 0;
	_currentMsg = nullptr;
	_isSnapStarted = false;
	_isSnapshotEnd = false;
	_snapshotSyncNo = 0;
	_lineState = LineState::JUST_STARTED;
	_contentType = ContentType::HB;
}

void Line::start()
{
	// initialize the base Line
	//initialize the Native feed specefic line
	(this->*_nativStart)();
	(_lineAPI->*(_lineAPI->_onLineStarted))(this);
}

/**
 * insert the order from ordermap maintained at the line group level
 */
void Line::insert(uint64_t orderID, Order *order)
{
#ifdef __ORDERMAP_LATENCY__
	timespec mt = globalClock();
	_orderMap->insert(make_pair(orderID, order));
	getLatency(_lineGroup->_om, mt);
#else
	_orderMap->insert(make_pair(orderID, order));
#endif

}
/**
 * returns the order from ordermap maintained at the line group level
 */
Order* Line::find(uint64_t orderID) const
{
	std::unordered_map<uint64_t, Order *>::const_iterator itr = _orderMap->find(orderID);
	if(itr != _orderMap->end())
	{
		return itr->second;
	}
	else
	{
		logMessage(EXCEPTION, "For Line [ %s : %p ] could not find order [ %llu ] in the orderMap [ %p ] in the orderMap to modify order" , this->_name, this, orderID, _orderMap);
		return nullptr;
	}
}

/**
 * Erase the order from ordermap maintained at the line group level
 */
void Line::erase(uint64_t orderID) const
{
	std::unordered_map<uint64_t, Order *>::const_iterator itr = _orderMap->find(orderID);
	if(itr != _orderMap->end())
	{
		_orderMap->erase(itr);
		return;
	}
	else
	{
		logMessage(EXCEPTION, "For Line [ %s : %p ] could not find order [ %llu ] to erase in the orderMap [ %p ]" , this->_name, this, orderID, _orderMap);
		return;
	}
}

/**
 *	\brief: printStats 
 *		print stats of all the underlying lines
 */
void Line::printStats(const Thread *_thread) const
{
}

int32_t Line::process() 
{
	// Process the MAIN and RETRANS messages
	if(_packet->_packetAddress->_channelType != ChannelType::SNAP)
	{
		return processMainLinePacket();
	}
	else // Process the SNAP Message
	{
		return processSnapshotPacket();
	}
}

int32_t Line::processMainLinePacket()
{
	// if feed is already snapped
	if(_lineState == LineState::NORMAL || _lineState == LineState::GAPPED) 
	{
		//_nativGetPacketStats(_contentType, _headerSeqNo, _endSeqNo, _currentMsg);
		(this->*_nativGetPacketStats)();

		if(_contentType == ContentType::HB)
		{
			// We have been gapped as HB seq is expected seq no to arrive 
			// So we declare we are gapped and note the timestamp of gap
			if(_headerSeqNo > _lastSeqNo+1   &&   _lineState != LineState::GAPPED)
			{ 
				_lineState = LineState::GAPPED; 	
				reRequestMissedPacket();
			}
			return PROCESSED;
		}
		else if(_contentType == ContentType::DATA_PACKET)
		{

			// This packet has next useful message
			if(_headerSeqNo <= _lastSeqNo+1   &&   _endSeqNo >= _lastSeqNo+1)
			{
				// We have some useful messages to be processed
				processPacket();

				if(_lineState == LineState::GAPPED)
				{
					processGapCache();
				}
				return PROCESSED;
			}
			else if(_endSeqNo <= _lastSeqNo)
			{
				// We have already processed all messages in this packet
				return PROCESSED;
			}
			else
			{
				// We are facing fresh gap, add packet to gap cache in sorted way
				_lineState = LineState::GAPPED; 	
				int32_t retval = addToGapCache();
				reRequestMissedPacket();
				return retval;
			}
		}
		
		// Not HB/DATA packet not of any use
		return PROCESSED;
	}
	else if(_lineState == LineState::SNAPPING)
	{
		if(_contentType != ContentType::HB)
		{
			return addToSnapCache();
		}

		// return HB as processed
		return PROCESSED;
	}
	else // We are yet to decide where to snap or not
	{
		// We yet to complete snap. Cache the main/retranse line packets
		//_nativGetPacketStats(_contentType, _headerSeqNo, _endSeqNo, _currentMsg);
		(this->*_nativGetPacketStats)();

		// this is the first packet with seq no 1
		// or intial HBs with seq no 1 in the ideal period during early hours
		if(_snapshotEnabled)
		{
			if(_headerSeqNo == 1)
			{
				_lastSeqNo = 0;
				_lineState = LineState::NORMAL;

				// We have some useful messages to be processed
				if(_contentType != ContentType::HB)
				{
					processPacket();
				}
				return PROCESSED; 
			}
		
			// We request snapshot and add current packet to the
			// snapCache and processs after snapshot completion
			_lineState = LineState::SNAPPING;
			reRequestSnap();
			if(_contentType == ContentType::HB)
			{
				return PROCESSED;
			}
			else
			{
				return addToSnapCache();
			}
		}
		else
		{
			//snapshot is not enabled
			_lastSeqNo = _headerSeqNo -1;
			_lineState = LineState::NORMAL;

			// We have some useful messages to be processed
			if(_contentType != ContentType::HB)
			{
				processPacket();
			}
			return PROCESSED; 
		}
	}
}

int32_t Line::processSnapshotPacket()
{
	if(_lineState != LineState::SNAPPING)
	{
		return PROCESSED;
	}
	else
	{
		(this->*_nativGetPacketStatsSnap)();
		if(_contentType == ContentType::HB)
		{
			// We have been gapped as HB seq is greater than expected sequence no to arrive 
			// So we cannot declare that we are gapped, 
			// That is why we will immeditely re-request the snapshot 
			// Though we might get missing packet immediatly,
			if(_headerSeqNo > _lastSeqNo+1)
			{
				reRequestSnap();
			}

			return PROCESSED;
		}
		else if(_contentType == ContentType::DATA_PACKET)
		{
			// We have some useful messages to be processed

			// We have recieved the start of snapshot
			if(_isSnapStarted)
			{
				// Clear any snapshot channel gap cache packets
				// And set _lastSeqNo so that _headerSeqNo is the expected one
				// As well clear packets having _endSeqNo <= _snapshotSyncNo
				clearGapCache();
				_lastSeqNo = _headerSeqNo - 1;

				//@TODO: Do we really want to clear non-imp packets
				// as of now?
				//clearSnapCache(_snapshotSyncNo);
			}

			if(_headerSeqNo <= _lastSeqNo+1   &&   _endSeqNo >= _lastSeqNo+1)
			{
				//@TODO: assert that _isSnapStarted is true
				//This is a valid packet 
				processPacket();

				if(_isSnapshotEnd)
				{
					//@TODO: assert that  _lastSeqNo == _snapshotSyncNo 
					// clear snapshot packets from gap cache
					// And then process the packets after _snapshotSyncNo
					_lineState = LineState::NORMAL;

					//clear the packets from snapshot line
					clearGapCache();
					
					//process the packets from the real time mc line
					processSnapCache();
				}
			}
			else if(_endSeqNo <= _lastSeqNo)
			{
				// We have processed this packet
				return PROCESSED;
			}
			else
			{
				// we were snapping and then gapped
				if(_isSnapStarted)
				{
					// We are facing gap, add packet to gap cache and re-request the snapshot
					reRequestSnap();
					return addToGapCache();
				}
			}
		}
	}
}

void Line::processPacket()
{
	(_lineAPI->*(_lineAPI->_onPacketStart))(this);
	// calling actual feed specefic process
	(this->*_processPacket)();
	(_lineAPI->*(_lineAPI->_onPacketEnd))(this);
}

void Line::reRequestMissedPacket()
{
	// This function is called from 3 points.
	// Detected the gap because of the HB
	uint64_t requestTill = _headerSeqNo;
	
	if(!_gapCache.empty())
	{
		if(_gapCache.begin()->first._headerSeqNo < requestTill)
		{
			//request the minimal required packets
			requestTill = _gapCache.begin()->first._headerSeqNo;
		}
	}

	uint64_t requestFrom = _lastSeqNo;

	if(_lastSeqNo < _gapRequestedTill)
	{
		//Till this sequence we have already requested gap
		requestFrom = _gapRequestedTill;	
	}

	//Re-Requst all required packets
	if(requestFrom+1 <= requestTill -1)
	{
		logMessage(INFO, "Line [%s : %p] Unordered Data packet detected Gap. _lastSeqNo = %lu, _gapRequestedTill = %lu, next available _headerSeqNo = %lu. Requesting packets %lu-%lu", _name, this, _lastSeqNo, _gapRequestedTill, requestTill, requestFrom+1, requestTill-1);
		(this->*_nativReRequestMissedPackets)(requestFrom+1, requestTill-1);
		_gapRequestedTill = requestTill - 1;
	}
}

int32_t Line::addToGapCache()
{
	return addToCache(_gapCache);
}

// returns true if we are successfully recoverd from gap
void Line::processGapCache()
{
	static bool processingGapCache = false;
	if(!processingGapCache) // prevents recursive call to this function
	{
		processingGapCache = true;
		// process pakets after gap is filled 
		while(!_gapCache.empty())
		{
			std::map<SeqRange, Packet *>::iterator itr = _gapCache.begin();
			
			_packet = itr->second;
			
			if(itr->first._endSeqNo <= _lastSeqNo)
			{
				logMessage(DEBUG, "Line :[ %s: %p ], Ignoring the packet from cache as  _endSeqNo %lu <= _lastSeqNo %lu", _name, this, itr->first._endSeqNo, _lastSeqNo);
				itr->second->popDeleter();
				_gapCache.erase(itr);
			}
			else if(itr->first._headerSeqNo <= _lastSeqNo+1  &&  itr->first._endSeqNo >= _lastSeqNo+1)
			{
				logMessage(DEBUG, "Line :[ %s: %p ], Processing packet from cache as  _headerSeqNo = %lu  _endSeqNo %lu and _lastSeqNo %lu", _name, this, itr->first._headerSeqNo, itr->first._endSeqNo, _lastSeqNo);
				
				(this->*_nativGetPacketStats)();
				// We have some useful messages to be processed
				processPacket();

				itr->second->popDeleter();
				_gapCache.erase(itr);
			}
			else
			{
				break;
			}
		}

		if(_gapCache.empty())
		{
			_lineState = LineState::NORMAL;

			// we have been fully recovered from gap
			ASSERT(_endSeqNo == _lastSeqNo, "ProcessGapCache, fully recovered but _lastSeqNo != _endSeqNo");
			logMessage(INFO, "processGapCache : Line :[ %s: %p ], Fully recovered from Gap. as _endSeqNo %lu == _lastSeqNo %lu", _name, this, _endSeqNo, _lastSeqNo);
		}
		else
		{
			// we have not been recovered, might want to re-request the missing packet
			// _headerSeqNo is set appropriatly in the above loop
			// On some feeds if you request gap of 2500, they will send only 50.
			// Below call ensures that remaining 2450 are recalled again.
			reRequestMissedPacket();
		}
		processingGapCache = false;
	}
}

// After snapshot is complete process each packet 
// having _headerSeqNo > _snapshotSyncNo, from main line
void Line::processSnapCache()
{
	// process pakets after _snapshotSyncNo
	while(!_snapCache.empty())
	{
		std::map<SeqRange, Packet *>::iterator itr = _snapCache.begin();
		_packet = itr->second;
		int32_t retval = processMainLinePacket();
		if(!retval)
		{
			// ensure that _snapCache is not modified by above processMainLinePacket
			// function, otherwise this iterator will be invalidated
			itr->second->popDeleter();
}
		_snapCache.erase(itr);
	}
}

void Line::reRequestSnap()
{
	// start counting of the snap period from the when we recieve the snap start message
	logMessage(INFO, "Requesting snapshot for Line :[ %s: %p ] _lastSeqNo = %lu, _headerSeqNo = %lu", _name, this, _lastSeqNo, _headerSeqNo);
	_lineState = LineState::SNAPPING;
}

/**
 *	Add packet to the snapshot cache
 */
int32_t Line::addToSnapCache()
{
	return addToCache(_snapCache);
}

int32_t Line::addToCache(std::map<SeqRange, Packet *> &_cache)
{
	// Insert packet into map. If same packet is present, Process
	// The one with more no of the packets as line A and line B have different packaging
	SeqRange newRange(_headerSeqNo, _endSeqNo);
	auto itr = _cache.find(newRange);

	if(itr == _cache.end())
	{
		logMessage(INFO, "Line :[ %s: %p ], Adding packet to the cache _headerSeqNo = %lu  _endSeqNo %lu", _name, this, _headerSeqNo, _endSeqNo);
		_cache.insert(std::make_pair(newRange, _packet));
		return NOT_PROCESSED; 
	}
	else
	{
		SeqRange range = itr->first;

		//current packet has more useful message;
		if(newRange._endSeqNo > range._endSeqNo)
		{
			//free and erase older packet
			itr->second->popDeleter();
			_cache.erase(itr);

			logMessage(INFO, "Line :[ %s: %p ], Adding packet to the cache _headerSeqNo = %lu  _endSeqNo %lu", _name, this, _headerSeqNo, _endSeqNo);
			//write newer packet with greater _endSeqNo
			_cache.insert(std::make_pair(newRange, _packet));
			return NOT_PROCESSED; 
		}
		return PROCESSED; 
	}
}

// Erase every packet in the gap cache
void Line::clearGapCache()
{
	_gapCache.clear();
}

// Erase every packet in the Snap cache
void Line::clearSnapCache()
{
	_snapCache.clear();
}

/*
 *  Converts the _currentMsg + offset into the uint32_t id
 *	and then find the subscription in lineGroup sub map
 */
Subscription* Line::getIdSub32(uint16_t offset)
{
	uint64_t id = *reinterpret_cast<const uint32_t *>(_currentMsg + offset);
	return _lineGroup->getIdSub(id);
}

IP::IP()
{
	sin_family = AF_INET;
	sin_addr.s_addr = 0;
	sin_port = 0;
}

///< Check if IP string provided is valid one
IP IP::getParsedIPPort(const MarketDataApplication *_appInstance, const pugi::xml_node &node, const char *ipType, const std::string ipString)
{
	IP ip;
	std::size_t index;

	///< Check if string is in  IP:port format
	if((index= std::string(ipType).find("-mc-"))!= std::string::npos)
	{
		ip._type = SOCK_DGRAM;
	}
	else if((index= std::string(ipType).find("-tcp-"))!= std::string::npos)
	{
		ip._type = SOCK_STREAM;
	}
	else
	{
		///< Throw an error exception Error Invalid IP:PORT 
		char errorBuff[512];
					
		snprintf(errorBuff, sizeof(errorBuff), "<%s name=%s> %s attribute represents invalid argument name. Attribute name must contain \"-mc-\" or \"-tcp-\" to represent SOCK_DGRAM or SOCK_STREAM ", node.name(), node.getAttributeAsString("name", "").c_str(), ipType);
		std::string error(errorBuff);

		throw std::invalid_argument(error);
	}

	std::size_t found = ipString.find_first_of(':');

	///< Check if string is in  IP:port format
	if(found == std::string::npos)
	{
		///< Throw an error exception Error Invalid IP:PORT 
		char errorBuff[512];
					
		snprintf(errorBuff, sizeof(errorBuff), "<%s name=%s> %s attribute represents invalid IP:PORT[%s] provided on line. Please provide port", node.name(), node.getAttributeAsString("name", "").c_str(), ipType, ipString.c_str());
		std::string error(errorBuff);

		throw std::invalid_argument(error);
	}

	std::string rawIP = ipString.substr(0, found);
	///< Extract and check IP  is in  IPv4 format
	if (inet_aton(rawIP.c_str(), &ip.sin_addr) == 0)
	{
		///< Throw an error exception Error Invalid IP
		char errorBuff[512];
					
		snprintf(errorBuff, sizeof(errorBuff), "<%s name=%s> %s attribute represents invalid IP[%s] provided on line. Please provide correct IP", node.name(), node.getAttributeAsString("name", "").c_str(), ipType, rawIP.c_str());
		std::string error(errorBuff);
		throw std::invalid_argument(error);
	}	

	///< Extract and check PORT is unsigned numeric value between 0-65535
	std::string rawPORT = ipString.substr(found+1);
	try 
	{
		uint32_t port = std::stoul(rawPORT);
		if(port < 0 || port > 65535)
		{
			///< Throw an error exception Error Invalid IP
			char errorBuff[512];
						
			snprintf(errorBuff, sizeof(errorBuff), "<%s name=%s> %s attribute represents invalid PORT[%s] provided on line. Please provide correct PORT between 0-65535", node.name(), node.getAttributeAsString("name", "").c_str(), ipType, rawPORT.c_str());

			std::string error(errorBuff);
			throw std::invalid_argument(error);
		}
		ip.sin_port = htons(port);
	}
	catch(std::exception& e) 
	{
		///< Throw an error exception Error Invalid IP
		char errorBuff[512];
					
		snprintf(errorBuff, sizeof(errorBuff), "<%s name=%s> %s attribute represents invalid PORT[%s] provided on line. Please provide correct PORT between 0-65535", node.name(), node.getAttributeAsString("name", "").c_str(), ipType, rawPORT.c_str());

		std::string error(errorBuff);
		throw std::invalid_argument(error);
	}

	logConsole(TRACE, "For node [ %s : %s ] created %s=%s", node.name(), node.getAttributeAsString("name", "").c_str(), ipType, ipString.c_str());
	return ip;
}

IP IP::getParsedIPPort(const MarketDataApplication *_appInstance, const pugi::xml_node &lineNode, const char *ipType)
{
	return getParsedIPPort(_appInstance, lineNode, ipType, lineNode.getAttributeAsString(ipType, "0.0.0.0:0000"));
}

const std::string IP::toString() const
{
	char buffer[16];
	const char* result=inet_ntop(AF_INET , &sin_addr.s_addr, buffer, sizeof(buffer));
	
	char ipPort[21];
	snprintf(ipPort, sizeof(ipPort), "%s:%hu", buffer, ntohs(sin_port));	
	return std::string(ipPort); 
}

PacketAddress::PacketAddress()
	: IP()
	, _pLine(nullptr)
	, _lineGroup(nullptr)
	, _ipType(IPType::IPTYPE_MAX)
	, _channelType(ChannelType::CHANNELTYPE_MAX)
	, _pPacketQueue(nullptr)
{
}

PacketAddress::PacketAddress(const IP& ip, IPType ipType, ChannelType channelType, const Line *line, const LineGroup *lineGroup)
	: IP(ip)
	, _ipType(ipType)
	, _channelType(channelType)
	, _pLine(line)
	, _lineGroup(lineGroup)
	, _pPacketQueue(lineGroup->packetQueue())
{
}

BoostSPSCQueue<Packet> *PacketAddress::pPacketQueue() const
{
	return const_cast<BoostSPSCQueue<Packet> *>(_pPacketQueue);
}

Socket& PacketAddress::socket() const
{
	return const_cast<Socket&>(_socket);
}

const std::string PacketAddress::toString() const
{
	char buffer[256];
	snprintf(buffer, sizeof(buffer), "line %s:%p , lineGroup %s:%p , channel %s, iptype %s, ip %s", _pLine->_name, _pLine, _lineGroup->_name, _lineGroup, getChannelString(_channelType), IPString[(uint32_t)_ipType], static_cast<const IP*>(this)->toString().c_str());	
	return buffer; 
}

bool IP::operator < (const IP &rhs) const
{
	if(sin_addr.s_addr < rhs.sin_addr.s_addr)
	{
		return true;
	}
	else if( sin_addr.s_addr == rhs.sin_addr.s_addr)
	{
		if(sin_port <= rhs.sin_port)
		{
			return false;
		}
		else
		{
			return true;
		}
	}
	else
	{
		return false;
	}
}

bool IP::operator == (const IP &rhs) const
{
	return  (sin_port == rhs.sin_port) &&  ( sin_addr.s_addr == rhs.sin_addr.s_addr);
}

bool IP::operator != (const IP &rhs) const
{
	return  (sin_port != rhs.sin_port) || ( sin_addr.s_addr != rhs.sin_addr.s_addr);
}
**************FILE************ ./source/0.9.0.0/base/NetworkReader.cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <stdlib.h>
#include <unordered_map>
#include <boost/tokenizer.hpp>

#include "infra/logger/Logger.h"
#include "infra/utils/StringUtils.h"
#include "base/NetworkReader.h"
#include "base/MarketDataApplication.h"
#include "base/FeedHandler.h"
#include "base/LineGroup.h"
#include "base/Line.h"
#include "base/Packet.h"
#include "base/Recorder.h"

using namespace base;
using namespace infra;

/**
 *	\brief:	NetworkReader
 *			Constructor creates the Network reader object and thread belonging to it.
 */

NetworkReader::NetworkReader(const MarketDataApplication *app, const pugi::xml_node &readerNode)
	: _appInstance(app)
	, _name()
	, _stopApp(false)
	, _updateIPVector(false)
	, _mode(PlaybackMode::LIVE_PLAYBACK)
	, _recordQueue(nullptr)
{
	strncpy(const_cast<char *>(_name), readerNode.getAttributeAsCString("name", "", false, ""), sizeof(_name));
    logConsole(INFO, "Created the NetworkReader [ %s : %p ]", _name, this);    
	_thread = new Thread(_appInstance, readerNode, _name, this, NetworkReader::start);	
}

/*
 * Register LineGroups files
 *	if 
 */
void NetworkReader::registerLineGroup(LineGroup *lg)
{
	// Ensure that we have same playback mode for all the feeds under this network reader
	if(_feedStreams.size() != 0)
	{
		if(_mode != lg->_feedHandler->_mode)
		{
			///< Throw an error exception duplicate reader name 
			char errorBuff[512];

			snprintf(errorBuff, sizeof(errorBuff), "For NetworkReader [ %s : %p ] : LineGroup [ %s , %p ] is being registered. But FeedHandler [ %s : %p ] has playback mode [ %s ] different than perviosuly registered feeds for this NetworkReader [%s]", _name, this, lg->_name, lg, lg->_feedHandler->_name, lg->_feedHandler, playbackModeToStr(lg->_feedHandler->_mode), playbackModeToStr(_mode));
			std::string error(errorBuff);
			throw std::invalid_argument(error);
		}
	}
	
	_mode = lg->_feedHandler->_mode;
	if(lg->_feedHandler->_recording)
	{
		_recordQueue = _appInstance->getRecorder()->registerNetworkReader(this);	
	}
	
	// In FILE_PLAYBACK mode write the recordings into the _feedHandler map

	if(_mode == PlaybackMode::FILE_PLAYBACK)
	{
		const std::vector<std::string> &recordings = lg->_feedHandler->_playbackFilesVector;
		std::vector<Recording *>& streams = _feedStreams[lg->_feedHandler];

		//do not add same _feedHandler recordings twice for multiple lineGroups registrations
		if(streams.empty())
		{
			for(const std::string &recording : recordings)	
			{
				//open recording for reading 
				streams.push_back(new Recording(lg->_feedHandler, recording, false));
			}
		}
	}
}

/**
 * Starts the actual OS thread instance
 */
void NetworkReader::start()
{
	_thread->start();
	return;
}

/**
 * Stops actual OS thread instance
 */
void NetworkReader::stop()
{
	_thread->signalToStop();

	while(!_thread->isStopped());

	logConsole(INFO, "NetworkReader [ %s : %p ] is stopped", _name, this);
	return;
}

/**
 * Calls the processing function
 */
void* NetworkReader::start(void *obj)
{
	NetworkReader *nr = static_cast<NetworkReader *>(obj);
	if(nr->_mode == PlaybackMode::LIVE_PLAYBACK)
	{
		nr->networkReaderLoop();
	}
	else
	{
		nr->networkReaderLoopFile();
	}
	return nullptr;
}

/**
 * \brief: addIPToNetworkReader
 *			
 *
 */
void NetworkReader::addIPToNetworkReader(const PacketAddress* pPacketAddress)
{
	WLock wlock(_mutexToAddRemove);
	///@TODO: create socket here 
	_addIPs.push_back(pPacketAddress);
	_updateIPVector = true;
}

/**
 * \brief: removeIPFromNetworkReader
 *			
 *
 */
 ///@TODO: move this function to the Line. As someone might try to log something here
void NetworkReader::removeIPFromNetworkReader(const PacketAddress* pPacketAddress)
{
	WLock wlock(_mutexToAddRemove);
	///@TODO: create socket here 
	_removeIPs.push_back(pPacketAddress);
	_updateIPVector = true;
}

/**
 * \brief: networkReaderLoop 	
 * 			Read all the active IPs 	
 */
void NetworkReader::networkReaderLoop()
{
	//Read ech of the packet from all the registered lines
	logMessage(INFO, "Starting a Network Loop for NetworkReader [ %s : %p ] in LIVE_PLAYBACK mode", _name, this);

	std::unordered_map<int32_t, const PacketAddress *> socketfdMap;
	fd_set rfds;
	struct timespec ts = {.tv_sec = 1, .tv_nsec = 1000};
	struct timespec tv = {.tv_sec = 1, .tv_nsec = 1000};
	int32_t nfds = -1;

	while(_thread->isActive())
	{
		if(_updateIPVector)
		{
		 	//Add and remove the sockets that are modified
			updateIPVector();

			FD_ZERO(&rfds);
			nfds = -1;
			for(auto itr: _ipReadVector)
			{
				int32_t fd = itr->socket().socketfd();
				FD_SET(fd, &rfds);
				if(fd > nfds)
				{
					nfds = fd;
				}
			}
			nfds = nfds + 1;
		}

		fd_set temprfds = rfds;
		int retval = pselect(nfds, &temprfds, NULL, NULL, &ts, NULL);
		//int retval = select(nfds, &temprfds, NULL, NULL, &tv);
		
		if(retval > 0)
		{
			for(auto itr: _ipReadVector)
			{
				///@TODO: improve this routine with one of polling/select method.
				//Read socket and publish it to the LineGroup 
				if(FD_ISSET(itr->socket().socketfd(), &temprfds))
				{
					Packet *packet = itr->pPacketQueue()->push();
					if(packet)
					{
						packet->setPacketDataLen(itr->socket().readSocket(packet->packetData(), PACKET_DATA_SIZE));
						if(packet->packetDataLen() == -1)
						{
							logMessage(WARN, "Nothing to read on sock : %s. Wrong Alarm", itr->toString().c_str()); 
						}

						packet->_packetAddress = itr;
						packet->_rt = globalClock();

						FeedHandler *fh = packet->_packetAddress->_lineGroup->_feedHandler;
						Recording *recording = fh->_recording;
						if(recording)
						{
							std::shared_ptr<Packet> rpacket= _recordQueue->pushPtr();
							if(rpacket)
							{
								rpacket->_packetAddress = packet->_packetAddress;
								rpacket->_rt = packet->_rt;
								memcpy(rpacket->packetData(), packet->packetData(), packet->packetDataLen());
								rpacket->setPacketDataLen(packet->packetDataLen());
							}
							else
							{
								logMessage(EXCEPTION, "For FeedHandler [ %s : %p ], NetworkReader [ %s : %p ]  recordQueue is full", fh->_name, fh, this->_name, this); 
							}
						}
						packet->pushDeleter();
					}
					else
					{
						logMessage(WARN, "Network write queue for sock : %s is full", itr->toString().c_str()); 
					}
					//Packet is completely writen in the queue 
					//with the deleter specefied in return of pushPtr
					//Packet will be read by lineGroup via queue
				}
			}
		}
		else if(retval < 0)	
		{
			logMessage(TRACE, "select Error in reading, ERROR ID : %d!!!!!", retval);
		}
	}
	logMessage(DEBUG, "NetworkReader [ %s : %p ] thread is stopping now", _name, this);
	_thread->stop();
}

void NetworkReader::networkReaderLoopFile()
{
	//Read ech of the packet from all the registered feedHandlers recording files
	logMessage(INFO, "Starting a Network Loop for NetworkReader [ %s : %p ] in FILE_PLAYBACK mode", _name, this);

	fd_set rfds;

	while(_thread->isActive())
	{
		if(_updateIPVector)
		{
			//Add and remove the sockets that are modified
			updateIPVector();
		}

		int32_t result = 0;
		auto itr = _feedStreams.begin();
		for( ; itr != _feedStreams.end(); itr++)
		{
			result = readPacket(itr->second.front());

			// some error has occured, Please stop
			if(result)
			{
				break;
			}
		}

		if(result)
		{
			//Erase first recording stream and try to get Try to read the next recording.
			std::vector<Recording *>::iterator streamItr = itr->second.begin();
			Recording *rec = *streamItr;
			logMessage(INFO, "NetworkReader [ %s : %p ] will stop reading from recording %s for FeedHandler[%s : %p], Reason code: %d", _name, this, rec->_filename.c_str(), rec->_feedHandler->_name, rec->_feedHandler, result);
			itr->second.erase(streamItr);

			// If no more recording availabale for feed 
			// delete the feed from the map and signal feed to stop now 
			if(itr->second.empty())
			{
				_feedStreams.erase(itr);
				if(_feedStreams.empty())
				{
					// No recording to read signal to stop app
					_stopApp = true;
					_appInstance->stopApp();
				}
			}
			// no more operations on itr as it _feedStreams modified now
		}
	}
	logMessage(DEBUG, "NetworkReader [ %s : %p ] thread is stopping now", _name, this);
	_thread->stop();
}

/**
 * readPacket: Reads the next packet from the recording stream
 * return: if recording ends returns -1
 *			if packet is allowed to publish according to playback mode, then returns
 *			packet with the length
 */
int32_t NetworkReader::readPacket(Recording *recording)
{
	std::string line; 
	streampos currentPos = recording->_in->tellg();

	if(getline(*recording->_in, line))
	{
		if(line.compare(0, 24, CLARICE_HEADER))
		{
			logMessage(EXCEPTION, "FeedHandler [ %s : %p ] Corrupt Recording %s. Will move to next recording", recording->_feedHandler->_name, recording->_feedHandler, recording->_filename.c_str());
			return RECORDING_CORRUPT;
		}
		else
		{
			char data[PACKET_DATA_SIZE];

			vector<string> fields = tokenize(line, ",");
			if(fields.size() < 4)
			{
				fprintf(stderr, "FeedHandler [ %s : %p ] Recording %s : Few fields on the line : %s", recording->_feedHandler->_name, recording->_feedHandler, recording->_filename.c_str(), line.c_str());
				return RECORDING_CORRUPT;
			}

			int length = atoi(fields[LENGTH].c_str());
			int headerLength = fields[HEADER].size() + fields[TIME].size() + fields[IP_PORT].size() + fields[LENGTH].size() + 4;

			uint32_t dataLength = line.size() - headerLength;
			memcpy(data, line.c_str() + headerLength, dataLength);

			while(length > dataLength)
			{
				memcpy(data + dataLength, "\n", 1);
				dataLength++;

				// Next line does not start with CLARICE_HEADER, just write whole line
				std::string lineWithoutHeader;
				if(getline(*recording->_in, lineWithoutHeader))
				{
					memcpy(data + dataLength, lineWithoutHeader.c_str(), lineWithoutHeader.size());
					dataLength += lineWithoutHeader.size();
				}
				else
				{
					fprintf(stderr, "FeedHandler [ %s : %p ] Recording %s : Could not get line without header", recording->_feedHandler->_name, recording->_feedHandler, recording->_filename.c_str());
					return RECORDING_FINISHED_ABNORMALLY;
				}
			}

			if(length != dataLength || length < 0)
			{
				return RECORDING_CORRUPT;
			}

			std:string header = fields[HEADER] + ","+ fields[TIME] + "," + fields[IP_PORT] + "," + fields[LENGTH] + ",";
			if(recording->_reRecord)
			{
				recording->_reRecord->write(header.c_str(), header.size());
				recording->_reRecord->write(data, dataLength);
				recording->_reRecord->write("\n", 1);
			}

			auto packetAddrItr = _ipReadVector.begin();
			for( ; packetAddrItr != _ipReadVector.end(); packetAddrItr++)
			{
				if(static_cast<const IP *>(*packetAddrItr)->toString() == fields[IP_PORT])
				{
					break;
				}
			}

			if(packetAddrItr != _ipReadVector.end())
			{
				const PacketAddress *packetAddr = *packetAddrItr;
				
				// Always spin below for now, as we can not seek back in the recording currently
				Packet *packet = packetAddr->pPacketQueue()->pushSpin();

				if(packet)
				{
					memcpy(packet->packetData(), data, dataLength);
					packet->setPacketDataLen(dataLength);
					if(packet->packetDataLen() == -1)
					{
						logMessage(INFO, "FeedHandler [ %s : %p ] Nothing to read in the packet in recording %s. Empty packet recorded", recording->_feedHandler->_name, recording->_feedHandler, recording->_filename.c_str()); 
					}

					packet->_packetAddress = packetAddr;
					packet->_recordTime.tv_sec = atoll(fields[TIME].c_str());
					packet->_recordTime.tv_nsec = 0;
					uint32_t index = fields[TIME].find_first_of('.');
					if ( index < fields[TIME].size())
					{
						packet->_recordTime.tv_nsec = atoll(fields[TIME].c_str() + index +1 ) * 1000;
					}
					packet->_rt = globalClock();
				
					FeedHandler *fh = packetAddr->_lineGroup->_feedHandler;
					Recording *recording = fh->_recording;
					if(recording)
					{
						Packet *rpacket = _recordQueue->pushSpin();
						if(rpacket)
						{
								rpacket->_packetAddress = packet->_packetAddress;
								//rpacket->_rt = packet->_rt;
								rpacket->_rt.tv_sec = atoll(fields[TIME].c_str());
								rpacket->_rt.tv_nsec = 0;
								uint32_t index = fields[TIME].find_first_of('.');
								if ( index < fields[TIME].size())
								{
									rpacket->_rt.tv_nsec = atoll(fields[TIME].c_str() + index +1 );
								}
								memcpy(rpacket->packetData(), packet->packetData(), packet->packetDataLen());
								rpacket->setPacketDataLen(packet->packetDataLen());
						}
						else
						{
							uint64_t count = recording->_in->gcount();
							// seeking back in the files somehow is not working. anyways not needed as its a file mode
							ASSERT(false, "seeking back in the files somehow is not working.");
							// Going back into the recording file stream so that next time same packet is read
							recording->_in->seekg(currentPos);
							logMessage(EXCEPTION, "For FeedHandler [ %s : %p ], NetworkReader [ %s : %p ]  recordQueue is full. Prev gcount : %llu, Curr gcount %llu, Recording stream is good : %d", fh->_name, fh, this->_name, this, count, recording->_in->gcount(), recording->_in->good()); 
						}
					}
					packet->pushDeleter();
				}
				else
				{
					uint64_t count = recording->_in->gcount();
					// seeking back in the files somehow is not working. anyways not needed as its a file mode
					ASSERT(false, "seeking back in the files somehow is not working.");
					// Going back into the recording file stream so that next time same packet is read
					recording->_in->seekg(currentPos);
					logMessage(EXCEPTION, "For FeedHandler [ %s : %p ], NetworkReader [ %s : %p ] PacketQueue is full for LineGroup [ %s : %p ] in FILE_PLAYBACK mode. Prev gcount : %llu, Curr gcount %llu, Recording stream is good : %d", recording->_feedHandler->_name, recording->_feedHandler, this->_name, this, packetAddr->_lineGroup->_name, packetAddr->_lineGroup, count, recording->_in->gcount(), recording->_in->good()); 
				}
			}
			else
			{
				logMessage(DEBUG, "For FeedHandler [ %s : %p ], No such IP address %s present, Recording: %s", recording->_feedHandler->_name, recording->_feedHandler, fields[IP_PORT].c_str(), recording->_filename.c_str());
			}
		}
		return SUCCESS;
	}
	else
	{
		return RECORDING_FINISHED;
	}
}

/**
 * \brief: updateIPVector
 *			
 * @algo: 
 *		1> Add IPs from _addIPs into _ipReadVector
 *		2> clear _addIPs
 *		3> Remove IPs those IPs from _ipReadVector which are also present in _removeIPs 
 *		4> clear _removeIPs
 *		5> clear _updateIPVector as _ipReadVector is updated now
 */
void NetworkReader::updateIPVector()
{
	WLock lock(_mutexToAddRemove);

	for(auto itr: _addIPs)
	{
		//Check if ip is already present in the vector. If yes, Please raise an exception	
		bool found = false;
			
		for(auto readVectorElement: _ipReadVector)
		{
			if(readVectorElement == itr)
			{
				found = true;
				break;
			}
		}
		
		if(found)
		{
			logMessage(EXCEPTION, "IP [ %s ] is already present", itr->toString().c_str());
		}
		else
		{
			logConsole(DEBUG, "Added IP [ %s ] to the network reader [ %s : %p ]", itr->toString().c_str(), _name, this);
			new ((void *)&itr->socket()) Socket(itr, itr->type());
			_ipReadVector.push_back(itr);
		}
	}
	_addIPs.clear();

	for(auto itr: _removeIPs)
	{
		//Check if ip is already present in the vector. If yes, Please raise an exception	
		bool erased = false;
		auto readVectorItr = _ipReadVector.begin();
		auto readVectorEnd = _ipReadVector.end();

		for(; readVectorItr != readVectorEnd; ++readVectorItr)
		{
			if(*readVectorItr == itr)
			{
				_ipReadVector.erase(readVectorItr);
				logMessage(DEBUG, "Removed IP [ %s ] from NetworkReader [ %s : %p ]", itr->toString().c_str(), _name, this);
				erased = true;
				break;
			}
		}

		if(!erased)
		{
			logMessage(EXCEPTION, "Could not remove IP [ %s ]. NetworkReader [ %s : %p ] was not listening to this IP", itr->toString().c_str(), _name, this);
		}
	}
	_removeIPs.clear();
	_updateIPVector = false;
}

Recording::Recording(const FeedHandler *feed, const std::string &filename, bool write)
	: _in(write? nullptr: new igzstream())
	, _out(write? new ogzstream() : nullptr)
	, _filename(filename)
	, _feedHandler(feed)
	, _reRecord((feed->_reRecord && !write)? new ogzstream() : nullptr)
{
	if(write)
	{
		_out->open(filename.c_str(), ios::out);

		if(!_out->good() )
		{
			///< Throw an error exception duplicate reader name 
			char errorBuff[512];
			snprintf(errorBuff, sizeof(errorBuff), "For FeedHandler [ %s : %p ], could not open playback file %s in write mode, Please check if path exists and have permission to write", _feedHandler->_name, _feedHandler, _filename.c_str());

			std::string error(errorBuff);
			throw std::invalid_argument(error);
		}
	}
	else
	{
		_in->open(filename.c_str(), ios::in);

		if(!_in->good() )
		{
			///< Throw an error exception duplicate reader name 
			char errorBuff[512];
			snprintf(errorBuff, sizeof(errorBuff), "For FeedHandler [ %s : %p ], could not open playback file %s in read mode, Please check if file exists and have permission to read", _feedHandler->_name, _feedHandler, _filename.c_str());

			std::string error(errorBuff);
			throw std::invalid_argument(error);
		}

		if(_reRecord)
		{
			_reRecord->open((filename+".re-record").c_str(), ios::out);
			if(!_reRecord->good() )
			{
				///< Throw an error exception duplicate reader name 
				char errorBuff[512];
				snprintf(errorBuff, sizeof(errorBuff), "For FeedHandler [ %s : %p ], could not open playback file %s in write mode, Please check if file exists and have permission to write", _feedHandler->_name, _feedHandler, (_filename + "re-record").c_str());
				std::string error(errorBuff);
				throw std::invalid_argument(error);
			}

		}
		logConsole(INFO, "For FeedHandler [ %s : %p ] Reading packets from playback file %s in read mode", _feedHandler->_name, _feedHandler, _filename.c_str());
	}
}

Recording::~Recording()
{
// Do not implement the function. It closes the file handles
//	_in->close();
//	delete _in;
}


**************FILE************ ./source/0.9.0.0/base/Recorder.h
#ifndef __RECORDER_H__
#define __RECORDER_H__

#include <map>
#include "infra/thread/Thread.h"
#include "base/BaseCommon.h"
#include "base/Packet.h"

using namespace infra;

namespace base
{
	class Recorder
	{
		public:
			Recorder(const MarketDataApplication *app, const pugi::xml_node &node);
			~Recorder();
			void registerFeed();
			static void* _start(void *);
			void start();
			void stop();
			void* recorderLoop();
			BoostSPSCQueue<Packet>* registerNetworkReader(const NetworkReader *nr);

			const MarketDataApplication *_appInstance;
			const char _name[NAME_SIZE];
			Thread *_thread;

		private:
			std::vector<std::pair<const NetworkReader*, BoostSPSCQueue<Packet> *> > _recordQueues;
	};
}

#endif //__RECORDER_H__
**************FILE************ ./source/0.9.0.0/base/Subscription.h
#ifndef __SUBSCRIPTION_H__
#define __SUBSCRIPTION_H__

#include <atomic>
#include "base/Book.h" 
#include "base/Quote.h" 
#include "base/Trade.h" 
#include "base/Status.h" 

namespace base
{
	const char * InstrStateToString(InstrState state);

	class Subscription
	{
		public:
			Subscription(const uint64_t symbolID, bool activate);
			Subscription(const char *symbol, bool activate);
			//bool hasInterest(CallBacks callback) const;

			//@TODO: take look if needed atomic
			std::atomic<bool>	_isActive;
			char				_symbol[NAME_SIZE];
			uint64_t			_symbolID;
			char				_isin[13];

			//Atomic so that wrong callback is not raised
			//and could be overide by main thread subscribe
			ProductInfo	*_prodInfo;
			Status _status;
			Trade _trade;
			Quote _quote;	
			Book _book;
	};
}

#endif// __SUBSCRIPTION_H__
**************FILE************ ./source/0.9.0.0/base/LineGroup.h
#ifndef __CONNECTION_H__
#define __CONNECTION_H__

#include <map>
#include <unordered_map>

#include "base/BaseCommon.h"
#include "infra/InfraCommon.h"
#include "infra/containers/spsc/BoostSPSCQueue.h"

using namespace infra;

namespace base
{
	typedef Line* (*LineConstructor)(const base::MarketDataApplication *, FeedHandler *, LineGroup *, Thread *, const pugi::xml_node&, LineAPI *);
	class LineGroup
	{
		public:
			LineGroup(const MarketDataApplication *app, FeedHandler *feedHandler, const pugi::xml_node & lineGroupNode, LineConstructor lineConstructor, LineGroupAPI *lineGroupAPI);
			void registerCallbacks(CallBacks );
			NetworkReader *networkReader() const;
			Subscription* getIdSub(uint64_t);
			void start();
			void stop();
			void printLatency(const Thread *, const char *latencyType, const uint64_t *arr) const;
			void printStats(const Thread *) const;
			static void* _start(void *); 		///< calls lineGroupLoop 
			void lineGroupLoop(); 				///< main loop

			const char _name[NAME_SIZE];						// Name of the Line group

			BoostSPSCQueue<Packet> *packetQueue() const
			{
				return _packetQueue;
			}

			const FeedHandler* feedHandler() const {return _feedHandler;}
			FeedHandler *_feedHandler;				// Feed manager pointer
			Thread *_thread;

#if defined(__LATENCY__)
			uint64_t _rl[LATENCY_SIZE]; // recieve latency from packet read to callback
			uint64_t _ml[LATENCY_SIZE]; // message processing to callback fire latency
			uint64_t _readLatency[LATENCY_SIZE]; // Time took to detect read packet availibility 
			uint64_t _ql[LATENCY_SIZE]; // avrage read latency of net reader q 
			uint64_t _sf[LATENCY_SIZE]; // Subscription finding latency 
			uint64_t _om[LATENCY_SIZE]; // order map latency 
			uint64_t _op[LATENCY_SIZE]; // order pool latency 
#endif // __LATENCY__

			timespec		_mt; // message time
			const MarketDataApplication	*_appInstance;			// App instance pointer
			
		private:
			void createLines(const pugi::xml_node &configNode);	


			typedef std::map<std::string, Line *> NameToLineMap; 
			NameToLineMap _lineMap;			// name to line map

			NetworkReader *_networkReader;	// Network reader to which all lines of group belong

			BoostSPSCQueue<Packet>  *_packetQueue; 
			LineConstructor _lineConstructor;

			std::unordered_map<uint64_t, Subscription *> _idSubMap;
			std::map<char *, Subscription *> _symbolSubMap;

			LineGroupAPI *_lineGroupAPI;
	};
}
#endif //__CONNECTION_H__
**************FILE************ ./source/0.9.0.0/base/Line.h
#ifndef __LINE_H__
#define __LINE_H__

#include <arpa/inet.h>
#include <map>
#include <unordered_map>

#include "infra/containers/spsc/BoostSPSCQueue.h"
#include "infra/socket/Socket.h"
#include "base/BaseCommon.h"
#include "infra/InfraCommon.h"

using namespace infra;

namespace base
{
	enum ReturnValue
	{
		PROCESSED = 0,
		NOT_PROCESSED = -1
	};

	enum class LineState
	{
		JUST_STARTED,	// Intraday or morning start
		SNAPPING,		// Snapping becuase of intraday 
		NORMAL,			// Properly snapped
		GAPPED,			// It is gapped currently
	};

	enum class ContentType 
	{
		HB,
		DATA_PACKET,
	};

	class SeqRange
	{
		public:
		bool operator < (const SeqRange &rhs) const
		{
			return _headerSeqNo < rhs._headerSeqNo; 
		}

			SeqRange(uint64_t head, uint64_t end)
			: _headerSeqNo(head)
			, _endSeqNo(end)
			{
			}

			uint64_t _headerSeqNo;
			uint64_t _endSeqNo;
	};

	typedef void (Line::*NativFunc)();	
	class MessageFunc
	{
		public: 
		MessageFunc()
		: _nativFunc(nullptr)
		, _couldAssign(false)
		, _size(0)
		, _idOffset(0)
		, _callbacks(NO_CALLBACK)
		{
		}
		
		MessageFunc(NativFunc func, bool assign, uint16_t size, uint16_t offset, CallBacks callbacks)
		: _nativFunc(func)
		, _couldAssign(assign)
		, _size(size)
		, _idOffset(offset)
		, _callbacks(callbacks)
		{
		}

		NativFunc	_nativFunc;
		bool		_couldAssign;
		uint16_t	_size;
		uint16_t	_idOffset;
		uint32_t	_callbacks;
	};

	const char *getChannelString(ChannelType type);

	class IP : public sockaddr_in 
	{
		public:
			IP();
			static const char *IPString[24];	
			const std::string toString() const;
			bool operator < (const IP &rhs) const;
			bool operator == (const IP &rhs) const;
			bool operator != (const IP &rhs) const;
			
			static IP getParsedIPPort(const MarketDataApplication *_appInstance, const pugi::xml_node &node, const char *ipType, const std::string ipString);
			static IP getParsedIPPort(const MarketDataApplication *_appInstance, const pugi::xml_node &lineNode, const char *ipType);

			int32_t type() const
			{
				return _type;
			}

		private:
			int32_t _type;
	};

	class PacketAddress : public IP
	{
		public:
			PacketAddress();
			PacketAddress(const IP& ip, IPType ipType, ChannelType channelType, const Line *line, const LineGroup *lineGroup);
			
			using IP::operator ==;

			const std::string toString() const;
			BoostSPSCQueue<Packet> *pPacketQueue() const;
			Socket& socket() const;

			const Line *_pLine;
			const LineGroup *_lineGroup;
			IPType _ipType;
			ChannelType _channelType;
			BoostSPSCQueue<Packet>  *_pPacketQueue; 
			Socket	_socket;
	};

    class Line
    {
		public:

			typedef void (Line::*Start)();
			typedef void (Line::*GetPackStats)();
			typedef void (Line::*ProcessPacket)();
			typedef void (Line::*GetPackStatsSnap)();
			typedef bool (Line::*ReRequestMissedPackets)(uint64_t, uint64_t);

			Line(const MarketDataApplication *, FeedHandler *, LineGroup *, Thread *thread, const pugi::xml_node &, LineAPI *, Start, ProcessPacket processFunc, GetPackStats, GetPackStatsSnap, ReRequestMissedPackets);

            const char _name[NAME_SIZE];
			
			int32_t process();
			const ProcessPacket _processPacket;
			void reset();
			void insert(uint64_t orderID, Order *order);
			Order* find(uint64_t orderID) const;
			void erase(uint64_t orderID) const;
			void printStats() const;
			
			// Related with the sequencing of the packet
			Packet *_packet; // This is packet to be procesed
			uint64_t	_lastSeqNo;		//Last processed seq no
			uint64_t	_headerSeqNo;	//Seq no of first msg Or if HB packet this is next expected
			uint64_t	_endSeqNo;		//Seq no of last msg Or if HB then _endSeqNo = _headerSq-1
			uint64_t	_gapRequestedTill; //Seq no of last re-requesetd gap message 
			const char  *_currentMsg;	//Points to current msg to be processed within _packetData
			bool _snapshotEnabled;
			bool _isSnapStarted;	// We have recieved the start of snapshot
			bool _isSnapshotEnd;	// We have recieved the end of snapshot
			uint64_t _snapshotSyncNo; // To this seq no from the mainline we are synced.
			LineState	_lineState; // Is it just started[to be snapped], normal[snapped], gapped
			ContentType	_contentType; // It is data packet or just HB
			uint32_t _xtSecs;		// Commong msg exchange epoch in packet header or time msg
			uint32_t _xtNanoSecs;	// Commong msg exchange nano sec part from nano seconds time msg
			MessageFunc parseFuncMap[256];// = {{nullptr, false, 0}};

			void start();
			void printStats(const Thread *_thread) const;
			Subscription* getIdSub32(uint16_t offset);
			
			const MarketDataApplication	*_appInstance;			
			FeedHandler *_feedHandler;
			LineGroup *_lineGroup;
			const Thread *_thread;	
			PriceLevelPool *_priceLevelPool;//pool for allocating price levels
			OrderPool *_orderPool; // order object pool
			bool _maintainOrders;

			void registerCallbacks(CallBacks );
			bool hasInterest(CallBacks callback) const;
			bool hasStrictInterest(CallBacks callback) const;
			LineAPI *_lineAPI;

		protected:
			Subscription *_sub;
		
		private:
			void createLineIPs(const pugi::xml_node &lineNode);
			
			int32_t processMainLinePacket();
			int32_t processSnapshotPacket();

			void processPacket();
			void reRequestMissedPacket();
			int32_t addToGapCache();
			void processGapCache();
			void processSnapCache();
			void reRequestSnap();
			int32_t addToSnapCache();
			int32_t addToCache(std::map<SeqRange, Packet *> &_cache);
			void clearGapCache();
			void clearSnapCache();

			PacketAddress _IPs[static_cast<int>(IPType::IPTYPE_MAX)];

			GetPackStats _nativGetPacketStats;
			GetPackStatsSnap _nativGetPacketStatsSnap;
			ReRequestMissedPackets _nativReRequestMissedPackets;
			Start _nativStart;

			//This must be map of the shared_ptr and these Packets could
			//be assigned to the assigner thread. 
			std::map<SeqRange, Packet *> _snapCache;
			std::map<SeqRange, Packet *> _gapCache;

			std::unordered_map<uint64_t, Order*> *_orderMap; // order object map 
			CallBacks _callbacks;
    };
}

#endif //__LINE_H__
**************FILE************ ./source/0.9.0.0/base/Status.h
#ifndef __STATUS_H__
#define __STATUS_H__

#include <stdint.h>
#include "base/BaseCommon.h"
#include "base/Base.h"

namespace base
{
	enum class InstrState : uint8_t
	{
		UNKNOWN	= 0,
		PREOPEN	= 1,
		OPEN	= 2,
		AUCTION	= 3,
		AUCTION_OPEN	= 4,
		AUCTION_INTRA	= 5,
		AUCTION_VOLA	= 6,
		AUCTION_CLOSE	= 7,
		HALTED		= 8,
		CLOSED		= 9,
		SUSPENDED	= 10,
		// Add new case for new state below in StateToCStr function
	};

	class Status: public Base
	{
		public:
			Status(Subscription *sub);
			
			void update(Line *, Subscription *, uint32_t, uint64_t, uint32_t, uint32_t, InstrState);

			static const char* StateToCStr(InstrState state);

			//_prev state must come before the _state as constructor assumes
			// order of declaration in initializer list
			InstrState _prevState;
			InstrState _state;
	};
}

#include "base/Subscription.h"
#include "base/Line.h"
#include "base/API.h"

using namespace base;

inline Status::Status(Subscription *sub)
	: Base(sub, STATUS_UPDATE)
	, _state(InstrState::UNKNOWN) 
	, _prevState(InstrState::UNKNOWN)
{
}

inline void Status::update(Line *line, Subscription *sub, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, InstrState state)
{
	Base::update(line, msgType, seqNo, exSeconds, exUSeconds);
	_prevState = _state;
	_state = state;
	LineAPI *api = _line->_lineAPI;
	(api->*(api->_onStatus))(this);
}
#endif //__STATUS_H__
**************FILE************ ./source/0.9.0.0/base/ReferenceFileReader.cpp
#include "moReader.h"



**************FILE************ ./source/0.9.0.0/base/LineGroup.cpp
#include "pool/object_pool.hpp"

#include "infra/logger/Logger.h"
#include "base/MarketDataApplication.h"
#include "base/FeedHandler.h"
#include "base/LineGroup.h"
#include "base/NetworkReader.h"
#include "base/API.h"
#include "base/Subscription.h"
#include "base/Line.h"
#include "base/Packet.h"


using namespace base;
using namespace infra;

LineGroup::LineGroup(const MarketDataApplication *app, FeedHandler *feedHandler, const pugi::xml_node &lineGroupNode, LineConstructor lineConstructor, LineGroupAPI *lineGroupAPI)
	: _lineGroupAPI(lineGroupAPI)
	, _appInstance(app)
	, _feedHandler(feedHandler)
	, _thread(nullptr)
	, _packetQueue(new BoostSPSCQueue<Packet>())
	, _lineConstructor(lineConstructor)
	, _name()
	, _networkReader(app->getNetworkReader(lineGroupNode.getAttributeAsCString("network-reader", "", true, ""), lineGroupNode))
{
	strncpy(const_cast<char *>(_name), lineGroupNode.getAttributeAsCString("name", "", false, ""), sizeof(_name));
	_thread = new Thread(_appInstance, lineGroupNode, _name, this, LineGroup::_start);	

	createLines(lineGroupNode);
	
	_networkReader->registerLineGroup(this);
}

void LineGroup::registerCallbacks(CallBacks callbacks)
{
	NameToLineMap::iterator itr = _lineMap.begin();

	for( ; itr != _lineMap.end(); itr++)
	{
		itr->second->registerCallbacks(callbacks);		
	}
}

/*
 * \brief: networkReader
 *			returns the NetworkReader
 */
NetworkReader *LineGroup::networkReader() const
{
	return _networkReader;
}

/**
 *	\brief: createLines
 *			Creates all Lines under for LineGroup. 
 */
void LineGroup::createLines(const pugi::xml_node &lineGroupNode)
{
	pugi::xml_node lines = lineGroupNode.child("Lines");
	if(lines)
	{
		for (pugi::xml_node_iterator it = lines.begin(); it != lines.end(); ++it)
		{
			pugi::xml_node lineNode = *it;
			std::string nameOfChildNode = lineNode.name();
			if(nameOfChildNode == "Line")
			{
				std::string lineName = lineNode.getAttributeAsString("name", "", false, "");
			
				const NameToLineMap::iterator itr = _lineMap.find(lineName);
				if(itr == _lineMap.end())
				{
					Line *pLine = _lineConstructor(_appInstance, _feedHandler, this, _thread, lineNode, _lineGroupAPI);
					_lineMap.insert(std::make_pair(lineName, pLine));
					logConsole(DEBUG, "Inserted line [ %s : %p ] into map", lineName.c_str(), pLine);
				}
				else
				{
					///< Throw an error exception duplicate line name 
					char errorBuff[512];
					
					snprintf(errorBuff, sizeof(errorBuff), "Duplicate Line Name found in config. Line is already present %s : %p into map", lineName.c_str(), itr->second);
					std::string error(errorBuff);

					throw std::invalid_argument(error);
				}
			}
			else
			{
				///< Unintended node specified in the config file, raise exception log 
				logConsole(WARN, "<Lines> config node has unexpected child node <%s>", nameOfChildNode.c_str());
			}
		}
	}
}

/*
 *	Get the symbol subscription which must be active and has _prodInfo
 *	Otherwise return null
 */
Subscription* LineGroup::getIdSub(uint64_t symbolID)
{
	Subscription *sub = nullptr;
	auto itr = _idSubMap.find(symbolID);

	//Got the subscription and it is activ one
	if(itr != _idSubMap.end())
	{
		sub = itr->second;
	}
	else
	{
		sub = _feedHandler->getIdSub(symbolID);
		_idSubMap.insert(make_pair(symbolID, sub));	
	}
	
	ASSERT(sub->_prodInfo != nullptr, "sub->_prodInfo : " << sub->_prodInfo);

	if(sub->_isActive && sub->_prodInfo)
	{
		return sub;
	}
	else
	{
		return nullptr;
	}
}

/**
 * Starts the actual OS thread instance
 */
void LineGroup::start()
{
	_thread->start();
	return;
}

/**
 * Stops actual OS thread instance
 */
void LineGroup::stop()
{
	_thread->signalToStop();

	while(!_thread->isStopped());

	logConsole(INFO, "LineGroup [ %s : %p ] is stopped", _name, this);
	return;
}


void LineGroup::printLatency(const Thread *_thread, const char *latencyType, const uint64_t *arr) const
{
	uint64_t total = 0;
	for(int i = 0; i < LATENCY_SIZE ; i++)
	{
		total += arr[i];	
	}

	if(!total)
	{
		total = 1;
	}

	uint64_t cumSum = 0;
	uint64_t step = 0;
	for(int i = 0; i < LATENCY_SIZE ; i++)
	{
		cumSum += arr[i];
		uint64_t  perctentile = (cumSum * 100)/ total;
		if(perctentile >= step)
		{
			logMessage(INFO, "LineGroup [ %s : %p ]: %lu %s latency : %d] %lu [ %lu, %lu / %lu]", _name, this, total, latencyType, i, perctentile, arr[i], cumSum, total);
			if(step >= 90 && step < 99)
			{
				step += 1;
			}
			else
			{
				step += 10;
			}
		}
	}
}

/**
 *	\brief: printStats 
 *		print stats of all the underlying lines
 */
void LineGroup::printStats(const Thread *_thread) const
{
	logMessage(INFO, "LineGroup [ %s : %p ] stats", _name, this);
#if defined(__QWRITEREAD_LATENCY__)
	printLatency(_thread, "Queue Write Read", _ql);
#endif 

#if defined(__NEXTREAD_LATENCY__)
	printLatency(_thread, "Next Read", _readLatency);
#endif 

#if defined(__MSG_LATENCY__)
	printLatency(_thread, "Message Processing", _ml);
#endif 

#if defined(__PACKET_LATENCY__)
	printLatency(_thread, "Net Packet to Callback Raise", _rl);
#endif 

#if defined(__SUBMAP_LATENCY__)
	printLatency(_thread, "Subscription find Latency", _sf);
#endif 

#if defined(__ORDERMAP_LATENCY__)
	printLatency(_thread, "Order Map Latency", _om);
#endif 

#if defined(__ORDERPOOL_LATENCY__)
	printLatency(_thread, "Order Pool Latency", _op);
#endif 
}

/**
 * Calls the processing function
 */
void* LineGroup::_start(void *obj)
{
	static_cast<LineGroup *>(obj)->lineGroupLoop();
	return nullptr;
}

/**
 * \brief: lineGroupLoop
 * 		Reads all the queues belonging to IPs of this lines belonging to this LineGroup
 *
 */
void LineGroup::lineGroupLoop()
{
	logMessage(INFO, "Started LineGroup [ %s : %p ]", _name, this);
	for(auto itr : _lineMap)
	{
		itr.second->start();
	}

	(_lineGroupAPI->*(_lineGroupAPI->_onLineGroupStarted))(this);

	timespec lastReadTime = globalClock();
	while(_thread->isActive())
	{
		Packet *readPtr = _packetQueue->pop();
		timespec ct = globalClock();
		if(readPtr)
		{
			Line *pLine = const_cast<Line *>(readPtr->_packetAddress->_pLine);
			pLine->_packet = readPtr;

			{
#if defined(__QWRITEREAD_LATENCY__)
				timespec rt = readPtr->_rt;
				uint64_t timeDiff = ((ct.tv_sec - rt.tv_sec) * 1000000000) + ct.tv_nsec - rt.tv_nsec; 

				if(timeDiff >= LATENCY_SIZE) 
				{
					timeDiff = LATENCY_SIZE - 1;
				} 
				++_ql[timeDiff];
#endif

#if defined(__NEXTREAD_LATENCY__)
				timeDiff = ((ct.tv_sec - lastReadTime.tv_sec) * 1000000000) + ct.tv_nsec - lastReadTime.tv_nsec; 
				if(timeDiff >= LATENCY_SIZE) 
				{
					timeDiff = LATENCY_SIZE - 1;
				} 
				++_readLatency[timeDiff];
#endif
			}

			int32_t retVal = pLine->process();
			pLine->_packet = nullptr;
			lastReadTime = globalClock();
			if(!retVal)
			{
			readPtr->popDeleter();
		}
		}
		else
		{
			lastReadTime = globalClock();
		}
	}

	logMessage(DEBUG, "LineGroup [ %s : %p ] is stopping now", _name, this);
	_thread->stop();
}

**************FILE************ ./source/0.9.0.0/base/Message.h
#ifndef __MESSAGE_H__
#define __MESSAGE_H__

#include "base/Packet.h"

namespace base
{
	//Line -> Assigner
	// Ensure that _customData member is always alligned
	// As it is filled with meaning full structs in native feed
	#define CUSTOM_DATA_SIZE 20

	class MessageInfo
	{
		public:
			MessageInfo()
			{
				_lastSeqNo = 0;
				_xtSecs = 0;
			}

			MessageInfo(uint64_t seq, uint64_t xtSecs)
			{
				_lastSeqNo = seq;
				_xtSecs = xtSecs;
			}
			uint64_t _lastSeqNo;
			uint64_t _xtSecs;
	};


	class Message : public BoostSPSCQueueElement
	{
		public: 
		Message()
		: _packet(nullptr)
		, _func(nullptr)
		, _currentMsg(nullptr)
		, _sub(nullptr)
		, _msgInfo()
		{
		}

		Message(std::shared_ptr<Packet> &ptr, NativFunc func, const char *msg, Subscription *sub, uint64_t seq, uint64_t xtSecs)
		: _packet(ptr)
		, _func(func)
		, _currentMsg(msg)
		, _sub(sub)
		, _msgInfo(seq, xtSecs)
		{
			//@TODO: remove the zero initialization
			//memset(_customData, 0, sizeof(_customData));
			//write the custom data with placement constructor 
			// later in native process funct before coming here
		}

		// This destructor is neccesory to immediatly
		// free the packet held in the shared pointer 
		// and is called by the deleter of the SPSC queue element 
		~Message()
		{
			//@TODO: below assignement is not compulsory as it will
			//		be alway over written
			//		and could be included only in debug builds.
			//		and could be removed from release build
			_func = nullptr;
			_sub  = nullptr;
			_currentMsg = nullptr;
			// Here it will unintizlize the shared ptr message->_packet with destructor
			//Call the base BoostSPSCQueueElement destructor
		}

		std::shared_ptr<Packet> _packet;
		NativFunc				_func;
		Subscription			*_sub;
		const char 				*_currentMsg;
		MessageInfo				_msgInfo;
	};

	}
#endif // __MESSAGE_H__



**************FILE************ ./source/0.9.0.0/base/FeedHandler.cpp
#include "infra/logger/Logger.h"
#include "infra/utils/StringUtils.h"
#include "base/MarketDataApplication.h"
#include "base/BaseCommon.h"
#include "base/NetworkReader.h"
#include "base/FeedHandler.h"
#include "base/LineGroup.h"
#include "base/Subscription.h"
#include "base/ProductInfo.h"
#include "base/API.h"

using namespace base;
using namespace infra;

FeedHandler::FeedHandler(const MarketDataApplication *app, const pugi::xml_node &feedHandlerNode, FeedID feedID, LineGroupConstructor func, FeedAPI *feedAPI)
	: _feedAPI(feedAPI)
	, _feedID(feedID)
	, _name()
	, _mode(playbackMode(feedHandlerNode.getAttributeAsString("playback-mode", "", false, "file,live")))
	, _playbackFilesVector(_mode == PlaybackMode::FILE_PLAYBACK ? tokenize(feedHandlerNode.getAttributeAsString("playback-files", "", false, ""), ","): std::vector<std::string> ()) 
	, _lineGroupConstructor(func)
	, _appInstance(app)
	, _lineGroupMap()
	, _logger(nullptr)
	, _subMapMutex()	
	//@TODO: search what is this constant 255 means
	, _symbolSubMap(255)	
	, _isinSubMap(255)	
	, _prodInfoMap(255)	
	, _prodInfoMapISIN(255)	
	, _reRecord(feedHandlerNode.getAttributeAsBool("re-record", false))
	, _maintainOrders(feedHandlerNode.getAttributeAsBool("maintain-orders", false))
	, _recording(nullptr)
{
	strncpy(const_cast<char *>(_name), feedHandlerNode.getAttributeAsCString("name", "", false, ""), sizeof(_name));
	
	bool record = feedHandlerNode.getAttributeAsBool("record", false);
	if(record)
	{
		std::string location = feedHandlerNode.getAttributeAsCString("record-location", "");
		std::string fileName;

		if(!location.empty())
		{
			fileName = location + "/" + std::string(_name) + ".cl.gz"; 
		}
		else
		{
			fileName = std::string(_name) + ".cl.gz"; 
		}

		_recording = new Recording(this, fileName, true);
	}

	///< create the LineGroups under this feed
	createLineGroups(feedHandlerNode);

	//register callbacks to the line
	registerCallbacks(feedHandlerNode.getAttributeAsCString("callbacks", ""));
}
			
void FeedHandler::registerCallbacks(CallBacks callbacks)
{
	NameToLineGroupMap::iterator itr = _lineGroupMap.begin();

	for( ; itr != _lineGroupMap.end(); itr++)
	{
		itr->second->registerCallbacks(callbacks);		
	}
}

void FeedHandler::registerCallbacks(std::string updateTypes)
{
	std::vector<std::string> result = tokenize(updateTypes, ",");

	CallBacks callbacks;
	CLEAR_CALLBACKS(callbacks);
	
	for(int i = 0; i < result.size(); i++)
	{
		std::string updateType = result[i];
		SET_CALLBACK(callbacks, getCallback(updateType));
	}

	registerCallbacks(callbacks);
}

FeedHandler::~FeedHandler()
{
	//_feedID = FeedID::UNKNOWN_FEED;
	//_name[0] = '\0';
	//_mode;
	//_playbackFilesVector
	_reRecord = false;
	// _recordingMutex
	delete _recording;
	//_lineGroupConstructor
	_appInstance = nullptr;
	//@TODO: delete _lineGroupMap
	_logger = nullptr;
	_recordPlayback = false;
	//_pbLocation
	//_ipToLineGroupMap
}

/**
 *	\brief: createLineGroups
 *			Creates all Ling Groups. 
 */
void FeedHandler::createLineGroups(const pugi::xml_node &configNode)
{
	pugi::xml_node lineGroups = configNode.child("LineGroups");
	if(lineGroups)
	{
		int i = 0;
		for (pugi::xml_node_iterator it = lineGroups.begin(); it != lineGroups.end(); ++it)
		{
			pugi::xml_node lineGroupNode = *it;
			std::string nameOfChildNode = lineGroupNode.name();
			if(nameOfChildNode == "LineGroup")
			{
				++i;
				char buff[10];
				snprintf(buff, 10, "%d", i);
				std::string lineGroupName = lineGroupNode.getAttributeAsString("name", "", false , "");
			
				const NameToLineGroupMap::iterator itr = _lineGroupMap.find(lineGroupName);
				if(itr == _lineGroupMap.end())
				{
					LineGroup *lineGroup = _lineGroupConstructor(_appInstance, this, lineGroupNode, _feedAPI);
					_lineGroupMap.insert(std::make_pair(lineGroupName, lineGroup));
					logConsole(DEBUG, "Inserted lineGroup [ %s : %p ] into map", lineGroupName.c_str(), lineGroup);
				}
				else
				{
					///< Throw an error exception duplicate lineGroup name 
					char errorBuff[512];
					
					snprintf(errorBuff, sizeof(errorBuff), "Duplicate LineGroup Name found in config. LineGroup is already present %s : %p into map", lineGroupName.c_str(), itr->second);
					std::string error(errorBuff);

					throw std::invalid_argument(error);
				}
			}
			else
			{
				///< Unintended node specified in the config file, raise exception log 
				logConsole(WARN, "<LineGroups> config node has unexpected child node <%s>", nameOfChildNode.c_str());
			}
		}
	}
}

/**
 *	\brief: start
 *		starts all the underlying line group threads
 */
void FeedHandler::start(const Thread* _thread) const
{
	logMessage(INFO, "Feed Handler [ %s : %p ] is starting LineGroups ", _name, this);
	NameToLineGroupMap::const_iterator itr = _lineGroupMap.begin();
	for( ; itr != _lineGroupMap.end(); itr++)
	{
		itr->second->start();
	}
	(_feedAPI->*(_feedAPI->_onFeedStarted))(this);
	logMessage(INFO, "Feed Handler [ %s : %p ] is started", _name, this);
}

/**
 *	\brief: stop
 *		stops all the underlying line group threads
 */
void FeedHandler::stop(const Thread* _thread) const
{
	logMessage(DEBUG, "Feed Handler [ %s : %p ] is stoping", _name, this);
	NameToLineGroupMap::const_iterator itr = _lineGroupMap.begin();
	for( ; itr != _lineGroupMap.end(); itr++)
	{
		itr->second->stop();
	}
	(_feedAPI->*(_feedAPI->_onFeedStopped))(this);
	logMessage(INFO, "Feed Handler [ %s : %p ] is stopped", _name, this);
}

/**
 *	\brief: printStats 
 *		print stats of all the underlying line group threads
 */
void FeedHandler::printStats(const Thread *_thread) const
{
	logMessage(INFO, "====================================================================================");
	logMessage(INFO, "Feed Handler [ %s : %p ] stats", _name, this);
	logMessage(INFO, "====================================================================================");
	NameToLineGroupMap::const_iterator itr = _lineGroupMap.begin();
	for( ; itr != _lineGroupMap.end(); itr++)
	{
		itr->second->printStats(_thread);
	}
	logMessage(INFO, "====================================================================================");
}

/*
 * subscribe using symbol id 
 */
int32_t FeedHandler::subscribe(const uint64_t symbolID, Subscription **retSub)
{
	WLock wlock(_subMapMutex);

	auto itr = _idSubMap.find(symbolID);		

	if(itr != _idSubMap.end())
	{
		// Activate the subscription
		//"TODO: assert if subscription is already activated
		Subscription *sub = itr->second;
		sub->_isActive.store(true, std::memory_order_release);
		*retSub = sub; 
		return SUCESS;
	}

	// create the new active subscrition
	*retSub = new Subscription(symbolID, true);
	_idSubMap.insert(make_pair(symbolID, *retSub));	
	return SUCESS;
}

bool ifStringIsRegEx(const char *str)
{
	while(*str)
	{
		if(!isalnum(*str))
		{
			return true;
		}
		str++;
	}
	return false;
}

bool ifStringIsNum(const char *str)
{
	while(*str)
	{
		if(!isdigit(*str))
		{
			return false;
		}
		str++;
	}
	return true;
}

bool ifStringIsISIN(const char *str)
{
	if(strlen(str) != 12)
	{
		return false;
	}

	if(isupper(str[0]) && isupper(str[1]))
	{
		for(int i = 2; i < 11; i++)
		{
			if(!isdigit(str[i]))
			{
				return false;
			}
		}
	}
	else
	{
		return false;
	}

	return true;
}

int32_t FeedHandler::subscribe(const char *symbol, Subscription **retSub)
{
	WLock wlock(_subMapMutex);

	if(ifStringIsRegEx(symbol))
	{
		logConsole(INFO, "Subscribed regex subscription %s to FeedHandler [%s : %p] ", symbol, _name, this);
		std::regex expr = std::regex(symbol, std::regex_constants::grep);
		_regexMap.push_back(expr);
		
		judySArray<Subscription *>::pair symbolSub = _symbolSubMap.begin();
		while(symbolSub.value)
		{
			// if inactive subscription matches newly added regex 
			// activate that subscription with callbacks and subAPI
			Subscription *sub = symbolSub.value;
			if(std::regex_match(sub->_symbol, expr))
			{
				if(!sub->_isActive)
				{
					sub->_isActive.store(true, std::memory_order_release);
				}
			}
			symbolSub = _symbolSubMap.next();
		}

		auto itrIdSubMap = _idSubMap.begin();
		if(itrIdSubMap != _idSubMap.end())
		{
			// if inactive subscription matches newly added regex 
			// activate that subscription with callbacks and subAPI
			Subscription *sub = itrIdSubMap->second;
			if(std::regex_match(std::to_string(sub->_symbolID), expr))
			{
				if(!sub->_isActive)
				{
					sub->_isActive.store(true, std::memory_order_release);
				}
			}
		}

		// We just added regex 
		return REGEX_SUBSCRIPTION;
	}
	else
	{
		// Check if its a number then its a symbolID subscription
		// Check if its a isin subscription
		// then its a  normal symbol subscription

		Subscription *sub;

		if(ifStringIsNum(symbol))
		{
			uint64_t symbolID = atoll(symbol); 
			auto itr = _idSubMap.find(symbolID);
			if(itr != _idSubMap.end())
			{
				// Activate the subscription
				//"TODO: assert if subscription is already activated
				sub = itr->second;
				sub->_isActive.store(true, std::memory_order_release);
				*retSub = sub; 
				return SUCESS;
			}
		}
		else
		{
			if(ifStringIsISIN(symbol))
			{
				sub = _isinSubMap.find(symbol);
			}
			else
			{
				sub = _symbolSubMap.find(symbol);
			}
			
			if(sub)
			{
				// Activate the subscription or overide the subAPIs and callbacks
				//"TODO: assert if subscription is already activated
				sub->_isActive.store(true, std::memory_order_release);
				*retSub = sub; 
				return SUCESS;
			}
		}

		// create the new active subscrition
		*retSub = new Subscription(symbol, true);
		_symbolSubMap.insert(symbol, *retSub);	
		return SUCESS;
	}
}

/*
 *	Get the symbol subscription which must be active
 */
Subscription* FeedHandler::getIdSub(uint64_t symbolID) 
{
	// _idSubMap might get modified
	WLock wlock(_subMapMutex);
	return _getIdSub(symbolID);
}

/*
 *	Get the symbol subscription which must be active
 */
Subscription* FeedHandler::_getIdSub(uint64_t symbolID) 
{
	// _idSubMap might get modified
	auto itr = _idSubMap.find(symbolID);

	//Got the subscription and it is activ one
	if(itr != _idSubMap.end())
	{
		return itr->second; 
	}
	else
	{
		// create the new active subscrition
		ProductInfo* pInfo = _getProductInfo(nullptr, 0, symbolID, "", "", 0, 0, 0);
		Subscription *sub = pInfo->_sub;

		for(auto itr : _regexMap)
		{
			if(std::regex_match(std::to_string(symbolID), itr))
			{
				sub->_isActive.store(true, std::memory_order_release);
			}
		}

		_idSubMap.insert(make_pair(symbolID, sub));	
		return sub;
	}
}

/*
 *	Get the symbol subscription which must be active
 */
Subscription* FeedHandler::getSymbolSub(const char *symbol) 
{
	// _idSubMap might get modified
	WLock wlock(_subMapMutex);
}

Subscription* FeedHandler::_getSymbolSub(const char *symbol) 
{
	Subscription *sub = _symbolSubMap.find(symbol);

	//Got the subscription and it is activ one
	if(sub)
	{
		return sub; 
	}
	else
	{
/*
		// create the new active subscrition
		sub = new Subscription(symbol, NO_CALLBACK, nullptr, false);

		for(auto itr : _regexMap)
		{
			if(std::regex_match(symbol, itr))
			{
				sub->_isActive.store(true, std::memory_order_release);
			}
		}
		_symbolSubMap.insert(symbol, sub);	
		return sub;
*/
		return nullptr;
	}
}

FeedID FeedHandler::getFeedID(const std::string& feedHandlerType)
{
	if(feedHandlerType == "millenium")
	{
		return FeedID::MILLENIUM;	
	}
	if(feedHandlerType == "omxnordic")
	{
		return FeedID::OMXNORDIC;	
	}
	else
	{
			///@TODO: raise an exception	
	}
}

const char* FeedHandler::getFeedType(FeedID id)
{
	switch(id)
	{
		case FeedID::MILLENIUM:
			return "Millenium";

		case FeedID::OMXNORDIC:
			return "OMXNordic";

		default:
			///@TODO: raise an exception	
			{
			}
	}
}

/*
 * Gives back the pointer to the productInfo of the symbol or symbolID
 */
ProductInfo* FeedHandler::getProductInfo(Line *line, uint32_t msgType, const char* symbol, uint64_t symbolID, const char *isin, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds)
{
	// Lock for _prodInfoMap, _symbolSubMap
	WLock wlock(_subMapMutex);
	return _getProductInfo(line, msgType, symbol, symbolID, isin, seqNo, exSeconds, exUSeconds);
}

ProductInfo* FeedHandler::_getProductInfo(Line *line, uint32_t msgType, const char* symbol, uint64_t symbolID, const char *isin, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds)
{
	ProductInfo *product = _prodInfoMap.find(symbol);
	if(product)
	{
		return product;
	}
	else
	{
		Subscription *sub = getValidIdIsinSymbolSub(symbolID, symbol, isin);
		product = new ProductInfo(line, sub, msgType, seqNo, exSeconds, exUSeconds, symbol);
		sub->_prodInfo = product;
		product->_sub = sub;
		
		// insert the _prodInfo in both the maps	
		_prodInfoMap.insert(symbol, product);
		if(symbolID)
		{
			_prodInfoMapID.insert(make_pair(symbolID, product));
		}
		return product;
	}
}

/*
 * Gives back the pointer to the productInfo of the symbol or symbolID
 * @precond: should not be called from function which takes WLock to _subMapMutex
 *			 as this function takes Wlock
 	@Algo:
		See if product info exists
			return productInfo
		else
			Get symbol subscription if exists
			Get isin subscription if exists

			if symbolSub && it is active
				replace _isinSub with symbol sub
			else if isinSub && it is active
				replace _symbolSub with isinSub
			else  if symbolSub
				
 */
ProductInfo* FeedHandler::getProductInfo(Line *line, uint32_t msgType, uint64_t symbolID, const char* symbol, const char *isin, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds)
{
	// Lock for _prodInfoMap, _symbolSubMap
	WLock wlock(_subMapMutex);

	return _getProductInfo(line, msgType, symbolID, symbol, isin, seqNo, exSeconds, exUSeconds);
}

ProductInfo* FeedHandler::_getProductInfo(Line *line, uint32_t msgType, uint64_t symbolID, const char* symbol, const char *isin, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds)
{
	auto itr = _prodInfoMapID.find(symbolID);
	if(itr != _prodInfoMapID.end())
	{
		return itr->second;
	}
	else
	{
		Subscription *sub = getValidIdIsinSymbolSub(symbolID, symbol, isin);

		ProductInfo *product = new ProductInfo(line, sub, msgType, seqNo, exSeconds, exUSeconds, symbolID, symbol , isin);

		// sub->_productInfo and productInfo->_sub settting
		sub->_prodInfo = product;
		product->_sub = sub;
		
		// insert the _prodInfo in both the maps	
		_prodInfoMapID.insert(make_pair(symbolID, product));
		if(strcmp(symbol, ""))
		{
			_prodInfoMap.insert(symbol, product);
		}

		if(strcmp(isin, ""))
		{
			_prodInfoMapISIN.insert(isin, product);
		}
		return product;
	}
}

/*
 * Check all 3 synscription maps symbolId, symbol, isin for the 
 * subscription. Priority is given to symbolId, then symbol and then Isin.
 *	
 *	@precond:  This requires Wlock to _subMapMutex. So should be called only
 *				from function getProductInfo(which takes has it)
 *
 * @Algo :
 *          1> remove the subscriptions belonging from all three maps
 *  		2> If there are different subscription in every map for Product-Symbol-ISIN
 * which represent same instrument, Keep only one subscription for all three
 *				Priority is to SymbolID sub, then symbol sub and then isin sub
 *			3> If we choose idSub as primary sub and it is not active
 *				but corrosponding _symbolSub or _isinSub are then replace
 *				make _productSub active. Again _symbolSub attributes override _isinSub
 *			4> Reinsert the primary sub in all 3 maps
 *			
 */ 
Subscription* FeedHandler::getValidIdIsinSymbolSub(uint64_t symbolID, const char* symbol, const char *isin)
{
		Subscription *sub = nullptr;
		Subscription *symbolSub = nullptr;
		Subscription *isinSub = nullptr;
		Subscription *productSub = nullptr;
		if(strcmp(symbol, ""))
		{
			symbolSub = _symbolSubMap.find(symbol);
			//remove the subscription for now from map 
			// and later insert the modified sub
			_symbolSubMap.removeEntry(symbol);
		}

		if(strcmp(isin, ""))
		{
			isinSub = _isinSubMap.find(isin);
			//remove the subscription for now from map 
			// and later insert the modified sub
			_isinSubMap.removeEntry(isin);
		}

		auto itr = _idSubMap.find(symbolID);
		if(itr != _idSubMap.end())
		{
			productSub = itr->second;
			//remove the subscription for now from map 
			// and later insert the modified sub
			_idSubMap.erase(itr);
		}

		if(productSub) // we just have raw symbolSub, which is not activated 
		{
			sub = productSub; 
		}
		if(symbolSub && symbolSub->_isActive)
		{
			sub = symbolSub;
		}
		else if(isinSub && isinSub->_isActive)
		{
			sub = isinSub;
		}
		else if(symbolSub) // we just have raw symbolSub, which is not activated 
		{
			sub = symbolSub; 
		}
		else if(isinSub) // we just have raw isinSub, which is not activated 
		{
			sub = isinSub; 
		}
		else // none of above is true, create a raw subscription if needed
		{
			sub = new Subscription(symbolID, false);
			for(auto itr : _regexMap)
			{
				if(std::regex_match(std::to_string(symbolID), itr))
				{
					sub->_isActive.store(true, std::memory_order_release);
				}
			}
		}

		//this must be productSub to be inactive 
		if(!sub->_isActive)
		{
			if(isinSub && isinSub->_isActive)
			{
				sub->_isActive.store(true, std::memory_order_release);
			}

			if(symbolSub && symbolSub->_isActive)
			{
				sub->_isActive.store(true, std::memory_order_release);
			}
		}

		// Unifying symbols, replace if needed
		sub->_symbolID = symbolID;
		_idSubMap.insert(make_pair(symbolID, sub));	
		if(productSub && productSub != sub)
		{
			// raise the subscription replace;
		}

		if(strcmp(symbol, ""))
		{
			strncpy(sub->_symbol, symbol, sizeof(sub->_symbol));
			_symbolSubMap.insert(symbol, sub);	
			if(symbolSub && symbolSub != sub)
			{
				// raise the subscription replace;
			}
		}

		if(strcmp(isin, ""))
		{
			strncpy(sub->_isin, isin, sizeof(sub->_isin));
			_isinSubMap.insert(isin, sub);	
			if(isinSub && isinSub != sub)
			{
				// raise the subscription replace;
			}
		}

		return sub;
}
**************FILE************ ./source/0.9.0.0/base/Book.h
#ifndef __BOOK_H__
#define __BOOK_H__

#include <limits>
#include <iostream>
#include <map>
#include "pool/object_pool.hpp"

#include "base/Base.h"
#include "base/BaseCommon.h"

namespace base
{
	// http://www.josuttis.com/cppcode/myalloc.hpp
	template <class T>
	class BookAlloc 
	{
		public:
			// type definitions
			boost::object_pool<T> _pool;
			typedef T        value_type;
			typedef T*       pointer;
			typedef const T* const_pointer;
			typedef T&       reference;
			typedef const T& const_reference;
			typedef std::size_t    size_type;
			typedef std::ptrdiff_t difference_type;

			// rebind allocator to type U
			template <class U>
				struct rebind {
					typedef BookAlloc<U> other;
				};

			// return address of values
			pointer address (reference value) const {
				return &value;
			}
			const_pointer address (const_reference value) const {
				return &value;
			}

			/* constructors and destructor
			 * - nothing to do because the allocator has no state
			 */
			BookAlloc() throw()
				: _pool(256)
			{
				_pool.set_next_size(512);
			}

			BookAlloc(const BookAlloc&) throw() {
			}

			template <class U>
				BookAlloc (const BookAlloc<U>&) throw() {
				}
			~BookAlloc() throw() {
			}

			// return maximum number of elements that can be allocated
			size_type max_size () const throw() {
				return std::numeric_limits<std::size_t>::max() / sizeof(T);
			}

			// allocate but don't initialize num elements of type T
			pointer allocate (size_type num, const void* = 0) {
				// print message and allocate memory with global new
				//std::cerr << "allocate " << num << " element(s)"
				//	<< " of size " << sizeof(T) << std::endl;
				pointer ret = (pointer)(::operator new(num*sizeof(T)));
				//std::cerr << " allocated at: " << (void*)ret << std::endl;
				//return ret;
				ASSERT(num == 1, "num : " << num);
				return _pool.malloc();
			}

			// initialize elements of allocated storage p with value value
			void construct (pointer p, const T& value) {
				// initialize memory with placement new
				new((void*)p)T(value);
			}

			// destroy elements of initialized storage p
			void destroy (pointer p) {
				// destroy objects by calling their destructor
				p->~T();
			}

			// deallocate storage p of deleted elements
			void deallocate (pointer p, size_type num) {
				// print message and deallocate memory with global delete
				//std::cerr << "deallocate " << num << " element(s)"
				//	<< " of size " << sizeof(T)
				//		<< " at: " << (void*)p << std::endl;
				//::operator delete((void*)p);
				ASSERT(num == 1, "num : " << num);
				_pool.free(p);
			}
	};

// return that all specializations of this allocator are interchangeable
template <class T1, class T2>
	bool operator== (const BookAlloc<T1>&,
			const BookAlloc<T2>&) throw() {
		return true;
	}
template <class T1, class T2>
	bool operator!= (const BookAlloc<T1>&,
			const BookAlloc<T2>&) throw() {
		return false;
	}


	typedef std::map<double, PriceLevel *> PriceLevelMap;
	class PriceLevels
	{
		public:
			PriceLevels(Side side);
			uint64_t _quantity;
			PriceLevelMap *_priceLevels;	
	};

	class Book : public Base
	{
		public:
			Book(Subscription *sub);
			~Book();
			void addOrder(Order *order, bool modifyOrder = false);
			void addOrder(Side side, double px, uint64_t size, bool modifyOrder = false);
			void modifyOrder(Order *order);
			void modifyOrder(Side side, double px, double oldPx, uint64_t size, uint64_t oldSize);
			void deleteOrder(Order *order, bool modifyOrder = false);
			void deleteOrder(Side side, double oldPx, uint64_t oldSize, bool modifyOrder = false);

			uint64_t _buyQuantity;
			uint64_t _sellQuantity;

			std::map<double, PriceLevel *, std::greater<double>, BookAlloc<std::pair<const double, PriceLevel *> > > _buys;
			std::map<double, PriceLevel *, std::less<double>, BookAlloc<std::pair<const double, PriceLevel *> > > _sells;
	};
}

#endif //__BOOK_H__
**************FILE************ ./source/0.9.0.0/base/PriceLevels.h
#ifndef __PRICELEVELS_H__
#define __PRICELEVELS_H__

namespace base 
{
	class PriceLevels
	{
	};
}

#endif //__PRICELEVELS_H__
**************FILE************ ./source/0.9.0.0/base/ProductInfo.cpp
#include <string.h>
#include "base/ProductInfo.h"

using namespace base;

ProductInfo::ProductInfo(Line *line, Subscription *sub, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, const char *symbol)
	: Base(line, sub, msgType, seqNo, exSeconds, exUSeconds, PRODUCTINFO_UPDATE)
{
	strncpy(_symbol, symbol, sizeof(_symbol));	
}

ProductInfo::ProductInfo(Line *line, Subscription *sub, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, uint64_t symbolID, const char *symbol, const char *isin)
	: Base(line, sub, msgType, seqNo, exSeconds, exUSeconds, PRODUCTINFO_UPDATE)
	, _symbolID(symbolID)
{
	strncpy(_symbol, symbol, sizeof(_symbol));	
	strncpy(_isin, isin, sizeof(_isin));	
}
**************FILE************ ./source/0.9.0.0/base/MarketDataApplication.h
#ifndef __MARKETDATAPPLICATION_H__
#define __MARKETDATAPPLICATION_H__

#include <time.h>
#include <set>
#include <map>

#include "infra/InfraCommon.h"
#include "infra/thread/Thread.h"
#include "infra/lock/Lock.h"
#include "infra/logger/Logger.h"
#include "base/BaseCommon.h"

using namespace infra;

namespace base 
{

	enum Error
	{
		INVALID_FEEDNAME = -1,
		SUCESS = 0,
		REGEX_SUBSCRIPTION = 1
	};


	typedef FeedHandler* (*FeedHandlerConstructor)(MarketDataApplication *, const pugi::xml_node&, FeedAPI *feedAPI);
	/**
	 * \brief MarketDataApplication: 
	 *			This is main class, Initialize the resources properly
	 *			once created, create the subscritions and start the app
	 */ 
	class MarketDataApplication
	{
		public:
			static bool registerFeedConstructors(FeedID feedID, FeedHandlerConstructor feedHandlerConstructor);
			void refreshTime();
			static FeedHandlerConstructor *feedHandlerConstructors;

			MarketDataApplication(std::string, FeedAPI *);
			~MarketDataApplication();
			Recorder* getRecorder() const; //get recorder instance
			const Logger *getLoggerInstance() const; 		///< get the logger server instance
			void start(); 									///< Start the main thread associated with the application
			void stop(); 						///< stop Thread
			BindThreads getThreadMode(const char *); // return core allocation mode
			void stopComponents();		///< Stop the child threads, started in the start function
			void printStats();		// print the stats
			void stopApp() const;	// check to see if we could stop app in file mode

			void setLoggerInstance(Logger *logger)	///< set the logger instance in Logger constructor
			{
				_loggerInstance = logger;
			}

			FeedHandler	*getFeedHandler(const char *) const;
			NetworkReader *getNetworkReader(const char *, const pugi::xml_node &) const;

			int32_t subscribe(const char *, const char *, Subscription **) const;
			int32_t subscribe(const char *, const uint64_t , Subscription **) const;

			BindThreads	_bindThreads;
			mutable uint32_t       _lastcpu;
			const char	_name[NAME_SIZE];			///< Logical name of an application 

		private:
			static void* start(void *); 		///< calls startApplication
			void MarketDataApplicationLoop(); 	///< start function of main thread, which keeps eye on stats and health of app	

			void createNetworkReaders(const pugi::xml_node &);
			void createFeedHandlers(const pugi::xml_node &);
			FeedHandler* feedHandlerConstructor(const pugi::xml_node &, const std::string &);

			void startFeedHandlers() const;
			void startNetworkReaders() const;

			MarketDataApplication *_appInstance;	///< Pointer to self for logging on console
			Thread		*_thread; 			///< Main application thread
			Logger		*_loggerInstance;	///< Logger Instance
			std::string	_configFile;		///< config file path
			pugi::xml_parse_result _config;	///< config xml handle
			std::mutex	_mutex;	 			///< Mutex lock for whole class data members 
			struct timespec _globalClock;		///< Maintains the current Time
			std::atomic<__int128> _time;
			
			typedef std::map<std::string, NetworkReader *> NameToNetworkReaderMap;
			NameToNetworkReaderMap _networkReaderMap; ///< Name-NetworkReader map

			typedef std::map<std::string, FeedHandler *> NameToFeedHandlerMap;
			NameToFeedHandlerMap _feedHandlerMap; ///< Name-FeedHandler map

			FeedAPI *_feedAPI;
			Recorder *_recorder; //recorder instance
	};
}


#endif //__MARKETDATAPPLICATION_H__
**************FILE************ ./source/0.9.0.0/base/API.cpp
#include "base/API.h"
#include "base/Line.h"
#include "base/LineGroup.h"
#include "base/FeedHandler.h"

using namespace base;

extern "C"
CallBacks getCallback(const std::string updateType)
{
	if(updateType == "ORDER")
	{
		return ORDER;
	}
	else if(updateType == "BOOK")
	{
		return BOOK;
	}
	else if(updateType == "STATUS")
	{
		return STATUS;
	}
	else if(updateType == "QUOTE")
	{
		return QUOTE;
	}
	else if(updateType == "CUSTOM")
	{
		return CUSTOM;
	}
	else if(updateType == "ALL")
	{
		return ALL_CALLBACKS;
	}
	else
	{
		return NO_CALLBACK;
	}
}

void FeedAPI::onFeedStarted(const FeedHandler *feedHandler)
{
}

void FeedAPI::onFeedStopped(const FeedHandler *feedHandler)
{
}

FeedAPI::FeedAPI()
	: LineGroupAPI()
	, _onFeedStarted(&FeedAPI::onFeedStarted)
	, _onFeedStopped(&FeedAPI::onFeedStopped)
{
}

FeedAPI::FeedAPI(OnFeedStarted onFeedStarted, OnFeedStopped onFeedStopped, OnLineGroupStarted onLineGroupStarted, OnLineGroupStopped onLineGroupStopped, OnLineStarted onLineStarted, OnLineStopped onLineStopped, OnPacketStart onPacketStart, OnPacketEnd onPacketEnd, OnOrder onOrder, OnBook onBook, OnQuote onQuote, OnTrade onTrade, OnStatus onStatus, OnCustom onCustom, OnProductInfo onProductInfo)
	: LineGroupAPI(onLineGroupStarted, onLineGroupStopped, onLineStarted, onLineStopped, onPacketStart, onPacketEnd, onOrder , onBook , onQuote , onTrade , onStatus , onCustom , onProductInfo)
	, _onFeedStarted(onFeedStarted)
	, _onFeedStopped(onFeedStopped)
{
}

void LineGroupAPI::onLineGroupStarted(const LineGroup *lineGroup)
{
}

void LineGroupAPI::onLineGroupStopped(const LineGroup *lineGroup)
{
}

LineGroupAPI::LineGroupAPI()
	: LineAPI()
	, _onLineGroupStarted(&LineGroupAPI::onLineGroupStarted)
	, _onLineGroupStopped(&LineGroupAPI::onLineGroupStopped)
{
}

LineGroupAPI::LineGroupAPI(OnLineGroupStarted onLineGroupStarted, OnLineGroupStopped onLineGroupStopped, OnLineStarted onLineStarted, OnLineStopped onLineStopped, OnPacketStart onPacketStart, OnPacketEnd onPacketEnd, OnOrder onOrder, OnBook onBook, OnQuote onQuote, OnTrade onTrade, OnStatus onStatus, OnCustom onCustom, OnProductInfo onProductInfo)
	: LineAPI(onLineStarted, onLineStopped, onPacketStart, onPacketEnd, onOrder , onBook , onQuote , onTrade , onStatus , onCustom , onProductInfo)
	, _onLineGroupStarted(onLineGroupStarted)
	, _onLineGroupStopped(onLineGroupStopped)
{
}


void LineAPI::onLineStarted(const Line *pLine)
{
}

void LineAPI::onLineStopped(const Line *pLine)
{
}

void LineAPI::onPacketStart(const Line *pLine)
{
}

void LineAPI::onPacketEnd(const Line *pLine)
{
}

void LineAPI::onProductInfo(const ProductInfo *product)
{
}

void LineAPI::onOrder(const Order *order)
{
}

void LineAPI::onBook(const Book *book)
{
	
}

void LineAPI::onQuote(const Quote *quote)
{
	
}

void LineAPI::onTrade(const Trade *trade, const Order *order)
{
}

void LineAPI::onStatus(const Status *status)
{
}

void LineAPI::onCustom(const Custom *custom)
{

}

LineAPI::LineAPI()
	: _onLineStarted(&LineAPI::onLineStarted)
	, _onLineStopped(&LineAPI::onLineStopped)
	, _onPacketStart(&LineAPI::onPacketStart)
	, _onPacketEnd(&LineAPI::onPacketEnd)
	, _onOrder(&LineAPI::onOrder)
	, _onBook(&LineAPI::onBook)
	, _onQuote(&LineAPI::onQuote)
	, _onTrade(&LineAPI::onTrade)
	, _onStatus(&LineAPI::onStatus)
	, _onCustom(&LineAPI::onCustom)
	, _onProductInfo(&LineAPI::onProductInfo)
{
}

LineAPI::LineAPI(OnLineStarted onLineStarted, OnLineStopped onLineStopped, OnPacketStart onPacketStart, OnPacketEnd onPacketEnd, OnOrder onOrder, OnBook onBook, OnQuote onQuote, OnTrade onTrade, OnStatus onStatus, OnCustom onCustom, OnProductInfo onProductInfo)
	: _onLineStarted(onLineStarted)
	, _onLineStopped(onLineStopped)
	, _onPacketStart(onPacketStart)
	, _onPacketEnd(onPacketEnd)
	, _onOrder(onOrder)
	, _onBook(onBook)
	, _onQuote(onQuote)
	, _onTrade(onTrade)
	, _onStatus(onStatus)
	, _onCustom(onCustom)
	, _onProductInfo(onProductInfo)
{
}
**************FILE************ ./source/0.9.0.0/base/Trade.h
#ifndef __TRADE_H__
#define __TRADE_H__

#include "base/BaseCommon.h"
#include "base/Base.h"

namespace base
{
	enum TradeBook 
	{
		TRADE_ONBOOK = 'N',
		TRADE_OFFBOOK = 'F', 
		TRADE_UNKNOWNBOOK = 'U'
	};

	enum TradeExchange
	{
		TRADE_ONEXCHANGE = 'N',
		TRADE_OFFEXCHANGE = 'F',
		TRADE_UNKNOWNEX	= 'U'
	};

    class Trade : public Base
    {
        public:
			Trade(Subscription *sub);
			Trade(Line *, Subscription *, uint32_t, uint64_t, uint32_t, uint32_t, double, uint32_t, Side, uint64_t);

			void update(Line *, uint32_t, uint64_t, uint32_t, uint32_t, double, uint32_t, Side, uint64_t);
			~Trade();
		
            double          _px;
            uint32_t		_size;
            Side			_side;
            ID				_tradeID;
			TradeBook		_tradeBook;
			TradeExchange	_tradeExchange;
    };
}

#include "base/BaseCommon.h"
#include "base/Subscription.h"
#include "base/Line.h"
#include "base/API.h"

using namespace base;

// when _sub->_trade is initialized
inline Trade::Trade(Subscription *sub)
	: Base(sub, TRADE_UPDATE)
	, _px(0)
	, _size(0)
	, _side(SIDE_UNKNOWN)
	, _tradeID()
	, _tradeBook(TRADE_UNKNOWNBOOK)
	, _tradeExchange(TRADE_UNKNOWNEX)
{
}

//Used for reporting the offbook trades 
inline Trade::Trade(Line *line, Subscription *sub, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, double px, uint32_t size, Side side, uint64_t tradeID)
	: Base(line, sub, msgType, seqNo, exSeconds, exUSeconds, TRADE_UPDATE)
	, _px(px)
	, _size(size)
	, _side(side)
	, _tradeID(tradeID)
	, _tradeBook(TRADE_ONBOOK)
	, _tradeExchange(TRADE_ONEXCHANGE)

{
}

// For updating regular onbook, onexchange trades _sub->_trade
inline void Trade::update(Line *line, uint32_t msgType, uint64_t seqNo, uint32_t exSeconds, uint32_t exUSeconds, double px, uint32_t size, Side side, uint64_t tradeID)
{
	ASSERT( _line == line || _line == nullptr, "_line : " << _line << ", line : " << line);
	Base::update(line, msgType, seqNo, exSeconds, exUSeconds);
	_px = px;
	_size = size;
	_side = side;
	_tradeID = tradeID;
	_tradeBook = TRADE_ONBOOK;
	_tradeExchange = TRADE_ONEXCHANGE;
	LineAPI *api = _line->_lineAPI;
	(api->*(api->_onTrade))(this, nullptr);
}

inline Trade::~Trade()
{
	_px   = 0.0;
	_size    = 0;
	_side	= SIDE_UNKNOWN;
	_tradeBook = TRADE_UNKNOWNBOOK;
	_tradeExchange = TRADE_UNKNOWNEX;
	// ~Base::Base
}

#endif // __TRADE_H__ 
**************FILE************ ./source/0.9.0.0/base/Recorder.cpp
#include "infra/logger/Logger.h"
#include "infra/thread/Thread.h"
#include "base/BaseCommon.h"
#include "base/MarketDataApplication.h"
#include "base/NetworkReader.h"
#include "base/FeedHandler.h"
#include "base/LineGroup.h"
#include "base/Line.h"
#include "base/Recorder.h"

using namespace infra;
using namespace base;

Recorder::Recorder(const MarketDataApplication *app, const pugi::xml_node &node)
	: _appInstance(app)
	, _name()
	, _thread(nullptr)
{
	strncpy(const_cast<char *>(_name), "recorder", sizeof(_name));
	_thread = new Thread(_appInstance, node, _name, this, Recorder::_start);	
}

/*
 * create a recorder queue for each network recorder 
 */
BoostSPSCQueue<Packet>* Recorder::registerNetworkReader(const NetworkReader *nr)
{
	for(auto pair : _recordQueues)
	{
		// duplicate registration for same network reader
		if(pair.first == nr)
		{
			return pair.second;
		}
	}

	BoostSPSCQueue<Packet> *queue = new BoostSPSCQueue<Packet>(); 
	logConsole(DEBUG, "Registering NetworkReader [ %s : %p ] to Recorder [ %s : %p ] with queue", nr->_name, nr, _name, this, queue);
	_recordQueues.push_back(std::make_pair(nr, queue));
	return queue;
}

Recorder::~Recorder()
{
	delete _thread;
}

/**
 * Starts the actual OS thread instance
 */
void Recorder::start()
{
	_thread->start();
	return;
}

/**
 * Stops actual OS thread instance
 */
void Recorder::stop()
{
	_thread->signalToStop();

	while(!_thread->isStopped());

	logConsole(INFO, "Recorder [ %s : %p ] is stopped", _name, this);
	return;
}

/**
 * Calls the processing function
 */
void* Recorder::_start(void *obj)
{
	static_cast<Recorder *>(obj)->recorderLoop();
	return nullptr;
}

/**
 * Recording loop 
 */
void* Recorder::recorderLoop()
{
	logMessage(INFO, "Recorder [ %s : %p ] started", _name, this);

	while(_thread->isActive())
	{
		std::vector<std::pair<const NetworkReader*, BoostSPSCQueue<Packet> *> >::const_iterator itr = _recordQueues.begin();
		for(; itr != _recordQueues.end(); itr++)
		{
			std::shared_ptr<Packet> record = itr->second->popPtr(); 
			if(record)
			{
				Packet *packet = record.get(); // This is packet to be recorded 
				FeedHandler *fh = packet->_packetAddress->_lineGroup->_feedHandler;
				logMessage(TRACE, "Got packet to write for FeedHandler [ %s : %p ]", fh->_name, fh);
			
				std:string header = CLARICE_HEADER;
				IP ip = *packet->_packetAddress;
				header = header + "," + std::to_string(packet->_rt.tv_sec) + "." + std::to_string(packet->_rt.tv_nsec) + "," + ip.toString() + "," + std::to_string(packet->packetDataLen()) + ",";
				Recording *recording = fh->_recording;
				if(recording)
				{
					recording->_out->write(header.c_str(), header.size());
					recording->_out->write(packet->packetData(), packet->packetDataLen());
					recording->_out->write("\n", 1);
				}
			}
		}
	}

	logMessage(DEBUG, "Recorder [ %s : %p ] is stopping now", _name, this);
	_thread->stop();
}
**************FILE************ ./source/0.9.0.0/base/NetworkReader.h
#ifndef __NETWORK_READER_H__
#define __NETWORK_READER_H__

#include <mutex>
#include <vector>
#include <map>
#include <set>

#include "infra/InfraCommon.h"
#include "base/BaseCommon.h"
#include "base/Packet.h"
#include "base/Recorder.h"

using namespace infra;

namespace base 
{
	class NetworkReader
	{
		public:
			NetworkReader(const MarketDataApplication *app, const pugi::xml_node &readerNode);
			void registerLineGroup(LineGroup *lineGroup);
			void start(); // Start the main thread associated with the NetworkReader 
			void stop(); // Stop the NetworkReader thread
			static void* start(void *); // calls networkReaderLoop 
			void addIPToNetworkReader(const PacketAddress* pPacketAddress);
			void removeIPFromNetworkReader(const PacketAddress* pPacketAddress);
			void networkReaderLoop(); // main loop for live env
			void networkReaderLoopFile(); // main loop for playback
			int32_t readPacket(Recording *); //read paacket from recording stream
			void updateIPVector();	// add/delete ips from _ipReadVector 

			const char _name[NAME_SIZE];	// Name of thread belonging to network reader
			bool _stopApp;

		private:
			const MarketDataApplication *_appInstance; // App instance
			Thread 		*_thread;

			std::vector<const PacketAddress *> _ipReadVector;  // read these IPs for packets
			
			std::mutex		_mutexToAddRemove;
			PlaybackMode 	_mode;
			bool			_updateIPVector;
			std::vector<const PacketAddress*> _addIPs; // All IPs to add to read 
			std::vector<const PacketAddress*> _removeIPs; // All IPs to add to read 

			std::map<FeedHandler *, std::vector<Recording *> > _feedStreams;
			BoostSPSCQueue<Packet>* _recordQueue;
	};
}

#endif //__NETWORK_READER_H__
**************FILE************ ./source/0.9.0.0/base/BaseCommon.h
#ifndef __BASECOMMON_H__
#define __BASECOMMON_H__

#include "pool/object_pool.hpp"
#include "infra/gzstream/gzstream.h"
#include <stdint.h>
#include <string>
#include <boost/assert.hpp>

namespace base 
{

#if defined ASSERT_ENABLED 

	#define ASSERT(cond, msg) {\
		if(!(cond))\
		{\
			std::stringstream str;\
			str << msg;\
			BOOST_ASSERT_MSG(cond, str.str().c_str());\
		}\
	}
#else
	#define ASSERT(...) 
#endif

	#define NAME_SIZE 20
	
	enum IDType
    {
        NUMERIC = 0,
        ALPHANUM = 1,
		IDTYPE_UNKNOWN = 2
    };

	enum Side
	{
		BUY = 'B',
		SELL = 'S',
		SIDE_UNKNOWN = 'U'
	};

	class ID
    {
        public:
			ID();
			ID(char *strID);
			ID(uint64_t numericID);
            ~ID();

			IDType type() const {return _IDType;}
			
			std::string to_string() const;

			uint64_t numeric() const;
			const char* alphanum() const;
			
        private:
			union 
			{
            	uint64_t  _numericID;
	            char      _alphaNumID[20];
			};
            IDType _IDType;
    };

	extern "C" const char *CLARICE_HEADER;

	enum PlaybackError
	{
		RECORDING_FINISHED_ABNORMALLY = -3,
		RECORDING_CORRUPT = -2,
		RECORDING_FINISHED = -1,
		SUCCESS = 0,
	};

	enum class PlaybackMode : uint8_t
	{
		FILE_PLAYBACK = 0,
		LIVE_PLAYBACK = 1
	};

	extern "C" 
	{
		PlaybackMode playbackMode(const std::string &strMode);
		const char* playbackModeToStr(const PlaybackMode mode);
	}
	
	enum RecordField
	{
		HEADER = 0,
		TIME = 1,
		IP_PORT = 2,
		LENGTH = 3
	};

	typedef uint32_t CallBacks;

#define CLEAR_CALLBACKS(callbacks) callbacks = NO_CALLBACK
#define ALL_CALLBACKS(callbacks) callbacks = ALL_CALLBACKS
#define SET_CALLBACK(callbacks, type) callbacks |= type
#define CLEAR_CALLBACK(callbacks, type) callbacks &= ~type

	enum Callback
	{
		NO_CALLBACK		= 0x0000,
		TRADE			= 0x0001,
		ORDER			= 0x0002,
		BOOK			= 0x0006,	// 0x06 = ORDER(2) + BOOK(4)
		STATUS			= 0x0008,
		QUOTE			= 0x0016,	// 0x16 = BOOK(6)  + QUOTE(0x10)
		CUSTOM			= 0x0020,
		ALL_CALLBACKS	= 0xFFFF	// 0XFFFF
	};

	enum class ChannelType : uint32_t
	{
		MAIN,
		SNAP,
		RETRANS,
//		MAIN_TCP,
//		SEC_TCP,
//		RETRANS_TCP,
		CHANNELTYPE_MAX
	};

	enum class IPType : uint32_t
	{
		PRIM_MC,	// Primary/Secondary real time data MC line
		SEC_MC,

		DR_PRIM_MC,
		DR_SEC_MC,

		PRIM_TCP, // Primary/Secondary selective retranse data TCP line
		SEC_TCP,

		DR_PRIM_TCP,
		DR_SEC_TCP,

		PRIM_MC_SNAP, // Primary/Secondary snapshot data MC line
		SEC_MC_SNAP,

		DR_PRIM_MC_SNAP,
		DR_SEC_MC_SNAP,

		PRIM_TCP_SNAP, //  Primary/Secondary snapshot data TCP line 
		SEC_TCP_SNAP,

		DR_PRIM_TCP_SNAP,
		DR_SEC_TCP_SNAP,

		PRIM_MC_RETRANS, // Primary/Secondary selective retranse data MC line
		SEC_MC_RETRANS,

		DR_PRIM_MC_RETRANS,
		DR_SEC_MC_RETRANS,

		PRIM_TCP_RETRANS, // Primary/Secondary TCP retranse line
		SEC_TCP_RETRANS,

		DR_PRIM_TCP_RETRANS,
		DR_SEC_TCP_RETRANS,

		IPTYPE_MAX
	};
#define LATENCY_SIZE 5000
class FeedHandler;
	class Recording
	{
		public:
			Recording(const FeedHandler *feed, const std::string &filename, bool write);
			~Recording();
			
			infra::igzstream *_in;
			infra::ogzstream *_out;
			const std::string _filename;
			const FeedHandler *_feedHandler;
			infra::ogzstream *_reRecord;
	};

	class Base;
	class Order;
	class Book;
	class Quote;
	class PriceLevels;
	class PriceLevel;
	class Quote;
	class Trade;
	class Status;
	class Custom;
	class ProductInfo;

	class MarketDataApplication;
	class NetworkReader;
	class Subscription;
	class SubAndQueue;
	class SubscriptionAPI;
	class LineGroup;
	class Line;
	class Packet;
	class IP;
	class PacketAddress;
	class ApplicationAPI;
	class FeedAPI;
	class LineGroupAPI;
	class LineAPI;
	class SubscriptionAPI;
	class Recorder;
	enum class FeedID;
	
	typedef boost::object_pool<base::PriceLevel> PriceLevelPool;
	typedef boost::object_pool<base::Order> OrderPool;

	/*
	 * Clock instance to get the appliction time.
	 * It is updated constantly by the start loop in the startApplication
	 * and accessed heavily by the logger and whenever system time is required
	 * by the linehandlers and the processing threads 
	 */
inline timespec globalClock() ///< Return current time 
	{
		timespec globalClock;
#if 1 //REAL_TIME
		// Take time from real
		clock_gettime(CLOCK_REALTIME, &globalClock);
#else
		// Take time main application thread maintained time
		__int128 *ptr = reinterpret_cast<__int128 *>(&globalClock);
		*ptr = _time.load(memory_order_acquire);
#endif
		return globalClock;
	}

inline void getLatency(uint64_t *latencyArr, timespec &mt)
{
	timespec ct = globalClock();
	int64_t timeDiff = ((ct.tv_sec - mt.tv_sec) * 1000000000) + ct.tv_nsec - mt.tv_nsec; 
	
	if(timeDiff >= LATENCY_SIZE) 
	{
		timeDiff = LATENCY_SIZE - 1;
	} 

	++latencyArr[timeDiff];
}

}
#endif //__BASE_COMMON_H__
**************FILE************ ./source/0.9.0.0/base/Custom.h
#ifndef __CUSTOM_H__
#define __CUSTOM_H__

namespace base
{
	class Custom
	{
	};
}

#endif //__CUSTOM_H__
**************FILE************ ./source/0.9.0.0/base/Status.cpp
#include "base/Status.h"

const char* Status::StateToCStr(InstrState state)
{
	switch(state)
	{
		case InstrState::UNKNOWN:
			return "UNKNOWN";

		case InstrState::PREOPEN:
			return "PREOPEN";

		case InstrState::OPEN:
			return "OPEN";

		case InstrState::AUCTION:
			return "AUCTION";

		case InstrState::AUCTION_OPEN:
			return "AUCTION_OPEN";

		case InstrState::AUCTION_INTRA:
			return "AUCTION_INTRA";

		case InstrState::AUCTION_VOLA:
			return "AUCTION_VOLA";

		case InstrState::AUCTION_CLOSE:
			return "AUCTION_CLOSE";

		case InstrState::HALTED:
			return "HALTED";

		case InstrState::CLOSED:
			return "AUCTION_CLOSED";

		case InstrState::SUSPENDED:
			return "SUSPENDED";
	}
}
**************FILE************ ./source/0.9.0.0/utilities
**************FILE************ ./source/0.9.0.0/utilities/publish.h
#ifndef __PUBLISH_H__
#define __PUBLISH_H__
#endif //__PUBLISH_H__
**************FILE************ ./source/0.9.0.0/utilities/publish.cpp
#include "publish.h"
**************FILE************ ./source/0.9.0.0/env.sh
#!/bin/bash

#
# Contains the directories and OS specs definitions.
##############################################################

export CD_HOME=`pwd`
export HOSTNAME=`hostname`
export HOSTOS=`uname`
if [ "$HOSTTYPE" == "x86_64" ]; then 
    export  HOSTBITS=64
else 
    export  HOSTBITS=32
fi
export LD_LIBRARY_PATH=/usr/local/lib:$CD_HOME/libs/$HOSTBITS

**************FILE************ ./source/0.9.0.0/product-docs
**************FILE************ ./source/0.9.0.0/product-docs/logger
**************FILE************ ./source/0.9.0.0/product-docs/logger/logger.txt
What log line should be comaprased of
	1> Date, Time , Level, threadName:ThreadId, file, pretty_function, line, *format, Data... 

Per thread one LoggerClientHandle will be available. 
Use LoggerClientHandle handle to write log in the queue.
If Queue is full, first try to write an Error log in the queue itself that queue is full at time. and then write the log in the queue.

**************FILE************ ./source/0.9.0.0/product-docs/productDoc.txt
Writing in c has advantage that it could be easily replaced by the hardware units/FPGAs
c++ has some compiler complexity disadvantages which might hurt a moduler h/w implementation as well it could be slow.
c++ Data structures are I think written for million to billion objects handling, but what platform needs is data structure to fastly handle 0.1 million objects 
rarely any data structure instance will contain more than this objs.

publisher:

Will function to playback on file/mc mode, depending upon whether packets are read from socket or directly filled to the queues from the file-recorded-packets. 
This should have functionality to playback like realtime, but in the fast way. 
As well architecture should embed logic to include publisher as a thread and not as a saperate process. As well publisher should be able to play back the file in possible fast mode.

Logger:
This should have functionality to log message like it has been logged real time.

GH
Gap handler should have recovery-mechanism which could be supported by the other process (mini-recovery-handler) or all the lines in the same feed could support the single login-password(how could exchange know which linehandler is sending the request-and which process is requesting the packet). This could be used for the shared login-among the multiple instances of the feed running on the machine. Even this could even support use of single instances of the same feed running on the different machines, and this single primary-feed could have only single IP which could be used to get the message. Running feed as saperate process and not compositor on feed side is a basic change.
Gap sending api should have parameter to send bulk request or request-on arrival packets of prev response.
Gap handler should pass the some messages forcefully for the process.eg. like sequence reset, which clears the books. This might need extra output parameter to the SequneceNumDetection function.

Base distributor:
    A Base-distributer could also be placed over here so that two different feed-implementations could get same data(no additional licence) for the feed. This is crucial. Two companies could share licence without letting anyone. Other thing is that whenever mc-feed-addresses change you need not to change the address of the feed-clients listening at this level. 
    HBs should include the primary and secondary tcp-addreses on which mc-addresses should be requested. At the base-distributor level functionality for failover to the secondary data-source should be available. As well any failure of tcp-connection break should be reported via admin.

Feed:
Though saperate feed running thread each line handler would force us to use saperate machine for each feed because of limited number of cores, this will prevent us from getting the
1>  Compositor will be on the client side, so releasing new software will be only release a new feature in the client and setup new feed on the one of new machine or add feed to the machine.
2>  Low traffic lines could have same line handler- no extra core.
3>  Routes will be added to the single server.
4> if any server fails to run, whole of that feed will go wrong. So its better to run the 2 different feeds on the same machines, same pair will be on the different machine.
5> should include functionality to process the symbol/mo records. and form the product info.

Packager
Packager would act to create the business objects. These business objects will have constant data type but could have variable structure defined by clients, clients will have business objects in thier own format. Aswell support fix(type-field) structures, let the client choose, what they really want out of platform.
As well the system should give freedom to user to replace one or more module with their own. like customized packager-This could allow clients to use their own data-types.

collector and Admin-lower-upper
Admin at the level of the collector which could give gaps happened, filled, out of sequence packet count. Admin could be connected from out of network. A tool to connect the all admins from all the feeds.

Upper Distributor
Upper-Distributor could send messages depending upon type(trade,quote,book)/name-range.
Distributor should be moduler to support fix fast. As well immplement full A-B line(tcp-mc), selective-full(per-symbol/full-mkt/segment) retranse-snap on the tcp-mc. It includes HBs and recovering depending upon, time, packets cached and HB seq num. The upper distributor HBs should include primary and secondary mc-addresses.
Distribution should be supported on the server basis as well.

====
Memeory and cpu and cache checking scripts which could
====

Client
Failover: in case of not recieving data/hb failover to the secondary server.

reciever:
recieves the data.

compositor:
Linux kernel doulby linked list with mutiple list, with prev-nest for native and composite links.

Admin:
    should be able to show the composite books

====
Memeory and cpu and cache checking scripts which could
====

Running saperate feed has some advantages
1>  If client is comparising the compositor, you do not need 6 different mdrc servers  in the env, so only client would be realease with the some functionality.
2>  Feeds could share login, lines. See common-login-feed
3>

-   check the all recovery-login passwords are working with all the lines, if login-password is shared for all lines.
-   Check duplicate requests are not being sent if login-password is shared among multiple feeds.

Recorder
-   recording will have a header-file <date, > and data<sec.nanoSec timeDiff from day start,>
-   inbuilt md-pub which mc-data. Not absolute file recording reader
-   list the libraries used by the each module.
-   Release notes/ updated release doc with libs
-  External release thing with the code.

Normalized platform not just normalized data.

built-in testing of fields in BO and the gap-handling.


1> selective symbol snapshot functionality from the exchange, while other securities are ok.
2> MACRO to enable the code inclusion into the binary.
3> Test suite, which tests the output after sending single packet.
4> Admin should include the functionality to test the packets processed, last packet arrived, thread_processed_packets(in case of threads sharing the line)
5> Admin should tell the page faults functionality. Better if system call changes are traced.
6> enhaced single callback after processing all messages in the packet should be inside the core code. 
8> No book should be raised before snpashot is complete.
9> Use single threaded STL data structures, Our design supports only one data structure accesses the other.
10> Logger should be run on the trivial work socket of cores. So that cache lines could not be missed because of the logging
11> Implement the sanity in the logging macro.
12> Create a utiliy which raises exception if threads are pinned to same core.
**************FILE************ ./source/0.9.0.0/product-docs/optimizations
1> Recordings:
	Recording structure is still not perfect. But still see if you could go with same.

2> Logger:
	Get the new optimized interface queue working

3> Locks:
	Implement the userspace locks.

4> Provide automatic disaster recovery in case of feed 
	Plus provide automatic recovery to the client connecting to multiple distribution server


**************FILE************ ./source/0.9.0.0/product-docs/config
**************FILE************ ./source/0.9.0.0/product-docs/goals
1> Comeup with the proprietary recording format
 	support the pcap file format
	1> InProc-Publisher : could be used for the latency purpose
	2> Raw-Player
	Done

2> Comeup with the prorpietary custom data format

3> Comeup with the proprietary mo format

4> Check network queue reading latency
	from NR packet write in queue till LG reads the packet
	
5> Turnoff 2ndary MC channel whenever not needed

6> Implement the TCP channels

0216 goals
	- implement the callbacks on request

0222 goals
	- implement the euronext

0304
	- Add the comments
	- do the performance monitoring
	- support the euronext
	- write doc on the latency. 
	- support the NIC card, hw timestamp for the packet
	- support the LSE
	- support the nordic
	- support the disabling secondary mc
	- support the quotes
	- support the secondary mc domarncy
	- support if snapshot/rerequest is not present, clear cache
	- support millenium disabling of the order not found messages
	- support the time based recovery failure
	- correct the millenium parseFunc array
	- parallel processing model for lines
	- support other millenium exchanges
**************FILE************ ./source/0.9.0.0/product-docs/dev.txt
=======================================================================
Writing a new feed
	1> 
**************FILE************ ./source/0.9.0.0/product-docs/codingDoc
Constructors
	every constructor should be explicit
	User defined members data should be initialised like derivedClass():memberConstrctr(), member2Constrctr()
	should contain the unitilised member check, which must be optional check which could raise the exception
	write default values at both the places of declaration and definition and take care that they are correct
	There should not be plain set and getMember data functions. Class must act as a service.
	If any memberData setting function and getting function should be inside the .h file which will make them inline by default.All other functions should be defined in the corrosponding cpp file

	eg: 
		class A	
		{
			data _countA;
			public:
				data();	
				get_countA();
				~data();
		}
		
Functions:
	If user data type,  use pass by reference-to-const only.	
	No default arguments, at all.
	first input parameters, then input-output parameters and then output parameters.
	The input paramters must be const[Mayers, effectice C++,3rdE, page19].


variable naming;
	boolean: must start with "_is" keyword
	No Macro Variables: they are not logged in symbol tables, do not have scopes. Use constants, inline functions, templates.[Mayers, effectice C++,3rdE, page13]. only #def macros should be used.

Including files:
	first std headers
	then boost/STL headers
	then own infra headers
	then local feed/module header

	
**************FILE************ ./source/0.9.0.0/product-docs/commands
#See on which core threads are running 
inter-active 
watch -tdn0.5	ps -mo pid,tid,%cpu,psr -p \`pgrep mdapp-debug\`
ps -mo pid,tid,%cpu,psr -p `pgrep mdapp-debug`

#See all the thread running 
top -H -p PID 
	
#See intrupts per core
 cat /proc/interrupts

#Disable IRQ balacing ie. All intruppts go to 0
in file /etc/default/irqbalance set ENABLED="0"

#Ban the CPU 1110 ie 0x07 ie 2,3, 4 from irqs 
in file /etc/default/irqbalance set IRQBALANCE_BANNED_CPUS="7"

#see the intrupt count increament in 1 second
cat /proc/interrupts > i1; sleep 1 ; cat /proc/interrupts > i2; vim -Od i1 i2

#See CPU cores frequency
cat /proc/cpuinfo | grep  MH

------------------------------------------------
#enable core dump
#corefile stuff in /etc/sysctl.conf
kernel.core_uses_pid = 1
kernel.core_pattern = ./core-%e-%s-%u-%g-%p-%t
fs.suid_dumpable = 2

#to Activate setting immdiatly
sudo sysctl -p
------------------------------------------------

#gdb load core file
gdb  bin/64/mdapp-debug  core-0tom-11-1000-1000-10340-1449171271

#switch the svn server ip: old ip first
svn switch --relocate svn+ssh://jcrawford@192.168.0.108/svn-clarice/clarice svn+ssh://jcrawford@192.168.0.102/svn-clarice/clarice

#catch system call in gdb
catch syscall <futex or system-call no>
**************FILE************ ./source/0.9.0.0/product-docs/main_config.xml
<?xml version="1.0" encoding="utf-8"?>

<config>
<Logger file="clariec.log"	level="debug" logger-queue-size="2000" max-size-in-mb="1000" />

<ApplicationManager name="MarketDataUS" bind-thread="" cpu="-1"/>

<CallBackThreadPool name="global-raiser">
	<CallbackThread name="" cpu="" range="0-9a-m"/>
	<CallbackThread name="" cpu="" range="n-z" />
</CallBackThreadPool>

<NetworkReaders>
	<NetworkReader xname="global-network-reader" cpu="" />
	<NetworkOtherType name="otherType" cpu="" />
</NetworkReaders>

<FeedManagers>
	<FeedOtherType/>			

	<FeedManager name="SampleFeed" playback-mode="file" libarary="" callback-thread-pool="">			
		<Recovery snapshot-username="" snapshot-password="" global-primary-tcp-snapshot="" global-secondary-tcp-snapshot="" global-primary-tcp-retranse="" global-secondary-tcp-retrans=""
				retranse-username="" retranse-password="" global-primary-udp-snapshot="" global-secondary-udp-snapshot="" global-primary-udp-retranse="" global-secondary-udp-retrans=""/>
		<CallBackThreadPool name="feed-raiser"/>
		<Connection name="" callback-thread-pool="">
			<CallBackThreadPool name="connection1-raiser1"/>
			<CallBackThreadPool name="connection1-raiser2"/>
			<Linehandler name="" type="" data-type="" thread="" callback-thread-pool="" dormant-secondarr=""
					username="" password="" primary-mc-line="" 	secondary-mc-line=""  primary-mc-snapshot=""  secondary-mc-snapshot=""  primary-mc-retrans=""   secondary-mc-retrans=""
					snapshot-username="" snapshot-password="" primary-tcp-line=""	secondary-tcp-line="" primary-tcp-snapshot="" secondary-tcp-snapshot="" primary-tcp-retranse="" secondary-tcp-retrans=""
					retranse-username="" retranse-password="" primary-mc-snapshot="" secondary-mc-snapshot="" primary-mc-retranse="" secondary-mc-retrans=""/>
		</Connection>
		<Connection cpu="" callback-thread-pool="">
			<CallBackThreadPool name="connection2-raiser1"/>
			<CallBackThreadPool name="connection2-raiser2"/>
			<Linehandler name="" type="" data-type="" callback-thread-pool=""
					primary-mc-line="" 	secondary-mc-line=""  primary-mc-snapshot=""  secondary-mc-snapshot=""  primary-mc-retrans=""   secondary-mc-retrans=""
					primary-tcp-line=""	secondary-tcp-line="" primary-tcp-snapshot="" secondary-tcp-snapshot="" primary-tcp-retranse="" secondary-tcp-retrans=""
					udp-primary-snapshot="" udp-secondary-snapshot="" udp-primary-retranse="" udp-secondary-retrans=""/>
		</Connection>
	</FeedManager>
</FeedManagers>
</config>

<!--
Logger
	file	: Log file name. Absolute or relative path
				if Directory not present will be created
	
	max-size-in-mb	: Max size of single log file. Successive versions
				will be created after the file 

	logger-queue-size : Size of each logger handler queue. Default value is  

	level:	Below are the logLevels. Default log level is SANITY 
			CRITICAL	
			ERROR	: No subscription found. Can not login to recovery
			EXCEPTION
			WARN	: High usage,
			SANITY	: Sanitly checks like cross book
			INFO	: Something less trivial
			DEBUG	: Something trivial
			TRACE	: Log all the members from the message

ApplicationManager
			Only one node of the ApplicationManager must be there. Otherwise it will throw a config exception.	
	name	: Symbolic name of application manager.
	cpu		: CPU no to which to bind the application manager. It is must to bound this thread to particular CPU.
	bind-threads : Default value manual.
				automatically:	Assign thread no automatically,
							Ensure that there are sufficient cores are available. Otherwise
							if all cores are allocated it will raise exception
				manually	 : consider core given with "cpu" config option on 
								respective config nodes to bind
				false		 : No thread binding and "cpu" config option on nodes is
								ignored
		
CallBackThreadPool
		CallBackThreadPool is pool of threads, which raise the callbacks. To get callback for particular security on
		particular thread, you must associate your session managers, connections, linehadlers with the thread pool.
		
	name	: Name of the thread pool. "none" and "inherit" cannot be the name of the thread pools. 

FeedManagers:
	name	: Name of the feed manager instance within application.
	feed	: Type of the feed this node belongs to eg Millenium, ITCH, BATS ... etc
	playback-mode : Either file or live. In file mode you must provide config option 
				playback-file to point to correct playback file.

LineGroup:
	name	: Name of the LineGroup instance within FeedManager.
				It must be uniq within session manager.

	packet-queue-size : size of packet queue, written by Network Reader and read by LineGroup thread
				Must be sufficient to handle load at market open, close and when market is volatile
	
Line
	name	: Name of the thread;
	type	: Type of linehandler
				consumer: Consumes data.
				assigner: Assigns data to process to particular thread depending upon the subscription name
	data-type : One or multiple of following 
				order/book/quote.
				 trade
				 status
				 custom 
				 productInfo
				 
	callback-thread-pool :  Name of CallBackThreadPool. The values are below
				inherit	: Whatever is the callback-thread-pool of the parent Connection. 
							so lineHandlers could share the threadpool
				none	: LineHandler itself will raise the callbacks
				
				"Name of thread-pool": Name of the CallBackThreadPool.

	dormant-secondary: Listen to packets from secondary line only if needed. ie gap found on the primary
				till it is resolved.

	swaplines-a-b:	Listen to B line first. A line will act as secondary.

	primary-*: Primary mc, tcp lines.	
	secondary-*: Secondary mc, tcp lines.	

-->
	
**************FILE************ ./source/0.9.0.0/core
**************FILE************ ./source/0.9.0.0/core/Subcription.h
#ifndef __SUBCRIPTION_H__
#define __SUBCRIPTION_H__

#include "book.h"
#include "trade.h"

namespace core
{
    enum SymbolType
    {
        SymbolType_Numbric		= 0,
        SymbolType_Alphanumbric	= 1
    };

    class Symbol
    {
            union
            {
                unsigned long long  _numericSymbol;
                char[16]            _alphanumricSymbol;
            };
            SymbolType  _symbolType;
    };

    class Subscription
    {
            Symbol	_symbol;
            bool	_isSubscribed;
            bool	_isComposite;
            unsigned long long  *_clientMap;
            Book    _book;
            Trade	_trade;
			/** 
			 * Callback Thread which raises the callbacks for subscription 
			 */
			Thread	_thread;	
    };
}

#endif //__SUBCRIPTION_H__
**************FILE************ ./source/0.9.0.0/core/PriceLevels.h
#ifndef __PRICELEVELS_H__
#define __PRICELEVELS_H__

namespace core
{
	class PriceLevels
	{
	};
}

#endif //__PRICELEVELS_H__
**************FILE************ ./source/0.9.0.0/core/NetworkReader.h
#ifndef __NETWORK_READER_H__
#define __NETWORK_READER_H__

#include "infra/app/MarketDataApplication.h"

namespace core
{
	enum IPType
	{
		PRIM_MC,
		SEC_MC,
		PRIM_MC_SNAP,
		SEC_MC_SNAP,
		PRIM_MC_RETRANS,
		SEC_MC_RETRANS,
		PRIM_TCP,
		SEC_TCP,
		PRIM_TCP_SNAP,
		SEC_TCP_SNAP,
		PRIM_TCP_RETRANS,
		SEC_TCP_RETRANS,
		IPTYPE_MAX
	};

	class IP
	{
		uint32_t	IPv4;
		uint16_t	port;
	};

	class Line
	{
		IP	ips[IPTYPE_MAX];
	};

	class NetworkReader
	{
		public:
			NetworkReader(const infra::MarketDataApplication *app, infra::LoggerClientHandleSharedPtr logger, const pugi::xml_node &readerNode, std::string readerName);

		private:
			std::string 	_name;	///< Name of thread belonging to network reader
			std::set<Line>	_lines;	///< All the lines beloning to this network reader 
			
	};

	typedef std::shared_ptr<NetworkReader> SharedReaderPtr;
}

#endif //__NETWORK_READER_H__
**************FILE************ ./source/0.9.0.0/scripts
**************FILE************ ./source/0.9.0.0/scripts/turnoff.sh
#!/bin/bash
if [ $# -ne 3 ]; then
	echo "Usage : sudo $0 [on/off] [from core] [to core]"
	echo "Usage : sudo ./turnoff.sh on 4 16"
	echo "Usage : sudo ./turnoff.sh off 4 16"
	exit 0
fi

if [ "$1" == "on" ]; then
	turnOnOff=1;
	onoff="on"
else
	turnOnOff=0;
	onoff="off"
fi

if [ $# -eq 3 ]; then
	cpu=$2
	cpu2=$3
	while [ $cpu -le $cpu2 ];
	do 
		echo "Turning $onoff cpu $cpu"
		sudo echo $turnOnOff > /sys/devices/system/cpu/cpu$cpu/online
		cpu=$((cpu + 1))
	done
	exit 0
fi

echo "Not a valid usage"
echo "$0 [on/off] cpu_no"
echo "$0 [on/off] cpu1 cpu2"
**************FILE************ ./source/0.9.0.0/scripts/monitorSyscalls.sh
#!/bin/bash 


if [ $# -ne 1 ]; then
	>&2 echo "Usage : $0 process-name
			: $0 mdapp-debug" 
	exit -1;
fi

app_name=$1
id=`pgrep $app_name`
logs_dir=logs-$id
mkdir  -p $logs_dir
rm $logs_dir/*

	top -b -n 1 -H -p `pgrep $app_name` | awk '{ if (NR > 7) { print } }' | 
	while read line
	do
		echo $line
		t_id=`echo $line | awk '{print $1}'`
		p_name=`echo $line | awk '{print $13}'`
		echo $pname.$t_id 
		strace -c -tt -p $t_id 2> $logs_dir/$p_name.$t_id & 
	done
wait
**************FILE************ ./source/0.9.0.0/scripts/irqbind.sh
#!/bin/bash

if [ $# -ne 3 ]; then
	echo "Usage : sudo $0 [cpu-core-range] [from interrupt] [to interrupt]"
	echo "Usage : sudo ./irqbind.sh 0-4 0 45"
	exit -1
fi

cpulist=$1
cpuFrom=$2
cputTo=$3
echo "Binding interrupts $cpuFrom-$cputTo to cores $cpulist"

i=$cpuFrom

while [ $i -le $cputTo ];
do
	if [ -f /proc/irq/$i/smp_affinity_list ]; then
		echo "Setting irq $i affinity to core $cpulist"
		echo "echo $cpulisti > /proc/irq/$i/smp_affinity_list"
		echo $cpulist > /proc/irq/$i/smp_affinity_list
	fi
	i=$((i + 1))
done

if  [ -f /proc/irq/default_smp_affinity ]; then
	echo 3 > /proc/irq/default_smp_affinity
fi
**************FILE************ ./source/0.9.0.0/scripts/count_chars.py
#!/usr/bin/env python3
import sys

chars = open(sys.argv[1]).read().strip().replace("\n", "")
[print(c+" -", chars.count(c)) for c in sorted(set([c for c in chars]))]
**************FILE************ ./source/0.9.0.0/scripts/regression.sh
#!/bin/bash

sudo ../scripts/turnoff.sh on 4 16
sudo ../scripts/irqbind.sh 0-4 0 45

if [ $# -ne 1 ]; then
	echo "Usage $0 <no-of-runs>"
	echo "		$0 5"
	exit -1
fi

logDir="app-logs"
mkdir -p $logDir
rm $logDir/*

runs=$1
i=0
while [ $i -lt $runs ];
do
	export MAINTAIN_ORDER=false
	../bin/64/mdapp-release -c sample-no-order.xml -s ".*" #-p 10 -f output-$i
	#./count_chars.py output-$i > charCount-$i
	mv MarketDataUS-clarice.log MarketDataUS-clarice.log-$i
	mv output-$i charCount-$i MarketDataUS-clarice.log-$i $logDir/

	export MAINTAIN_ORDER=true
	../bin/64/mdapp-release -c sample.xml -s ".*" #-o -p 10 -f output-$i-maintain
	#./count_chars.py output-$i-maintain > charCount-$i-maintain
	mv MarketDataUS-clarice.log MarketDataUS-clarice.log-$i-maintain
	mv output-$i-maintain charCount-$i-maintain MarketDataUS-clarice.log-$i-maintain $logDir/

	i=`expr $i + 1`
done
**************FILE************ ./source/0.9.0.0/scripts/run.sh
#!/bin/bash

sudo ../scripts/turnoff.sh on 4 16
sudo ../scripts/irqbind.sh  0-3 0 100

./regression.sh 5

**************FILE************ ./source/0.9.0.0/infra
**************FILE************ ./source/0.9.0.0/infra/logger
**************FILE************ ./source/0.9.0.0/infra/logger/Logger.cpp
#include <string.h>
#include <sys/syscall.h>
#include <time.h>

#include <algorithm>

#include "infra/logger/Logger.h"
#include "infra/thread/Thread.h"
#include "infra/lock/Lock.h"
#include "infra/pugixml/pugixml.h"

#include "base/MarketDataApplication.h" 

using namespace infra;
using namespace base;

Logger* Logger::_loggerInstance; 

/**
 *	getLoggerInstance: get single instance of logger.
 *
 *	@precondition	: Called when application started as single thread instance
 *	@input		 	: Take logger config node 
 *	@output			: Creates the logger if not present.
 *						If tried to call second time, log exception
 *	@return			: Returns pointer to singlton _loggerInstance
 *
 * 	@algo:
 *			If not have _loggerInstance
 * 				create _loggerInstance with opening log file to write;
 *				and start the _thread; 
 */
Logger* Logger::getLoggerInstance(const std::string& appName, const MarketDataApplication *appInstance, pugi::xml_document& doc)
{
	if(!_loggerInstance)
	{
		new Logger(appName, appInstance, doc );
		//@TODO _loggerInstance->_thread->start(Logger::loop);	
	}
	return _loggerInstance;
}

/**
 * Try to open the log file
 * 
 * if path does not exists,
 * 		create path.
 * 		if can not createPath, throw an exception.
 * create file
 * Log the customised log message that logger has been instantiated
 */
Logger::Logger(const std::string& appName, const MarketDataApplication *appInstance, pugi::xml_node LoggerNode)
				: _appInstance(appInstance)
				, _thread(nullptr)
				, _mutex()
				, _logFileHandle(nullptr)
				, _loggerClientHandlesVector()
				, _threadToClientHandlesMap()
				, _name()
				, _logFile("")
				, _maxFileSize(1024*1024*1024)
				, _logQueueSize(1024)
				, _level(LogLevel::SANTY)
{
	strncpy(const_cast<char *>(_name), LoggerNode.getAttributeAsCString("name" , "", false, ""), sizeof(_name));
	//TODO: intialize _name, maxFileSize, logQueueSize and level from the config
	_logFile		= appName + "-" + LoggerNode.getAttributeAsString("file", _name);
	_logQueueSize	= LoggerNode.getAttributeAsUInt("logger-queue-size", _logQueueSize);
	_level			= Logger::getLoggerLevelFromString(LoggerNode.getAttributeAsString("level", "SANTY"));
	_maxFileSize	= LoggerNode.getAttributeAsUInt("size", _maxFileSize); 
	_logFileHandle	= fopen(_logFile.c_str(), "w");

	const_cast<MarketDataApplication *>(_appInstance)->setLoggerInstance(this);

	_loggerInstance = this;
	if(_logFileHandle)
	{
		_thread	= new Thread(appInstance, LoggerNode, _name, this, &Logger::startLogger);
	}
	else
	{
		///<@TODO: Raise an exception. 
	}
}

Logger::~Logger()
{
	WLock wlock(_mutex);

	// delete the logger client handles
	std::vector<LoggerClientHandle *>::iterator itr = _loggerClientHandlesVector.begin();
	for(; itr != _loggerClientHandlesVector.end(); itr++)
	{
		delete *itr;
	}
	_loggerClientHandlesVector.clear();		

	//flush and close the file handler
	fflush(_logFileHandle);
	fclose(_logFileHandle);
}

/**
 *	\brief:	getentHandleForLogger(Thread *_thread, uint32_t _logQueueSize = 1024, LogLevel _level = INFOClientHandleForLogger, 
 *			get loggerClientHandle for the thread to write logs into queue
 *
 *	@input	: Thread*, which needs the handle
 *			_logQueueSize, size of logQueue
 *			_level, level of logging message 
 * 
 * 	@output : create the logger client handle if not present for the thread.
 *  @returns: LoggerClientHandle* representing the log queue of thread
 *	@TODO	: implement the function createOrGetLoggerHandle with locks
 *	@algo	: 
 *			 Check if client handle for thread is already present in _threadToClientHandlesMap
 *			 if present
 *				return it;
 *			 else
 *			 	create shared_ptr to new loggerClientHandle;
 *				add shared_ptr to map;
 *				add shared_ptr to vector;
 *				return shared_ptr;
 *
 */	
LoggerClientHandle *Logger::getClientHandleForLogger(Thread *thread)
{
	// lock for both _threadToClientHandlesMap and _loggerClientHandlesVector
	WLock wlock(_mutex);

	//@TODO: Take write lock
	std::map<Thread *, LoggerClientHandle *>::iterator itr = _threadToClientHandlesMap.find(thread);
	if(itr != _threadToClientHandlesMap.end())
	{
		//@TODO: This should never happened. Assert required
		return itr->second;
	}
	else
	{
		LoggerClientHandle *loggerClientHandle =  new LoggerClientHandle(_appInstance, thread, _logQueueSize, _level);	
		_threadToClientHandlesMap.insert(std::pair<Thread *, LoggerClientHandle *>(thread, loggerClientHandle));
		_loggerClientHandlesVector.push_back(loggerClientHandle);
		return loggerClientHandle;
	}
}

// @return : file handle to write in the file
const FILE *Logger::getLogFileHandle() const
{
	return _logFileHandle;
}

/**
 * \brief : thread
 *		returns the thread which runs in loop and writes log to the file 
 */
Thread *Logger::thread() const
{
	return _thread;
}

/**
 * getLoggerLevelFromString
 *		get the log level from the string
 *		default devel is SANTY
 */

LogLevel Logger::getLoggerLevelFromString(std::string level)
{
	if(level == "TRACE")
		return LogLevel::TRACE;
	else if(level == "DEBUG")
		return LogLevel::DEBUG;
	else if(level == "SANTY")
		return LogLevel::SANTY;
	else if(level == "INFO")
		return LogLevel::INFO;
	else if(level == "WARN")
		return LogLevel::WARN;
	else if(level == "ERROR")
		return LogLevel::ERROR;
	else if(level == "EXCEPTION")
		return LogLevel::EXCEPTION;
	else if(level == "CRITICAL")
		return LogLevel::CRITICAL;
	else
		return LogLevel::SANTY; ///< Default one, atleast return this
}

/**
 *  Returns the Log level string used by the logger macros.
 * The order of the log levels in switch case is scrambled to get 
 * the better hit at INFO logger level which will be used by most
 * production ready systems
 */
const char *Logger::getLogLevelString(LogLevel level)
{
	switch(level)
	{
		case LogLevel::INFO:
			return "INFO";

		case LogLevel::WARN:
			return "WARN";
		
		case LogLevel::DEBUG:
			return "DEBUG";

		case LogLevel::SANTY:
			return "SANTY";
		
		case LogLevel::ERROR:
			return "ERROR";
		
		case LogLevel::EXCEPTION:
			return "EXCEPTION";
		
		case LogLevel::CRITICAL:
			return "CRITICAL";
		
		case LogLevel::TRACE:
			return "TRACE";
		
		default:
			return "UNKNOWN";
	}
}

/**
 * \brief : printInFile
 *			
 */
void Logger::printInFile(LogLevel LEVEL, const char *FILENAME, uint32_t LINE, const char *func, const char *FORMAT, ...)
{
	if(LEVEL >= _level) 
	{
		LogMessage msg;
		msg._timeStamp.tv_sec = globalClock().tv_sec;
		msg._timeStamp.tv_nsec = globalClock().tv_nsec;
		msg._file = FILENAME;
		msg._function = func;
		msg._lineNo = LINE;
		msg._level = LEVEL;

		va_list ARGS;
		va_start(ARGS, FORMAT);
		vsnprintf(msg._message, LOG_MSG_SIZE, FORMAT, ARGS);

		writeLog(&msg, getpid(), syscall(SYS_gettid));

/*
		fprintf(stderr, "%d.%09ld [%d,%ld] %s %s %u %s ", tv_sec, tv_nsec, getpid(), syscall (SYS_gettid), Logger::getLogLevelString(LEVEL), FILENAME, LINE, func);

		va_list ARGS;
		char BUFFER[LOG_MSG_SIZE];
		va_start(ARGS, FORMAT);
		vsnprintf(BUFFER, LOG_MSG_SIZE, FORMAT, ARGS);
		va_end(ARGS);
		fprintf(stderr, " %s\n", BUFFER);
		*/
	}
}

/**
 * \brief : startLogger 
 *		Static wrapper function around LoggerLoop	
 */
void* Logger::startLogger(void *arg)
{
	static_cast<Logger *>(arg)->LoggerLoop();	
	return nullptr;
}

/**
 * Stops actual OS thread instance
 */
void Logger::stop()
{
	_thread->signalToStop();

	while(!_thread->isStopped());

	logConsole(INFO, "Logger [ %s : %p ] is stopped", _name, this);
	return;
}

/**
 *	\brief operator<(const timespec &lhs, const timval &rhs)
 *			Used by the logger thread to sort the logging queues
 *			to print the latest logs
 */
inline bool operator < (const timespec &lhs, const timespec &rhs)
{
	if(lhs.tv_sec == rhs.tv_sec)
	{
		if(lhs.tv_nsec < rhs.tv_nsec)
		{
			return true;
		} 
		else
		{
			return false;
		} 
	}
	else if(lhs.tv_sec < rhs.tv_sec)
	{
		return true;
	}
	else // lhs.tv_sec > rhs.tv_sec
	{
		return false;
	}
}

inline bool operator <= (const timespec &lhs, const timespec &rhs)
{
	if(lhs < rhs)
		return true;

	if(lhs.tv_sec == rhs.tv_sec && lhs.tv_nsec == rhs.tv_nsec)
	{
		return true;
	} 
	return false;
}

/**
  * Change the algorithm to print the logs in the timely manner
  * Currently it prints first log from every LoggerClientHandle queue.
	  *  sort the vector depending upon its front element.
	  *  for all the loggerClientHandle print all the messages with lowest timestamp
  *
  */
void* Logger::LoggerLoop()
{
	logMessage(INFO, "Starting the Logger [ %s : %p ] thread [ %s : %p ] with LoggerLoop: Will write the logs", _name, this, _thread->_name, _thread);

	while(_thread->isActive())
	{
		// Below lock is required as _loggerClientHandlesVector could be changing
		RLock rlock(_mutex);
		if(! _loggerClientHandlesVector.empty())
		{
			for(auto itr : _loggerClientHandlesVector)
			{
				std::shared_ptr<LogMessage> pMsg = nullptr; ;
				while(pMsg = itr->_logMessageQueue.popPtr())
				{
					writeLog(pMsg.get(), getpid(), itr->_thread->getThreadID());
				}
			}
		}

		timespec syncTime = globalClock();
		if(!(syncTime.tv_sec % 10))
		{
			fflush(_logFileHandle);
		}
	}
	_thread->stop();
	return nullptr;
}

/**
 * \brief: writeLog
 *		Actual write in the log file
 *		Write mutex is already aquired in the main Logger::LoggerLoop
 */
void Logger::writeLog(LogMessage *msg, uint32_t pid, uint32_t tid)
{
	struct tm  ts;
    char       buf[80];
    char       funbuf[50];
	time_t     now = msg->_timeStamp.tv_sec;
	ts = *localtime(&now);
    strftime(buf, sizeof(buf), "%a %Y-%m-%d %Z %H:%M:%S", &ts);
	snprintf(funbuf, 50, "%s:%u::%s", msg->_file, msg->_lineNo, msg->_function);
	fprintf(_logFileHandle, "%s.%-.6ld [%-5d,%-5d] %-5s %-50s %s\n", buf, msg->_timeStamp.tv_nsec, pid, tid, Logger::getLogLevelString(msg->_level), funbuf , msg->_message);
}

/**
 * LoggerClientHandle: creats loggerHandle 
 *	@precondition	: should be only called by the getClientHandleForLogger function 
 */
LoggerClientHandle::LoggerClientHandle(const MarketDataApplication *appInstance, Thread *thread, uint32_t logQueueSize, LogLevel level)
		: _logMessageQueue()
		, _thread(thread)
		, _appInstance(appInstance)
		, _level(level)
		, _logQueueSize(logQueueSize)
		, _logFileHandle(appInstance->getLoggerInstance()->getLogFileHandle())
{
}

/**
 * logAndPut : Writes the log message in the queue
 */
void LoggerClientHandle::logAndPut(LogLevel LEVEL, const char *FILENAME, uint32_t LINE, const char *func, const char *FORMAT, ...)
{
	va_list ARGS;
	va_start(ARGS, FORMAT);

	std::shared_ptr<LogMessage> pMsg = _logMessageQueue.pushPtrSpin();

	pMsg->_timeStamp = globalClock();
	pMsg->_file = FILENAME;
	pMsg->_function = func;
	pMsg->_lineNo = LINE;
	pMsg->_level = LEVEL;

	vsnprintf(pMsg->_message, LOG_MSG_SIZE, FORMAT, ARGS);
	return;
}
**************FILE************ ./source/0.9.0.0/infra/logger/Logger.h
#ifndef __LOGGER_H__
#define __LOGGER_H__

#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <map>
#include <vector>
#include <queue>

#include "infra/containers/spsc/BoostSPSCQueue.h"
#include "infra/InfraCommon.h"
#include "infra/pugixml/pugixml.h"
#include "infra/lock/Lock.h"

#include "base/BaseCommon.h"

namespace infra
{
// @TODO:
// Later this console log will write into the logger file directly
// once we have the proper queue and lock mechnism we want

#define logConsole(LEVEL,FORMAT...) {\
			Logger::_loggerInstance->printInFile(infra::LogLevel::LEVEL, __FILE__, __LINE__, __func__, FORMAT);\
			}

#define logConstructor(LEVEL,FORMAT...) if(infra::LogLevel::LEVEL >=  logger->level()) {\
				logger->logAndPut(infra::LogLevel::LEVEL, __FILE__, __LINE__, __func__, FORMAT);\
			}

#define logMessage(LEVEL,FORMAT...) if(infra::LogLevel::LEVEL >=  _thread->loggerClient()->level()) {\
				_thread->loggerClient()->logAndPut(infra::LogLevel::LEVEL, __FILE__, __LINE__, __func__, FORMAT);\
			}

#define LOG_MSG_SIZE 512

	/**
	 *	\brief Log Message structure.
	 *
	 * @TODO: See that how message could be printed with minimal effort
	 *			See how Log message first string with threadNo could be alredy formed
	 */
	class LogMessage: public BoostSPSCQueueElement
	{
		public:
			timespec		_timeStamp;		// Logging timestamp		
			const char	*_file;			// Name of source file
			const char	*_function;		// Function
			uint32_t	_lineNo;		// Line no of file
			LogLevel	_level;			// Level of log being printed
			char 		_message[LOG_MSG_SIZE];	// Message Buffer
	};

	/**
	 *	\brief LoggerClientHandle 
	 *			This is uniq per thread and represents the per thread message queue 
	 *	@TODO: replace the std::queue with the efficient data structure	
	 */
	class LoggerClientHandle 
	{
		public:
			LoggerClientHandle(const base::MarketDataApplication *appInstance, Thread *thread, uint32_t logQueueSize, LogLevel level);

 			//@return: Returns level of the loggerClientHandle
			inline LogLevel level() const { return _level;}

			void logAndPut(LogLevel LEVEL, const char *FILENAME, uint32_t LINE, const char *func, const char *FORMAT, ...);
			static bool compareLess(const LoggerClientHandle *lhs, const LoggerClientHandle *rhs);

			BoostSPSCQueue<LogMessage> _logMessageQueue;	// Queue of log messages
			const Thread	*_thread; 		//  Thread to which LoggerClientHandle is associated

		private:
			const base::MarketDataApplication *_appInstance;
			LogLevel _level;					// log level
			uint32_t _logQueueSize;				// size of queue

			friend class Logger;	// only Logger functions can call LoggerClientHandle 
			const FILE *_logFileHandle; /// file of the logger Instance;
	};



	/*
	 *	Logger: singleton instance of global logger, 
	 *				represent log writer thread
	 *
	 *  This is the first class created by application.
	 *	This runs as single thread, running in while loop,
	 *	it reads all the log SPSC queues written by processing
	 *	threads and writes the oldest log first in the file.
	 *	
	 */
	class Logger
	{
		public:
			static Logger* getLoggerInstance(const std::string& appName, const base::MarketDataApplication *appInstance, pugi::xml_document& doc);
			Logger(const std::string& appName, const base::MarketDataApplication *appInstance, pugi::xml_node LoggerNode);
			~Logger();

			LoggerClientHandle *getClientHandleForLogger(Thread *_thread);
			const FILE *getLogFileHandle() const;
			Thread *thread() const; // get the Logger::_thread
 			
			//@return: Returns level of the logger
			LogLevel level() const { return _level;}

			static LogLevel getLoggerLevelFromString(std::string level); 
			static const char *getLogLevelString(LogLevel level);
			void printInFile(LogLevel LEVEL, const char *FILENAME, uint32_t LINE, const char *func, const char *FORMAT, ...);

			void writeLog(LogMessage *msg, uint32_t pid, uint32_t tid);
			static Logger* _loggerInstance; // Global singleton _loggerInstance
			void stop(); //stop the logger

		private:

			static void *startLogger(void *arg);	// main routine of the Logger

			void *LoggerLoop();

			const base::MarketDataApplication *_appInstance;
			Thread *_thread;				// Loggers own thread
			
			std::mutex	_mutex;
			FILE *_logFileHandle;
			std::vector<LoggerClientHandle *> _loggerClientHandlesVector;	// vector of logger client handles
			std::map<Thread *, LoggerClientHandle *> _threadToClientHandlesMap;	// Thread to client handle map
			const char _name[NAME_SIZE];	// Name of logger
			std::string	_logFile;			// Log file for writing logs
			uint32_t _maxFileSize;			// Maximum size of the log file
			uint32_t _logQueueSize;			// Default value of every logQueue 
			LogLevel _level;				// Loggers own log level and default for other log queues
	};
}
#endif //__LOGGER_H__
**************FILE************ ./source/0.9.0.0/infra/data-structures
**************FILE************ ./source/0.9.0.0/infra/pugixml
**************FILE************ ./source/0.9.0.0/infra/pugixml/pugixml.h
/**
 * pugixml parser - version 1.4
 * --------------------------------------------------------
 * Copyright (C) 2006-2014, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at http://pugixml.org/
 *
 * This library is distributed under the MIT License. See notice at the end
 * of this file.
 *
 * This work is based on the pugxml parser, which is:
 * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)
 */

#ifndef PUGIXML_VERSION
// Define version macro; evaluates to major * 100 + minor so that it's safe to use in less-than comparisons
#	define PUGIXML_VERSION 140
#endif

// Include user configuration file (this can define various configuration macros)
#include "pugiconfig.h"

#ifndef HEADER_PUGIXML_HPP
#define HEADER_PUGIXML_HPP

// Include stddef.h for size_t and ptrdiff_t
#include <stddef.h>

// Include exception header for XPath
#if !defined(PUGIXML_NO_XPATH) && !defined(PUGIXML_NO_EXCEPTIONS)
#	include <exception>
#endif

// Include STL headers
#ifndef PUGIXML_NO_STL
#	include <iterator>
#	include <iosfwd>
#	include <string>
#endif

// Macro for deprecated features
#ifndef PUGIXML_DEPRECATED
#	if defined(__GNUC__)
#		define PUGIXML_DEPRECATED __attribute__((deprecated))
#	elif defined(_MSC_VER) && _MSC_VER >= 1300
#		define PUGIXML_DEPRECATED __declspec(deprecated)
#	else
#		define PUGIXML_DEPRECATED
#	endif
#endif

// If no API is defined, assume default
#ifndef PUGIXML_API
#	define PUGIXML_API
#endif

// If no API for classes is defined, assume default
#ifndef PUGIXML_CLASS
#	define PUGIXML_CLASS PUGIXML_API
#endif

// If no API for functions is defined, assume default
#ifndef PUGIXML_FUNCTION
#	define PUGIXML_FUNCTION PUGIXML_API
#endif

// If the platform is known to have long long support, enable long long functions
#ifndef PUGIXML_HAS_LONG_LONG
#	if defined(__cplusplus) && __cplusplus >= 201103
#		define PUGIXML_HAS_LONG_LONG
#	elif defined(_MSC_VER) && _MSC_VER >= 1400
#		define PUGIXML_HAS_LONG_LONG
#	endif
#endif

// Character interface macros
#ifdef PUGIXML_WCHAR_MODE
#	define PUGIXML_TEXT(t) L ## t
#	define PUGIXML_CHAR wchar_t
#else
#	define PUGIXML_TEXT(t) t
#	define PUGIXML_CHAR char
#endif

namespace pugi
{
	// Character type used for all internal storage and operations; depends on PUGIXML_WCHAR_MODE
	typedef PUGIXML_CHAR char_t;

#ifndef PUGIXML_NO_STL
	// String type used for operations that work with STL string; depends on PUGIXML_WCHAR_MODE
	typedef std::basic_string<PUGIXML_CHAR, std::char_traits<PUGIXML_CHAR>, std::allocator<PUGIXML_CHAR> > string_t;
#endif
}

// The PugiXML namespace
namespace pugi
{
	// Tree node types
	enum xml_node_type
	{
		node_null,			// Empty (null) node handle
		node_document,		// A document tree's absolute root
		node_element,		// Element tag, i.e. '<node/>'
		node_pcdata,		// Plain character data, i.e. 'text'
		node_cdata,			// Character data, i.e. '<![CDATA[text]]>'
		node_comment,		// Comment tag, i.e. '<!-- text -->'
		node_pi,			// Processing instruction, i.e. '<?name?>'
		node_declaration,	// Document declaration, i.e. '<?xml version="1.0"?>'
		node_doctype		// Document type declaration, i.e. '<!DOCTYPE doc>'
	};

	// Parsing options

	// Minimal parsing mode (equivalent to turning all other flags off).
	// Only elements and PCDATA sections are added to the DOM tree, no text conversions are performed.
	const unsigned int parse_minimal = 0x0000;

	// This flag determines if processing instructions (node_pi) are added to the DOM tree. This flag is off by default.
	const unsigned int parse_pi = 0x0001;

	// This flag determines if comments (node_comment) are added to the DOM tree. This flag is off by default.
	const unsigned int parse_comments = 0x0002;

	// This flag determines if CDATA sections (node_cdata) are added to the DOM tree. This flag is on by default.
	const unsigned int parse_cdata = 0x0004;

	// This flag determines if plain character data (node_pcdata) that consist only of whitespace are added to the DOM tree.
	// This flag is off by default; turning it on usually results in slower parsing and more memory consumption.
	const unsigned int parse_ws_pcdata = 0x0008;

	// This flag determines if character and entity references are expanded during parsing. This flag is on by default.
	const unsigned int parse_escapes = 0x0010;

	// This flag determines if EOL characters are normalized (converted to #xA) during parsing. This flag is on by default.
	const unsigned int parse_eol = 0x0020;
	
	// This flag determines if attribute values are normalized using CDATA normalization rules during parsing. This flag is on by default.
	const unsigned int parse_wconv_attribute = 0x0040;

	// This flag determines if attribute values are normalized using NMTOKENS normalization rules during parsing. This flag is off by default.
	const unsigned int parse_wnorm_attribute = 0x0080;
	
	// This flag determines if document declaration (node_declaration) is added to the DOM tree. This flag is off by default.
	const unsigned int parse_declaration = 0x0100;

	// This flag determines if document type declaration (node_doctype) is added to the DOM tree. This flag is off by default.
	const unsigned int parse_doctype = 0x0200;

	// This flag determines if plain character data (node_pcdata) that is the only child of the parent node and that consists only
	// of whitespace is added to the DOM tree.
	// This flag is off by default; turning it on may result in slower parsing and more memory consumption.
	const unsigned int parse_ws_pcdata_single = 0x0400;

	// This flag determines if leading and trailing whitespace is to be removed from plain character data. This flag is off by default.
	const unsigned int parse_trim_pcdata = 0x0800;

	// This flag determines if plain character data that does not have a parent node is added to the DOM tree, and if an empty document
	// is a valid document. This flag is off by default.
	const unsigned int parse_fragment = 0x1000;

	// The default parsing mode.
	// Elements, PCDATA and CDATA sections are added to the DOM tree, character/reference entities are expanded,
	// End-of-Line characters are normalized, attribute values are normalized using CDATA normalization rules.
	const unsigned int parse_default = parse_cdata | parse_escapes | parse_wconv_attribute | parse_eol;

	// The full parsing mode.
	// Nodes of all types are added to the DOM tree, character/reference entities are expanded,
	// End-of-Line characters are normalized, attribute values are normalized using CDATA normalization rules.
	const unsigned int parse_full = parse_default | parse_pi | parse_comments | parse_declaration | parse_doctype;

	// These flags determine the encoding of input data for XML document
	enum xml_encoding
	{
		encoding_auto,		// Auto-detect input encoding using BOM or < / <? detection; use UTF8 if BOM is not found
		encoding_utf8,		// UTF8 encoding
		encoding_utf16_le,	// Little-endian UTF16
		encoding_utf16_be,	// Big-endian UTF16
		encoding_utf16,		// UTF16 with native endianness
		encoding_utf32_le,	// Little-endian UTF32
		encoding_utf32_be,	// Big-endian UTF32
		encoding_utf32,		// UTF32 with native endianness
		encoding_wchar,		// The same encoding wchar_t has (either UTF16 or UTF32)
		encoding_latin1
	};

	// Formatting flags
	
	// Indent the nodes that are written to output stream with as many indentation strings as deep the node is in DOM tree. This flag is on by default.
	const unsigned int format_indent = 0x01;
	
	// Write encoding-specific BOM to the output stream. This flag is off by default.
	const unsigned int format_write_bom = 0x02;

	// Use raw output mode (no indentation and no line breaks are written). This flag is off by default.
	const unsigned int format_raw = 0x04;
	
	// Omit default XML declaration even if there is no declaration in the document. This flag is off by default.
	const unsigned int format_no_declaration = 0x08;

	// Don't escape attribute values and PCDATA contents. This flag is off by default.
	const unsigned int format_no_escapes = 0x10;

	// Open file using text mode in xml_document::save_file. This enables special character (i.e. new-line) conversions on some systems. This flag is off by default.
	const unsigned int format_save_file_text = 0x20;

	// The default set of formatting flags.
	// Nodes are indented depending on their depth in DOM tree, a default declaration is output if document has none.
	const unsigned int format_default = format_indent;
		
	// Forward declarations
	struct xml_attribute_struct;
	struct xml_node_struct;

	class xml_node_iterator;
	class xml_attribute_iterator;
	class xml_named_node_iterator;

	class xml_tree_walker;

	struct xml_parse_result;

	class xml_node;

	class xml_text;
	
	#ifndef PUGIXML_NO_XPATH
	class xpath_node;
	class xpath_node_set;
	class xpath_query;
	class xpath_variable_set;
	#endif

	// Range-based for loop support
	template <typename It> class xml_object_range
	{
	public:
		typedef It const_iterator;
		typedef It iterator;

		xml_object_range(It b, It e): _begin(b), _end(e)
		{
		}

		It begin() const { return _begin; }
		It end() const { return _end; }

	private:
		It _begin, _end;
	};

	// Writer interface for node printing (see xml_node::print)
	class PUGIXML_CLASS xml_writer
	{
	public:
		virtual ~xml_writer() {}

		// Write memory chunk into stream/file/whatever
		virtual void write(const void* data, size_t size) = 0;
	};

	// xml_writer implementation for FILE*
	class PUGIXML_CLASS xml_writer_file: public xml_writer
	{
	public:
		// Construct writer from a FILE* object; void* is used to avoid header dependencies on stdio
		xml_writer_file(void* file);

		virtual void write(const void* data, size_t size);

	private:
		void* file;
	};

	#ifndef PUGIXML_NO_STL
	// xml_writer implementation for streams
	class PUGIXML_CLASS xml_writer_stream: public xml_writer
	{
	public:
		// Construct writer from an output stream object
		xml_writer_stream(std::basic_ostream<char, std::char_traits<char> >& stream);
		xml_writer_stream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream);

		virtual void write(const void* data, size_t size);

	private:
		std::basic_ostream<char, std::char_traits<char> >* narrow_stream;
		std::basic_ostream<wchar_t, std::char_traits<wchar_t> >* wide_stream;
	};
	#endif

	// A light-weight handle for manipulating attributes in DOM tree
	class PUGIXML_CLASS xml_attribute
	{
		friend class xml_attribute_iterator;
		friend class xml_node;

	private:
		xml_attribute_struct* _attr;
	
		typedef void (*unspecified_bool_type)(xml_attribute***);

	public:
		// Default constructor. Constructs an empty attribute.
		xml_attribute();
		
		// Constructs attribute from internal pointer
		explicit xml_attribute(xml_attribute_struct* attr);

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;

		// Comparison operators (compares wrapped attribute pointers)
		bool operator==(const xml_attribute& r) const;
		bool operator!=(const xml_attribute& r) const;
		bool operator<(const xml_attribute& r) const;
		bool operator>(const xml_attribute& r) const;
		bool operator<=(const xml_attribute& r) const;
		bool operator>=(const xml_attribute& r) const;

		// Check if attribute is empty
		bool empty() const;

		// Get attribute name/value, or "" if attribute is empty
		const char_t* name() const;
		const char_t* value() const;

		// Get attribute value, or the default value if attribute is empty
		const char_t* as_string(const char_t* def = PUGIXML_TEXT("")) const;

		// Get attribute value as a number, or the default value if conversion did not succeed or attribute is empty
		int as_int(int def = 0) const;
		unsigned int as_uint(unsigned int def = 0) const;
		double as_double(double def = 0) const;
		float as_float(float def = 0) const;

	#ifdef PUGIXML_HAS_LONG_LONG
		long long as_llong(long long def = 0) const;
		unsigned long long as_ullong(unsigned long long def = 0) const;
	#endif

		// Get attribute value as bool (returns true if first character is in '1tTyY' set), or the default value if attribute is empty
		bool as_bool(bool def = false) const;

		// Set attribute name/value (returns false if attribute is empty or there is not enough memory)
		bool set_name(const char_t* rhs);
		bool set_value(const char_t* rhs);

		// Set attribute value with type conversion (numbers are converted to strings, boolean is converted to "true"/"false")
		bool set_value(int rhs);
		bool set_value(unsigned int rhs);
		bool set_value(double rhs);
		bool set_value(bool rhs);

	#ifdef PUGIXML_HAS_LONG_LONG
		bool set_value(long long rhs);
		bool set_value(unsigned long long rhs);
	#endif

		// Set attribute value (equivalent to set_value without error checking)
		xml_attribute& operator=(const char_t* rhs);
		xml_attribute& operator=(int rhs);
		xml_attribute& operator=(unsigned int rhs);
		xml_attribute& operator=(double rhs);
		xml_attribute& operator=(bool rhs);

	#ifdef PUGIXML_HAS_LONG_LONG
		xml_attribute& operator=(long long rhs);
		xml_attribute& operator=(unsigned long long rhs);
	#endif

		// Get next/previous attribute in the attribute list of the parent node
		xml_attribute next_attribute() const;
		xml_attribute previous_attribute() const;

		// Get hash value (unique for handles to the same object)
		size_t hash_value() const;

		// Get internal pointer
		xml_attribute_struct* internal_object() const;
	};

#ifdef __BORLANDC__
	// Borland C++ workaround
	bool PUGIXML_FUNCTION operator&&(const xml_attribute& lhs, bool rhs);
	bool PUGIXML_FUNCTION operator||(const xml_attribute& lhs, bool rhs);
#endif

	// A light-weight handle for manipulating nodes in DOM tree
	class PUGIXML_CLASS xml_node
	{
		friend class xml_attribute_iterator;
		friend class xml_node_iterator;
		friend class xml_named_node_iterator;

	protected:
		xml_node_struct* _root;

		typedef void (*unspecified_bool_type)(xml_node***);

	public:
		// Default constructor. Constructs an empty node.
		xml_node();

		// Constructs node from internal pointer
		explicit xml_node(xml_node_struct* p);

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;
	
		// Comparison operators (compares wrapped node pointers)
		bool operator==(const xml_node& r) const;
		bool operator!=(const xml_node& r) const;
		bool operator<(const xml_node& r) const;
		bool operator>(const xml_node& r) const;
		bool operator<=(const xml_node& r) const;
		bool operator>=(const xml_node& r) const;

		// Check if node is empty.
		bool empty() const;

		// Get node type
		xml_node_type type() const;

		// Get node name, or "" if node is empty or it has no name
		const char_t* name() const;

		// Get node value, or "" if node is empty or it has no value
        // Note: For <node>text</node> node.value() does not return "text"! Use child_value() or text() methods to access text inside nodes.
		const char_t* value() const;
	
		// Get attribute list
		xml_attribute first_attribute() const;
		xml_attribute last_attribute() const;

		// Get children list
		xml_node first_child() const;
		xml_node last_child() const;

		// Get next/previous sibling in the children list of the parent node
		xml_node next_sibling() const;
		xml_node previous_sibling() const;
		
		// Get parent node
		xml_node parent() const;

		// Get root of DOM tree this node belongs to
		xml_node root() const;

		// Get text object for the current node
		xml_text text() const;

		// Get child, attribute or next/previous sibling with the specified name
		xml_node child(const char_t* name) const;
		xml_attribute attribute(const char_t* name) const;
		xml_node next_sibling(const char_t* name) const;
		xml_node previous_sibling(const char_t* name) const;

		//get Attribute with the already converted values
		const std::string getAttributeAsString(const char_t* name_, const char_t* defaultValue_, bool couldBeEmpty_, const char_t* validValues_) const;
		const std::string getAttributeAsString(const char_t* name_, const char_t* def = PUGIXML_TEXT("")) const;

		const char_t *getAttributeAsCString(const char_t* name_, const char_t* defaultValue_, bool couldBeEmpty_, const char_t* validValues_) const;
		const char_t *getAttributeAsCString(const char_t* name_, const char_t* def = PUGIXML_TEXT("")) const;

		int getAttributeAsInt(const char_t* name_, int def = 0) const;
		unsigned int getAttributeAsUInt(const char_t* name_, unsigned int def = 0) const;
		double getAttributeAsDouble(const char_t* name_, double def = 0) const;
		float getAttributeAsFloat(const char_t* name_, float def = 0) const;
		bool getAttributeAsBool(const char_t* name_, bool def = false) const;

	#ifdef PUGIXML_HAS_LONG_LONG
		long long getAttributeAsLlong(const char_t* name_, long long def = 0) const;
		unsigned long long getAttributeAsUllong(const char_t* name_, unsigned long long def = 0) const;
	#endif

		// Get child value of current node; that is, value of the first child node of type PCDATA/CDATA
		const char_t* child_value() const;

		// Get child value of child with specified name. Equivalent to child(name).child_value().
		const char_t* child_value(const char_t* name) const;

		// Set node name/value (returns false if node is empty, there is not enough memory, or node can not have name/value)
		bool set_name(const char_t* rhs);
		bool set_value(const char_t* rhs);
		
		// Add attribute with specified name. Returns added attribute, or empty attribute on errors.
		xml_attribute append_attribute(const char_t* name);
		xml_attribute prepend_attribute(const char_t* name);
		xml_attribute insert_attribute_after(const char_t* name, const xml_attribute& attr);
		xml_attribute insert_attribute_before(const char_t* name, const xml_attribute& attr);

		// Add a copy of the specified attribute. Returns added attribute, or empty attribute on errors.
		xml_attribute append_copy(const xml_attribute& proto);
		xml_attribute prepend_copy(const xml_attribute& proto);
		xml_attribute insert_copy_after(const xml_attribute& proto, const xml_attribute& attr);
		xml_attribute insert_copy_before(const xml_attribute& proto, const xml_attribute& attr);

		// Add child node with specified type. Returns added node, or empty node on errors.
		xml_node append_child(xml_node_type type = node_element);
		xml_node prepend_child(xml_node_type type = node_element);
		xml_node insert_child_after(xml_node_type type, const xml_node& node);
		xml_node insert_child_before(xml_node_type type, const xml_node& node);

		// Add child element with specified name. Returns added node, or empty node on errors.
		xml_node append_child(const char_t* name);
		xml_node prepend_child(const char_t* name);
		xml_node insert_child_after(const char_t* name, const xml_node& node);
		xml_node insert_child_before(const char_t* name, const xml_node& node);

		// Add a copy of the specified node as a child. Returns added node, or empty node on errors.
		xml_node append_copy(const xml_node& proto);
		xml_node prepend_copy(const xml_node& proto);
		xml_node insert_copy_after(const xml_node& proto, const xml_node& node);
		xml_node insert_copy_before(const xml_node& proto, const xml_node& node);

		// Remove specified attribute
		bool remove_attribute(const xml_attribute& a);
		bool remove_attribute(const char_t* name);

		// Remove specified child
		bool remove_child(const xml_node& n);
		bool remove_child(const char_t* name);

		// Parses buffer as an XML document fragment and appends all nodes as children of the current node.
		// Copies/converts the buffer, so it may be deleted or changed after the function returns.
		// Note: append_buffer allocates memory that has the lifetime of the owning document; removing the appended nodes does not immediately reclaim that memory.
		xml_parse_result append_buffer(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Find attribute using predicate. Returns first attribute for which predicate returned true.
		template <typename Predicate> xml_attribute find_attribute(Predicate pred) const
		{
			if (!_root) return xml_attribute();
			
			for (xml_attribute attrib = first_attribute(); attrib; attrib = attrib.next_attribute())
				if (pred(attrib))
					return attrib;
		
			return xml_attribute();
		}

		// Find child node using predicate. Returns first child for which predicate returned true.
		template <typename Predicate> xml_node find_child(Predicate pred) const
		{
			if (!_root) return xml_node();
	
			for (xml_node node = first_child(); node; node = node.next_sibling())
				if (pred(node))
					return node;
		
			return xml_node();
		}

		// Find node from subtree using predicate. Returns first node from subtree (depth-first), for which predicate returned true.
		template <typename Predicate> xml_node find_node(Predicate pred) const
		{
			if (!_root) return xml_node();

			xml_node cur = first_child();
			
			while (cur._root && cur._root != _root)
			{
				if (pred(cur)) return cur;

				if (cur.first_child()) cur = cur.first_child();
				else if (cur.next_sibling()) cur = cur.next_sibling();
				else
				{
					while (!cur.next_sibling() && cur._root != _root) cur = cur.parent();

					if (cur._root != _root) cur = cur.next_sibling();
				}
			}

			return xml_node();
		}

		// Find child node by attribute name/value
		xml_node find_child_by_attribute(const char_t* name, const char_t* attr_name, const char_t* attr_value) const;
		xml_node find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const;

	#ifndef PUGIXML_NO_STL
		// Get the absolute node path from root as a text string.
		string_t path(char_t delimiter = '/') const;
	#endif

		// Search for a node by path consisting of node names and . or .. elements.
		xml_node first_element_by_path(const char_t* path, char_t delimiter = '/') const;

		// Recursively traverse subtree with xml_tree_walker
		bool traverse(xml_tree_walker& walker);
	
	#ifndef PUGIXML_NO_XPATH
		// Select single node by evaluating XPath query. Returns first node from the resulting node set.
		xpath_node select_single_node(const char_t* query, xpath_variable_set* variables = 0) const;
		xpath_node select_single_node(const xpath_query& query) const;

		// Select node set by evaluating XPath query
		xpath_node_set select_nodes(const char_t* query, xpath_variable_set* variables = 0) const;
		xpath_node_set select_nodes(const xpath_query& query) const;
	#endif
		
		// Print subtree using a writer object
		void print(xml_writer& writer, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;

	#ifndef PUGIXML_NO_STL
		// Print subtree to stream
		void print(std::basic_ostream<char, std::char_traits<char> >& os, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;
		void print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& os, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, unsigned int depth = 0) const;
	#endif

		// Child nodes iterators
		typedef xml_node_iterator iterator;

		iterator begin() const;
		iterator end() const;

		// Attribute iterators
		typedef xml_attribute_iterator attribute_iterator;

		attribute_iterator attributes_begin() const;
		attribute_iterator attributes_end() const;

		// Range-based for support
		xml_object_range<xml_node_iterator> children() const;
		xml_object_range<xml_named_node_iterator> children(const char_t* name) const;
		xml_object_range<xml_attribute_iterator> attributes() const;

		// Get node offset in parsed file/string (in char_t units) for debugging purposes
		ptrdiff_t offset_debug() const;

		// Get hash value (unique for handles to the same object)
		size_t hash_value() const;

		// Get internal pointer
		xml_node_struct* internal_object() const;
	};

#ifdef __BORLANDC__
	// Borland C++ workaround
	bool PUGIXML_FUNCTION operator&&(const xml_node& lhs, bool rhs);
	bool PUGIXML_FUNCTION operator||(const xml_node& lhs, bool rhs);
#endif

	// A helper for working with text inside PCDATA nodes
	class PUGIXML_CLASS xml_text
	{
		friend class xml_node;

		xml_node_struct* _root;

		typedef void (*unspecified_bool_type)(xml_text***);

		explicit xml_text(xml_node_struct* root);

		xml_node_struct* _data_new();
		xml_node_struct* _data() const;

	public:
		// Default constructor. Constructs an empty object.
		xml_text();

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;

		// Check if text object is empty
		bool empty() const;

		// Get text, or "" if object is empty
		const char_t* get() const;

		// Get text, or the default value if object is empty
		const char_t* as_string(const char_t* def = PUGIXML_TEXT("")) const;

		// Get text as a number, or the default value if conversion did not succeed or object is empty
		int as_int(int def = 0) const;
		unsigned int as_uint(unsigned int def = 0) const;
		double as_double(double def = 0) const;
		float as_float(float def = 0) const;

	#ifdef PUGIXML_HAS_LONG_LONG
		long long as_llong(long long def = 0) const;
		unsigned long long as_ullong(unsigned long long def = 0) const;
	#endif

		// Get text as bool (returns true if first character is in '1tTyY' set), or the default value if object is empty
		bool as_bool(bool def = false) const;

		// Set text (returns false if object is empty or there is not enough memory)
		bool set(const char_t* rhs);

		// Set text with type conversion (numbers are converted to strings, boolean is converted to "true"/"false")
		bool set(int rhs);
		bool set(unsigned int rhs);
		bool set(double rhs);
		bool set(bool rhs);

	#ifdef PUGIXML_HAS_LONG_LONG
		bool set(long long rhs);
		bool set(unsigned long long rhs);
	#endif

		// Set text (equivalent to set without error checking)
		xml_text& operator=(const char_t* rhs);
		xml_text& operator=(int rhs);
		xml_text& operator=(unsigned int rhs);
		xml_text& operator=(double rhs);
		xml_text& operator=(bool rhs);

	#ifdef PUGIXML_HAS_LONG_LONG
		xml_text& operator=(long long rhs);
		xml_text& operator=(unsigned long long rhs);
	#endif

		// Get the data node (node_pcdata or node_cdata) for this object
		xml_node data() const;
	};

#ifdef __BORLANDC__
	// Borland C++ workaround
	bool PUGIXML_FUNCTION operator&&(const xml_text& lhs, bool rhs);
	bool PUGIXML_FUNCTION operator||(const xml_text& lhs, bool rhs);
#endif

	// Child node iterator (a bidirectional iterator over a collection of xml_node)
	class PUGIXML_CLASS xml_node_iterator
	{
		friend class xml_node;

	private:
		mutable xml_node _wrap;
		xml_node _parent;

		xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent);

	public:
		// Iterator traits
		typedef ptrdiff_t difference_type;
		typedef xml_node value_type;
		typedef xml_node* pointer;
		typedef xml_node& reference;

	#ifndef PUGIXML_NO_STL
		typedef std::bidirectional_iterator_tag iterator_category;
	#endif

		// Default constructor
		xml_node_iterator();

		// Construct an iterator which points to the specified node
		xml_node_iterator(const xml_node& node);

		// Iterator operators
		bool operator==(const xml_node_iterator& rhs) const;
		bool operator!=(const xml_node_iterator& rhs) const;

		xml_node& operator*() const;
		xml_node* operator->() const;

		const xml_node_iterator& operator++();
		xml_node_iterator operator++(int);

		const xml_node_iterator& operator--();
		xml_node_iterator operator--(int);
	};

	// Attribute iterator (a bidirectional iterator over a collection of xml_attribute)
	class PUGIXML_CLASS xml_attribute_iterator
	{
		friend class xml_node;

	private:
		mutable xml_attribute _wrap;
		xml_node _parent;

		xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent);

	public:
		// Iterator traits
		typedef ptrdiff_t difference_type;
		typedef xml_attribute value_type;
		typedef xml_attribute* pointer;
		typedef xml_attribute& reference;

	#ifndef PUGIXML_NO_STL
		typedef std::bidirectional_iterator_tag iterator_category;
	#endif

		// Default constructor
		xml_attribute_iterator();

		// Construct an iterator which points to the specified attribute
		xml_attribute_iterator(const xml_attribute& attr, const xml_node& parent);

		// Iterator operators
		bool operator==(const xml_attribute_iterator& rhs) const;
		bool operator!=(const xml_attribute_iterator& rhs) const;

		xml_attribute& operator*() const;
		xml_attribute* operator->() const;

		const xml_attribute_iterator& operator++();
		xml_attribute_iterator operator++(int);

		const xml_attribute_iterator& operator--();
		xml_attribute_iterator operator--(int);
	};

	// Named node range helper
	class PUGIXML_CLASS xml_named_node_iterator
	{
		friend class xml_node;

	public:
		// Iterator traits
		typedef ptrdiff_t difference_type;
		typedef xml_node value_type;
		typedef xml_node* pointer;
		typedef xml_node& reference;

	#ifndef PUGIXML_NO_STL
		typedef std::bidirectional_iterator_tag iterator_category;
	#endif

		// Default constructor
		xml_named_node_iterator();

		// Construct an iterator which points to the specified node
		xml_named_node_iterator(const xml_node& node, const char_t* name);

		// Iterator operators
		bool operator==(const xml_named_node_iterator& rhs) const;
		bool operator!=(const xml_named_node_iterator& rhs) const;

		xml_node& operator*() const;
		xml_node* operator->() const;

		const xml_named_node_iterator& operator++();
		xml_named_node_iterator operator++(int);

		const xml_named_node_iterator& operator--();
		xml_named_node_iterator operator--(int);

	private:
		mutable xml_node _wrap;
		xml_node _parent;
		const char_t* _name;

		xml_named_node_iterator(xml_node_struct* ref, xml_node_struct* parent, const char_t* name);
	};

	// Abstract tree walker class (see xml_node::traverse)
	class PUGIXML_CLASS xml_tree_walker
	{
		friend class xml_node;

	private:
		int _depth;
	
	protected:
		// Get current traversal depth
		int depth() const;
	
	public:
		xml_tree_walker();
		virtual ~xml_tree_walker();

		// Callback that is called when traversal begins
		virtual bool begin(xml_node& node);

		// Callback that is called for each node traversed
		virtual bool for_each(xml_node& node) = 0;

		// Callback that is called when traversal ends
		virtual bool end(xml_node& node);
	};

	// Parsing status, returned as part of xml_parse_result object
	enum xml_parse_status
	{
		status_ok = 0,				// No error

		status_file_not_found,		// File was not found during load_file()
		status_io_error,			// Error reading from file/stream
		status_out_of_memory,		// Could not allocate memory
		status_internal_error,		// Internal error occurred

		status_unrecognized_tag,	// Parser could not determine tag type

		status_bad_pi,				// Parsing error occurred while parsing document declaration/processing instruction
		status_bad_comment,			// Parsing error occurred while parsing comment
		status_bad_cdata,			// Parsing error occurred while parsing CDATA section
		status_bad_doctype,			// Parsing error occurred while parsing document type declaration
		status_bad_pcdata,			// Parsing error occurred while parsing PCDATA section
		status_bad_start_element,	// Parsing error occurred while parsing start element tag
		status_bad_attribute,		// Parsing error occurred while parsing element attribute
		status_bad_end_element,		// Parsing error occurred while parsing end element tag
		status_end_element_mismatch,// There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or there was an excessive closing tag)

		status_append_invalid_root,	// Unable to append nodes since root type is not node_element or node_document (exclusive to xml_node::append_buffer)

		status_no_document_element	// Parsing resulted in a document without element nodes
	};

	// Parsing result
	struct PUGIXML_CLASS xml_parse_result
	{
		// Parsing status (see xml_parse_status)
		xml_parse_status status;

		// Last parsed offset (in char_t units from start of input data)
		ptrdiff_t offset;

		// Source document encoding
		xml_encoding encoding;

		// Default constructor, initializes object to failed state
		xml_parse_result();

		// Cast to bool operator
		operator bool() const;

		// Get error description
		const char* description() const;
	};

	// Document class (DOM tree root)
	class PUGIXML_CLASS xml_document: public xml_node
	{
	private:
		char_t* _buffer;

		char _memory[192];
		
		// Non-copyable semantics
		xml_document(const xml_document&);
		const xml_document& operator=(const xml_document&);

		void create();
		void destroy();

	public:
		// Default constructor, makes empty document
		xml_document();

		// Destructor, invalidates all node/attribute handles to this document
		~xml_document();

		// Removes all nodes, leaving the empty document
		void reset();

		// Removes all nodes, then copies the entire contents of the specified document
		void reset(const xml_document& proto);

	#ifndef PUGIXML_NO_STL
		// Load document from stream.
		xml_parse_result load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);
		xml_parse_result load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options = parse_default);
	#endif

		// Load document from zero-terminated string. No encoding conversions are applied.
		xml_parse_result load(const char_t* contents, unsigned int options = parse_default);

		// Load document from file
		xml_parse_result load_file(const char* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);
		xml_parse_result load_file(const wchar_t* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Load document from buffer. Copies/converts the buffer, so it may be deleted or changed after the function returns.
		xml_parse_result load_buffer(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for storage of document data).
		// You should ensure that buffer data will persist throughout the document's lifetime, and free the buffer memory manually once document is destroyed.
		xml_parse_result load_buffer_inplace(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for storage of document data).
		// You should allocate the buffer with pugixml allocation function; document will free the buffer when it is no longer needed (you can't use it anymore).
		xml_parse_result load_buffer_inplace_own(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Save XML document to writer (semantics is slightly different from xml_node::print, see documentation for details).
		void save(xml_writer& writer, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;

	#ifndef PUGIXML_NO_STL
		// Save XML document to stream (semantics is slightly different from xml_node::print, see documentation for details).
		void save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;
		void save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default) const;
	#endif

		// Save XML to file
		bool save_file(const char* path, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;
		bool save_file(const wchar_t* path, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;

		// Get document element
		xml_node document_element() const;
	};

#ifndef PUGIXML_NO_XPATH
	// XPath query return type
	enum xpath_value_type
	{
		xpath_type_none,	  // Unknown type (query failed to compile)
		xpath_type_node_set,  // Node set (xpath_node_set)
		xpath_type_number,	  // Number
		xpath_type_string,	  // String
		xpath_type_boolean	  // Boolean
	};

	// XPath parsing result
	struct PUGIXML_CLASS xpath_parse_result
	{
		// Error message (0 if no error)
		const char* error;

		// Last parsed offset (in char_t units from string start)
		ptrdiff_t offset;

		// Default constructor, initializes object to failed state
		xpath_parse_result();

		// Cast to bool operator
		operator bool() const;

		// Get error description
		const char* description() const;
	};

	// A single XPath variable
	class PUGIXML_CLASS xpath_variable
	{
		friend class xpath_variable_set;

	protected:
		xpath_value_type _type;
		xpath_variable* _next;

		xpath_variable();

		// Non-copyable semantics
		xpath_variable(const xpath_variable&);
		xpath_variable& operator=(const xpath_variable&);
		
	public:
		// Get variable name
		const char_t* name() const;

		// Get variable type
		xpath_value_type type() const;

		// Get variable value; no type conversion is performed, default value (false, NaN, empty string, empty node set) is returned on type mismatch error
		bool get_boolean() const;
		double get_number() const;
		const char_t* get_string() const;
		const xpath_node_set& get_node_set() const;

		// Set variable value; no type conversion is performed, false is returned on type mismatch error
		bool set(bool value);
		bool set(double value);
		bool set(const char_t* value);
		bool set(const xpath_node_set& value);
	};

	// A set of XPath variables
	class PUGIXML_CLASS xpath_variable_set
	{
	private:
		xpath_variable* _data[64];

		// Non-copyable semantics
		xpath_variable_set(const xpath_variable_set&);
		xpath_variable_set& operator=(const xpath_variable_set&);

		xpath_variable* find(const char_t* name) const;

	public:
		// Default constructor/destructor
		xpath_variable_set();
		~xpath_variable_set();

		// Add a new variable or get the existing one, if the types match
		xpath_variable* add(const char_t* name, xpath_value_type type);

		// Set value of an existing variable; no type conversion is performed, false is returned if there is no such variable or if types mismatch
		bool set(const char_t* name, bool value);
		bool set(const char_t* name, double value);
		bool set(const char_t* name, const char_t* value);
		bool set(const char_t* name, const xpath_node_set& value);

		// Get existing variable by name
		xpath_variable* get(const char_t* name);
		const xpath_variable* get(const char_t* name) const;
	};

	// A compiled XPath query object
	class PUGIXML_CLASS xpath_query
	{
	private:
		void* _impl;
		xpath_parse_result _result;

		typedef void (*unspecified_bool_type)(xpath_query***);

		// Non-copyable semantics
		xpath_query(const xpath_query&);
		xpath_query& operator=(const xpath_query&);

	public:
		// Construct a compiled object from XPath expression.
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws xpath_exception on compilation errors.
		explicit xpath_query(const char_t* query, xpath_variable_set* variables = 0);

		// Destructor
		~xpath_query();

		// Get query expression return type
		xpath_value_type return_type() const;
		
		// Evaluate expression as boolean value in the specified context; performs type conversion if necessary.
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors.
		bool evaluate_boolean(const xpath_node& n) const;
		
		// Evaluate expression as double value in the specified context; performs type conversion if necessary.
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors.
		double evaluate_number(const xpath_node& n) const;
		
	#ifndef PUGIXML_NO_STL
		// Evaluate expression as string value in the specified context; performs type conversion if necessary.
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors.
		string_t evaluate_string(const xpath_node& n) const;
	#endif
		
		// Evaluate expression as string value in the specified context; performs type conversion if necessary.
		// At most capacity characters are written to the destination buffer, full result size is returned (includes terminating zero).
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors.
		// If PUGIXML_NO_EXCEPTIONS is defined, returns empty  set instead.
		size_t evaluate_string(char_t* buffer, size_t capacity, const xpath_node& n) const;

		// Evaluate expression as node set in the specified context.
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws xpath_exception on type mismatch and std::bad_alloc on out of memory errors.
		// If PUGIXML_NO_EXCEPTIONS is defined, returns empty node set instead.
		xpath_node_set evaluate_node_set(const xpath_node& n) const;

		// Get parsing result (used to get compilation errors in PUGIXML_NO_EXCEPTIONS mode)
		const xpath_parse_result& result() const;

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;
	};
	
	#ifndef PUGIXML_NO_EXCEPTIONS
	// XPath exception class
	class PUGIXML_CLASS xpath_exception: public std::exception
	{
	private:
		xpath_parse_result _result;

	public:
		// Construct exception from parse result
		explicit xpath_exception(const xpath_parse_result& result);

		// Get error message
		virtual const char* what() const throw();

		// Get parse result
		const xpath_parse_result& result() const;
	};
	#endif
	
	// XPath node class (either xml_node or xml_attribute)
	class PUGIXML_CLASS xpath_node
	{
	private:
		xml_node _node;
		xml_attribute _attribute;
	
		typedef void (*unspecified_bool_type)(xpath_node***);

	public:
		// Default constructor; constructs empty XPath node
		xpath_node();
		
		// Construct XPath node from XML node/attribute
		xpath_node(const xml_node& node);
		xpath_node(const xml_attribute& attribute, const xml_node& parent);

		// Get node/attribute, if any
		xml_node node() const;
		xml_attribute attribute() const;
		
		// Get parent of contained node/attribute
		xml_node parent() const;

		// Safe bool conversion operator
		operator unspecified_bool_type() const;
		
		// Borland C++ workaround
		bool operator!() const;

		// Comparison operators
		bool operator==(const xpath_node& n) const;
		bool operator!=(const xpath_node& n) const;
	};

#ifdef __BORLANDC__
	// Borland C++ workaround
	bool PUGIXML_FUNCTION operator&&(const xpath_node& lhs, bool rhs);
	bool PUGIXML_FUNCTION operator||(const xpath_node& lhs, bool rhs);
#endif

	// A fixed-size collection of XPath nodes
	class PUGIXML_CLASS xpath_node_set
	{
	public:
		// Collection type
		enum type_t
		{
			type_unsorted,			// Not ordered
			type_sorted,			// Sorted by document order (ascending)
			type_sorted_reverse		// Sorted by document order (descending)
		};
		
		// Constant iterator type
		typedef const xpath_node* const_iterator;
	
		// Default constructor. Constructs empty set.
		xpath_node_set();

		// Constructs a set from iterator range; data is not checked for duplicates and is not sorted according to provided type, so be careful
		xpath_node_set(const_iterator begin, const_iterator end, type_t type = type_unsorted);

		// Destructor
		~xpath_node_set();
		
		// Copy constructor/assignment operator
		xpath_node_set(const xpath_node_set& ns);
		xpath_node_set& operator=(const xpath_node_set& ns);

		// Get collection type
		type_t type() const;
		
		// Get collection size
		size_t size() const;

		// Indexing operator
		const xpath_node& operator[](size_t index) const;
		
		// Collection iterators
		const_iterator begin() const;
		const_iterator end() const;

		// Sort the collection in ascending/descending order by document order
		void sort(bool reverse = false);
		
		// Get first node in the collection by document order
		xpath_node first() const;
		
		// Check if collection is empty
		bool empty() const;
	
	private:
		type_t _type;
		
		xpath_node _storage;
		
		xpath_node* _begin;
		xpath_node* _end;

		void _assign(const_iterator begin, const_iterator end);
	};
#endif

#ifndef PUGIXML_NO_STL
	// Convert wide string to UTF8
	std::basic_string<char, std::char_traits<char>, std::allocator<char> > PUGIXML_FUNCTION as_utf8(const wchar_t* str);
	std::basic_string<char, std::char_traits<char>, std::allocator<char> > PUGIXML_FUNCTION as_utf8(const std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >& str);
	
	// Convert UTF8 to wide string
	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > PUGIXML_FUNCTION as_wide(const char* str);
	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > PUGIXML_FUNCTION as_wide(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >& str);
#endif

	// Memory allocation function interface; returns pointer to allocated memory or NULL on failure
	typedef void* (*allocation_function)(size_t size);
	
	// Memory deallocation function interface
	typedef void (*deallocation_function)(void* ptr);

	// Override default memory management functions. All subsequent allocations/deallocations will be performed via supplied functions.
	void PUGIXML_FUNCTION set_memory_management_functions(allocation_function allocate, deallocation_function deallocate);
	
	// Get current memory management functions
	allocation_function PUGIXML_FUNCTION get_memory_allocation_function();
	deallocation_function PUGIXML_FUNCTION get_memory_deallocation_function();
}

#if !defined(PUGIXML_NO_STL) && (defined(_MSC_VER) || defined(__ICC))
namespace std
{
	// Workarounds for (non-standard) iterator category detection for older versions (MSVC7/IC8 and earlier)
	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_node_iterator&);
	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_attribute_iterator&);
	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_named_node_iterator&);
}
#endif

#if !defined(PUGIXML_NO_STL) && defined(__SUNPRO_CC)
namespace std
{
	// Workarounds for (non-standard) iterator category detection
	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_node_iterator&);
	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_attribute_iterator&);
	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_named_node_iterator&);
}
#endif

#endif

/**
 * Copyright (c) 2006-2014 Arseny Kapoulkine
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
**************FILE************ ./source/0.9.0.0/infra/pugixml/pugixml.cpp
/**
 * pugixml parser - version 1.4
 * --------------------------------------------------------
 * Copyright (C) 2006-2014, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at http://pugixml.org/
 *
 * This library is distributed under the MIT License. See notice at the end
 * of this file.
 *
 * This work is based on the pugxml parser, which is:
 * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)
 */

#ifndef SOURCE_PUGIXML_CPP
#define SOURCE_PUGIXML_CPP

#include "infra/utils/StringUtils.h"
#include "pugixml.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <vector>

#ifdef PUGIXML_WCHAR_MODE
#	include <wchar.h>
#endif

#ifndef PUGIXML_NO_XPATH
#	include <math.h>
#	include <float.h>
#	ifdef PUGIXML_NO_EXCEPTIONS
#		include <setjmp.h>
#	endif
#endif

#ifndef PUGIXML_NO_STL
#	include <istream>
#	include <ostream>
#	include <string>
#	include <stdexcept>
#endif

// For placement new
#include <new>

#ifdef _MSC_VER
#	pragma warning(push)
#	pragma warning(disable: 4127) // conditional expression is constant
#	pragma warning(disable: 4324) // structure was padded due to __declspec(align())
#	pragma warning(disable: 4611) // interaction between '_setjmp' and C++ object destruction is non-portable
#	pragma warning(disable: 4702) // unreachable code
#	pragma warning(disable: 4996) // this function or variable may be unsafe
#	pragma warning(disable: 4793) // function compiled as native: presence of '_setjmp' makes a function unmanaged
#endif

#ifdef __INTEL_COMPILER
#	pragma warning(disable: 177) // function was declared but never referenced 
#	pragma warning(disable: 279) // controlling expression is constant
#	pragma warning(disable: 1478 1786) // function was declared "deprecated"
#	pragma warning(disable: 1684) // conversion from pointer to same-sized integral type
#endif

#if defined(__BORLANDC__) && defined(PUGIXML_HEADER_ONLY)
#	pragma warn -8080 // symbol is declared but never used; disabling this inside push/pop bracket does not make the warning go away
#endif

#ifdef __BORLANDC__
#	pragma option push
#	pragma warn -8008 // condition is always false
#	pragma warn -8066 // unreachable code
#endif

#ifdef __SNC__
// Using diag_push/diag_pop does not disable the warnings inside templates due to a compiler bug
#	pragma diag_suppress=178 // function was declared but never referenced
#	pragma diag_suppress=237 // controlling expression is constant
#endif

// Inlining controls
#if defined(_MSC_VER) && _MSC_VER >= 1300
#	define PUGI__NO_INLINE __declspec(noinline)
#elif defined(__GNUC__)
#	define PUGI__NO_INLINE __attribute__((noinline))
#else
#	define PUGI__NO_INLINE 
#endif

// Simple static assertion
#define PUGI__STATIC_ASSERT(cond) { static const char condition_failed[(cond) ? 1 : -1] = {0}; (void)condition_failed[0]; }

// Digital Mars C++ bug workaround for passing char loaded from memory via stack
#ifdef __DMC__
#	define PUGI__DMC_VOLATILE volatile
#else
#	define PUGI__DMC_VOLATILE
#endif

// Borland C++ bug workaround for not defining ::memcpy depending on header include order (can't always use std::memcpy because some compilers don't have it at all)
#if defined(__BORLANDC__) && !defined(__MEM_H_USING_LIST)
using std::memcpy;
using std::memmove;
#endif

// In some environments MSVC is a compiler but the CRT lacks certain MSVC-specific features
#if defined(_MSC_VER) && !defined(__S3E__)
#	define PUGI__MSVC_CRT_VERSION _MSC_VER
#endif

#ifdef PUGIXML_HEADER_ONLY
#	define PUGI__NS_BEGIN namespace pugi { namespace impl {
#	define PUGI__NS_END } }
#	define PUGI__FN inline
#	define PUGI__FN_NO_INLINE inline
#else
#	if defined(_MSC_VER) && _MSC_VER < 1300 // MSVC6 seems to have an amusing bug with anonymous namespaces inside namespaces
#		define PUGI__NS_BEGIN namespace pugi { namespace impl {
#		define PUGI__NS_END } }
#	else
#		define PUGI__NS_BEGIN namespace pugi { namespace impl { namespace {
#		define PUGI__NS_END } } }
#	endif
#	define PUGI__FN
#	define PUGI__FN_NO_INLINE PUGI__NO_INLINE
#endif

// uintptr_t
#if !defined(_MSC_VER) || _MSC_VER >= 1600
#	include <stdint.h>
#else
#	ifndef _UINTPTR_T_DEFINED
// No native uintptr_t in MSVC6 and in some WinCE versions
typedef size_t uintptr_t;
#define _UINTPTR_T_DEFINED
#	endif
PUGI__NS_BEGIN
	typedef unsigned __int8 uint8_t;
	typedef unsigned __int16 uint16_t;
	typedef unsigned __int32 uint32_t;
PUGI__NS_END
#endif

// Memory allocation
PUGI__NS_BEGIN
	PUGI__FN void* default_allocate(size_t size)
	{
		return malloc(size);
	}

	PUGI__FN void default_deallocate(void* ptr)
	{
		free(ptr);
	}

	template <typename T>
	struct xml_memory_management_function_storage
	{
		static allocation_function allocate;
		static deallocation_function deallocate;
	};

	template <typename T> allocation_function xml_memory_management_function_storage<T>::allocate = default_allocate;
	template <typename T> deallocation_function xml_memory_management_function_storage<T>::deallocate = default_deallocate;

	typedef xml_memory_management_function_storage<int> xml_memory;
PUGI__NS_END

// String utilities
PUGI__NS_BEGIN
	// Get string length
	PUGI__FN size_t strlength(const char_t* s)
	{
		assert(s);

	#ifdef PUGIXML_WCHAR_MODE
		return wcslen(s);
	#else
		return strlen(s);
	#endif
	}

	// Compare two strings
	PUGI__FN bool strequal(const char_t* src, const char_t* dst)
	{
		assert(src && dst);

	#ifdef PUGIXML_WCHAR_MODE
		return wcscmp(src, dst) == 0;
	#else
		return strcmp(src, dst) == 0;
	#endif
	}

	// Compare lhs with [rhs_begin, rhs_end)
	PUGI__FN bool strequalrange(const char_t* lhs, const char_t* rhs, size_t count)
	{
		for (size_t i = 0; i < count; ++i)
			if (lhs[i] != rhs[i])
				return false;
	
		return lhs[count] == 0;
	}

	// Get length of wide string, even if CRT lacks wide character support
	PUGI__FN size_t strlength_wide(const wchar_t* s)
	{
		assert(s);

	#ifdef PUGIXML_WCHAR_MODE
		return wcslen(s);
	#else
		const wchar_t* end = s;
		while (*end) end++;
		return static_cast<size_t>(end - s);
	#endif
	}

#ifdef PUGIXML_WCHAR_MODE
	// Convert string to wide string, assuming all symbols are ASCII
	PUGI__FN void widen_ascii(wchar_t* dest, const char* source)
	{
		for (const char* i = source; *i; ++i) *dest++ = *i;
		*dest = 0;
	}
#endif
PUGI__NS_END

#if !defined(PUGIXML_NO_STL) || !defined(PUGIXML_NO_XPATH)
// auto_ptr-like buffer holder for exception recovery
PUGI__NS_BEGIN
	struct buffer_holder
	{
		void* data;
		void (*deleter)(void*);

		buffer_holder(void* data_, void (*deleter_)(void*)): data(data_), deleter(deleter_)
		{
		}

		~buffer_holder()
		{
			if (data) deleter(data);
		}

		void* release()
		{
			void* result = data;
			data = 0;
			return result;
		}
	};
PUGI__NS_END
#endif

PUGI__NS_BEGIN
	static const size_t xml_memory_page_size =
	#ifdef PUGIXML_MEMORY_PAGE_SIZE
		PUGIXML_MEMORY_PAGE_SIZE
	#else
		32768
	#endif
		;

	static const uintptr_t xml_memory_page_alignment = 32;
	static const uintptr_t xml_memory_page_pointer_mask = ~(xml_memory_page_alignment - 1);
	static const uintptr_t xml_memory_page_name_allocated_mask = 16;
	static const uintptr_t xml_memory_page_value_allocated_mask = 8;
	static const uintptr_t xml_memory_page_type_mask = 7;

	struct xml_allocator;

	struct xml_memory_page
	{
		static xml_memory_page* construct(void* memory)
		{
			if (!memory) return 0; //$ redundant, left for performance

			xml_memory_page* result = static_cast<xml_memory_page*>(memory);

			result->allocator = 0;
			result->memory = 0;
			result->prev = 0;
			result->next = 0;
			result->busy_size = 0;
			result->freed_size = 0;

			return result;
		}

		xml_allocator* allocator;

		void* memory;

		xml_memory_page* prev;
		xml_memory_page* next;

		size_t busy_size;
		size_t freed_size;

		char data[1];
	};

	struct xml_memory_string_header
	{
		uint16_t page_offset; // offset from page->data
		uint16_t full_size; // 0 if string occupies whole page
	};

	struct xml_allocator
	{
		xml_allocator(xml_memory_page* root): _root(root), _busy_size(root->busy_size)
		{
		}

		xml_memory_page* allocate_page(size_t data_size)
		{
			size_t size = offsetof(xml_memory_page, data) + data_size;

			// allocate block with some alignment, leaving memory for worst-case padding
			void* memory = xml_memory::allocate(size + xml_memory_page_alignment);
			if (!memory) return 0;

			// align upwards to page boundary
			void* page_memory = reinterpret_cast<void*>((reinterpret_cast<uintptr_t>(memory) + (xml_memory_page_alignment - 1)) & ~(xml_memory_page_alignment - 1));

			// prepare page structure
			xml_memory_page* page = xml_memory_page::construct(page_memory);
			assert(page);

			page->memory = memory;
			page->allocator = _root->allocator;

			return page;
		}

		static void deallocate_page(xml_memory_page* page)
		{
			xml_memory::deallocate(page->memory);
		}

		void* allocate_memory_oob(size_t size, xml_memory_page*& out_page);

		void* allocate_memory(size_t size, xml_memory_page*& out_page)
		{
			if (_busy_size + size > xml_memory_page_size) return allocate_memory_oob(size, out_page);

			void* buf = _root->data + _busy_size;

			_busy_size += size;

			out_page = _root;

			return buf;
		}

		void deallocate_memory(void* ptr, size_t size, xml_memory_page* page)
		{
			if (page == _root) page->busy_size = _busy_size;

			assert(ptr >= page->data && ptr < page->data + page->busy_size);
			(void)!ptr;

			page->freed_size += size;
			assert(page->freed_size <= page->busy_size);

			if (page->freed_size == page->busy_size)
			{
				if (page->next == 0)
				{
					assert(_root == page);

					// top page freed, just reset sizes
					page->busy_size = page->freed_size = 0;
					_busy_size = 0;
				}
				else
				{
					assert(_root != page);
					assert(page->prev);

					// remove from the list
					page->prev->next = page->next;
					page->next->prev = page->prev;

					// deallocate
					deallocate_page(page);
				}
			}
		}

		char_t* allocate_string(size_t length)
		{
			// allocate memory for string and header block
			size_t size = sizeof(xml_memory_string_header) + length * sizeof(char_t);
			
			// round size up to pointer alignment boundary
			size_t full_size = (size + (sizeof(void*) - 1)) & ~(sizeof(void*) - 1);

			xml_memory_page* page;
			xml_memory_string_header* header = static_cast<xml_memory_string_header*>(allocate_memory(full_size, page));

			if (!header) return 0;

			// setup header
			ptrdiff_t page_offset = reinterpret_cast<char*>(header) - page->data;

			assert(page_offset >= 0 && page_offset < (1 << 16));
			header->page_offset = static_cast<uint16_t>(page_offset);

			// full_size == 0 for large strings that occupy the whole page
			assert(full_size < (1 << 16) || (page->busy_size == full_size && page_offset == 0));
			header->full_size = static_cast<uint16_t>(full_size < (1 << 16) ? full_size : 0);

			// round-trip through void* to avoid 'cast increases required alignment of target type' warning
			// header is guaranteed a pointer-sized alignment, which should be enough for char_t
			return static_cast<char_t*>(static_cast<void*>(header + 1));
		}

		void deallocate_string(char_t* string)
		{
			// this function casts pointers through void* to avoid 'cast increases required alignment of target type' warnings
			// we're guaranteed the proper (pointer-sized) alignment on the input string if it was allocated via allocate_string

			// get header
			xml_memory_string_header* header = static_cast<xml_memory_string_header*>(static_cast<void*>(string)) - 1;

			// deallocate
			size_t page_offset = offsetof(xml_memory_page, data) + header->page_offset;
			xml_memory_page* page = reinterpret_cast<xml_memory_page*>(static_cast<void*>(reinterpret_cast<char*>(header) - page_offset));

			// if full_size == 0 then this string occupies the whole page
			size_t full_size = header->full_size == 0 ? page->busy_size : header->full_size;

			deallocate_memory(header, full_size, page);
		}

		xml_memory_page* _root;
		size_t _busy_size;
	};

	PUGI__FN_NO_INLINE void* xml_allocator::allocate_memory_oob(size_t size, xml_memory_page*& out_page)
	{
		const size_t large_allocation_threshold = xml_memory_page_size / 4;

		xml_memory_page* page = allocate_page(size <= large_allocation_threshold ? xml_memory_page_size : size);
		out_page = page;

		if (!page) return 0;

		if (size <= large_allocation_threshold)
		{
			_root->busy_size = _busy_size;

			// insert page at the end of linked list
			page->prev = _root;
			_root->next = page;
			_root = page;

			_busy_size = size;
		}
		else
		{
			// insert page before the end of linked list, so that it is deleted as soon as possible
			// the last page is not deleted even if it's empty (see deallocate_memory)
			assert(_root->prev);

			page->prev = _root->prev;
			page->next = _root;

			_root->prev->next = page;
			_root->prev = page;
		}

		// allocate inside page
		page->busy_size = size;

		return page->data;
	}
PUGI__NS_END

namespace pugi
{
	/// A 'name=value' XML attribute structure.
	struct xml_attribute_struct
	{
		/// Default ctor
		xml_attribute_struct(impl::xml_memory_page* page): header(reinterpret_cast<uintptr_t>(page)), name(0), value(0), prev_attribute_c(0), next_attribute(0)
		{
		}

		uintptr_t header;

		char_t* name;	///< Pointer to attribute name.
		char_t*	value;	///< Pointer to attribute value.

		xml_attribute_struct* prev_attribute_c;	///< Previous attribute (cyclic list)
		xml_attribute_struct* next_attribute;	///< Next attribute
	};

	/// An XML document tree node.
	struct xml_node_struct
	{
		/// Default ctor
		/// \param type - node type
		xml_node_struct(impl::xml_memory_page* page, xml_node_type type): header(reinterpret_cast<uintptr_t>(page) | (type - 1)), parent(0), name(0), value(0), first_child(0), prev_sibling_c(0), next_sibling(0), first_attribute(0)
		{
		}

		uintptr_t header;

		xml_node_struct*		parent;					///< Pointer to parent

		char_t*					name;					///< Pointer to element name.
		char_t*					value;					///< Pointer to any associated string data.

		xml_node_struct*		first_child;			///< First child
		
		xml_node_struct*		prev_sibling_c;			///< Left brother (cyclic list)
		xml_node_struct*		next_sibling;			///< Right brother
		
		xml_attribute_struct*	first_attribute;		///< First attribute
	};
}

PUGI__NS_BEGIN
	struct xml_extra_buffer
	{
		char_t* buffer;
		xml_extra_buffer* next;
	};

	struct xml_document_struct: public xml_node_struct, public xml_allocator
	{
		xml_document_struct(xml_memory_page* page): xml_node_struct(page, node_document), xml_allocator(page), buffer(0), extra_buffers(0)
		{
		}

		const char_t* buffer;

		xml_extra_buffer* extra_buffers;
	};

	inline xml_allocator& get_allocator(const xml_node_struct* node)
	{
		assert(node);

		return *reinterpret_cast<xml_memory_page*>(node->header & xml_memory_page_pointer_mask)->allocator;
	}
PUGI__NS_END

// Low-level DOM operations
PUGI__NS_BEGIN
	inline xml_attribute_struct* allocate_attribute(xml_allocator& alloc)
	{
		xml_memory_page* page;
		void* memory = alloc.allocate_memory(sizeof(xml_attribute_struct), page);

		return new (memory) xml_attribute_struct(page);
	}

	inline xml_node_struct* allocate_node(xml_allocator& alloc, xml_node_type type)
	{
		xml_memory_page* page;
		void* memory = alloc.allocate_memory(sizeof(xml_node_struct), page);

		return new (memory) xml_node_struct(page, type);
	}

	inline void destroy_attribute(xml_attribute_struct* a, xml_allocator& alloc)
	{
		uintptr_t header = a->header;

		if (header & impl::xml_memory_page_name_allocated_mask) alloc.deallocate_string(a->name);
		if (header & impl::xml_memory_page_value_allocated_mask) alloc.deallocate_string(a->value);

		alloc.deallocate_memory(a, sizeof(xml_attribute_struct), reinterpret_cast<xml_memory_page*>(header & xml_memory_page_pointer_mask));
	}

	inline void destroy_node(xml_node_struct* n, xml_allocator& alloc)
	{
		uintptr_t header = n->header;

		if (header & impl::xml_memory_page_name_allocated_mask) alloc.deallocate_string(n->name);
		if (header & impl::xml_memory_page_value_allocated_mask) alloc.deallocate_string(n->value);

		for (xml_attribute_struct* attr = n->first_attribute; attr; )
		{
			xml_attribute_struct* next = attr->next_attribute;

			destroy_attribute(attr, alloc);

			attr = next;
		}

		for (xml_node_struct* child = n->first_child; child; )
		{
			xml_node_struct* next = child->next_sibling;

			destroy_node(child, alloc);

			child = next;
		}

		alloc.deallocate_memory(n, sizeof(xml_node_struct), reinterpret_cast<xml_memory_page*>(header & xml_memory_page_pointer_mask));
	}

	PUGI__FN_NO_INLINE xml_node_struct* append_node(xml_node_struct* node, xml_allocator& alloc, xml_node_type type = node_element)
	{
		xml_node_struct* child = allocate_node(alloc, type);
		if (!child) return 0;

		child->parent = node;

		xml_node_struct* first_child = node->first_child;
			
		if (first_child)
		{
			xml_node_struct* last_child = first_child->prev_sibling_c;

			last_child->next_sibling = child;
			child->prev_sibling_c = last_child;
			first_child->prev_sibling_c = child;
		}
		else
		{
			node->first_child = child;
			child->prev_sibling_c = child;
		}
			
		return child;
	}

	PUGI__FN_NO_INLINE xml_attribute_struct* append_attribute_ll(xml_node_struct* node, xml_allocator& alloc)
	{
		xml_attribute_struct* a = allocate_attribute(alloc);
		if (!a) return 0;

		xml_attribute_struct* first_attribute = node->first_attribute;

		if (first_attribute)
		{
			xml_attribute_struct* last_attribute = first_attribute->prev_attribute_c;

			last_attribute->next_attribute = a;
			a->prev_attribute_c = last_attribute;
			first_attribute->prev_attribute_c = a;
		}
		else
		{
			node->first_attribute = a;
			a->prev_attribute_c = a;
		}
			
		return a;
	}
PUGI__NS_END

// Helper classes for code generation
PUGI__NS_BEGIN
	struct opt_false
	{
		enum { value = 0 };
	};

	struct opt_true
	{
		enum { value = 1 };
	};
PUGI__NS_END

// Unicode utilities
PUGI__NS_BEGIN
	inline uint16_t endian_swap(uint16_t value)
	{
		return static_cast<uint16_t>(((value & 0xff) << 8) | (value >> 8));
	}

	inline uint32_t endian_swap(uint32_t value)
	{
		return ((value & 0xff) << 24) | ((value & 0xff00) << 8) | ((value & 0xff0000) >> 8) | (value >> 24);
	}

	struct utf8_counter
	{
		typedef size_t value_type;

		static value_type low(value_type result, uint32_t ch)
		{
			// U+0000..U+007F
			if (ch < 0x80) return result + 1;
			// U+0080..U+07FF
			else if (ch < 0x800) return result + 2;
			// U+0800..U+FFFF
			else return result + 3;
		}

		static value_type high(value_type result, uint32_t)
		{
			// U+10000..U+10FFFF
			return result + 4;
		}
	};

	struct utf8_writer
	{
		typedef uint8_t* value_type;

		static value_type low(value_type result, uint32_t ch)
		{
			// U+0000..U+007F
			if (ch < 0x80)
			{
				*result = static_cast<uint8_t>(ch);
				return result + 1;
			}
			// U+0080..U+07FF
			else if (ch < 0x800)
			{
				result[0] = static_cast<uint8_t>(0xC0 | (ch >> 6));
				result[1] = static_cast<uint8_t>(0x80 | (ch & 0x3F));
				return result + 2;
			}
			// U+0800..U+FFFF
			else
			{
				result[0] = static_cast<uint8_t>(0xE0 | (ch >> 12));
				result[1] = static_cast<uint8_t>(0x80 | ((ch >> 6) & 0x3F));
				result[2] = static_cast<uint8_t>(0x80 | (ch & 0x3F));
				return result + 3;
			}
		}

		static value_type high(value_type result, uint32_t ch)
		{
			// U+10000..U+10FFFF
			result[0] = static_cast<uint8_t>(0xF0 | (ch >> 18));
			result[1] = static_cast<uint8_t>(0x80 | ((ch >> 12) & 0x3F));
			result[2] = static_cast<uint8_t>(0x80 | ((ch >> 6) & 0x3F));
			result[3] = static_cast<uint8_t>(0x80 | (ch & 0x3F));
			return result + 4;
		}

		static value_type any(value_type result, uint32_t ch)
		{
			return (ch < 0x10000) ? low(result, ch) : high(result, ch);
		}
	};

	struct utf16_counter
	{
		typedef size_t value_type;

		static value_type low(value_type result, uint32_t)
		{
			return result + 1;
		}

		static value_type high(value_type result, uint32_t)
		{
			return result + 2;
		}
	};

	struct utf16_writer
	{
		typedef uint16_t* value_type;

		static value_type low(value_type result, uint32_t ch)
		{
			*result = static_cast<uint16_t>(ch);

			return result + 1;
		}

		static value_type high(value_type result, uint32_t ch)
		{
			uint32_t msh = static_cast<uint32_t>(ch - 0x10000) >> 10;
			uint32_t lsh = static_cast<uint32_t>(ch - 0x10000) & 0x3ff;

			result[0] = static_cast<uint16_t>(0xD800 + msh);
			result[1] = static_cast<uint16_t>(0xDC00 + lsh);

			return result + 2;
		}

		static value_type any(value_type result, uint32_t ch)
		{
			return (ch < 0x10000) ? low(result, ch) : high(result, ch);
		}
	};

	struct utf32_counter
	{
		typedef size_t value_type;

		static value_type low(value_type result, uint32_t)
		{
			return result + 1;
		}

		static value_type high(value_type result, uint32_t)
		{
			return result + 1;
		}
	};

	struct utf32_writer
	{
		typedef uint32_t* value_type;

		static value_type low(value_type result, uint32_t ch)
		{
			*result = ch;

			return result + 1;
		}

		static value_type high(value_type result, uint32_t ch)
		{
			*result = ch;

			return result + 1;
		}

		static value_type any(value_type result, uint32_t ch)
		{
			*result = ch;

			return result + 1;
		}
	};

	struct latin1_writer
	{
		typedef uint8_t* value_type;

		static value_type low(value_type result, uint32_t ch)
		{
			*result = static_cast<uint8_t>(ch > 255 ? '?' : ch);

			return result + 1;
		}

		static value_type high(value_type result, uint32_t ch)
		{
			(void)ch;

			*result = '?';

			return result + 1;
		}
	};

	template <size_t size> struct wchar_selector;

	template <> struct wchar_selector<2>
	{
		typedef uint16_t type;
		typedef utf16_counter counter;
		typedef utf16_writer writer;
	};

	template <> struct wchar_selector<4>
	{
		typedef uint32_t type;
		typedef utf32_counter counter;
		typedef utf32_writer writer;
	};

	typedef wchar_selector<sizeof(wchar_t)>::counter wchar_counter;
	typedef wchar_selector<sizeof(wchar_t)>::writer wchar_writer;

	template <typename Traits, typename opt_swap = opt_false> struct utf_decoder
	{
		static inline typename Traits::value_type decode_utf8_block(const uint8_t* data, size_t size, typename Traits::value_type result)
		{
			const uint8_t utf8_byte_mask = 0x3f;

			while (size)
			{
				uint8_t lead = *data;

				// 0xxxxxxx -> U+0000..U+007F
				if (lead < 0x80)
				{
					result = Traits::low(result, lead);
					data += 1;
					size -= 1;

					// process aligned single-byte (ascii) blocks
					if ((reinterpret_cast<uintptr_t>(data) & 3) == 0)
					{
						// round-trip through void* to silence 'cast increases required alignment of target type' warnings
						while (size >= 4 && (*static_cast<const uint32_t*>(static_cast<const void*>(data)) & 0x80808080) == 0)
						{
							result = Traits::low(result, data[0]);
							result = Traits::low(result, data[1]);
							result = Traits::low(result, data[2]);
							result = Traits::low(result, data[3]);
							data += 4;
							size -= 4;
						}
					}
				}
				// 110xxxxx -> U+0080..U+07FF
				else if (static_cast<unsigned int>(lead - 0xC0) < 0x20 && size >= 2 && (data[1] & 0xc0) == 0x80)
				{
					result = Traits::low(result, ((lead & ~0xC0) << 6) | (data[1] & utf8_byte_mask));
					data += 2;
					size -= 2;
				}
				// 1110xxxx -> U+0800-U+FFFF
				else if (static_cast<unsigned int>(lead - 0xE0) < 0x10 && size >= 3 && (data[1] & 0xc0) == 0x80 && (data[2] & 0xc0) == 0x80)
				{
					result = Traits::low(result, ((lead & ~0xE0) << 12) | ((data[1] & utf8_byte_mask) << 6) | (data[2] & utf8_byte_mask));
					data += 3;
					size -= 3;
				}
				// 11110xxx -> U+10000..U+10FFFF
				else if (static_cast<unsigned int>(lead - 0xF0) < 0x08 && size >= 4 && (data[1] & 0xc0) == 0x80 && (data[2] & 0xc0) == 0x80 && (data[3] & 0xc0) == 0x80)
				{
					result = Traits::high(result, ((lead & ~0xF0) << 18) | ((data[1] & utf8_byte_mask) << 12) | ((data[2] & utf8_byte_mask) << 6) | (data[3] & utf8_byte_mask));
					data += 4;
					size -= 4;
				}
				// 10xxxxxx or 11111xxx -> invalid
				else
				{
					data += 1;
					size -= 1;
				}
			}

			return result;
		}

		static inline typename Traits::value_type decode_utf16_block(const uint16_t* data, size_t size, typename Traits::value_type result)
		{
			const uint16_t* end = data + size;

			while (data < end)
			{
				unsigned int lead = opt_swap::value ? endian_swap(*data) : *data;

				// U+0000..U+D7FF
				if (lead < 0xD800)
				{
					result = Traits::low(result, lead);
					data += 1;
				}
				// U+E000..U+FFFF
				else if (static_cast<unsigned int>(lead - 0xE000) < 0x2000)
				{
					result = Traits::low(result, lead);
					data += 1;
				}
				// surrogate pair lead
				else if (static_cast<unsigned int>(lead - 0xD800) < 0x400 && data + 1 < end)
				{
					uint16_t next = opt_swap::value ? endian_swap(data[1]) : data[1];

					if (static_cast<unsigned int>(next - 0xDC00) < 0x400)
					{
						result = Traits::high(result, 0x10000 + ((lead & 0x3ff) << 10) + (next & 0x3ff));
						data += 2;
					}
					else
					{
						data += 1;
					}
				}
				else
				{
					data += 1;
				}
			}

			return result;
		}

		static inline typename Traits::value_type decode_utf32_block(const uint32_t* data, size_t size, typename Traits::value_type result)
		{
			const uint32_t* end = data + size;

			while (data < end)
			{
				uint32_t lead = opt_swap::value ? endian_swap(*data) : *data;

				// U+0000..U+FFFF
				if (lead < 0x10000)
				{
					result = Traits::low(result, lead);
					data += 1;
				}
				// U+10000..U+10FFFF
				else
				{
					result = Traits::high(result, lead);
					data += 1;
				}
			}

			return result;
		}

		static inline typename Traits::value_type decode_latin1_block(const uint8_t* data, size_t size, typename Traits::value_type result)
		{
			for (size_t i = 0; i < size; ++i)
			{
				result = Traits::low(result, data[i]);
			}

			return result;
		}

		static inline typename Traits::value_type decode_wchar_block_impl(const uint16_t* data, size_t size, typename Traits::value_type result)
		{
			return decode_utf16_block(data, size, result);
		}

		static inline typename Traits::value_type decode_wchar_block_impl(const uint32_t* data, size_t size, typename Traits::value_type result)
		{
			return decode_utf32_block(data, size, result);
		}

		static inline typename Traits::value_type decode_wchar_block(const wchar_t* data, size_t size, typename Traits::value_type result)
		{
			return decode_wchar_block_impl(reinterpret_cast<const wchar_selector<sizeof(wchar_t)>::type*>(data), size, result);
		}
	};

	template <typename T> PUGI__FN void convert_utf_endian_swap(T* result, const T* data, size_t length)
	{
		for (size_t i = 0; i < length; ++i) result[i] = endian_swap(data[i]);
	}

#ifdef PUGIXML_WCHAR_MODE
	PUGI__FN void convert_wchar_endian_swap(wchar_t* result, const wchar_t* data, size_t length)
	{
		for (size_t i = 0; i < length; ++i) result[i] = static_cast<wchar_t>(endian_swap(static_cast<wchar_selector<sizeof(wchar_t)>::type>(data[i])));
	}
#endif
PUGI__NS_END

PUGI__NS_BEGIN
	enum chartype_t
	{
		ct_parse_pcdata = 1,	// \0, &, \r, <
		ct_parse_attr = 2,		// \0, &, \r, ', "
		ct_parse_attr_ws = 4,	// \0, &, \r, ', ", \n, tab
		ct_space = 8,			// \r, \n, space, tab
		ct_parse_cdata = 16,	// \0, ], >, \r
		ct_parse_comment = 32,	// \0, -, >, \r
		ct_symbol = 64,			// Any symbol > 127, a-z, A-Z, 0-9, _, :, -, .
		ct_start_symbol = 128	// Any symbol > 127, a-z, A-Z, _, :
	};

	static const unsigned char chartype_table[256] =
	{
		55,  0,   0,   0,   0,   0,   0,   0,      0,   12,  12,  0,   0,   63,  0,   0,   // 0-15
		0,   0,   0,   0,   0,   0,   0,   0,      0,   0,   0,   0,   0,   0,   0,   0,   // 16-31
		8,   0,   6,   0,   0,   0,   7,   6,      0,   0,   0,   0,   0,   96,  64,  0,   // 32-47
		64,  64,  64,  64,  64,  64,  64,  64,     64,  64,  192, 0,   1,   0,   48,  0,   // 48-63
		0,   192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 64-79
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 0,   0,   16,  0,   192, // 80-95
		0,   192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 96-111
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 0, 0, 0, 0, 0,           // 112-127

		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 128+
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192
	};

	enum chartypex_t
	{
		ctx_special_pcdata = 1,   // Any symbol >= 0 and < 32 (except \t, \r, \n), &, <, >
		ctx_special_attr = 2,     // Any symbol >= 0 and < 32 (except \t), &, <, >, "
		ctx_start_symbol = 4,	  // Any symbol > 127, a-z, A-Z, _
		ctx_digit = 8,			  // 0-9
		ctx_symbol = 16			  // Any symbol > 127, a-z, A-Z, 0-9, _, -, .
	};
	
	static const unsigned char chartypex_table[256] =
	{
		3,  3,  3,  3,  3,  3,  3,  3,     3,  0,  2,  3,  3,  2,  3,  3,     // 0-15
		3,  3,  3,  3,  3,  3,  3,  3,     3,  3,  3,  3,  3,  3,  3,  3,     // 16-31
		0,  0,  2,  0,  0,  0,  3,  0,     0,  0,  0,  0,  0, 16, 16,  0,     // 32-47
		24, 24, 24, 24, 24, 24, 24, 24,    24, 24, 0,  0,  3,  0,  3,  0,     // 48-63

		0,  20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 64-79
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 0,  0,  0,  0,  20,    // 80-95
		0,  20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 96-111
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 0,  0,  0,  0,  0,     // 112-127

		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 128+
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20
	};
	
#ifdef PUGIXML_WCHAR_MODE
	#define PUGI__IS_CHARTYPE_IMPL(c, ct, table) ((static_cast<unsigned int>(c) < 128 ? table[static_cast<unsigned int>(c)] : table[128]) & (ct))
#else
	#define PUGI__IS_CHARTYPE_IMPL(c, ct, table) (table[static_cast<unsigned char>(c)] & (ct))
#endif

	#define PUGI__IS_CHARTYPE(c, ct) PUGI__IS_CHARTYPE_IMPL(c, ct, chartype_table)
	#define PUGI__IS_CHARTYPEX(c, ct) PUGI__IS_CHARTYPE_IMPL(c, ct, chartypex_table)

	PUGI__FN bool is_little_endian()
	{
		unsigned int ui = 1;

		return *reinterpret_cast<unsigned char*>(&ui) == 1;
	}

	PUGI__FN xml_encoding get_wchar_encoding()
	{
		PUGI__STATIC_ASSERT(sizeof(wchar_t) == 2 || sizeof(wchar_t) == 4);

		if (sizeof(wchar_t) == 2)
			return is_little_endian() ? encoding_utf16_le : encoding_utf16_be;
		else 
			return is_little_endian() ? encoding_utf32_le : encoding_utf32_be;
	}

	PUGI__FN xml_encoding guess_buffer_encoding(uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
	{
		// look for BOM in first few bytes
		if (d0 == 0 && d1 == 0 && d2 == 0xfe && d3 == 0xff) return encoding_utf32_be;
		if (d0 == 0xff && d1 == 0xfe && d2 == 0 && d3 == 0) return encoding_utf32_le;
		if (d0 == 0xfe && d1 == 0xff) return encoding_utf16_be;
		if (d0 == 0xff && d1 == 0xfe) return encoding_utf16_le;
		if (d0 == 0xef && d1 == 0xbb && d2 == 0xbf) return encoding_utf8;

		// look for <, <? or <?xm in various encodings
		if (d0 == 0 && d1 == 0 && d2 == 0 && d3 == 0x3c) return encoding_utf32_be;
		if (d0 == 0x3c && d1 == 0 && d2 == 0 && d3 == 0) return encoding_utf32_le;
		if (d0 == 0 && d1 == 0x3c && d2 == 0 && d3 == 0x3f) return encoding_utf16_be;
		if (d0 == 0x3c && d1 == 0 && d2 == 0x3f && d3 == 0) return encoding_utf16_le;
		if (d0 == 0x3c && d1 == 0x3f && d2 == 0x78 && d3 == 0x6d) return encoding_utf8;

		// look for utf16 < followed by node name (this may fail, but is better than utf8 since it's zero terminated so early)
		if (d0 == 0 && d1 == 0x3c) return encoding_utf16_be;
		if (d0 == 0x3c && d1 == 0) return encoding_utf16_le;

		// no known BOM detected, assume utf8
		return encoding_utf8;
	}

	PUGI__FN xml_encoding get_buffer_encoding(xml_encoding encoding, const void* contents, size_t size)
	{
		// replace wchar encoding with utf implementation
		if (encoding == encoding_wchar) return get_wchar_encoding();

		// replace utf16 encoding with utf16 with specific endianness
		if (encoding == encoding_utf16) return is_little_endian() ? encoding_utf16_le : encoding_utf16_be;

		// replace utf32 encoding with utf32 with specific endianness
		if (encoding == encoding_utf32) return is_little_endian() ? encoding_utf32_le : encoding_utf32_be;

		// only do autodetection if no explicit encoding is requested
		if (encoding != encoding_auto) return encoding;

		// skip encoding autodetection if input buffer is too small
		if (size < 4) return encoding_utf8;

		// try to guess encoding (based on XML specification, Appendix F.1)
		const uint8_t* data = static_cast<const uint8_t*>(contents);

		PUGI__DMC_VOLATILE uint8_t d0 = data[0], d1 = data[1], d2 = data[2], d3 = data[3];

		return guess_buffer_encoding(d0, d1, d2, d3);
	}

	PUGI__FN bool get_mutable_buffer(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)
	{
		size_t length = size / sizeof(char_t);

		if (is_mutable)
		{
			out_buffer = static_cast<char_t*>(const_cast<void*>(contents));
			out_length = length;
		}
		else
		{
			char_t* buffer = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
			if (!buffer) return false;

			memcpy(buffer, contents, length * sizeof(char_t));
			buffer[length] = 0;

			out_buffer = buffer;
			out_length = length + 1;
		}

		return true;
	}

#ifdef PUGIXML_WCHAR_MODE
	PUGI__FN bool need_endian_swap_utf(xml_encoding le, xml_encoding re)
	{
		return (le == encoding_utf16_be && re == encoding_utf16_le) || (le == encoding_utf16_le && re == encoding_utf16_be) ||
			   (le == encoding_utf32_be && re == encoding_utf32_le) || (le == encoding_utf32_le && re == encoding_utf32_be);
	}

	PUGI__FN bool convert_buffer_endian_swap(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)
	{
		const char_t* data = static_cast<const char_t*>(contents);
		size_t length = size / sizeof(char_t);

		if (is_mutable)
		{
			char_t* buffer = const_cast<char_t*>(data);

			convert_wchar_endian_swap(buffer, data, length);

			out_buffer = buffer;
			out_length = length;
		}
		else
		{
			char_t* buffer = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
			if (!buffer) return false;

			convert_wchar_endian_swap(buffer, data, length);
			buffer[length] = 0;

			out_buffer = buffer;
			out_length = length + 1;
		}

		return true;
	}

	PUGI__FN bool convert_buffer_utf8(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size)
	{
		const uint8_t* data = static_cast<const uint8_t*>(contents);
		size_t data_length = size;

		// first pass: get length in wchar_t units
		size_t length = utf_decoder<wchar_counter>::decode_utf8_block(data, data_length, 0);

		// allocate buffer of suitable length
		char_t* buffer = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
		if (!buffer) return false;

		// second pass: convert utf8 input to wchar_t
		wchar_writer::value_type obegin = reinterpret_cast<wchar_writer::value_type>(buffer);
		wchar_writer::value_type oend = utf_decoder<wchar_writer>::decode_utf8_block(data, data_length, obegin);

		assert(oend == obegin + length);
		*oend = 0;

		out_buffer = buffer;
		out_length = length + 1;

		return true;
	}

	template <typename opt_swap> PUGI__FN bool convert_buffer_utf16(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, opt_swap)
	{
		const uint16_t* data = static_cast<const uint16_t*>(contents);
		size_t data_length = size / sizeof(uint16_t);

		// first pass: get length in wchar_t units
		size_t length = utf_decoder<wchar_counter, opt_swap>::decode_utf16_block(data, data_length, 0);

		// allocate buffer of suitable length
		char_t* buffer = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
		if (!buffer) return false;

		// second pass: convert utf16 input to wchar_t
		wchar_writer::value_type obegin = reinterpret_cast<wchar_writer::value_type>(buffer);
		wchar_writer::value_type oend = utf_decoder<wchar_writer, opt_swap>::decode_utf16_block(data, data_length, obegin);

		assert(oend == obegin + length);
		*oend = 0;

		out_buffer = buffer;
		out_length = length + 1;

		return true;
	}

	template <typename opt_swap> PUGI__FN bool convert_buffer_utf32(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, opt_swap)
	{
		const uint32_t* data = static_cast<const uint32_t*>(contents);
		size_t data_length = size / sizeof(uint32_t);

		// first pass: get length in wchar_t units
		size_t length = utf_decoder<wchar_counter, opt_swap>::decode_utf32_block(data, data_length, 0);

		// allocate buffer of suitable length
		char_t* buffer = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
		if (!buffer) return false;

		// second pass: convert utf32 input to wchar_t
		wchar_writer::value_type obegin = reinterpret_cast<wchar_writer::value_type>(buffer);
		wchar_writer::value_type oend = utf_decoder<wchar_writer, opt_swap>::decode_utf32_block(data, data_length, obegin);

		assert(oend == obegin + length);
		*oend = 0;

		out_buffer = buffer;
		out_length = length + 1;

		return true;
	}

	PUGI__FN bool convert_buffer_latin1(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size)
	{
		const uint8_t* data = static_cast<const uint8_t*>(contents);
		size_t data_length = size;

		// get length in wchar_t units
		size_t length = data_length;

		// allocate buffer of suitable length
		char_t* buffer = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
		if (!buffer) return false;

		// convert latin1 input to wchar_t
		wchar_writer::value_type obegin = reinterpret_cast<wchar_writer::value_type>(buffer);
		wchar_writer::value_type oend = utf_decoder<wchar_writer>::decode_latin1_block(data, data_length, obegin);

		assert(oend == obegin + length);
		*oend = 0;

		out_buffer = buffer;
		out_length = length + 1;

		return true;
	}

	PUGI__FN bool convert_buffer(char_t*& out_buffer, size_t& out_length, xml_encoding encoding, const void* contents, size_t size, bool is_mutable)
	{
		// get native encoding
		xml_encoding wchar_encoding = get_wchar_encoding();

		// fast path: no conversion required
		if (encoding == wchar_encoding) return get_mutable_buffer(out_buffer, out_length, contents, size, is_mutable);

		// only endian-swapping is required
		if (need_endian_swap_utf(encoding, wchar_encoding)) return convert_buffer_endian_swap(out_buffer, out_length, contents, size, is_mutable);

		// source encoding is utf8
		if (encoding == encoding_utf8) return convert_buffer_utf8(out_buffer, out_length, contents, size);

		// source encoding is utf16
		if (encoding == encoding_utf16_be || encoding == encoding_utf16_le)
		{
			xml_encoding native_encoding = is_little_endian() ? encoding_utf16_le : encoding_utf16_be;

			return (native_encoding == encoding) ?
				convert_buffer_utf16(out_buffer, out_length, contents, size, opt_false()) :
				convert_buffer_utf16(out_buffer, out_length, contents, size, opt_true());
		}

		// source encoding is utf32
		if (encoding == encoding_utf32_be || encoding == encoding_utf32_le)
		{
			xml_encoding native_encoding = is_little_endian() ? encoding_utf32_le : encoding_utf32_be;

			return (native_encoding == encoding) ?
				convert_buffer_utf32(out_buffer, out_length, contents, size, opt_false()) :
				convert_buffer_utf32(out_buffer, out_length, contents, size, opt_true());
		}

		// source encoding is latin1
		if (encoding == encoding_latin1) return convert_buffer_latin1(out_buffer, out_length, contents, size);

		assert(!"Invalid encoding");
		return false;
	}
#else
	template <typename opt_swap> PUGI__FN bool convert_buffer_utf16(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, opt_swap)
	{
		const uint16_t* data = static_cast<const uint16_t*>(contents);
		size_t data_length = size / sizeof(uint16_t);

		// first pass: get length in utf8 units
		size_t length = utf_decoder<utf8_counter, opt_swap>::decode_utf16_block(data, data_length, 0);

		// allocate buffer of suitable length
		char_t* buffer = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
		if (!buffer) return false;

		// second pass: convert utf16 input to utf8
		uint8_t* obegin = reinterpret_cast<uint8_t*>(buffer);
		uint8_t* oend = utf_decoder<utf8_writer, opt_swap>::decode_utf16_block(data, data_length, obegin);

		assert(oend == obegin + length);
		*oend = 0;

		out_buffer = buffer;
		out_length = length + 1;

		return true;
	}

	template <typename opt_swap> PUGI__FN bool convert_buffer_utf32(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, opt_swap)
	{
		const uint32_t* data = static_cast<const uint32_t*>(contents);
		size_t data_length = size / sizeof(uint32_t);

		// first pass: get length in utf8 units
		size_t length = utf_decoder<utf8_counter, opt_swap>::decode_utf32_block(data, data_length, 0);

		// allocate buffer of suitable length
		char_t* buffer = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
		if (!buffer) return false;

		// second pass: convert utf32 input to utf8
		uint8_t* obegin = reinterpret_cast<uint8_t*>(buffer);
		uint8_t* oend = utf_decoder<utf8_writer, opt_swap>::decode_utf32_block(data, data_length, obegin);

		assert(oend == obegin + length);
		*oend = 0;

		out_buffer = buffer;
		out_length = length + 1;

		return true;
	}

	PUGI__FN size_t get_latin1_7bit_prefix_length(const uint8_t* data, size_t size)
	{
		for (size_t i = 0; i < size; ++i)
			if (data[i] > 127)
				return i;

		return size;
	}

	PUGI__FN bool convert_buffer_latin1(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)
	{
		const uint8_t* data = static_cast<const uint8_t*>(contents);
		size_t data_length = size;

		// get size of prefix that does not need utf8 conversion
		size_t prefix_length = get_latin1_7bit_prefix_length(data, data_length);
		assert(prefix_length <= data_length);

		const uint8_t* postfix = data + prefix_length;
		size_t postfix_length = data_length - prefix_length;

		// if no conversion is needed, just return the original buffer
		if (postfix_length == 0) return get_mutable_buffer(out_buffer, out_length, contents, size, is_mutable);

		// first pass: get length in utf8 units
		size_t length = prefix_length + utf_decoder<utf8_counter>::decode_latin1_block(postfix, postfix_length, 0);

		// allocate buffer of suitable length
		char_t* buffer = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
		if (!buffer) return false;

		// second pass: convert latin1 input to utf8
		memcpy(buffer, data, prefix_length);

		uint8_t* obegin = reinterpret_cast<uint8_t*>(buffer);
		uint8_t* oend = utf_decoder<utf8_writer>::decode_latin1_block(postfix, postfix_length, obegin + prefix_length);

		assert(oend == obegin + length);
		*oend = 0;

		out_buffer = buffer;
		out_length = length + 1;

		return true;
	}

	PUGI__FN bool convert_buffer(char_t*& out_buffer, size_t& out_length, xml_encoding encoding, const void* contents, size_t size, bool is_mutable)
	{
		// fast path: no conversion required
		if (encoding == encoding_utf8) return get_mutable_buffer(out_buffer, out_length, contents, size, is_mutable);

		// source encoding is utf16
		if (encoding == encoding_utf16_be || encoding == encoding_utf16_le)
		{
			xml_encoding native_encoding = is_little_endian() ? encoding_utf16_le : encoding_utf16_be;

			return (native_encoding == encoding) ?
				convert_buffer_utf16(out_buffer, out_length, contents, size, opt_false()) :
				convert_buffer_utf16(out_buffer, out_length, contents, size, opt_true());
		}

		// source encoding is utf32
		if (encoding == encoding_utf32_be || encoding == encoding_utf32_le)
		{
			xml_encoding native_encoding = is_little_endian() ? encoding_utf32_le : encoding_utf32_be;

			return (native_encoding == encoding) ?
				convert_buffer_utf32(out_buffer, out_length, contents, size, opt_false()) :
				convert_buffer_utf32(out_buffer, out_length, contents, size, opt_true());
		}

		// source encoding is latin1
		if (encoding == encoding_latin1) return convert_buffer_latin1(out_buffer, out_length, contents, size, is_mutable);

		assert(!"Invalid encoding");
		return false;
	}
#endif

	PUGI__FN size_t as_utf8_begin(const wchar_t* str, size_t length)
	{
		// get length in utf8 characters
		return utf_decoder<utf8_counter>::decode_wchar_block(str, length, 0);
	}

	PUGI__FN void as_utf8_end(char* buffer, size_t size, const wchar_t* str, size_t length)
	{
		// convert to utf8
		uint8_t* begin = reinterpret_cast<uint8_t*>(buffer);
		uint8_t* end = utf_decoder<utf8_writer>::decode_wchar_block(str, length, begin);
	
		assert(begin + size == end);
		(void)!end;

		// zero-terminate
		buffer[size] = 0;
	}
	
#ifndef PUGIXML_NO_STL
	PUGI__FN std::string as_utf8_impl(const wchar_t* str, size_t length)
	{
		// first pass: get length in utf8 characters
		size_t size = as_utf8_begin(str, length);

		// allocate resulting string
		std::string result;
		result.resize(size);

		// second pass: convert to utf8
		if (size > 0) as_utf8_end(&result[0], size, str, length);

		return result;
	}

	PUGI__FN std::basic_string<wchar_t> as_wide_impl(const char* str, size_t size)
	{
		const uint8_t* data = reinterpret_cast<const uint8_t*>(str);

		// first pass: get length in wchar_t units
		size_t length = utf_decoder<wchar_counter>::decode_utf8_block(data, size, 0);

		// allocate resulting string
		std::basic_string<wchar_t> result;
		result.resize(length);

		// second pass: convert to wchar_t
		if (length > 0)
		{
			wchar_writer::value_type begin = reinterpret_cast<wchar_writer::value_type>(&result[0]);
			wchar_writer::value_type end = utf_decoder<wchar_writer>::decode_utf8_block(data, size, begin);

			assert(begin + length == end);
			(void)!end;
		}

		return result;
	}
#endif

	inline bool strcpy_insitu_allow(size_t length, uintptr_t allocated, char_t* target)
	{
		assert(target);
		size_t target_length = strlength(target);

		// always reuse document buffer memory if possible
		if (!allocated) return target_length >= length;

		// reuse heap memory if waste is not too great
		const size_t reuse_threshold = 32;

		return target_length >= length && (target_length < reuse_threshold || target_length - length < target_length / 2);
	}

	PUGI__FN bool strcpy_insitu(char_t*& dest, uintptr_t& header, uintptr_t header_mask, const char_t* source)
	{
		assert(header);

		size_t source_length = strlength(source);

		if (source_length == 0)
		{
			// empty string and null pointer are equivalent, so just deallocate old memory
			xml_allocator* alloc = reinterpret_cast<xml_memory_page*>(header & xml_memory_page_pointer_mask)->allocator;

			if (header & header_mask) alloc->deallocate_string(dest);
			
			// mark the string as not allocated
			dest = 0;
			header &= ~header_mask;

			return true;
		}
		else if (dest && strcpy_insitu_allow(source_length, header & header_mask, dest))
		{
			// we can reuse old buffer, so just copy the new data (including zero terminator)
			memcpy(dest, source, (source_length + 1) * sizeof(char_t));
			
			return true;
		}
		else
		{
			xml_allocator* alloc = reinterpret_cast<xml_memory_page*>(header & xml_memory_page_pointer_mask)->allocator;

			// allocate new buffer
			char_t* buf = alloc->allocate_string(source_length + 1);
			if (!buf) return false;

			// copy the string (including zero terminator)
			memcpy(buf, source, (source_length + 1) * sizeof(char_t));

			// deallocate old buffer (*after* the above to protect against overlapping memory and/or allocation failures)
			if (header & header_mask) alloc->deallocate_string(dest);
			
			// the string is now allocated, so set the flag
			dest = buf;
			header |= header_mask;

			return true;
		}
	}

	struct gap
	{
		char_t* end;
		size_t size;
			
		gap(): end(0), size(0)
		{
		}
			
		// Push new gap, move s count bytes further (skipping the gap).
		// Collapse previous gap.
		void push(char_t*& s, size_t count)
		{
			if (end) // there was a gap already; collapse it
			{
				// Move [old_gap_end, new_gap_start) to [old_gap_start, ...)
				assert(s >= end);
				memmove(end - size, end, reinterpret_cast<char*>(s) - reinterpret_cast<char*>(end));
			}
				
			s += count; // end of current gap
				
			// "merge" two gaps
			end = s;
			size += count;
		}
			
		// Collapse all gaps, return past-the-end pointer
		char_t* flush(char_t* s)
		{
			if (end)
			{
				// Move [old_gap_end, current_pos) to [old_gap_start, ...)
				assert(s >= end);
				memmove(end - size, end, reinterpret_cast<char*>(s) - reinterpret_cast<char*>(end));

				return s - size;
			}
			else return s;
		}
	};
	
	PUGI__FN char_t* strconv_escape(char_t* s, gap& g)
	{
		char_t* stre = s + 1;

		switch (*stre)
		{
			case '#':	// &#...
			{
				unsigned int ucsc = 0;

				if (stre[1] == 'x') // &#x... (hex code)
				{
					stre += 2;

					char_t ch = *stre;

					if (ch == ';') return stre;

					for (;;)
					{
						if (static_cast<unsigned int>(ch - '0') <= 9)
							ucsc = 16 * ucsc + (ch - '0');
						else if (static_cast<unsigned int>((ch | ' ') - 'a') <= 5)
							ucsc = 16 * ucsc + ((ch | ' ') - 'a' + 10);
						else if (ch == ';')
							break;
						else // cancel
							return stre;

						ch = *++stre;
					}
					
					++stre;
				}
				else	// &#... (dec code)
				{
					char_t ch = *++stre;

					if (ch == ';') return stre;

					for (;;)
					{
						if (static_cast<unsigned int>(static_cast<unsigned int>(ch) - '0') <= 9)
							ucsc = 10 * ucsc + (ch - '0');
						else if (ch == ';')
							break;
						else // cancel
							return stre;

						ch = *++stre;
					}
					
					++stre;
				}

			#ifdef PUGIXML_WCHAR_MODE
				s = reinterpret_cast<char_t*>(wchar_writer::any(reinterpret_cast<wchar_writer::value_type>(s), ucsc));
			#else
				s = reinterpret_cast<char_t*>(utf8_writer::any(reinterpret_cast<uint8_t*>(s), ucsc));
			#endif
					
				g.push(s, stre - s);
				return stre;
			}

			case 'a':	// &a
			{
				++stre;

				if (*stre == 'm') // &am
				{
					if (*++stre == 'p' && *++stre == ';') // &amp;
					{
						*s++ = '&';
						++stre;
							
						g.push(s, stre - s);
						return stre;
					}
				}
				else if (*stre == 'p') // &ap
				{
					if (*++stre == 'o' && *++stre == 's' && *++stre == ';') // &apos;
					{
						*s++ = '\'';
						++stre;

						g.push(s, stre - s);
						return stre;
					}
				}
				break;
			}

			case 'g': // &g
			{
				if (*++stre == 't' && *++stre == ';') // &gt;
				{
					*s++ = '>';
					++stre;
					
					g.push(s, stre - s);
					return stre;
				}
				break;
			}

			case 'l': // &l
			{
				if (*++stre == 't' && *++stre == ';') // &lt;
				{
					*s++ = '<';
					++stre;
						
					g.push(s, stre - s);
					return stre;
				}
				break;
			}

			case 'q': // &q
			{
				if (*++stre == 'u' && *++stre == 'o' && *++stre == 't' && *++stre == ';') // &quot;
				{
					*s++ = '"';
					++stre;
					
					g.push(s, stre - s);
					return stre;
				}
				break;
			}

			default:
				break;
		}
		
		return stre;
	}

	// Utility macro for last character handling
	#define ENDSWITH(c, e) ((c) == (e) || ((c) == 0 && endch == (e)))

	PUGI__FN char_t* strconv_comment(char_t* s, char_t endch)
	{
		gap g;
		
		while (true)
		{
			while (!PUGI__IS_CHARTYPE(*s, ct_parse_comment)) ++s;
		
			if (*s == '\r') // Either a single 0x0d or 0x0d 0x0a pair
			{
				*s++ = '\n'; // replace first one with 0x0a
				
				if (*s == '\n') g.push(s, 1);
			}
			else if (s[0] == '-' && s[1] == '-' && ENDSWITH(s[2], '>')) // comment ends here
			{
				*g.flush(s) = 0;
				
				return s + (s[2] == '>' ? 3 : 2);
			}
			else if (*s == 0)
			{
				return 0;
			}
			else ++s;
		}
	}

	PUGI__FN char_t* strconv_cdata(char_t* s, char_t endch)
	{
		gap g;
			
		while (true)
		{
			while (!PUGI__IS_CHARTYPE(*s, ct_parse_cdata)) ++s;
			
			if (*s == '\r') // Either a single 0x0d or 0x0d 0x0a pair
			{
				*s++ = '\n'; // replace first one with 0x0a
				
				if (*s == '\n') g.push(s, 1);
			}
			else if (s[0] == ']' && s[1] == ']' && ENDSWITH(s[2], '>')) // CDATA ends here
			{
				*g.flush(s) = 0;
				
				return s + 1;
			}
			else if (*s == 0)
			{
				return 0;
			}
			else ++s;
		}
	}
	
	typedef char_t* (*strconv_pcdata_t)(char_t*);
		
	template <typename opt_trim, typename opt_eol, typename opt_escape> struct strconv_pcdata_impl
	{
		static char_t* parse(char_t* s)
		{
			gap g;

			char_t* begin = s;

			while (true)
			{
				while (!PUGI__IS_CHARTYPE(*s, ct_parse_pcdata)) ++s;
					
				if (*s == '<') // PCDATA ends here
				{
					char_t* end = g.flush(s);

					if (opt_trim::value)
						while (end > begin && PUGI__IS_CHARTYPE(end[-1], ct_space))
							--end;

					*end = 0;
					
					return s + 1;
				}
				else if (opt_eol::value && *s == '\r') // Either a single 0x0d or 0x0d 0x0a pair
				{
					*s++ = '\n'; // replace first one with 0x0a
					
					if (*s == '\n') g.push(s, 1);
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (*s == 0)
				{
					char_t* end = g.flush(s);

					if (opt_trim::value)
						while (end > begin && PUGI__IS_CHARTYPE(end[-1], ct_space))
							--end;

					*end = 0;

					return s;
				}
				else ++s;
			}
		}
	};
	
	PUGI__FN strconv_pcdata_t get_strconv_pcdata(unsigned int optmask)
	{
		PUGI__STATIC_ASSERT(parse_escapes == 0x10 && parse_eol == 0x20 && parse_trim_pcdata == 0x0800);

		switch (((optmask >> 4) & 3) | ((optmask >> 9) & 4)) // get bitmask for flags (eol escapes trim)
		{
		case 0: return strconv_pcdata_impl<opt_false, opt_false, opt_false>::parse;
		case 1: return strconv_pcdata_impl<opt_false, opt_false, opt_true>::parse;
		case 2: return strconv_pcdata_impl<opt_false, opt_true, opt_false>::parse;
		case 3: return strconv_pcdata_impl<opt_false, opt_true, opt_true>::parse;
		case 4: return strconv_pcdata_impl<opt_true, opt_false, opt_false>::parse;
		case 5: return strconv_pcdata_impl<opt_true, opt_false, opt_true>::parse;
		case 6: return strconv_pcdata_impl<opt_true, opt_true, opt_false>::parse;
		case 7: return strconv_pcdata_impl<opt_true, opt_true, opt_true>::parse;
		default: assert(false); return 0; // should not get here
		}
	}

	typedef char_t* (*strconv_attribute_t)(char_t*, char_t);
	
	template <typename opt_escape> struct strconv_attribute_impl
	{
		static char_t* parse_wnorm(char_t* s, char_t end_quote)
		{
			gap g;

			// trim leading whitespaces
			if (PUGI__IS_CHARTYPE(*s, ct_space))
			{
				char_t* str = s;
				
				do ++str;
				while (PUGI__IS_CHARTYPE(*str, ct_space));
				
				g.push(s, str - s);
			}

			while (true)
			{
				while (!PUGI__IS_CHARTYPE(*s, ct_parse_attr_ws | ct_space)) ++s;
				
				if (*s == end_quote)
				{
					char_t* str = g.flush(s);
					
					do *str-- = 0;
					while (PUGI__IS_CHARTYPE(*str, ct_space));
				
					return s + 1;
				}
				else if (PUGI__IS_CHARTYPE(*s, ct_space))
				{
					*s++ = ' ';
		
					if (PUGI__IS_CHARTYPE(*s, ct_space))
					{
						char_t* str = s + 1;
						while (PUGI__IS_CHARTYPE(*str, ct_space)) ++str;
						
						g.push(s, str - s);
					}
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}

		static char_t* parse_wconv(char_t* s, char_t end_quote)
		{
			gap g;

			while (true)
			{
				while (!PUGI__IS_CHARTYPE(*s, ct_parse_attr_ws)) ++s;
				
				if (*s == end_quote)
				{
					*g.flush(s) = 0;
				
					return s + 1;
				}
				else if (PUGI__IS_CHARTYPE(*s, ct_space))
				{
					if (*s == '\r')
					{
						*s++ = ' ';
				
						if (*s == '\n') g.push(s, 1);
					}
					else *s++ = ' ';
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}

		static char_t* parse_eol(char_t* s, char_t end_quote)
		{
			gap g;

			while (true)
			{
				while (!PUGI__IS_CHARTYPE(*s, ct_parse_attr)) ++s;
				
				if (*s == end_quote)
				{
					*g.flush(s) = 0;
				
					return s + 1;
				}
				else if (*s == '\r')
				{
					*s++ = '\n';
					
					if (*s == '\n') g.push(s, 1);
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}

		static char_t* parse_simple(char_t* s, char_t end_quote)
		{
			gap g;

			while (true)
			{
				while (!PUGI__IS_CHARTYPE(*s, ct_parse_attr)) ++s;
				
				if (*s == end_quote)
				{
					*g.flush(s) = 0;
				
					return s + 1;
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}
	};

	PUGI__FN strconv_attribute_t get_strconv_attribute(unsigned int optmask)
	{
		PUGI__STATIC_ASSERT(parse_escapes == 0x10 && parse_eol == 0x20 && parse_wconv_attribute == 0x40 && parse_wnorm_attribute == 0x80);
		
		switch ((optmask >> 4) & 15) // get bitmask for flags (wconv wnorm eol escapes)
		{
		case 0:  return strconv_attribute_impl<opt_false>::parse_simple;
		case 1:  return strconv_attribute_impl<opt_true>::parse_simple;
		case 2:  return strconv_attribute_impl<opt_false>::parse_eol;
		case 3:  return strconv_attribute_impl<opt_true>::parse_eol;
		case 4:  return strconv_attribute_impl<opt_false>::parse_wconv;
		case 5:  return strconv_attribute_impl<opt_true>::parse_wconv;
		case 6:  return strconv_attribute_impl<opt_false>::parse_wconv;
		case 7:  return strconv_attribute_impl<opt_true>::parse_wconv;
		case 8:  return strconv_attribute_impl<opt_false>::parse_wnorm;
		case 9:  return strconv_attribute_impl<opt_true>::parse_wnorm;
		case 10: return strconv_attribute_impl<opt_false>::parse_wnorm;
		case 11: return strconv_attribute_impl<opt_true>::parse_wnorm;
		case 12: return strconv_attribute_impl<opt_false>::parse_wnorm;
		case 13: return strconv_attribute_impl<opt_true>::parse_wnorm;
		case 14: return strconv_attribute_impl<opt_false>::parse_wnorm;
		case 15: return strconv_attribute_impl<opt_true>::parse_wnorm;
		default: assert(false); return 0; // should not get here
		}
	}

	inline xml_parse_result make_parse_result(xml_parse_status status, ptrdiff_t offset = 0)
	{
		xml_parse_result result;
		result.status = status;
		result.offset = offset;

		return result;
	}

	struct xml_parser
	{
		xml_allocator alloc;
		char_t* error_offset;
		xml_parse_status error_status;
		
		// Parser utilities.
		#define PUGI__SKIPWS()			{ while (PUGI__IS_CHARTYPE(*s, ct_space)) ++s; }
		#define PUGI__OPTSET(OPT)			( optmsk & (OPT) )
		#define PUGI__PUSHNODE(TYPE)		{ cursor = append_node(cursor, alloc, TYPE); if (!cursor) PUGI__THROW_ERROR(status_out_of_memory, s); }
		#define PUGI__POPNODE()			{ cursor = cursor->parent; }
		#define PUGI__SCANFOR(X)			{ while (*s != 0 && !(X)) ++s; }
		#define PUGI__SCANWHILE(X)		{ while ((X)) ++s; }
		#define PUGI__ENDSEG()			{ ch = *s; *s = 0; ++s; }
		#define PUGI__THROW_ERROR(err, m)	return error_offset = m, error_status = err, static_cast<char_t*>(0)
		#define PUGI__CHECK_ERROR(err, m)	{ if (*s == 0) PUGI__THROW_ERROR(err, m); }
		
		xml_parser(const xml_allocator& alloc_): alloc(alloc_), error_offset(0), error_status(status_ok)
		{
		}

		// DOCTYPE consists of nested sections of the following possible types:
		// <!-- ... -->, <? ... ?>, "...", '...'
		// <![...]]>
		// <!...>
		// First group can not contain nested groups
		// Second group can contain nested groups of the same type
		// Third group can contain all other groups
		char_t* parse_doctype_primitive(char_t* s)
		{
			if (*s == '"' || *s == '\'')
			{
				// quoted string
				char_t ch = *s++;
				PUGI__SCANFOR(*s == ch);
				if (!*s) PUGI__THROW_ERROR(status_bad_doctype, s);

				s++;
			}
			else if (s[0] == '<' && s[1] == '?')
			{
				// <? ... ?>
				s += 2;
				PUGI__SCANFOR(s[0] == '?' && s[1] == '>'); // no need for ENDSWITH because ?> can't terminate proper doctype
				if (!*s) PUGI__THROW_ERROR(status_bad_doctype, s);

				s += 2;
			}
			else if (s[0] == '<' && s[1] == '!' && s[2] == '-' && s[3] == '-')
			{
				s += 4;
				PUGI__SCANFOR(s[0] == '-' && s[1] == '-' && s[2] == '>'); // no need for ENDSWITH because --> can't terminate proper doctype
				if (!*s) PUGI__THROW_ERROR(status_bad_doctype, s);

				s += 4;
			}
			else PUGI__THROW_ERROR(status_bad_doctype, s);

			return s;
		}

		char_t* parse_doctype_ignore(char_t* s)
		{
			assert(s[0] == '<' && s[1] == '!' && s[2] == '[');
			s++;

			while (*s)
			{
				if (s[0] == '<' && s[1] == '!' && s[2] == '[')
				{
					// nested ignore section
					s = parse_doctype_ignore(s);
					if (!s) return s;
				}
				else if (s[0] == ']' && s[1] == ']' && s[2] == '>')
				{
					// ignore section end
					s += 3;

					return s;
				}
				else s++;
			}

			PUGI__THROW_ERROR(status_bad_doctype, s);
		}

		char_t* parse_doctype_group(char_t* s, char_t endch, bool toplevel)
		{
			assert((s[0] == '<' || s[0] == 0) && s[1] == '!');
			s++;

			while (*s)
			{
				if (s[0] == '<' && s[1] == '!' && s[2] != '-')
				{
					if (s[2] == '[')
					{
						// ignore
						s = parse_doctype_ignore(s);
						if (!s) return s;
					}
					else
					{
						// some control group
						s = parse_doctype_group(s, endch, false);
						if (!s) return s;

						// skip >
						assert(*s == '>');
						s++;
					}
				}
				else if (s[0] == '<' || s[0] == '"' || s[0] == '\'')
				{
					// unknown tag (forbidden), or some primitive group
					s = parse_doctype_primitive(s);
					if (!s) return s;
				}
				else if (*s == '>')
				{
					return s;
				}
				else s++;
			}

			if (!toplevel || endch != '>') PUGI__THROW_ERROR(status_bad_doctype, s);

			return s;
		}

		char_t* parse_exclamation(char_t* s, xml_node_struct* cursor, unsigned int optmsk, char_t endch)
		{
			// parse node contents, starting with exclamation mark
			++s;

			if (*s == '-') // '<!-...'
			{
				++s;

				if (*s == '-') // '<!--...'
				{
					++s;

					if (PUGI__OPTSET(parse_comments))
					{
						PUGI__PUSHNODE(node_comment); // Append a new node on the tree.
						cursor->value = s; // Save the offset.
					}

					if (PUGI__OPTSET(parse_eol) && PUGI__OPTSET(parse_comments))
					{
						s = strconv_comment(s, endch);

						if (!s) PUGI__THROW_ERROR(status_bad_comment, cursor->value);
					}
					else
					{
						// Scan for terminating '-->'.
						PUGI__SCANFOR(s[0] == '-' && s[1] == '-' && ENDSWITH(s[2], '>'));
						PUGI__CHECK_ERROR(status_bad_comment, s);

						if (PUGI__OPTSET(parse_comments))
							*s = 0; // Zero-terminate this segment at the first terminating '-'.

						s += (s[2] == '>' ? 3 : 2); // Step over the '\0->'.
					}
				}
				else PUGI__THROW_ERROR(status_bad_comment, s);
			}
			else if (*s == '[')
			{
				// '<![CDATA[...'
				if (*++s=='C' && *++s=='D' && *++s=='A' && *++s=='T' && *++s=='A' && *++s == '[')
				{
					++s;

					if (PUGI__OPTSET(parse_cdata))
					{
						PUGI__PUSHNODE(node_cdata); // Append a new node on the tree.
						cursor->value = s; // Save the offset.

						if (PUGI__OPTSET(parse_eol))
						{
							s = strconv_cdata(s, endch);

							if (!s) PUGI__THROW_ERROR(status_bad_cdata, cursor->value);
						}
						else
						{
							// Scan for terminating ']]>'.
							PUGI__SCANFOR(s[0] == ']' && s[1] == ']' && ENDSWITH(s[2], '>'));
							PUGI__CHECK_ERROR(status_bad_cdata, s);

							*s++ = 0; // Zero-terminate this segment.
						}
					}
					else // Flagged for discard, but we still have to scan for the terminator.
					{
						// Scan for terminating ']]>'.
						PUGI__SCANFOR(s[0] == ']' && s[1] == ']' && ENDSWITH(s[2], '>'));
						PUGI__CHECK_ERROR(status_bad_cdata, s);

						++s;
					}

					s += (s[1] == '>' ? 2 : 1); // Step over the last ']>'.
				}
				else PUGI__THROW_ERROR(status_bad_cdata, s);
			}
			else if (s[0] == 'D' && s[1] == 'O' && s[2] == 'C' && s[3] == 'T' && s[4] == 'Y' && s[5] == 'P' && ENDSWITH(s[6], 'E'))
			{
				s -= 2;

				if (cursor->parent) PUGI__THROW_ERROR(status_bad_doctype, s);

				char_t* mark = s + 9;

				s = parse_doctype_group(s, endch, true);
				if (!s) return s;

				assert((*s == 0 && endch == '>') || *s == '>');
				if (*s) *s++ = 0;

				if (PUGI__OPTSET(parse_doctype))
				{
					while (PUGI__IS_CHARTYPE(*mark, ct_space)) ++mark;

					PUGI__PUSHNODE(node_doctype);

					cursor->value = mark;

					PUGI__POPNODE();
				}
			}
			else if (*s == 0 && endch == '-') PUGI__THROW_ERROR(status_bad_comment, s);
			else if (*s == 0 && endch == '[') PUGI__THROW_ERROR(status_bad_cdata, s);
			else PUGI__THROW_ERROR(status_unrecognized_tag, s);

			return s;
		}

		char_t* parse_question(char_t* s, xml_node_struct*& ref_cursor, unsigned int optmsk, char_t endch)
		{
			// load into registers
			xml_node_struct* cursor = ref_cursor;
			char_t ch = 0;

			// parse node contents, starting with question mark
			++s;

			// read PI target
			char_t* target = s;

			if (!PUGI__IS_CHARTYPE(*s, ct_start_symbol)) PUGI__THROW_ERROR(status_bad_pi, s);

			PUGI__SCANWHILE(PUGI__IS_CHARTYPE(*s, ct_symbol));
			PUGI__CHECK_ERROR(status_bad_pi, s);

			// determine node type; stricmp / strcasecmp is not portable
			bool declaration = (target[0] | ' ') == 'x' && (target[1] | ' ') == 'm' && (target[2] | ' ') == 'l' && target + 3 == s;

			if (declaration ? PUGI__OPTSET(parse_declaration) : PUGI__OPTSET(parse_pi))
			{
				if (declaration)
				{
					// disallow non top-level declarations
					if (cursor->parent) PUGI__THROW_ERROR(status_bad_pi, s);

					PUGI__PUSHNODE(node_declaration);
				}
				else
				{
					PUGI__PUSHNODE(node_pi);
				}

				cursor->name = target;

				PUGI__ENDSEG();

				// parse value/attributes
				if (ch == '?')
				{
					// empty node
					if (!ENDSWITH(*s, '>')) PUGI__THROW_ERROR(status_bad_pi, s);
					s += (*s == '>');

					PUGI__POPNODE();
				}
				else if (PUGI__IS_CHARTYPE(ch, ct_space))
				{
					PUGI__SKIPWS();

					// scan for tag end
					char_t* value = s;

					PUGI__SCANFOR(s[0] == '?' && ENDSWITH(s[1], '>'));
					PUGI__CHECK_ERROR(status_bad_pi, s);

					if (declaration)
					{
						// replace ending ? with / so that 'element' terminates properly
						*s = '/';

						// we exit from this function with cursor at node_declaration, which is a signal to parse() to go to LOC_ATTRIBUTES
						s = value;
					}
					else
					{
						// store value and step over >
						cursor->value = value;
						PUGI__POPNODE();

						PUGI__ENDSEG();

						s += (*s == '>');
					}
				}
				else PUGI__THROW_ERROR(status_bad_pi, s);
			}
			else
			{
				// scan for tag end
				PUGI__SCANFOR(s[0] == '?' && ENDSWITH(s[1], '>'));
				PUGI__CHECK_ERROR(status_bad_pi, s);

				s += (s[1] == '>' ? 2 : 1);
			}

			// store from registers
			ref_cursor = cursor;

			return s;
		}

		char_t* parse_tree(char_t* s, xml_node_struct* root, unsigned int optmsk, char_t endch)
		{
			strconv_attribute_t strconv_attribute = get_strconv_attribute(optmsk);
			strconv_pcdata_t strconv_pcdata = get_strconv_pcdata(optmsk);
			
			char_t ch = 0;
			xml_node_struct* cursor = root;
			char_t* mark = s;

			while (*s != 0)
			{
				if (*s == '<')
				{
					++s;

				LOC_TAG:
					if (PUGI__IS_CHARTYPE(*s, ct_start_symbol)) // '<#...'
					{
						PUGI__PUSHNODE(node_element); // Append a new node to the tree.

						cursor->name = s;

						PUGI__SCANWHILE(PUGI__IS_CHARTYPE(*s, ct_symbol)); // Scan for a terminator.
						PUGI__ENDSEG(); // Save char in 'ch', terminate & step over.

						if (ch == '>')
						{
							// end of tag
						}
						else if (PUGI__IS_CHARTYPE(ch, ct_space))
						{
						LOC_ATTRIBUTES:
							while (true)
							{
								PUGI__SKIPWS(); // Eat any whitespace.
						
								if (PUGI__IS_CHARTYPE(*s, ct_start_symbol)) // <... #...
								{
									xml_attribute_struct* a = append_attribute_ll(cursor, alloc); // Make space for this attribute.
									if (!a) PUGI__THROW_ERROR(status_out_of_memory, s);

									a->name = s; // Save the offset.

									PUGI__SCANWHILE(PUGI__IS_CHARTYPE(*s, ct_symbol)); // Scan for a terminator.
									PUGI__CHECK_ERROR(status_bad_attribute, s); //$ redundant, left for performance

									PUGI__ENDSEG(); // Save char in 'ch', terminate & step over.
									PUGI__CHECK_ERROR(status_bad_attribute, s); //$ redundant, left for performance

									if (PUGI__IS_CHARTYPE(ch, ct_space))
									{
										PUGI__SKIPWS(); // Eat any whitespace.
										PUGI__CHECK_ERROR(status_bad_attribute, s); //$ redundant, left for performance

										ch = *s;
										++s;
									}
									
									if (ch == '=') // '<... #=...'
									{
										PUGI__SKIPWS(); // Eat any whitespace.

										if (*s == '"' || *s == '\'') // '<... #="...'
										{
											ch = *s; // Save quote char to avoid breaking on "''" -or- '""'.
											++s; // Step over the quote.
											a->value = s; // Save the offset.

											s = strconv_attribute(s, ch);
										
											if (!s) PUGI__THROW_ERROR(status_bad_attribute, a->value);

											// After this line the loop continues from the start;
											// Whitespaces, / and > are ok, symbols and EOF are wrong,
											// everything else will be detected
											if (PUGI__IS_CHARTYPE(*s, ct_start_symbol)) PUGI__THROW_ERROR(status_bad_attribute, s);
										}
										else PUGI__THROW_ERROR(status_bad_attribute, s);
									}
									else PUGI__THROW_ERROR(status_bad_attribute, s);
								}
								else if (*s == '/')
								{
									++s;
									
									if (*s == '>')
									{
										PUGI__POPNODE();
										s++;
										break;
									}
									else if (*s == 0 && endch == '>')
									{
										PUGI__POPNODE();
										break;
									}
									else PUGI__THROW_ERROR(status_bad_start_element, s);
								}
								else if (*s == '>')
								{
									++s;

									break;
								}
								else if (*s == 0 && endch == '>')
								{
									break;
								}
								else PUGI__THROW_ERROR(status_bad_start_element, s);
							}

							// !!!
						}
						else if (ch == '/') // '<#.../'
						{
							if (!ENDSWITH(*s, '>')) PUGI__THROW_ERROR(status_bad_start_element, s);

							PUGI__POPNODE(); // Pop.

							s += (*s == '>');
						}
						else if (ch == 0)
						{
							// we stepped over null terminator, backtrack & handle closing tag
							--s;
							
							if (endch != '>') PUGI__THROW_ERROR(status_bad_start_element, s);
						}
						else PUGI__THROW_ERROR(status_bad_start_element, s);
					}
					else if (*s == '/')
					{
						++s;

						char_t* name = cursor->name;
						if (!name) PUGI__THROW_ERROR(status_end_element_mismatch, s);
						
						while (PUGI__IS_CHARTYPE(*s, ct_symbol))
						{
							if (*s++ != *name++) PUGI__THROW_ERROR(status_end_element_mismatch, s);
						}

						if (*name)
						{
							if (*s == 0 && name[0] == endch && name[1] == 0) PUGI__THROW_ERROR(status_bad_end_element, s);
							else PUGI__THROW_ERROR(status_end_element_mismatch, s);
						}
							
						PUGI__POPNODE(); // Pop.

						PUGI__SKIPWS();

						if (*s == 0)
						{
							if (endch != '>') PUGI__THROW_ERROR(status_bad_end_element, s);
						}
						else
						{
							if (*s != '>') PUGI__THROW_ERROR(status_bad_end_element, s);
							++s;
						}
					}
					else if (*s == '?') // '<?...'
					{
						s = parse_question(s, cursor, optmsk, endch);
						if (!s) return s;

						assert(cursor);
						if ((cursor->header & xml_memory_page_type_mask) + 1 == node_declaration) goto LOC_ATTRIBUTES;
					}
					else if (*s == '!') // '<!...'
					{
						s = parse_exclamation(s, cursor, optmsk, endch);
						if (!s) return s;
					}
					else if (*s == 0 && endch == '?') PUGI__THROW_ERROR(status_bad_pi, s);
					else PUGI__THROW_ERROR(status_unrecognized_tag, s);
				}
				else
				{
					mark = s; // Save this offset while searching for a terminator.

					PUGI__SKIPWS(); // Eat whitespace if no genuine PCDATA here.

					if (*s == '<' || !*s)
					{
						// We skipped some whitespace characters because otherwise we would take the tag branch instead of PCDATA one
						assert(mark != s);

						if (!PUGI__OPTSET(parse_ws_pcdata | parse_ws_pcdata_single) || PUGI__OPTSET(parse_trim_pcdata))
						{
							continue;
						}
						else if (PUGI__OPTSET(parse_ws_pcdata_single))
						{
							if (s[0] != '<' || s[1] != '/' || cursor->first_child) continue;
						}
					}

					if (!PUGI__OPTSET(parse_trim_pcdata))
						s = mark;
							
					if (cursor->parent || PUGI__OPTSET(parse_fragment))
					{
						PUGI__PUSHNODE(node_pcdata); // Append a new node on the tree.
						cursor->value = s; // Save the offset.

						s = strconv_pcdata(s);
								
						PUGI__POPNODE(); // Pop since this is a standalone.
						
						if (!*s) break;
					}
					else
					{
						PUGI__SCANFOR(*s == '<'); // '...<'
						if (!*s) break;
						
						++s;
					}

					// We're after '<'
					goto LOC_TAG;
				}
			}

			// check that last tag is closed
			if (cursor != root) PUGI__THROW_ERROR(status_end_element_mismatch, s);

			return s;
		}

	#ifdef PUGIXML_WCHAR_MODE
		static char_t* parse_skip_bom(char_t* s)
		{
			unsigned int bom = 0xfeff;
			return (s[0] == static_cast<wchar_t>(bom)) ? s + 1 : s;
		}
	#else
		static char_t* parse_skip_bom(char_t* s)
		{
			return (s[0] == '\xef' && s[1] == '\xbb' && s[2] == '\xbf') ? s + 3 : s;
		}
	#endif

		static bool has_element_node_siblings(xml_node_struct* node)
		{
			while (node)
			{
				xml_node_type type = static_cast<xml_node_type>((node->header & impl::xml_memory_page_type_mask) + 1);
				if (type == node_element) return true;

				node = node->next_sibling;
			}

			return false;
		}

		static xml_parse_result parse(char_t* buffer, size_t length, xml_document_struct* xmldoc, xml_node_struct* root, unsigned int optmsk)
		{
			// allocator object is a part of document object
			xml_allocator& alloc = *static_cast<xml_allocator*>(xmldoc);

			// early-out for empty documents
			if (length == 0)
				return make_parse_result(PUGI__OPTSET(parse_fragment) ? status_ok : status_no_document_element);

			// get last child of the root before parsing
			xml_node_struct* last_root_child = root->first_child ? root->first_child->prev_sibling_c : 0;
	
			// create parser on stack
			xml_parser parser(alloc);

			// save last character and make buffer zero-terminated (speeds up parsing)
			char_t endch = buffer[length - 1];
			buffer[length - 1] = 0;
			
			// skip BOM to make sure it does not end up as part of parse output
			char_t* buffer_data = parse_skip_bom(buffer);

			// perform actual parsing
			parser.parse_tree(buffer_data, root, optmsk, endch);

			// update allocator state
			alloc = parser.alloc;

			xml_parse_result result = make_parse_result(parser.error_status, parser.error_offset ? parser.error_offset - buffer : 0);
			assert(result.offset >= 0 && static_cast<size_t>(result.offset) <= length);

			if (result)
			{
				// since we removed last character, we have to handle the only possible false positive (stray <)
				if (endch == '<')
					return make_parse_result(status_unrecognized_tag, length - 1);

				// check if there are any element nodes parsed
				xml_node_struct* first_root_child_parsed = last_root_child ? last_root_child->next_sibling : root->first_child;

				if (!PUGI__OPTSET(parse_fragment) && !has_element_node_siblings(first_root_child_parsed))
					return make_parse_result(status_no_document_element, length - 1);
			}
			else
			{
				// roll back offset if it occurs on a null terminator in the source buffer
				if (result.offset > 0 && static_cast<size_t>(result.offset) == length - 1 && endch == 0)
					result.offset--;
			}

			return result;
		}
	};

	// Output facilities
	PUGI__FN xml_encoding get_write_native_encoding()
	{
	#ifdef PUGIXML_WCHAR_MODE
		return get_wchar_encoding();
	#else
		return encoding_utf8;
	#endif
	}

	PUGI__FN xml_encoding get_write_encoding(xml_encoding encoding)
	{
		// replace wchar encoding with utf implementation
		if (encoding == encoding_wchar) return get_wchar_encoding();

		// replace utf16 encoding with utf16 with specific endianness
		if (encoding == encoding_utf16) return is_little_endian() ? encoding_utf16_le : encoding_utf16_be;

		// replace utf32 encoding with utf32 with specific endianness
		if (encoding == encoding_utf32) return is_little_endian() ? encoding_utf32_le : encoding_utf32_be;

		// only do autodetection if no explicit encoding is requested
		if (encoding != encoding_auto) return encoding;

		// assume utf8 encoding
		return encoding_utf8;
	}

#ifdef PUGIXML_WCHAR_MODE
	PUGI__FN size_t get_valid_length(const char_t* data, size_t length)
	{
		assert(length > 0);

		// discard last character if it's the lead of a surrogate pair 
		return (sizeof(wchar_t) == 2 && static_cast<unsigned int>(static_cast<uint16_t>(data[length - 1]) - 0xD800) < 0x400) ? length - 1 : length;
	}

	PUGI__FN size_t convert_buffer_output(char_t* r_char, uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)
	{
		// only endian-swapping is required
		if (need_endian_swap_utf(encoding, get_wchar_encoding()))
		{
			convert_wchar_endian_swap(r_char, data, length);

			return length * sizeof(char_t);
		}
	
		// convert to utf8
		if (encoding == encoding_utf8)
		{
			uint8_t* dest = r_u8;
			uint8_t* end = utf_decoder<utf8_writer>::decode_wchar_block(data, length, dest);

			return static_cast<size_t>(end - dest);
		}

		// convert to utf16
		if (encoding == encoding_utf16_be || encoding == encoding_utf16_le)
		{
			uint16_t* dest = r_u16;

			// convert to native utf16
			uint16_t* end = utf_decoder<utf16_writer>::decode_wchar_block(data, length, dest);

			// swap if necessary
			xml_encoding native_encoding = is_little_endian() ? encoding_utf16_le : encoding_utf16_be;

			if (native_encoding != encoding) convert_utf_endian_swap(dest, dest, static_cast<size_t>(end - dest));

			return static_cast<size_t>(end - dest) * sizeof(uint16_t);
		}

		// convert to utf32
		if (encoding == encoding_utf32_be || encoding == encoding_utf32_le)
		{
			uint32_t* dest = r_u32;

			// convert to native utf32
			uint32_t* end = utf_decoder<utf32_writer>::decode_wchar_block(data, length, dest);

			// swap if necessary
			xml_encoding native_encoding = is_little_endian() ? encoding_utf32_le : encoding_utf32_be;

			if (native_encoding != encoding) convert_utf_endian_swap(dest, dest, static_cast<size_t>(end - dest));

			return static_cast<size_t>(end - dest) * sizeof(uint32_t);
		}

		// convert to latin1
		if (encoding == encoding_latin1)
		{
			uint8_t* dest = r_u8;
			uint8_t* end = utf_decoder<latin1_writer>::decode_wchar_block(data, length, dest);

			return static_cast<size_t>(end - dest);
		}

		assert(!"Invalid encoding");
		return 0;
	}
#else
	PUGI__FN size_t get_valid_length(const char_t* data, size_t length)
	{
		assert(length > 4);

		for (size_t i = 1; i <= 4; ++i)
		{
			uint8_t ch = static_cast<uint8_t>(data[length - i]);

			// either a standalone character or a leading one
			if ((ch & 0xc0) != 0x80) return length - i;
		}

		// there are four non-leading characters at the end, sequence tail is broken so might as well process the whole chunk
		return length;
	}

	PUGI__FN size_t convert_buffer_output(char_t* /* r_char */, uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)
	{
		if (encoding == encoding_utf16_be || encoding == encoding_utf16_le)
		{
			uint16_t* dest = r_u16;

			// convert to native utf16
			uint16_t* end = utf_decoder<utf16_writer>::decode_utf8_block(reinterpret_cast<const uint8_t*>(data), length, dest);

			// swap if necessary
			xml_encoding native_encoding = is_little_endian() ? encoding_utf16_le : encoding_utf16_be;

			if (native_encoding != encoding) convert_utf_endian_swap(dest, dest, static_cast<size_t>(end - dest));

			return static_cast<size_t>(end - dest) * sizeof(uint16_t);
		}

		if (encoding == encoding_utf32_be || encoding == encoding_utf32_le)
		{
			uint32_t* dest = r_u32;

			// convert to native utf32
			uint32_t* end = utf_decoder<utf32_writer>::decode_utf8_block(reinterpret_cast<const uint8_t*>(data), length, dest);

			// swap if necessary
			xml_encoding native_encoding = is_little_endian() ? encoding_utf32_le : encoding_utf32_be;

			if (native_encoding != encoding) convert_utf_endian_swap(dest, dest, static_cast<size_t>(end - dest));

			return static_cast<size_t>(end - dest) * sizeof(uint32_t);
		}

		if (encoding == encoding_latin1)
		{
			uint8_t* dest = r_u8;
			uint8_t* end = utf_decoder<latin1_writer>::decode_utf8_block(reinterpret_cast<const uint8_t*>(data), length, dest);

			return static_cast<size_t>(end - dest);
		}

		assert(!"Invalid encoding");
		return 0;
	}
#endif

	class xml_buffered_writer
	{
		xml_buffered_writer(const xml_buffered_writer&);
		xml_buffered_writer& operator=(const xml_buffered_writer&);

	public:
		xml_buffered_writer(xml_writer& writer_, xml_encoding user_encoding): writer(writer_), bufsize(0), encoding(get_write_encoding(user_encoding))
		{
			PUGI__STATIC_ASSERT(bufcapacity >= 8);
		}

		~xml_buffered_writer()
		{
			flush();
		}

		void flush()
		{
			flush(buffer, bufsize);
			bufsize = 0;
		}

		void flush(const char_t* data, size_t size)
		{
			if (size == 0) return;

			// fast path, just write data
			if (encoding == get_write_native_encoding())
				writer.write(data, size * sizeof(char_t));
			else
			{
				// convert chunk
				size_t result = convert_buffer_output(scratch.data_char, scratch.data_u8, scratch.data_u16, scratch.data_u32, data, size, encoding);
				assert(result <= sizeof(scratch));

				// write data
				writer.write(scratch.data_u8, result);
			}
		}

		void write(const char_t* data, size_t length)
		{
			if (bufsize + length > bufcapacity)
			{
				// flush the remaining buffer contents
				flush();

				// handle large chunks
				if (length > bufcapacity)
				{
					if (encoding == get_write_native_encoding())
					{
						// fast path, can just write data chunk
						writer.write(data, length * sizeof(char_t));
						return;
					}

					// need to convert in suitable chunks
					while (length > bufcapacity)
					{
						// get chunk size by selecting such number of characters that are guaranteed to fit into scratch buffer
						// and form a complete codepoint sequence (i.e. discard start of last codepoint if necessary)
						size_t chunk_size = get_valid_length(data, bufcapacity);

						// convert chunk and write
						flush(data, chunk_size);

						// iterate
						data += chunk_size;
						length -= chunk_size;
					}

					// small tail is copied below
					bufsize = 0;
				}
			}

			memcpy(buffer + bufsize, data, length * sizeof(char_t));
			bufsize += length;
		}

		void write(const char_t* data)
		{
			write(data, strlength(data));
		}

		void write(char_t d0)
		{
			if (bufsize + 1 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			bufsize += 1;
		}

		void write(char_t d0, char_t d1)
		{
			if (bufsize + 2 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			buffer[bufsize + 1] = d1;
			bufsize += 2;
		}

		void write(char_t d0, char_t d1, char_t d2)
		{
			if (bufsize + 3 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			buffer[bufsize + 1] = d1;
			buffer[bufsize + 2] = d2;
			bufsize += 3;
		}

		void write(char_t d0, char_t d1, char_t d2, char_t d3)
		{
			if (bufsize + 4 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			buffer[bufsize + 1] = d1;
			buffer[bufsize + 2] = d2;
			buffer[bufsize + 3] = d3;
			bufsize += 4;
		}

		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4)
		{
			if (bufsize + 5 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			buffer[bufsize + 1] = d1;
			buffer[bufsize + 2] = d2;
			buffer[bufsize + 3] = d3;
			buffer[bufsize + 4] = d4;
			bufsize += 5;
		}

		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4, char_t d5)
		{
			if (bufsize + 6 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			buffer[bufsize + 1] = d1;
			buffer[bufsize + 2] = d2;
			buffer[bufsize + 3] = d3;
			buffer[bufsize + 4] = d4;
			buffer[bufsize + 5] = d5;
			bufsize += 6;
		}

		// utf8 maximum expansion: x4 (-> utf32)
		// utf16 maximum expansion: x2 (-> utf32)
		// utf32 maximum expansion: x1
		enum
		{
			bufcapacitybytes =
			#ifdef PUGIXML_MEMORY_OUTPUT_STACK
				PUGIXML_MEMORY_OUTPUT_STACK
			#else
				10240
			#endif
			,
			bufcapacity = bufcapacitybytes / (sizeof(char_t) + 4)
		};

		char_t buffer[bufcapacity];

		union
		{
			uint8_t data_u8[4 * bufcapacity];
			uint16_t data_u16[2 * bufcapacity];
			uint32_t data_u32[bufcapacity];
			char_t data_char[bufcapacity];
		} scratch;

		xml_writer& writer;
		size_t bufsize;
		xml_encoding encoding;
	};

	PUGI__FN void text_output_escaped(xml_buffered_writer& writer, const char_t* s, chartypex_t type)
	{
		while (*s)
		{
			const char_t* prev = s;
			
			// While *s is a usual symbol
			while (!PUGI__IS_CHARTYPEX(*s, type)) ++s;
		
			writer.write(prev, static_cast<size_t>(s - prev));

			switch (*s)
			{
				case 0: break;
				case '&':
					writer.write('&', 'a', 'm', 'p', ';');
					++s;
					break;
				case '<':
					writer.write('&', 'l', 't', ';');
					++s;
					break;
				case '>':
					writer.write('&', 'g', 't', ';');
					++s;
					break;
				case '"':
					writer.write('&', 'q', 'u', 'o', 't', ';');
					++s;
					break;
				default: // s is not a usual symbol
				{
					unsigned int ch = static_cast<unsigned int>(*s++);
					assert(ch < 32);

					writer.write('&', '#', static_cast<char_t>((ch / 10) + '0'), static_cast<char_t>((ch % 10) + '0'), ';');
				}
			}
		}
	}

	PUGI__FN void text_output(xml_buffered_writer& writer, const char_t* s, chartypex_t type, unsigned int flags)
	{
		if (flags & format_no_escapes)
			writer.write(s);
		else
			text_output_escaped(writer, s, type);
	}

	PUGI__FN void text_output_cdata(xml_buffered_writer& writer, const char_t* s)
	{
		do
		{
			writer.write('<', '!', '[', 'C', 'D');
			writer.write('A', 'T', 'A', '[');

			const char_t* prev = s;

			// look for ]]> sequence - we can't output it as is since it terminates CDATA
			while (*s && !(s[0] == ']' && s[1] == ']' && s[2] == '>')) ++s;

			// skip ]] if we stopped at ]]>, > will go to the next CDATA section
			if (*s) s += 2;

			writer.write(prev, static_cast<size_t>(s - prev));

			writer.write(']', ']', '>');
		}
		while (*s);
	}

	PUGI__FN void node_output_attributes(xml_buffered_writer& writer, const xml_node& node, unsigned int flags)
	{
		const char_t* default_name = PUGIXML_TEXT(":anonymous");

		for (xml_attribute a = node.first_attribute(); a; a = a.next_attribute())
		{
			writer.write(' ');
			writer.write(a.name()[0] ? a.name() : default_name);
			writer.write('=', '"');

			text_output(writer, a.value(), ctx_special_attr, flags);

			writer.write('"');
		}
	}

	PUGI__FN void node_output(xml_buffered_writer& writer, const xml_node& node, const char_t* indent, unsigned int flags, unsigned int depth)
	{
		const char_t* default_name = PUGIXML_TEXT(":anonymous");

		if ((flags & format_indent) != 0 && (flags & format_raw) == 0)
			for (unsigned int i = 0; i < depth; ++i) writer.write(indent);

		switch (node.type())
		{
		case node_document:
		{
			for (xml_node n = node.first_child(); n; n = n.next_sibling())
				node_output(writer, n, indent, flags, depth);
			break;
		}
			
		case node_element:
		{
			const char_t* name = node.name()[0] ? node.name() : default_name;

			writer.write('<');
			writer.write(name);

			node_output_attributes(writer, node, flags);

			if (flags & format_raw)
			{
				if (!node.first_child())
					writer.write(' ', '/', '>');
				else
				{
					writer.write('>');

					for (xml_node n = node.first_child(); n; n = n.next_sibling())
						node_output(writer, n, indent, flags, depth + 1);

					writer.write('<', '/');
					writer.write(name);
					writer.write('>');
				}
			}
			else if (!node.first_child())
				writer.write(' ', '/', '>', '\n');
			else if (node.first_child() == node.last_child() && (node.first_child().type() == node_pcdata || node.first_child().type() == node_cdata))
			{
				writer.write('>');

				if (node.first_child().type() == node_pcdata)
					text_output(writer, node.first_child().value(), ctx_special_pcdata, flags);
				else
					text_output_cdata(writer, node.first_child().value());

				writer.write('<', '/');
				writer.write(name);
				writer.write('>', '\n');
			}
			else
			{
				writer.write('>', '\n');
				
				for (xml_node n = node.first_child(); n; n = n.next_sibling())
					node_output(writer, n, indent, flags, depth + 1);

				if ((flags & format_indent) != 0 && (flags & format_raw) == 0)
					for (unsigned int i = 0; i < depth; ++i) writer.write(indent);
				
				writer.write('<', '/');
				writer.write(name);
				writer.write('>', '\n');
			}

			break;
		}
		
		case node_pcdata:
			text_output(writer, node.value(), ctx_special_pcdata, flags);
			if ((flags & format_raw) == 0) writer.write('\n');
			break;

		case node_cdata:
			text_output_cdata(writer, node.value());
			if ((flags & format_raw) == 0) writer.write('\n');
			break;

		case node_comment:
			writer.write('<', '!', '-', '-');
			writer.write(node.value());
			writer.write('-', '-', '>');
			if ((flags & format_raw) == 0) writer.write('\n');
			break;

		case node_pi:
		case node_declaration:
			writer.write('<', '?');
			writer.write(node.name()[0] ? node.name() : default_name);

			if (node.type() == node_declaration)
			{
				node_output_attributes(writer, node, flags);
			}
			else if (node.value()[0])
			{
				writer.write(' ');
				writer.write(node.value());
			}

			writer.write('?', '>');
			if ((flags & format_raw) == 0) writer.write('\n');
			break;

		case node_doctype:
			writer.write('<', '!', 'D', 'O', 'C');
			writer.write('T', 'Y', 'P', 'E');

			if (node.value()[0])
			{
				writer.write(' ');
				writer.write(node.value());
			}

			writer.write('>');
			if ((flags & format_raw) == 0) writer.write('\n');
			break;

		default:
			assert(!"Invalid node type");
		}
	}

	inline bool has_declaration(const xml_node& node)
	{
		for (xml_node child = node.first_child(); child; child = child.next_sibling())
		{
			xml_node_type type = child.type();

			if (type == node_declaration) return true;
			if (type == node_element) return false;
		}

		return false;
	}

	inline bool allow_insert_child(xml_node_type parent, xml_node_type child)
	{
		if (parent != node_document && parent != node_element) return false;
		if (child == node_document || child == node_null) return false;
		if (parent != node_document && (child == node_declaration || child == node_doctype)) return false;

		return true;
	}

	PUGI__FN void recursive_copy_skip(xml_node& dest, const xml_node& source, const xml_node& skip)
	{
		assert(dest.type() == source.type());

		switch (source.type())
		{
		case node_element:
		{
			dest.set_name(source.name());

			for (xml_attribute a = source.first_attribute(); a; a = a.next_attribute())
				dest.append_attribute(a.name()).set_value(a.value());

			for (xml_node c = source.first_child(); c; c = c.next_sibling())
			{
				if (c == skip) continue;

				xml_node cc = dest.append_child(c.type());
				assert(cc);

				recursive_copy_skip(cc, c, skip);
			}

			break;
		}

		case node_pcdata:
		case node_cdata:
		case node_comment:
		case node_doctype:
			dest.set_value(source.value());
			break;

		case node_pi:
			dest.set_name(source.name());
			dest.set_value(source.value());
			break;

		case node_declaration:
		{
			dest.set_name(source.name());

			for (xml_attribute a = source.first_attribute(); a; a = a.next_attribute())
				dest.append_attribute(a.name()).set_value(a.value());

			break;
		}

		default:
			assert(!"Invalid node type");
		}
	}

	inline bool is_text_node(xml_node_struct* node)
	{
		xml_node_type type = static_cast<xml_node_type>((node->header & impl::xml_memory_page_type_mask) + 1);

		return type == node_pcdata || type == node_cdata;
	}

	// get value with conversion functions
	PUGI__FN int get_integer_base(const char_t* value)
	{
		const char_t* s = value;

		while (PUGI__IS_CHARTYPE(*s, ct_space))
			s++;

		if (*s == '-')
			s++;

		return (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ? 16 : 10;
	}

	PUGI__FN int get_value_int(const char_t* value, int def)
	{
		if (!value) return def;

		int base = get_integer_base(value);

	#ifdef PUGIXML_WCHAR_MODE
		return static_cast<int>(wcstol(value, 0, base));
	#else
		return static_cast<int>(strtol(value, 0, base));
	#endif
	}

	PUGI__FN unsigned int get_value_uint(const char_t* value, unsigned int def)
	{
		if (!value) return def;

		int base = get_integer_base(value);

	#ifdef PUGIXML_WCHAR_MODE
		return static_cast<unsigned int>(wcstoul(value, 0, base));
	#else
		return static_cast<unsigned int>(strtoul(value, 0, base));
	#endif
	}

	PUGI__FN double get_value_double(const char_t* value, double def)
	{
		if (!value) return def;

	#ifdef PUGIXML_WCHAR_MODE
		return wcstod(value, 0);
	#else
		return strtod(value, 0);
	#endif
	}

	PUGI__FN float get_value_float(const char_t* value, float def)
	{
		if (!value) return def;

	#ifdef PUGIXML_WCHAR_MODE
		return static_cast<float>(wcstod(value, 0));
	#else
		return static_cast<float>(strtod(value, 0));
	#endif
	}

	PUGI__FN bool get_value_bool(const char_t* value, bool def)
	{
		if (!value) return def;

		// only look at first char
		char_t first = *value;

		// 1*, t* (true), T* (True), y* (yes), Y* (YES)
		return (first == '1' || first == 't' || first == 'T' || first == 'y' || first == 'Y');
	}

#ifdef PUGIXML_HAS_LONG_LONG
	PUGI__FN long long get_value_llong(const char_t* value, long long def)
	{
		if (!value) return def;

		int base = get_integer_base(value);

	#ifdef PUGIXML_WCHAR_MODE
		#ifdef PUGI__MSVC_CRT_VERSION
			return _wcstoi64(value, 0, base);
		#else
			return wcstoll(value, 0, base);
		#endif
	#else
		#ifdef PUGI__MSVC_CRT_VERSION
			return _strtoi64(value, 0, base);
		#else
			return strtoll(value, 0, base);
		#endif
	#endif
	}

	PUGI__FN unsigned long long get_value_ullong(const char_t* value, unsigned long long def)
	{
		if (!value) return def;

		int base = get_integer_base(value);

	#ifdef PUGIXML_WCHAR_MODE
		#ifdef PUGI__MSVC_CRT_VERSION
			return _wcstoui64(value, 0, base);
		#else
			return wcstoull(value, 0, base);
		#endif
	#else
		#ifdef PUGI__MSVC_CRT_VERSION
			return _strtoui64(value, 0, base);
		#else
			return strtoull(value, 0, base);
		#endif
	#endif
	}
#endif

	// set value with conversion functions
	PUGI__FN bool set_value_buffer(char_t*& dest, uintptr_t& header, uintptr_t header_mask, char (&buf)[128])
	{
	#ifdef PUGIXML_WCHAR_MODE
		char_t wbuf[128];
		impl::widen_ascii(wbuf, buf);

		return strcpy_insitu(dest, header, header_mask, wbuf);
	#else
		return strcpy_insitu(dest, header, header_mask, buf);
	#endif
	}

	PUGI__FN bool set_value_convert(char_t*& dest, uintptr_t& header, uintptr_t header_mask, int value)
	{
		char buf[128];
		sprintf(buf, "%d", value);
	
		return set_value_buffer(dest, header, header_mask, buf);
	}

	PUGI__FN bool set_value_convert(char_t*& dest, uintptr_t& header, uintptr_t header_mask, unsigned int value)
	{
		char buf[128];
		sprintf(buf, "%u", value);

		return set_value_buffer(dest, header, header_mask, buf);
	}

	PUGI__FN bool set_value_convert(char_t*& dest, uintptr_t& header, uintptr_t header_mask, double value)
	{
		char buf[128];
		sprintf(buf, "%g", value);

		return set_value_buffer(dest, header, header_mask, buf);
	}
	
	PUGI__FN bool set_value_convert(char_t*& dest, uintptr_t& header, uintptr_t header_mask, bool value)
	{
		return strcpy_insitu(dest, header, header_mask, value ? PUGIXML_TEXT("true") : PUGIXML_TEXT("false"));
	}

#ifdef PUGIXML_HAS_LONG_LONG
	PUGI__FN bool set_value_convert(char_t*& dest, uintptr_t& header, uintptr_t header_mask, long long value)
	{
		char buf[128];
		sprintf(buf, "%lld", value);
	
		return set_value_buffer(dest, header, header_mask, buf);
	}

	PUGI__FN bool set_value_convert(char_t*& dest, uintptr_t& header, uintptr_t header_mask, unsigned long long value)
	{
		char buf[128];
		sprintf(buf, "%llu", value);
	
		return set_value_buffer(dest, header, header_mask, buf);
	}
#endif

	// we need to get length of entire file to load it in memory; the only (relatively) sane way to do it is via seek/tell trick
	PUGI__FN xml_parse_status get_file_size(FILE* file, size_t& out_result)
	{
	#if defined(PUGI__MSVC_CRT_VERSION) && PUGI__MSVC_CRT_VERSION >= 1400 && !defined(_WIN32_WCE)
		// there are 64-bit versions of fseek/ftell, let's use them
		typedef __int64 length_type;

		_fseeki64(file, 0, SEEK_END);
		length_type length = _ftelli64(file);
		_fseeki64(file, 0, SEEK_SET);
	#elif defined(__MINGW32__) && !defined(__NO_MINGW_LFS) && !defined(__STRICT_ANSI__)
		// there are 64-bit versions of fseek/ftell, let's use them
		typedef off64_t length_type;

		fseeko64(file, 0, SEEK_END);
		length_type length = ftello64(file);
		fseeko64(file, 0, SEEK_SET);
	#else
		// if this is a 32-bit OS, long is enough; if this is a unix system, long is 64-bit, which is enough; otherwise we can't do anything anyway.
		typedef long length_type;

		fseek(file, 0, SEEK_END);
		length_type length = ftell(file);
		fseek(file, 0, SEEK_SET);
	#endif

		// check for I/O errors
		if (length < 0) return status_io_error;
		
		// check for overflow
		size_t result = static_cast<size_t>(length);

		if (static_cast<length_type>(result) != length) return status_out_of_memory;

		// finalize
		out_result = result;

		return status_ok;
	}

	PUGI__FN size_t zero_terminate_buffer(void* buffer, size_t size, xml_encoding encoding) 
	{
		// We only need to zero-terminate if encoding conversion does not do it for us
	#ifdef PUGIXML_WCHAR_MODE
		xml_encoding wchar_encoding = get_wchar_encoding();

		if (encoding == wchar_encoding || need_endian_swap_utf(encoding, wchar_encoding))
		{
			size_t length = size / sizeof(char_t);

			static_cast<char_t*>(buffer)[length] = 0;
			return (length + 1) * sizeof(char_t);
		}
	#else
		if (encoding == encoding_utf8)
		{
			static_cast<char*>(buffer)[size] = 0;
			return size + 1;
		}
	#endif

		return size;
	}

	PUGI__FN xml_parse_result load_file_impl(xml_document& doc, FILE* file, unsigned int options, xml_encoding encoding)
	{
		if (!file) return make_parse_result(status_file_not_found);

		// get file size (can result in I/O errors)
		size_t size = 0;
		xml_parse_status size_status = get_file_size(file, size);

		if (size_status != status_ok)
		{
			fclose(file);
			return make_parse_result(size_status);
		}
		
		size_t max_suffix_size = sizeof(char_t);

		// allocate buffer for the whole file
		char* contents = static_cast<char*>(xml_memory::allocate(size + max_suffix_size));

		if (!contents)
		{
			fclose(file);
			return make_parse_result(status_out_of_memory);
		}

		// read file in memory
		size_t read_size = fread(contents, 1, size, file);
		fclose(file);

		if (read_size != size)
		{
			xml_memory::deallocate(contents);
			return make_parse_result(status_io_error);
		}

		xml_encoding real_encoding = get_buffer_encoding(encoding, contents, size);
		
		return doc.load_buffer_inplace_own(contents, zero_terminate_buffer(contents, size, real_encoding), options, real_encoding);
	}

#ifndef PUGIXML_NO_STL
	template <typename T> struct xml_stream_chunk
	{
		static xml_stream_chunk* create()
		{
			void* memory = xml_memory::allocate(sizeof(xml_stream_chunk));
			
			return new (memory) xml_stream_chunk();
		}

		static void destroy(void* ptr)
		{
			xml_stream_chunk* chunk = static_cast<xml_stream_chunk*>(ptr);

			// free chunk chain
			while (chunk)
			{
				xml_stream_chunk* next = chunk->next;
				xml_memory::deallocate(chunk);
				chunk = next;
			}
		}

		xml_stream_chunk(): next(0), size(0)
		{
		}

		xml_stream_chunk* next;
		size_t size;

		T data[xml_memory_page_size / sizeof(T)];
	};

	template <typename T> PUGI__FN xml_parse_status load_stream_data_noseek(std::basic_istream<T>& stream, void** out_buffer, size_t* out_size)
	{
		buffer_holder chunks(0, xml_stream_chunk<T>::destroy);

		// read file to a chunk list
		size_t total = 0;
		xml_stream_chunk<T>* last = 0;

		while (!stream.eof())
		{
			// allocate new chunk
			xml_stream_chunk<T>* chunk = xml_stream_chunk<T>::create();
			if (!chunk) return status_out_of_memory;

			// append chunk to list
			if (last) last = last->next = chunk;
			else chunks.data = last = chunk;

			// read data to chunk
			stream.read(chunk->data, static_cast<std::streamsize>(sizeof(chunk->data) / sizeof(T)));
			chunk->size = static_cast<size_t>(stream.gcount()) * sizeof(T);

			// read may set failbit | eofbit in case gcount() is less than read length, so check for other I/O errors
			if (stream.bad() || (!stream.eof() && stream.fail())) return status_io_error;

			// guard against huge files (chunk size is small enough to make this overflow check work)
			if (total + chunk->size < total) return status_out_of_memory;
			total += chunk->size;
		}

		size_t max_suffix_size = sizeof(char_t);

		// copy chunk list to a contiguous buffer
		char* buffer = static_cast<char*>(xml_memory::allocate(total + max_suffix_size));
		if (!buffer) return status_out_of_memory;

		char* write = buffer;

		for (xml_stream_chunk<T>* chunk = static_cast<xml_stream_chunk<T>*>(chunks.data); chunk; chunk = chunk->next)
		{
			assert(write + chunk->size <= buffer + total);
			memcpy(write, chunk->data, chunk->size);
			write += chunk->size;
		}

		assert(write == buffer + total);

		// return buffer
		*out_buffer = buffer;
		*out_size = total;

		return status_ok;
	}

	template <typename T> PUGI__FN xml_parse_status load_stream_data_seek(std::basic_istream<T>& stream, void** out_buffer, size_t* out_size)
	{
		// get length of remaining data in stream
		typename std::basic_istream<T>::pos_type pos = stream.tellg();
		stream.seekg(0, std::ios::end);
		std::streamoff length = stream.tellg() - pos;
		stream.seekg(pos);

		if (stream.fail() || pos < 0) return status_io_error;

		// guard against huge files
		size_t read_length = static_cast<size_t>(length);

		if (static_cast<std::streamsize>(read_length) != length || length < 0) return status_out_of_memory;

		size_t max_suffix_size = sizeof(char_t);

		// read stream data into memory (guard against stream exceptions with buffer holder)
		buffer_holder buffer(xml_memory::allocate(read_length * sizeof(T) + max_suffix_size), xml_memory::deallocate);
		if (!buffer.data) return status_out_of_memory;

		stream.read(static_cast<T*>(buffer.data), static_cast<std::streamsize>(read_length));

		// read may set failbit | eofbit in case gcount() is less than read_length (i.e. line ending conversion), so check for other I/O errors
		if (stream.bad() || (!stream.eof() && stream.fail())) return status_io_error;

		// return buffer
		size_t actual_length = static_cast<size_t>(stream.gcount());
		assert(actual_length <= read_length);
		
		*out_buffer = buffer.release();
		*out_size = actual_length * sizeof(T);

		return status_ok;
	}

	template <typename T> PUGI__FN xml_parse_result load_stream_impl(xml_document& doc, std::basic_istream<T>& stream, unsigned int options, xml_encoding encoding)
	{
		void* buffer = 0;
		size_t size = 0;
		xml_parse_status status = status_ok;

		// if stream has an error bit set, bail out (otherwise tellg() can fail and we'll clear error bits)
		if (stream.fail()) return make_parse_result(status_io_error);

		// load stream to memory (using seek-based implementation if possible, since it's faster and takes less memory)
		if (stream.tellg() < 0)
		{
			stream.clear(); // clear error flags that could be set by a failing tellg
			status = load_stream_data_noseek(stream, &buffer, &size);
		}
		else
			status = load_stream_data_seek(stream, &buffer, &size);

		if (status != status_ok) return make_parse_result(status);

		xml_encoding real_encoding = get_buffer_encoding(encoding, buffer, size);
		
		return doc.load_buffer_inplace_own(buffer, zero_terminate_buffer(buffer, size, real_encoding), options, real_encoding);
	}
#endif

#if defined(PUGI__MSVC_CRT_VERSION) || defined(__BORLANDC__) || (defined(__MINGW32__) && !defined(__STRICT_ANSI__))
	PUGI__FN FILE* open_file_wide(const wchar_t* path, const wchar_t* mode)
	{
		return _wfopen(path, mode);
	}
#else
	PUGI__FN char* convert_path_heap(const wchar_t* str)
	{
		assert(str);

		// first pass: get length in utf8 characters
		size_t length = strlength_wide(str);
		size_t size = as_utf8_begin(str, length);

		// allocate resulting string
		char* result = static_cast<char*>(xml_memory::allocate(size + 1));
		if (!result) return 0;

		// second pass: convert to utf8
		as_utf8_end(result, size, str, length);

		return result;
	}

	PUGI__FN FILE* open_file_wide(const wchar_t* path, const wchar_t* mode)
	{
		// there is no standard function to open wide paths, so our best bet is to try utf8 path
		char* path_utf8 = convert_path_heap(path);
		if (!path_utf8) return 0;

		// convert mode to ASCII (we mirror _wfopen interface)
		char mode_ascii[4] = {0};
		for (size_t i = 0; mode[i]; ++i) mode_ascii[i] = static_cast<char>(mode[i]);

		// try to open the utf8 path
		FILE* result = fopen(path_utf8, mode_ascii);

		// free dummy buffer
		xml_memory::deallocate(path_utf8);

		return result;
	}
#endif

	PUGI__FN bool save_file_impl(const xml_document& doc, FILE* file, const char_t* indent, unsigned int flags, xml_encoding encoding)
	{
		if (!file) return false;

		xml_writer_file writer(file);
		doc.save(writer, indent, flags, encoding);

		int result = ferror(file);

		fclose(file);

		return result == 0;
	}

	PUGI__FN xml_parse_result load_buffer_impl(xml_document_struct* doc, xml_node_struct* root, void* contents, size_t size, unsigned int options, xml_encoding encoding, bool is_mutable, bool own, char_t** out_buffer)
	{
		// check input buffer
		assert(contents || size == 0);

		// get actual encoding
		xml_encoding buffer_encoding = impl::get_buffer_encoding(encoding, contents, size);

		// get private buffer
		char_t* buffer = 0;
		size_t length = 0;

		if (!impl::convert_buffer(buffer, length, buffer_encoding, contents, size, is_mutable)) return impl::make_parse_result(status_out_of_memory);
		
		// delete original buffer if we performed a conversion
		if (own && buffer != contents && contents) impl::xml_memory::deallocate(contents);

		// store buffer for offset_debug
		doc->buffer = buffer;

		// parse
		xml_parse_result res = impl::xml_parser::parse(buffer, length, doc, root, options);

		// remember encoding
		res.encoding = buffer_encoding;

		// grab onto buffer if it's our buffer, user is responsible for deallocating contents himself
		if (own || buffer != contents) *out_buffer = buffer;

		return res;
	}
PUGI__NS_END

namespace pugi
{
	PUGI__FN xml_writer_file::xml_writer_file(void* file_): file(file_)
	{
	}

	PUGI__FN void xml_writer_file::write(const void* data, size_t size)
	{
		size_t result = fwrite(data, 1, size, static_cast<FILE*>(file));
		(void)!result; // unfortunately we can't do proper error handling here
	}

#ifndef PUGIXML_NO_STL
	PUGI__FN xml_writer_stream::xml_writer_stream(std::basic_ostream<char, std::char_traits<char> >& stream): narrow_stream(&stream), wide_stream(0)
	{
	}

	PUGI__FN xml_writer_stream::xml_writer_stream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream): narrow_stream(0), wide_stream(&stream)
	{
	}

	PUGI__FN void xml_writer_stream::write(const void* data, size_t size)
	{
		if (narrow_stream)
		{
			assert(!wide_stream);
			narrow_stream->write(reinterpret_cast<const char*>(data), static_cast<std::streamsize>(size));
		}
		else
		{
			assert(wide_stream);
			assert(size % sizeof(wchar_t) == 0);

			wide_stream->write(reinterpret_cast<const wchar_t*>(data), static_cast<std::streamsize>(size / sizeof(wchar_t)));
		}
	}
#endif

	PUGI__FN xml_tree_walker::xml_tree_walker(): _depth(0)
	{
	}
	
	PUGI__FN xml_tree_walker::~xml_tree_walker()
	{
	}

	PUGI__FN int xml_tree_walker::depth() const
	{
		return _depth;
	}

	PUGI__FN bool xml_tree_walker::begin(xml_node&)
	{
		return true;
	}

	PUGI__FN bool xml_tree_walker::end(xml_node&)
	{
		return true;
	}

	PUGI__FN xml_attribute::xml_attribute(): _attr(0)
	{
	}

	PUGI__FN xml_attribute::xml_attribute(xml_attribute_struct* attr): _attr(attr)
	{
	}

	PUGI__FN static void unspecified_bool_xml_attribute(xml_attribute***)
	{
	}

	PUGI__FN xml_attribute::operator xml_attribute::unspecified_bool_type() const
	{
		return _attr ? unspecified_bool_xml_attribute : 0;
	}

	PUGI__FN bool xml_attribute::operator!() const
	{
		return !_attr;
	}

	PUGI__FN bool xml_attribute::operator==(const xml_attribute& r) const
	{
		return (_attr == r._attr);
	}
	
	PUGI__FN bool xml_attribute::operator!=(const xml_attribute& r) const
	{
		return (_attr != r._attr);
	}

	PUGI__FN bool xml_attribute::operator<(const xml_attribute& r) const
	{
		return (_attr < r._attr);
	}
	
	PUGI__FN bool xml_attribute::operator>(const xml_attribute& r) const
	{
		return (_attr > r._attr);
	}
	
	PUGI__FN bool xml_attribute::operator<=(const xml_attribute& r) const
	{
		return (_attr <= r._attr);
	}
	
	PUGI__FN bool xml_attribute::operator>=(const xml_attribute& r) const
	{
		return (_attr >= r._attr);
	}

	PUGI__FN xml_attribute xml_attribute::next_attribute() const
	{
		return _attr ? xml_attribute(_attr->next_attribute) : xml_attribute();
	}

	PUGI__FN xml_attribute xml_attribute::previous_attribute() const
	{
		return _attr && _attr->prev_attribute_c->next_attribute ? xml_attribute(_attr->prev_attribute_c) : xml_attribute();
	}

	PUGI__FN const char_t* xml_attribute::as_string(const char_t* def) const
	{
		return (_attr && _attr->value) ? _attr->value : def;
	}

	PUGI__FN int xml_attribute::as_int(int def) const
	{
		return impl::get_value_int(_attr ? _attr->value : 0, def);
	}

	PUGI__FN unsigned int xml_attribute::as_uint(unsigned int def) const
	{
		return impl::get_value_uint(_attr ? _attr->value : 0, def);
	}

	PUGI__FN double xml_attribute::as_double(double def) const
	{
		return impl::get_value_double(_attr ? _attr->value : 0, def);
	}

	PUGI__FN float xml_attribute::as_float(float def) const
	{
		return impl::get_value_float(_attr ? _attr->value : 0, def);
	}

	PUGI__FN bool xml_attribute::as_bool(bool def) const
	{
		return impl::get_value_bool(_attr ? _attr->value : 0, def);
	}

#ifdef PUGIXML_HAS_LONG_LONG
	PUGI__FN long long xml_attribute::as_llong(long long def) const
	{
		return impl::get_value_llong(_attr ? _attr->value : 0, def);
	}

	PUGI__FN unsigned long long xml_attribute::as_ullong(unsigned long long def) const
	{
		return impl::get_value_ullong(_attr ? _attr->value : 0, def);
	}
#endif

	PUGI__FN bool xml_attribute::empty() const
	{
		return !_attr;
	}

	PUGI__FN const char_t* xml_attribute::name() const
	{
		return (_attr && _attr->name) ? _attr->name : PUGIXML_TEXT("");
	}

	PUGI__FN const char_t* xml_attribute::value() const
	{
		return (_attr && _attr->value) ? _attr->value : PUGIXML_TEXT("");
	}

	PUGI__FN size_t xml_attribute::hash_value() const
	{
		return static_cast<size_t>(reinterpret_cast<uintptr_t>(_attr) / sizeof(xml_attribute_struct));
	}

	PUGI__FN xml_attribute_struct* xml_attribute::internal_object() const
	{
		return _attr;
	}

	PUGI__FN xml_attribute& xml_attribute::operator=(const char_t* rhs)
	{
		set_value(rhs);
		return *this;
	}
	
	PUGI__FN xml_attribute& xml_attribute::operator=(int rhs)
	{
		set_value(rhs);
		return *this;
	}

	PUGI__FN xml_attribute& xml_attribute::operator=(unsigned int rhs)
	{
		set_value(rhs);
		return *this;
	}

	PUGI__FN xml_attribute& xml_attribute::operator=(double rhs)
	{
		set_value(rhs);
		return *this;
	}
	
	PUGI__FN xml_attribute& xml_attribute::operator=(bool rhs)
	{
		set_value(rhs);
		return *this;
	}

#ifdef PUGIXML_HAS_LONG_LONG
	PUGI__FN xml_attribute& xml_attribute::operator=(long long rhs)
	{
		set_value(rhs);
		return *this;
	}

	PUGI__FN xml_attribute& xml_attribute::operator=(unsigned long long rhs)
	{
		set_value(rhs);
		return *this;
	}
#endif

	PUGI__FN bool xml_attribute::set_name(const char_t* rhs)
	{
		if (!_attr) return false;
		
		return impl::strcpy_insitu(_attr->name, _attr->header, impl::xml_memory_page_name_allocated_mask, rhs);
	}
		
	PUGI__FN bool xml_attribute::set_value(const char_t* rhs)
	{
		if (!_attr) return false;

		return impl::strcpy_insitu(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}

	PUGI__FN bool xml_attribute::set_value(int rhs)
	{
		if (!_attr) return false;

		return impl::set_value_convert(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}

	PUGI__FN bool xml_attribute::set_value(unsigned int rhs)
	{
		if (!_attr) return false;

		return impl::set_value_convert(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}

	PUGI__FN bool xml_attribute::set_value(double rhs)
	{
		if (!_attr) return false;

		return impl::set_value_convert(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}
	
	PUGI__FN bool xml_attribute::set_value(bool rhs)
	{
		if (!_attr) return false;

		return impl::set_value_convert(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}

#ifdef PUGIXML_HAS_LONG_LONG
	PUGI__FN bool xml_attribute::set_value(long long rhs)
	{
		if (!_attr) return false;

		return impl::set_value_convert(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}

	PUGI__FN bool xml_attribute::set_value(unsigned long long rhs)
	{
		if (!_attr) return false;

		return impl::set_value_convert(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}
#endif

#ifdef __BORLANDC__
	PUGI__FN bool operator&&(const xml_attribute& lhs, bool rhs)
	{
		return (bool)lhs && rhs;
	}

	PUGI__FN bool operator||(const xml_attribute& lhs, bool rhs)
	{
		return (bool)lhs || rhs;
	}
#endif

	PUGI__FN xml_node::xml_node(): _root(0)
	{
	}

	PUGI__FN xml_node::xml_node(xml_node_struct* p): _root(p)
	{
	}
	
	PUGI__FN static void unspecified_bool_xml_node(xml_node***)
	{
	}

	PUGI__FN xml_node::operator xml_node::unspecified_bool_type() const
	{
		return _root ? unspecified_bool_xml_node : 0;
	}

	PUGI__FN bool xml_node::operator!() const
	{
		return !_root;
	}

	PUGI__FN xml_node::iterator xml_node::begin() const
	{
		return iterator(_root ? _root->first_child : 0, _root);
	}

	PUGI__FN xml_node::iterator xml_node::end() const
	{
		return iterator(0, _root);
	}
	
	PUGI__FN xml_node::attribute_iterator xml_node::attributes_begin() const
	{
		return attribute_iterator(_root ? _root->first_attribute : 0, _root);
	}

	PUGI__FN xml_node::attribute_iterator xml_node::attributes_end() const
	{
		return attribute_iterator(0, _root);
	}
	
	PUGI__FN xml_object_range<xml_node_iterator> xml_node::children() const
	{
		return xml_object_range<xml_node_iterator>(begin(), end());
	}

	PUGI__FN xml_object_range<xml_named_node_iterator> xml_node::children(const char_t* name_) const
	{
		return xml_object_range<xml_named_node_iterator>(xml_named_node_iterator(child(name_)._root, _root, name_), xml_named_node_iterator(0, _root, name_));
	}

	PUGI__FN xml_object_range<xml_attribute_iterator> xml_node::attributes() const
	{
		return xml_object_range<xml_attribute_iterator>(attributes_begin(), attributes_end());
	}

	PUGI__FN bool xml_node::operator==(const xml_node& r) const
	{
		return (_root == r._root);
	}

	PUGI__FN bool xml_node::operator!=(const xml_node& r) const
	{
		return (_root != r._root);
	}

	PUGI__FN bool xml_node::operator<(const xml_node& r) const
	{
		return (_root < r._root);
	}
	
	PUGI__FN bool xml_node::operator>(const xml_node& r) const
	{
		return (_root > r._root);
	}
	
	PUGI__FN bool xml_node::operator<=(const xml_node& r) const
	{
		return (_root <= r._root);
	}
	
	PUGI__FN bool xml_node::operator>=(const xml_node& r) const
	{
		return (_root >= r._root);
	}

	PUGI__FN bool xml_node::empty() const
	{
		return !_root;
	}
	
	PUGI__FN const char_t* xml_node::name() const
	{
		return (_root && _root->name) ? _root->name : PUGIXML_TEXT("");
	}

	PUGI__FN xml_node_type xml_node::type() const
	{
		return _root ? static_cast<xml_node_type>((_root->header & impl::xml_memory_page_type_mask) + 1) : node_null;
	}
	
	PUGI__FN const char_t* xml_node::value() const
	{
		return (_root && _root->value) ? _root->value : PUGIXML_TEXT("");
	}
	
	PUGI__FN xml_node xml_node::child(const char_t* name_) const
	{
		if (!_root) return xml_node();

		for (xml_node_struct* i = _root->first_child; i; i = i->next_sibling)
			if (i->name && impl::strequal(name_, i->name)) return xml_node(i);

		return xml_node();
	}

	PUGI__FN const std::string xml_node::getAttributeAsString(const char_t* name_, const char_t* defaultValue_, bool couldBeEmpty_, const char_t* validValues_) const
	{
		const char_t *nodeType_ = name();
		const char_t *nodeName_ = getAttributeAsCString("name", "");

		const std::string value = getAttributeAsString(name_, defaultValue_);

		if(!couldBeEmpty_ && value.empty())
		{
			///<@TODO: Throw Exception, value of option is not meant to be empty		
			char errorBuff[512];
			snprintf(errorBuff, sizeof(errorBuff), "<%s name=\"%s\"> Empty config option \"%s\" on config node %s", nodeType_, nodeName_, name_, nodeType_);
			std::string error = errorBuff;
			throw std::invalid_argument(error);
		}
		
		const std::string validValues = validValues_;
		if(!validValues.empty())
		{
			std::vector<std::string> values = infra::tokenize(validValues, ",");
			std::vector<std::string>::const_iterator valueItr = values.begin();
			for( ; valueItr != values.end() ; valueItr++)
			{
				if(*valueItr == value)
					break;
			}

			if(valueItr == values.end())
			{
				///<@TODO: Throw Exception, value of option is not meant to one of validValues 
				char errorBuff[512];
				snprintf(errorBuff, sizeof(errorBuff), "<%s name=\"%s\"> Config option \"%s\" has value \"%s\". Expected value is one of [%s]", nodeType_, nodeName_, name_, value.c_str(), validValues_);
				std::string error = errorBuff;
				throw std::invalid_argument(error);
			}
		}
		
		return value;
	}

	PUGI__FN const char_t* xml_node::getAttributeAsCString(const char_t* name_, const char_t* defaultValue_, bool couldBeEmpty_, const char_t* validValues_) const
	{
		const char_t *nodeType_ = name();
		const char_t *nodeName_ = getAttributeAsCString("name", "");

		const char_t *value = getAttributeAsCString(name_, defaultValue_);

		if(!couldBeEmpty_ && !strcmp(value, ""))
		{
			///<@TODO: Throw Exception, value of option is not meant to be empty		
			char errorBuff[512];
			snprintf(errorBuff, sizeof(errorBuff), "<%s name=\"%s\"> Empty config option \"%s\" on config node %s", nodeType_, nodeName_, name_, nodeType_);
			std::string error = errorBuff;
			throw std::invalid_argument(error);
		}
		
		const std::string validValues = validValues_;
		if(!validValues.empty())
		{
			bool found = false;
			std::size_t oldIndex = 0;
			std::size_t index;
			do 
			{
				index = validValues.find_first_of(",", oldIndex);
				std::string substr = validValues.substr(oldIndex, index - oldIndex);	
				oldIndex = index + 1;

				if(substr == value)
				{
					found = true;
					break;
				}
			} while (index !=std::string::npos);

			if(!found)
			{
				///<@TODO: Throw Exception, value of option is not meant to one of validValues 
				char errorBuff[512];
				snprintf(errorBuff, sizeof(errorBuff), "<%s name=\"%s\"> Config option \"%s\" has value \"%s\". Expected value is one of [%s]", nodeType_, nodeName_, name_, value, validValues_);
				std::string error = errorBuff;
				throw std::invalid_argument(error);
			}
		}
		
		return value;
	}

	PUGI__FN const std::string xml_node::getAttributeAsString(const char_t* name_, const char_t* value_) const
	{
		 const std::string retVal = attribute(name_).as_string(value_);
		 if(retVal.empty())
		 {
		 	return std::string(value_);
		 }
		 return retVal;
	}
	
	PUGI__FN const char_t* xml_node::getAttributeAsCString(const char_t* name_, const char_t* value_) const
	{
		 const char_t *retVal = attribute(name_).as_string(value_);
		 if(!strcmp(retVal, ""))
		 {
		 	return value_;
		 }
		 return retVal;
	}

	PUGI__FN int xml_node::getAttributeAsInt(const char_t* name_, int def) const
	{
		return attribute(name_).as_int(def);
	}

	PUGI__FN unsigned int xml_node::getAttributeAsUInt(const char_t* name_, unsigned int def) const
	{
		return attribute(name_).as_uint(def); 
	}

	PUGI__FN double xml_node::getAttributeAsDouble(const char_t* name_, double def) const
	{
		return attribute(name_).as_double(def);
	}

	PUGI__FN float xml_node::getAttributeAsFloat(const char_t* name_, float def) const
	{
		return attribute(name_).as_float(def);
	}

	PUGI__FN bool xml_node::getAttributeAsBool(const char_t* name_, bool def) const
	{
		return attribute(name_).as_bool(def);
	}

#ifdef PUGIXML_HAS_LONG_LONG
	PUGI__FN long long xml_node::getAttributeAsLlong(const char_t* name_, long long def) const
	{
		return attribute(name_).as_llong(def);
	}

	PUGI__FN unsigned long long xml_node::getAttributeAsUllong(const char_t* name_, unsigned long long def) const
	{
		return attribute(name_).as_ullong(def);
	}
#endif

	PUGI__FN xml_attribute xml_node::attribute(const char_t* name_) const
	{
		if (!_root) return xml_attribute();

		for (xml_attribute_struct* i = _root->first_attribute; i; i = i->next_attribute)
			if (i->name && impl::strequal(name_, i->name))
				return xml_attribute(i);
		
		return xml_attribute();
	}
	
	PUGI__FN xml_node xml_node::next_sibling(const char_t* name_) const
	{
		if (!_root) return xml_node();
		
		for (xml_node_struct* i = _root->next_sibling; i; i = i->next_sibling)
			if (i->name && impl::strequal(name_, i->name)) return xml_node(i);

		return xml_node();
	}

	PUGI__FN xml_node xml_node::next_sibling() const
	{
		if (!_root) return xml_node();
		
		if (_root->next_sibling) return xml_node(_root->next_sibling);
		else return xml_node();
	}

	PUGI__FN xml_node xml_node::previous_sibling(const char_t* name_) const
	{
		if (!_root) return xml_node();
		
		for (xml_node_struct* i = _root->prev_sibling_c; i->next_sibling; i = i->prev_sibling_c)
			if (i->name && impl::strequal(name_, i->name)) return xml_node(i);

		return xml_node();
	}

	PUGI__FN xml_node xml_node::previous_sibling() const
	{
		if (!_root) return xml_node();
		
		if (_root->prev_sibling_c->next_sibling) return xml_node(_root->prev_sibling_c);
		else return xml_node();
	}

	PUGI__FN xml_node xml_node::parent() const
	{
		return _root ? xml_node(_root->parent) : xml_node();
	}

	PUGI__FN xml_node xml_node::root() const
	{
		if (!_root) return xml_node();

		impl::xml_memory_page* page = reinterpret_cast<impl::xml_memory_page*>(_root->header & impl::xml_memory_page_pointer_mask);

		return xml_node(static_cast<impl::xml_document_struct*>(page->allocator));
	}

	PUGI__FN xml_text xml_node::text() const
	{
		return xml_text(_root);
	}

	PUGI__FN const char_t* xml_node::child_value() const
	{
		if (!_root) return PUGIXML_TEXT("");
		
		for (xml_node_struct* i = _root->first_child; i; i = i->next_sibling)
			if (i->value && impl::is_text_node(i))
				return i->value;

		return PUGIXML_TEXT("");
	}

	PUGI__FN const char_t* xml_node::child_value(const char_t* name_) const
	{
		return child(name_).child_value();
	}

	PUGI__FN xml_attribute xml_node::first_attribute() const
	{
		return _root ? xml_attribute(_root->first_attribute) : xml_attribute();
	}

	PUGI__FN xml_attribute xml_node::last_attribute() const
	{
		return _root && _root->first_attribute ? xml_attribute(_root->first_attribute->prev_attribute_c) : xml_attribute();
	}

	PUGI__FN xml_node xml_node::first_child() const
	{
		return _root ? xml_node(_root->first_child) : xml_node();
	}

	PUGI__FN xml_node xml_node::last_child() const
	{
		return _root && _root->first_child ? xml_node(_root->first_child->prev_sibling_c) : xml_node();
	}

	PUGI__FN bool xml_node::set_name(const char_t* rhs)
	{
		switch (type())
		{
		case node_pi:
		case node_declaration:
		case node_element:
			return impl::strcpy_insitu(_root->name, _root->header, impl::xml_memory_page_name_allocated_mask, rhs);

		default:
			return false;
		}
	}
		
	PUGI__FN bool xml_node::set_value(const char_t* rhs)
	{
		switch (type())
		{
		case node_pi:
		case node_cdata:
		case node_pcdata:
		case node_comment:
		case node_doctype:
			return impl::strcpy_insitu(_root->value, _root->header, impl::xml_memory_page_value_allocated_mask, rhs);

		default:
			return false;
		}
	}

	PUGI__FN xml_attribute xml_node::append_attribute(const char_t* name_)
	{
		if (type() != node_element && type() != node_declaration) return xml_attribute();
		
		xml_attribute a(impl::append_attribute_ll(_root, impl::get_allocator(_root)));
		a.set_name(name_);
		
		return a;
	}

	PUGI__FN xml_attribute xml_node::prepend_attribute(const char_t* name_)
	{
		if (type() != node_element && type() != node_declaration) return xml_attribute();
		
		xml_attribute a(impl::allocate_attribute(impl::get_allocator(_root)));
		if (!a) return xml_attribute();

		a.set_name(name_);
		
		xml_attribute_struct* head = _root->first_attribute;

		if (head)
		{
			a._attr->prev_attribute_c = head->prev_attribute_c;
			head->prev_attribute_c = a._attr;
		}
		else
			a._attr->prev_attribute_c = a._attr;
		
		a._attr->next_attribute = head;
		_root->first_attribute = a._attr;
				
		return a;
	}

	PUGI__FN xml_attribute xml_node::insert_attribute_before(const char_t* name_, const xml_attribute& attr)
	{
		if ((type() != node_element && type() != node_declaration) || attr.empty()) return xml_attribute();
		
		// check that attribute belongs to *this
		xml_attribute_struct* cur = attr._attr;

		while (cur->prev_attribute_c->next_attribute) cur = cur->prev_attribute_c;

		if (cur != _root->first_attribute) return xml_attribute();

		xml_attribute a(impl::allocate_attribute(impl::get_allocator(_root)));
		if (!a) return xml_attribute();

		a.set_name(name_);

		if (attr._attr->prev_attribute_c->next_attribute)
			attr._attr->prev_attribute_c->next_attribute = a._attr;
		else
			_root->first_attribute = a._attr;
		
		a._attr->prev_attribute_c = attr._attr->prev_attribute_c;
		a._attr->next_attribute = attr._attr;
		attr._attr->prev_attribute_c = a._attr;
				
		return a;
	}

	PUGI__FN xml_attribute xml_node::insert_attribute_after(const char_t* name_, const xml_attribute& attr)
	{
		if ((type() != node_element && type() != node_declaration) || attr.empty()) return xml_attribute();
		
		// check that attribute belongs to *this
		xml_attribute_struct* cur = attr._attr;

		while (cur->prev_attribute_c->next_attribute) cur = cur->prev_attribute_c;

		if (cur != _root->first_attribute) return xml_attribute();

		xml_attribute a(impl::allocate_attribute(impl::get_allocator(_root)));
		if (!a) return xml_attribute();

		a.set_name(name_);

		if (attr._attr->next_attribute)
			attr._attr->next_attribute->prev_attribute_c = a._attr;
		else
			_root->first_attribute->prev_attribute_c = a._attr;
		
		a._attr->next_attribute = attr._attr->next_attribute;
		a._attr->prev_attribute_c = attr._attr;
		attr._attr->next_attribute = a._attr;

		return a;
	}

	PUGI__FN xml_attribute xml_node::append_copy(const xml_attribute& proto)
	{
		if (!proto) return xml_attribute();

		xml_attribute result = append_attribute(proto.name());
		result.set_value(proto.value());

		return result;
	}

	PUGI__FN xml_attribute xml_node::prepend_copy(const xml_attribute& proto)
	{
		if (!proto) return xml_attribute();

		xml_attribute result = prepend_attribute(proto.name());
		result.set_value(proto.value());

		return result;
	}

	PUGI__FN xml_attribute xml_node::insert_copy_after(const xml_attribute& proto, const xml_attribute& attr)
	{
		if (!proto) return xml_attribute();

		xml_attribute result = insert_attribute_after(proto.name(), attr);
		result.set_value(proto.value());

		return result;
	}

	PUGI__FN xml_attribute xml_node::insert_copy_before(const xml_attribute& proto, const xml_attribute& attr)
	{
		if (!proto) return xml_attribute();

		xml_attribute result = insert_attribute_before(proto.name(), attr);
		result.set_value(proto.value());

		return result;
	}

	PUGI__FN xml_node xml_node::append_child(xml_node_type type_)
	{
		if (!impl::allow_insert_child(this->type(), type_)) return xml_node();
		
		xml_node n(impl::append_node(_root, impl::get_allocator(_root), type_));

		if (type_ == node_declaration) n.set_name(PUGIXML_TEXT("xml"));

		return n;
	}

	PUGI__FN xml_node xml_node::prepend_child(xml_node_type type_)
	{
		if (!impl::allow_insert_child(this->type(), type_)) return xml_node();
		
		xml_node n(impl::allocate_node(impl::get_allocator(_root), type_));
		if (!n) return xml_node();

		n._root->parent = _root;

		xml_node_struct* head = _root->first_child;

		if (head)
		{
			n._root->prev_sibling_c = head->prev_sibling_c;
			head->prev_sibling_c = n._root;
		}
		else
			n._root->prev_sibling_c = n._root;
		
		n._root->next_sibling = head;
		_root->first_child = n._root;
				
		if (type_ == node_declaration) n.set_name(PUGIXML_TEXT("xml"));

		return n;
	}

	PUGI__FN xml_node xml_node::insert_child_before(xml_node_type type_, const xml_node& node)
	{
		if (!impl::allow_insert_child(this->type(), type_)) return xml_node();
		if (!node._root || node._root->parent != _root) return xml_node();
	
		xml_node n(impl::allocate_node(impl::get_allocator(_root), type_));
		if (!n) return xml_node();

		n._root->parent = _root;
		
		if (node._root->prev_sibling_c->next_sibling)
			node._root->prev_sibling_c->next_sibling = n._root;
		else
			_root->first_child = n._root;
		
		n._root->prev_sibling_c = node._root->prev_sibling_c;
		n._root->next_sibling = node._root;
		node._root->prev_sibling_c = n._root;

		if (type_ == node_declaration) n.set_name(PUGIXML_TEXT("xml"));

		return n;
	}

	PUGI__FN xml_node xml_node::insert_child_after(xml_node_type type_, const xml_node& node)
	{
		if (!impl::allow_insert_child(this->type(), type_)) return xml_node();
		if (!node._root || node._root->parent != _root) return xml_node();
	
		xml_node n(impl::allocate_node(impl::get_allocator(_root), type_));
		if (!n) return xml_node();

		n._root->parent = _root;
	
		if (node._root->next_sibling)
			node._root->next_sibling->prev_sibling_c = n._root;
		else
			_root->first_child->prev_sibling_c = n._root;
		
		n._root->next_sibling = node._root->next_sibling;
		n._root->prev_sibling_c = node._root;
		node._root->next_sibling = n._root;

		if (type_ == node_declaration) n.set_name(PUGIXML_TEXT("xml"));

		return n;
	}

	PUGI__FN xml_node xml_node::append_child(const char_t* name_)
	{
		xml_node result = append_child(node_element);

		result.set_name(name_);

		return result;
	}

	PUGI__FN xml_node xml_node::prepend_child(const char_t* name_)
	{
		xml_node result = prepend_child(node_element);

		result.set_name(name_);

		return result;
	}

	PUGI__FN xml_node xml_node::insert_child_after(const char_t* name_, const xml_node& node)
	{
		xml_node result = insert_child_after(node_element, node);

		result.set_name(name_);

		return result;
	}

	PUGI__FN xml_node xml_node::insert_child_before(const char_t* name_, const xml_node& node)
	{
		xml_node result = insert_child_before(node_element, node);

		result.set_name(name_);

		return result;
	}

	PUGI__FN xml_node xml_node::append_copy(const xml_node& proto)
	{
		xml_node result = append_child(proto.type());

		if (result) impl::recursive_copy_skip(result, proto, result);

		return result;
	}

	PUGI__FN xml_node xml_node::prepend_copy(const xml_node& proto)
	{
		xml_node result = prepend_child(proto.type());

		if (result) impl::recursive_copy_skip(result, proto, result);

		return result;
	}

	PUGI__FN xml_node xml_node::insert_copy_after(const xml_node& proto, const xml_node& node)
	{
		xml_node result = insert_child_after(proto.type(), node);

		if (result) impl::recursive_copy_skip(result, proto, result);

		return result;
	}

	PUGI__FN xml_node xml_node::insert_copy_before(const xml_node& proto, const xml_node& node)
	{
		xml_node result = insert_child_before(proto.type(), node);

		if (result) impl::recursive_copy_skip(result, proto, result);

		return result;
	}

	PUGI__FN bool xml_node::remove_attribute(const char_t* name_)
	{
		return remove_attribute(attribute(name_));
	}

	PUGI__FN bool xml_node::remove_attribute(const xml_attribute& a)
	{
		if (!_root || !a._attr) return false;

		// check that attribute belongs to *this
		xml_attribute_struct* attr = a._attr;

		while (attr->prev_attribute_c->next_attribute) attr = attr->prev_attribute_c;

		if (attr != _root->first_attribute) return false;

		if (a._attr->next_attribute) a._attr->next_attribute->prev_attribute_c = a._attr->prev_attribute_c;
		else if (_root->first_attribute) _root->first_attribute->prev_attribute_c = a._attr->prev_attribute_c;
		
		if (a._attr->prev_attribute_c->next_attribute) a._attr->prev_attribute_c->next_attribute = a._attr->next_attribute;
		else _root->first_attribute = a._attr->next_attribute;

		impl::destroy_attribute(a._attr, impl::get_allocator(_root));

		return true;
	}

	PUGI__FN bool xml_node::remove_child(const char_t* name_)
	{
		return remove_child(child(name_));
	}

	PUGI__FN bool xml_node::remove_child(const xml_node& n)
	{
		if (!_root || !n._root || n._root->parent != _root) return false;

		if (n._root->next_sibling) n._root->next_sibling->prev_sibling_c = n._root->prev_sibling_c;
		else if (_root->first_child) _root->first_child->prev_sibling_c = n._root->prev_sibling_c;
		
		if (n._root->prev_sibling_c->next_sibling) n._root->prev_sibling_c->next_sibling = n._root->next_sibling;
		else _root->first_child = n._root->next_sibling;
		
		impl::destroy_node(n._root, impl::get_allocator(_root));

		return true;
	}

	PUGI__FN xml_parse_result xml_node::append_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)
	{
		// append_buffer is only valid for elements/documents
		if (!impl::allow_insert_child(type(), node_element)) return impl::make_parse_result(status_append_invalid_root);

		// get document node
		impl::xml_document_struct* doc = static_cast<impl::xml_document_struct*>(root()._root);
		assert(doc);
		
		// get extra buffer element (we'll store the document fragment buffer there so that we can deallocate it later)
		impl::xml_memory_page* page = 0;
		impl::xml_extra_buffer* extra = static_cast<impl::xml_extra_buffer*>(doc->allocate_memory(sizeof(impl::xml_extra_buffer), page));
		(void)page;

		if (!extra) return impl::make_parse_result(status_out_of_memory);

		// save name; name of the root has to be NULL before parsing - otherwise closing node mismatches will not be detected at the top level
		char_t* rootname = _root->name;
		_root->name = 0;

		// parse
		char_t* buffer = 0;
		xml_parse_result res = impl::load_buffer_impl(doc, _root, const_cast<void*>(contents), size, options, encoding, false, false, &buffer);

		// restore name
		_root->name = rootname;

		// add extra buffer to the list
		extra->buffer = buffer;
		extra->next = doc->extra_buffers;
		doc->extra_buffers = extra;

		return res;
	}

	PUGI__FN xml_node xml_node::find_child_by_attribute(const char_t* name_, const char_t* attr_name, const char_t* attr_value) const
	{
		if (!_root) return xml_node();
		
		for (xml_node_struct* i = _root->first_child; i; i = i->next_sibling)
			if (i->name && impl::strequal(name_, i->name))
			{
				for (xml_attribute_struct* a = i->first_attribute; a; a = a->next_attribute)
					if (a->name && impl::strequal(attr_name, a->name) && impl::strequal(attr_value, a->value ? a->value : PUGIXML_TEXT("")))
						return xml_node(i);
			}

		return xml_node();
	}

	PUGI__FN xml_node xml_node::find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const
	{
		if (!_root) return xml_node();
		
		for (xml_node_struct* i = _root->first_child; i; i = i->next_sibling)
			for (xml_attribute_struct* a = i->first_attribute; a; a = a->next_attribute)
				if (a->name && impl::strequal(attr_name, a->name) && impl::strequal(attr_value, a->value ? a->value : PUGIXML_TEXT("")))
					return xml_node(i);

		return xml_node();
	}

#ifndef PUGIXML_NO_STL
	PUGI__FN string_t xml_node::path(char_t delimiter) const
	{
		xml_node cursor = *this; // Make a copy.
		
		string_t result = cursor.name();

		while (cursor.parent())
		{
			cursor = cursor.parent();
			
			string_t temp = cursor.name();
			temp += delimiter;
			temp += result;
			result.swap(temp);
		}

		return result;
	}
#endif

	PUGI__FN xml_node xml_node::first_element_by_path(const char_t* path_, char_t delimiter) const
	{
		xml_node found = *this; // Current search context.

		if (!_root || !path_ || !path_[0]) return found;

		if (path_[0] == delimiter)
		{
			// Absolute path; e.g. '/foo/bar'
			found = found.root();
			++path_;
		}

		const char_t* path_segment = path_;

		while (*path_segment == delimiter) ++path_segment;

		const char_t* path_segment_end = path_segment;

		while (*path_segment_end && *path_segment_end != delimiter) ++path_segment_end;

		if (path_segment == path_segment_end) return found;

		const char_t* next_segment = path_segment_end;

		while (*next_segment == delimiter) ++next_segment;

		if (*path_segment == '.' && path_segment + 1 == path_segment_end)
			return found.first_element_by_path(next_segment, delimiter);
		else if (*path_segment == '.' && *(path_segment+1) == '.' && path_segment + 2 == path_segment_end)
			return found.parent().first_element_by_path(next_segment, delimiter);
		else
		{
			for (xml_node_struct* j = found._root->first_child; j; j = j->next_sibling)
			{
				if (j->name && impl::strequalrange(j->name, path_segment, static_cast<size_t>(path_segment_end - path_segment)))
				{
					xml_node subsearch = xml_node(j).first_element_by_path(next_segment, delimiter);

					if (subsearch) return subsearch;
				}
			}

			return xml_node();
		}
	}

	PUGI__FN bool xml_node::traverse(xml_tree_walker& walker)
	{
		walker._depth = -1;
		
		xml_node arg_begin = *this;
		if (!walker.begin(arg_begin)) return false;

		xml_node cur = first_child();
				
		if (cur)
		{
			++walker._depth;

			do 
			{
				xml_node arg_for_each = cur;
				if (!walker.for_each(arg_for_each))
					return false;
						
				if (cur.first_child())
				{
					++walker._depth;
					cur = cur.first_child();
				}
				else if (cur.next_sibling())
					cur = cur.next_sibling();
				else
				{
					// Borland C++ workaround
					while (!cur.next_sibling() && cur != *this && !cur.parent().empty())
					{
						--walker._depth;
						cur = cur.parent();
					}
						
					if (cur != *this)
						cur = cur.next_sibling();
				}
			}
			while (cur && cur != *this);
		}

		assert(walker._depth == -1);

		xml_node arg_end = *this;
		return walker.end(arg_end);
	}

	PUGI__FN size_t xml_node::hash_value() const
	{
		return static_cast<size_t>(reinterpret_cast<uintptr_t>(_root) / sizeof(xml_node_struct));
	}

	PUGI__FN xml_node_struct* xml_node::internal_object() const
	{
		return _root;
	}

	PUGI__FN void xml_node::print(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const
	{
		if (!_root) return;

		impl::xml_buffered_writer buffered_writer(writer, encoding);

		impl::node_output(buffered_writer, *this, indent, flags, depth);
	}

#ifndef PUGIXML_NO_STL
	PUGI__FN void xml_node::print(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const
	{
		xml_writer_stream writer(stream);

		print(writer, indent, flags, encoding, depth);
	}

	PUGI__FN void xml_node::print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags, unsigned int depth) const
	{
		xml_writer_stream writer(stream);

		print(writer, indent, flags, encoding_wchar, depth);
	}
#endif

	PUGI__FN ptrdiff_t xml_node::offset_debug() const
	{
		xml_node_struct* r = root()._root;

		if (!r) return -1;

		const char_t* buffer = static_cast<impl::xml_document_struct*>(r)->buffer;

		if (!buffer) return -1;

		switch (type())
		{
		case node_document:
			return 0;

		case node_element:
		case node_declaration:
		case node_pi:
			return (_root->header & impl::xml_memory_page_name_allocated_mask) ? -1 : _root->name - buffer;

		case node_pcdata:
		case node_cdata:
		case node_comment:
		case node_doctype:
			return (_root->header & impl::xml_memory_page_value_allocated_mask) ? -1 : _root->value - buffer;

		default:
			return -1;
		}
	}

#ifdef __BORLANDC__
	PUGI__FN bool operator&&(const xml_node& lhs, bool rhs)
	{
		return (bool)lhs && rhs;
	}

	PUGI__FN bool operator||(const xml_node& lhs, bool rhs)
	{
		return (bool)lhs || rhs;
	}
#endif

	PUGI__FN xml_text::xml_text(xml_node_struct* root): _root(root)
	{
	}

	PUGI__FN xml_node_struct* xml_text::_data() const
	{
		if (!_root || impl::is_text_node(_root)) return _root;

		for (xml_node_struct* node = _root->first_child; node; node = node->next_sibling)
			if (impl::is_text_node(node))
				return node;

		return 0;
	}

	PUGI__FN xml_node_struct* xml_text::_data_new()
	{
		xml_node_struct* d = _data();
		if (d) return d;

		return xml_node(_root).append_child(node_pcdata).internal_object();
	}

	PUGI__FN xml_text::xml_text(): _root(0)
	{
	}

	PUGI__FN static void unspecified_bool_xml_text(xml_text***)
	{
	}

	PUGI__FN xml_text::operator xml_text::unspecified_bool_type() const
	{
		return _data() ? unspecified_bool_xml_text : 0;
	}

	PUGI__FN bool xml_text::operator!() const
	{
		return !_data();
	}

	PUGI__FN bool xml_text::empty() const
	{
		return _data() == 0;
	}

	PUGI__FN const char_t* xml_text::get() const
	{
		xml_node_struct* d = _data();

		return (d && d->value) ? d->value : PUGIXML_TEXT("");
	}

	PUGI__FN const char_t* xml_text::as_string(const char_t* def) const
	{
		xml_node_struct* d = _data();

		return (d && d->value) ? d->value : def;
	}

	PUGI__FN int xml_text::as_int(int def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_int(d ? d->value : 0, def);
	}

	PUGI__FN unsigned int xml_text::as_uint(unsigned int def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_uint(d ? d->value : 0, def);
	}

	PUGI__FN double xml_text::as_double(double def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_double(d ? d->value : 0, def);
	}

	PUGI__FN float xml_text::as_float(float def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_float(d ? d->value : 0, def);
	}

	PUGI__FN bool xml_text::as_bool(bool def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_bool(d ? d->value : 0, def);
	}

#ifdef PUGIXML_HAS_LONG_LONG
	PUGI__FN long long xml_text::as_llong(long long def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_llong(d ? d->value : 0, def);
	}

	PUGI__FN unsigned long long xml_text::as_ullong(unsigned long long def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_ullong(d ? d->value : 0, def);
	}
#endif

	PUGI__FN bool xml_text::set(const char_t* rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::strcpy_insitu(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

	PUGI__FN bool xml_text::set(int rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

	PUGI__FN bool xml_text::set(unsigned int rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

	PUGI__FN bool xml_text::set(double rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

	PUGI__FN bool xml_text::set(bool rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

#ifdef PUGIXML_HAS_LONG_LONG
	PUGI__FN bool xml_text::set(long long rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

	PUGI__FN bool xml_text::set(unsigned long long rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}
#endif

	PUGI__FN xml_text& xml_text::operator=(const char_t* rhs)
	{
		set(rhs);
		return *this;
	}

	PUGI__FN xml_text& xml_text::operator=(int rhs)
	{
		set(rhs);
		return *this;
	}

	PUGI__FN xml_text& xml_text::operator=(unsigned int rhs)
	{
		set(rhs);
		return *this;
	}

	PUGI__FN xml_text& xml_text::operator=(double rhs)
	{
		set(rhs);
		return *this;
	}

	PUGI__FN xml_text& xml_text::operator=(bool rhs)
	{
		set(rhs);
		return *this;
	}

#ifdef PUGIXML_HAS_LONG_LONG
	PUGI__FN xml_text& xml_text::operator=(long long rhs)
	{
		set(rhs);
		return *this;
	}

	PUGI__FN xml_text& xml_text::operator=(unsigned long long rhs)
	{
		set(rhs);
		return *this;
	}
#endif

	PUGI__FN xml_node xml_text::data() const
	{
		return xml_node(_data());
	}

#ifdef __BORLANDC__
	PUGI__FN bool operator&&(const xml_text& lhs, bool rhs)
	{
		return (bool)lhs && rhs;
	}

	PUGI__FN bool operator||(const xml_text& lhs, bool rhs)
	{
		return (bool)lhs || rhs;
	}
#endif

	PUGI__FN xml_node_iterator::xml_node_iterator()
	{
	}

	PUGI__FN xml_node_iterator::xml_node_iterator(const xml_node& node): _wrap(node), _parent(node.parent())
	{
	}

	PUGI__FN xml_node_iterator::xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)
	{
	}

	PUGI__FN bool xml_node_iterator::operator==(const xml_node_iterator& rhs) const
	{
		return _wrap._root == rhs._wrap._root && _parent._root == rhs._parent._root;
	}
	
	PUGI__FN bool xml_node_iterator::operator!=(const xml_node_iterator& rhs) const
	{
		return _wrap._root != rhs._wrap._root || _parent._root != rhs._parent._root;
	}

	PUGI__FN xml_node& xml_node_iterator::operator*() const
	{
		assert(_wrap._root);
		return _wrap;
	}

	PUGI__FN xml_node* xml_node_iterator::operator->() const
	{
		assert(_wrap._root);
		return const_cast<xml_node*>(&_wrap); // BCC32 workaround
	}

	PUGI__FN const xml_node_iterator& xml_node_iterator::operator++()
	{
		assert(_wrap._root);
		_wrap._root = _wrap._root->next_sibling;
		return *this;
	}

	PUGI__FN xml_node_iterator xml_node_iterator::operator++(int)
	{
		xml_node_iterator temp = *this;
		++*this;
		return temp;
	}

	PUGI__FN const xml_node_iterator& xml_node_iterator::operator--()
	{
		_wrap = _wrap._root ? _wrap.previous_sibling() : _parent.last_child();
		return *this;
	}

	PUGI__FN xml_node_iterator xml_node_iterator::operator--(int)
	{
		xml_node_iterator temp = *this;
		--*this;
		return temp;
	}

	PUGI__FN xml_attribute_iterator::xml_attribute_iterator()
	{
	}

	PUGI__FN xml_attribute_iterator::xml_attribute_iterator(const xml_attribute& attr, const xml_node& parent): _wrap(attr), _parent(parent)
	{
	}

	PUGI__FN xml_attribute_iterator::xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)
	{
	}

	PUGI__FN bool xml_attribute_iterator::operator==(const xml_attribute_iterator& rhs) const
	{
		return _wrap._attr == rhs._wrap._attr && _parent._root == rhs._parent._root;
	}
	
	PUGI__FN bool xml_attribute_iterator::operator!=(const xml_attribute_iterator& rhs) const
	{
		return _wrap._attr != rhs._wrap._attr || _parent._root != rhs._parent._root;
	}

	PUGI__FN xml_attribute& xml_attribute_iterator::operator*() const
	{
		assert(_wrap._attr);
		return _wrap;
	}

	PUGI__FN xml_attribute* xml_attribute_iterator::operator->() const
	{
		assert(_wrap._attr);
		return const_cast<xml_attribute*>(&_wrap); // BCC32 workaround
	}

	PUGI__FN const xml_attribute_iterator& xml_attribute_iterator::operator++()
	{
		assert(_wrap._attr);
		_wrap._attr = _wrap._attr->next_attribute;
		return *this;
	}

	PUGI__FN xml_attribute_iterator xml_attribute_iterator::operator++(int)
	{
		xml_attribute_iterator temp = *this;
		++*this;
		return temp;
	}

	PUGI__FN const xml_attribute_iterator& xml_attribute_iterator::operator--()
	{
		_wrap = _wrap._attr ? _wrap.previous_attribute() : _parent.last_attribute();
		return *this;
	}

	PUGI__FN xml_attribute_iterator xml_attribute_iterator::operator--(int)
	{
		xml_attribute_iterator temp = *this;
		--*this;
		return temp;
	}

	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(): _name(0)
	{
	}

	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(const xml_node& node, const char_t* name): _wrap(node), _parent(node.parent()), _name(name)
	{
	}

	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(xml_node_struct* ref, xml_node_struct* parent, const char_t* name): _wrap(ref), _parent(parent), _name(name)
	{
	}

	PUGI__FN bool xml_named_node_iterator::operator==(const xml_named_node_iterator& rhs) const
	{
		return _wrap._root == rhs._wrap._root && _parent._root == rhs._parent._root;
	}

	PUGI__FN bool xml_named_node_iterator::operator!=(const xml_named_node_iterator& rhs) const
	{
		return _wrap._root != rhs._wrap._root || _parent._root != rhs._parent._root;
	}

	PUGI__FN xml_node& xml_named_node_iterator::operator*() const
	{
		assert(_wrap._root);
		return _wrap;
	}

	PUGI__FN xml_node* xml_named_node_iterator::operator->() const
	{
		assert(_wrap._root);
		return const_cast<xml_node*>(&_wrap); // BCC32 workaround
	}

	PUGI__FN const xml_named_node_iterator& xml_named_node_iterator::operator++()
	{
		assert(_wrap._root);
		_wrap = _wrap.next_sibling(_name);
		return *this;
	}

	PUGI__FN xml_named_node_iterator xml_named_node_iterator::operator++(int)
	{
		xml_named_node_iterator temp = *this;
		++*this;
		return temp;
	}

	PUGI__FN const xml_named_node_iterator& xml_named_node_iterator::operator--()
	{
		if (_wrap._root)
			_wrap = _wrap.previous_sibling(_name);
		else
		{
			_wrap = _parent.last_child();

			if (!impl::strequal(_wrap.name(), _name))
				_wrap = _wrap.previous_sibling(_name);
		}

		return *this;
	}

	PUGI__FN xml_named_node_iterator xml_named_node_iterator::operator--(int)
	{
		xml_named_node_iterator temp = *this;
		--*this;
		return temp;
	}

	PUGI__FN xml_parse_result::xml_parse_result(): status(status_internal_error), offset(0), encoding(encoding_auto)
	{
	}

	PUGI__FN xml_parse_result::operator bool() const
	{
		return status == status_ok;
	}

	PUGI__FN const char* xml_parse_result::description() const
	{
		switch (status)
		{
		case status_ok: return "No error";

		case status_file_not_found: return "File was not found";
		case status_io_error: return "Error reading from file/stream";
		case status_out_of_memory: return "Could not allocate memory";
		case status_internal_error: return "Internal error occurred";

		case status_unrecognized_tag: return "Could not determine tag type";

		case status_bad_pi: return "Error parsing document declaration/processing instruction";
		case status_bad_comment: return "Error parsing comment";
		case status_bad_cdata: return "Error parsing CDATA section";
		case status_bad_doctype: return "Error parsing document type declaration";
		case status_bad_pcdata: return "Error parsing PCDATA section";
		case status_bad_start_element: return "Error parsing start element tag";
		case status_bad_attribute: return "Error parsing element attribute";
		case status_bad_end_element: return "Error parsing end element tag";
		case status_end_element_mismatch: return "Start-end tags mismatch";

		case status_append_invalid_root: return "Unable to append nodes: root is not an element or document";

		case status_no_document_element: return "No document element found";

		default: return "Unknown error";
		}
	}

	PUGI__FN xml_document::xml_document(): _buffer(0)
	{
		create();
	}

	PUGI__FN xml_document::~xml_document()
	{
		destroy();
	}

	PUGI__FN void xml_document::reset()
	{
		destroy();
		create();
	}

	PUGI__FN void xml_document::reset(const xml_document& proto)
	{
		reset();

		for (xml_node cur = proto.first_child(); cur; cur = cur.next_sibling())
			append_copy(cur);
	}

	PUGI__FN void xml_document::create()
	{
        assert(!_root);

		// initialize sentinel page
		PUGI__STATIC_ASSERT(sizeof(impl::xml_memory_page) + sizeof(impl::xml_document_struct) + impl::xml_memory_page_alignment <= sizeof(_memory));

		// align upwards to page boundary
		void* page_memory = reinterpret_cast<void*>((reinterpret_cast<uintptr_t>(_memory) + (impl::xml_memory_page_alignment - 1)) & ~(impl::xml_memory_page_alignment - 1));

		// prepare page structure
		impl::xml_memory_page* page = impl::xml_memory_page::construct(page_memory);
		assert(page);

		page->busy_size = impl::xml_memory_page_size;

		// allocate new root
		_root = new (page->data) impl::xml_document_struct(page);
		_root->prev_sibling_c = _root;

		// setup sentinel page
		page->allocator = static_cast<impl::xml_document_struct*>(_root);
	}

	PUGI__FN void xml_document::destroy()
	{
        assert(_root);

		// destroy static storage
		if (_buffer)
		{
			impl::xml_memory::deallocate(_buffer);
			_buffer = 0;
		}

		// destroy extra buffers (note: no need to destroy linked list nodes, they're allocated using document allocator)
		for (impl::xml_extra_buffer* extra = static_cast<impl::xml_document_struct*>(_root)->extra_buffers; extra; extra = extra->next)
		{
			if (extra->buffer) impl::xml_memory::deallocate(extra->buffer);
		}

		// destroy dynamic storage, leave sentinel page (it's in static memory)
        impl::xml_memory_page* root_page = reinterpret_cast<impl::xml_memory_page*>(_root->header & impl::xml_memory_page_pointer_mask);
        assert(root_page && !root_page->prev && !root_page->memory);

        for (impl::xml_memory_page* page = root_page->next; page; )
        {
            impl::xml_memory_page* next = page->next;

            impl::xml_allocator::deallocate_page(page);

            page = next;
        }

        _root = 0;
	}

#ifndef PUGIXML_NO_STL
	PUGI__FN xml_parse_result xml_document::load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options, xml_encoding encoding)
	{
		reset();

		return impl::load_stream_impl(*this, stream, options, encoding);
	}

	PUGI__FN xml_parse_result xml_document::load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options)
	{
		reset();

		return impl::load_stream_impl(*this, stream, options, encoding_wchar);
	}
#endif

	PUGI__FN xml_parse_result xml_document::load(const char_t* contents, unsigned int options)
	{
		// Force native encoding (skip autodetection)
	#ifdef PUGIXML_WCHAR_MODE
		xml_encoding encoding = encoding_wchar;
	#else
		xml_encoding encoding = encoding_utf8;
	#endif

		return load_buffer(contents, impl::strlength(contents) * sizeof(char_t), options, encoding);
	}

	PUGI__FN xml_parse_result xml_document::load_file(const char* path_, unsigned int options, xml_encoding encoding)
	{
		reset();

		FILE* file = fopen(path_, "rb");

		return impl::load_file_impl(*this, file, options, encoding);
	}

	PUGI__FN xml_parse_result xml_document::load_file(const wchar_t* path_, unsigned int options, xml_encoding encoding)
	{
		reset();

		FILE* file = impl::open_file_wide(path_, L"rb");

		return impl::load_file_impl(*this, file, options, encoding);
	}

	PUGI__FN xml_parse_result xml_document::load_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)
	{
		reset();

		return impl::load_buffer_impl(static_cast<impl::xml_document_struct*>(_root), _root, const_cast<void*>(contents), size, options, encoding, false, false, &_buffer);
	}

	PUGI__FN xml_parse_result xml_document::load_buffer_inplace(void* contents, size_t size, unsigned int options, xml_encoding encoding)
	{
		reset();

		return impl::load_buffer_impl(static_cast<impl::xml_document_struct*>(_root), _root, contents, size, options, encoding, true, false, &_buffer);
	}
		
	PUGI__FN xml_parse_result xml_document::load_buffer_inplace_own(void* contents, size_t size, unsigned int options, xml_encoding encoding)
	{
		reset();

		return impl::load_buffer_impl(static_cast<impl::xml_document_struct*>(_root), _root, contents, size, options, encoding, true, true, &_buffer);
	}

	PUGI__FN void xml_document::save(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding) const
	{
		impl::xml_buffered_writer buffered_writer(writer, encoding);

		if ((flags & format_write_bom) && encoding != encoding_latin1)
		{
			// BOM always represents the codepoint U+FEFF, so just write it in native encoding
		#ifdef PUGIXML_WCHAR_MODE
			unsigned int bom = 0xfeff;
			buffered_writer.write(static_cast<wchar_t>(bom));
		#else
			buffered_writer.write('\xef', '\xbb', '\xbf');
		#endif
		}

		if (!(flags & format_no_declaration) && !impl::has_declaration(*this))
		{
			buffered_writer.write(PUGIXML_TEXT("<?xml version=\"1.0\""));
			if (encoding == encoding_latin1) buffered_writer.write(PUGIXML_TEXT(" encoding=\"ISO-8859-1\""));
			buffered_writer.write('?', '>');
			if (!(flags & format_raw)) buffered_writer.write('\n');
		}

		impl::node_output(buffered_writer, *this, indent, flags, 0);
	}

#ifndef PUGIXML_NO_STL
	PUGI__FN void xml_document::save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding) const
	{
		xml_writer_stream writer(stream);

		save(writer, indent, flags, encoding);
	}

	PUGI__FN void xml_document::save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags) const
	{
		xml_writer_stream writer(stream);

		save(writer, indent, flags, encoding_wchar);
	}
#endif

	PUGI__FN bool xml_document::save_file(const char* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const
	{
		FILE* file = fopen(path_, (flags & format_save_file_text) ? "w" : "wb");
		return impl::save_file_impl(*this, file, indent, flags, encoding);
	}

	PUGI__FN bool xml_document::save_file(const wchar_t* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const
	{
		FILE* file = impl::open_file_wide(path_, (flags & format_save_file_text) ? L"w" : L"wb");
		return impl::save_file_impl(*this, file, indent, flags, encoding);
	}

	PUGI__FN xml_node xml_document::document_element() const
	{
        assert(_root);

		for (xml_node_struct* i = _root->first_child; i; i = i->next_sibling)
			if ((i->header & impl::xml_memory_page_type_mask) + 1 == node_element)
				return xml_node(i);

		return xml_node();
	}

#ifndef PUGIXML_NO_STL
	PUGI__FN std::string PUGIXML_FUNCTION as_utf8(const wchar_t* str)
	{
		assert(str);

		return impl::as_utf8_impl(str, impl::strlength_wide(str));
	}

	PUGI__FN std::string PUGIXML_FUNCTION as_utf8(const std::basic_string<wchar_t>& str)
	{
		return impl::as_utf8_impl(str.c_str(), str.size());
	}
	
	PUGI__FN std::basic_string<wchar_t> PUGIXML_FUNCTION as_wide(const char* str)
	{
		assert(str);

		return impl::as_wide_impl(str, strlen(str));
	}
	
	PUGI__FN std::basic_string<wchar_t> PUGIXML_FUNCTION as_wide(const std::string& str)
	{
		return impl::as_wide_impl(str.c_str(), str.size());
	}
#endif

	PUGI__FN void PUGIXML_FUNCTION set_memory_management_functions(allocation_function allocate, deallocation_function deallocate)
	{
		impl::xml_memory::allocate = allocate;
		impl::xml_memory::deallocate = deallocate;
	}

	PUGI__FN allocation_function PUGIXML_FUNCTION get_memory_allocation_function()
	{
		return impl::xml_memory::allocate;
	}

	PUGI__FN deallocation_function PUGIXML_FUNCTION get_memory_deallocation_function()
	{
		return impl::xml_memory::deallocate;
	}
}

#if !defined(PUGIXML_NO_STL) && (defined(_MSC_VER) || defined(__ICC))
namespace std
{
	// Workarounds for (non-standard) iterator category detection for older versions (MSVC7/IC8 and earlier)
	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_node_iterator&)
	{
		return std::bidirectional_iterator_tag();
	}

	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_attribute_iterator&)
	{
		return std::bidirectional_iterator_tag();
	}

	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_named_node_iterator&)
	{
		return std::bidirectional_iterator_tag();
	}
}
#endif

#if !defined(PUGIXML_NO_STL) && defined(__SUNPRO_CC)
namespace std
{
	// Workarounds for (non-standard) iterator category detection
	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_node_iterator&)
	{
		return std::bidirectional_iterator_tag();
	}

	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_attribute_iterator&)
	{
		return std::bidirectional_iterator_tag();
	}

	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_named_node_iterator&)
	{
		return std::bidirectional_iterator_tag();
	}
}
#endif

#ifndef PUGIXML_NO_XPATH

// STL replacements
PUGI__NS_BEGIN
	struct equal_to
	{
		template <typename T> bool operator()(const T& lhs, const T& rhs) const
		{
			return lhs == rhs;
		}
	};

	struct not_equal_to
	{
		template <typename T> bool operator()(const T& lhs, const T& rhs) const
		{
			return lhs != rhs;
		}
	};

	struct less
	{
		template <typename T> bool operator()(const T& lhs, const T& rhs) const
		{
			return lhs < rhs;
		}
	};

	struct less_equal
	{
		template <typename T> bool operator()(const T& lhs, const T& rhs) const
		{
			return lhs <= rhs;
		}
	};

	template <typename T> void swap(T& lhs, T& rhs)
	{
		T temp = lhs;
		lhs = rhs;
		rhs = temp;
	}

	template <typename I, typename Pred> I min_element(I begin, I end, const Pred& pred)
	{
		I result = begin;

		for (I it = begin + 1; it != end; ++it)
			if (pred(*it, *result))
				result = it;

		return result;
	}

	template <typename I> void reverse(I begin, I end)
	{
		while (end - begin > 1) swap(*begin++, *--end);
	}

	template <typename I> I unique(I begin, I end)
	{
		// fast skip head
		while (end - begin > 1 && *begin != *(begin + 1)) begin++;

		if (begin == end) return begin;

		// last written element
		I write = begin++; 

		// merge unique elements
		while (begin != end)
		{
			if (*begin != *write)
				*++write = *begin++;
			else
				begin++;
		}

		// past-the-end (write points to live element)
		return write + 1;
	}

	template <typename I> void copy_backwards(I begin, I end, I target)
	{
		while (begin != end) *--target = *--end;
	}

	template <typename I, typename Pred, typename T> void insertion_sort(I begin, I end, const Pred& pred, T*)
	{
		assert(begin != end);

		for (I it = begin + 1; it != end; ++it)
		{
			T val = *it;

			if (pred(val, *begin))
			{
				// move to front
				copy_backwards(begin, it, it + 1);
				*begin = val;
			}
			else
			{
				I hole = it;

				// move hole backwards
				while (pred(val, *(hole - 1)))
				{
					*hole = *(hole - 1);
					hole--;
				}

				// fill hole with element
				*hole = val;
			}
		}
	}

	// std variant for elements with ==
	template <typename I, typename Pred> void partition(I begin, I middle, I end, const Pred& pred, I* out_eqbeg, I* out_eqend)
	{
		I eqbeg = middle, eqend = middle + 1;

		// expand equal range
		while (eqbeg != begin && *(eqbeg - 1) == *eqbeg) --eqbeg;
		while (eqend != end && *eqend == *eqbeg) ++eqend;

		// process outer elements
		I ltend = eqbeg, gtbeg = eqend;

		for (;;)
		{
			// find the element from the right side that belongs to the left one
			for (; gtbeg != end; ++gtbeg)
				if (!pred(*eqbeg, *gtbeg))
				{
					if (*gtbeg == *eqbeg) swap(*gtbeg, *eqend++);
					else break;
				}

			// find the element from the left side that belongs to the right one
			for (; ltend != begin; --ltend)
				if (!pred(*(ltend - 1), *eqbeg))
				{
					if (*eqbeg == *(ltend - 1)) swap(*(ltend - 1), *--eqbeg);
					else break;
				}

			// scanned all elements
			if (gtbeg == end && ltend == begin)
			{
				*out_eqbeg = eqbeg;
				*out_eqend = eqend;
				return;
			}

			// make room for elements by moving equal area
			if (gtbeg == end)
			{
				if (--ltend != --eqbeg) swap(*ltend, *eqbeg);
				swap(*eqbeg, *--eqend);
			}
			else if (ltend == begin)
			{
				if (eqend != gtbeg) swap(*eqbeg, *eqend);
				++eqend;
				swap(*gtbeg++, *eqbeg++);
			}
			else swap(*gtbeg++, *--ltend);
		}
	}

	template <typename I, typename Pred> void median3(I first, I middle, I last, const Pred& pred)
	{
		if (pred(*middle, *first)) swap(*middle, *first);
		if (pred(*last, *middle)) swap(*last, *middle);
		if (pred(*middle, *first)) swap(*middle, *first);
	}

	template <typename I, typename Pred> void median(I first, I middle, I last, const Pred& pred)
	{
		if (last - first <= 40)
		{
			// median of three for small chunks
			median3(first, middle, last, pred);
		}
		else
		{
			// median of nine
			size_t step = (last - first + 1) / 8;

			median3(first, first + step, first + 2 * step, pred);
			median3(middle - step, middle, middle + step, pred);
			median3(last - 2 * step, last - step, last, pred);
			median3(first + step, middle, last - step, pred);
		}
	}

	template <typename I, typename Pred> void sort(I begin, I end, const Pred& pred)
	{
		// sort large chunks
		while (end - begin > 32)
		{
			// find median element
			I middle = begin + (end - begin) / 2;
			median(begin, middle, end - 1, pred);

			// partition in three chunks (< = >)
			I eqbeg, eqend;
			partition(begin, middle, end, pred, &eqbeg, &eqend);

			// loop on larger half
			if (eqbeg - begin > end - eqend)
			{
				sort(eqend, end, pred);
				end = eqbeg;
			}
			else
			{
				sort(begin, eqbeg, pred);
				begin = eqend;
			}
		}

		// insertion sort small chunk
		if (begin != end) insertion_sort(begin, end, pred, &*begin);
	}
PUGI__NS_END

// Allocator used for AST and evaluation stacks
PUGI__NS_BEGIN
	struct xpath_memory_block
	{	
		xpath_memory_block* next;

		char data[
	#ifdef PUGIXML_MEMORY_XPATH_PAGE_SIZE
			PUGIXML_MEMORY_XPATH_PAGE_SIZE
	#else
			4096
	#endif
		];
	};
		
	class xpath_allocator
	{
		xpath_memory_block* _root;
		size_t _root_size;

	public:
	#ifdef PUGIXML_NO_EXCEPTIONS
		jmp_buf* error_handler;
	#endif

		xpath_allocator(xpath_memory_block* root, size_t root_size = 0): _root(root), _root_size(root_size)
		{
		#ifdef PUGIXML_NO_EXCEPTIONS
			error_handler = 0;
		#endif
		}
		
		void* allocate_nothrow(size_t size)
		{
			const size_t block_capacity = sizeof(_root->data);

			// align size so that we're able to store pointers in subsequent blocks
			size = (size + sizeof(void*) - 1) & ~(sizeof(void*) - 1);

			if (_root_size + size <= block_capacity)
			{
				void* buf = _root->data + _root_size;
				_root_size += size;
				return buf;
			}
			else
			{
				size_t block_data_size = (size > block_capacity) ? size : block_capacity;
				size_t block_size = block_data_size + offsetof(xpath_memory_block, data);

				xpath_memory_block* block = static_cast<xpath_memory_block*>(xml_memory::allocate(block_size));
				if (!block) return 0;
				
				block->next = _root;
				
				_root = block;
				_root_size = size;
				
				return block->data;
			}
		}

		void* allocate(size_t size)
		{
			void* result = allocate_nothrow(size);

			if (!result)
			{
			#ifdef PUGIXML_NO_EXCEPTIONS
				assert(error_handler);
				longjmp(*error_handler, 1);
			#else
				throw std::bad_alloc();
			#endif
			}

			return result;
		}

		void* reallocate(void* ptr, size_t old_size, size_t new_size)
		{
			// align size so that we're able to store pointers in subsequent blocks
			old_size = (old_size + sizeof(void*) - 1) & ~(sizeof(void*) - 1);
			new_size = (new_size + sizeof(void*) - 1) & ~(sizeof(void*) - 1);

			// we can only reallocate the last object
			assert(ptr == 0 || static_cast<char*>(ptr) + old_size == _root->data + _root_size);

			// adjust root size so that we have not allocated the object at all
			bool only_object = (_root_size == old_size);

			if (ptr) _root_size -= old_size;

			// allocate a new version (this will obviously reuse the memory if possible)
			void* result = allocate(new_size);
			assert(result);

			// we have a new block
			if (result != ptr && ptr)
			{
				// copy old data
				assert(new_size >= old_size);
				memcpy(result, ptr, old_size);

				// free the previous page if it had no other objects
				if (only_object)
				{
					assert(_root->data == result);
					assert(_root->next);

					xpath_memory_block* next = _root->next->next;

					if (next)
					{
						// deallocate the whole page, unless it was the first one
						xml_memory::deallocate(_root->next);
						_root->next = next;
					}
				}
			}

			return result;
		}

		void revert(const xpath_allocator& state)
		{
			// free all new pages
			xpath_memory_block* cur = _root;

			while (cur != state._root)
			{
				xpath_memory_block* next = cur->next;

				xml_memory::deallocate(cur);

				cur = next;
			}

			// restore state
			_root = state._root;
			_root_size = state._root_size;
		}

		void release()
		{
			xpath_memory_block* cur = _root;
			assert(cur);

			while (cur->next)
			{
				xpath_memory_block* next = cur->next;

				xml_memory::deallocate(cur);

				cur = next;
			}
		}
	};

	struct xpath_allocator_capture
	{
		xpath_allocator_capture(xpath_allocator* alloc): _target(alloc), _state(*alloc)
		{
		}

		~xpath_allocator_capture()
		{
			_target->revert(_state);
		}

		xpath_allocator* _target;
		xpath_allocator _state;
	};

	struct xpath_stack
	{
		xpath_allocator* result;
		xpath_allocator* temp;
	};

	struct xpath_stack_data
	{
		xpath_memory_block blocks[2];
		xpath_allocator result;
		xpath_allocator temp;
		xpath_stack stack;

	#ifdef PUGIXML_NO_EXCEPTIONS
		jmp_buf error_handler;
	#endif

		xpath_stack_data(): result(blocks + 0), temp(blocks + 1)
		{
			blocks[0].next = blocks[1].next = 0;

			stack.result = &result;
			stack.temp = &temp;

		#ifdef PUGIXML_NO_EXCEPTIONS
			result.error_handler = temp.error_handler = &error_handler;
		#endif
		}

		~xpath_stack_data()
		{
			result.release();
			temp.release();
		}
	};
PUGI__NS_END

// String class
PUGI__NS_BEGIN
	class xpath_string
	{
		const char_t* _buffer;
		bool _uses_heap;

		static char_t* duplicate_string(const char_t* string, size_t length, xpath_allocator* alloc)
		{
			char_t* result = static_cast<char_t*>(alloc->allocate((length + 1) * sizeof(char_t)));
			assert(result);

			memcpy(result, string, length * sizeof(char_t));
			result[length] = 0;

			return result;
		}

		static char_t* duplicate_string(const char_t* string, xpath_allocator* alloc)
		{
			return duplicate_string(string, strlength(string), alloc);
		}

	public:
		xpath_string(): _buffer(PUGIXML_TEXT("")), _uses_heap(false)
		{
		}

		explicit xpath_string(const char_t* str, xpath_allocator* alloc)
		{
			bool empty_ = (*str == 0);

			_buffer = empty_ ? PUGIXML_TEXT("") : duplicate_string(str, alloc);
			_uses_heap = !empty_;
		}

		explicit xpath_string(const char_t* str, bool use_heap): _buffer(str), _uses_heap(use_heap)
		{
		}

		xpath_string(const char_t* begin, const char_t* end, xpath_allocator* alloc)
		{
			assert(begin <= end);

			bool empty_ = (begin == end);

			_buffer = empty_ ? PUGIXML_TEXT("") : duplicate_string(begin, static_cast<size_t>(end - begin), alloc);
			_uses_heap = !empty_;
		}

		void append(const xpath_string& o, xpath_allocator* alloc)
		{
			// skip empty sources
			if (!*o._buffer) return;

			// fast append for constant empty target and constant source
			if (!*_buffer && !_uses_heap && !o._uses_heap)
			{
				_buffer = o._buffer;
			}
			else
			{
				// need to make heap copy
				size_t target_length = strlength(_buffer);
				size_t source_length = strlength(o._buffer);
				size_t result_length = target_length + source_length;

				// allocate new buffer
				char_t* result = static_cast<char_t*>(alloc->reallocate(_uses_heap ? const_cast<char_t*>(_buffer) : 0, (target_length + 1) * sizeof(char_t), (result_length + 1) * sizeof(char_t)));
				assert(result);

				// append first string to the new buffer in case there was no reallocation
				if (!_uses_heap) memcpy(result, _buffer, target_length * sizeof(char_t));

				// append second string to the new buffer
				memcpy(result + target_length, o._buffer, source_length * sizeof(char_t));
				result[result_length] = 0;

				// finalize
				_buffer = result;
				_uses_heap = true;
			}
		}

		const char_t* c_str() const
		{
			return _buffer;
		}

		size_t length() const
		{
			return strlength(_buffer);
		}
		
		char_t* data(xpath_allocator* alloc)
		{
			// make private heap copy
			if (!_uses_heap)
			{
				_buffer = duplicate_string(_buffer, alloc);
				_uses_heap = true;
			}

			return const_cast<char_t*>(_buffer);
		}

		bool empty() const
		{
			return *_buffer == 0;
		}

		bool operator==(const xpath_string& o) const
		{
			return strequal(_buffer, o._buffer);
		}

		bool operator!=(const xpath_string& o) const
		{
			return !strequal(_buffer, o._buffer);
		}

		bool uses_heap() const
		{
			return _uses_heap;
		}
	};

	PUGI__FN xpath_string xpath_string_const(const char_t* str)
	{
		return xpath_string(str, false);
	}
PUGI__NS_END

PUGI__NS_BEGIN
	PUGI__FN bool starts_with(const char_t* string, const char_t* pattern)
	{
		while (*pattern && *string == *pattern)
		{
			string++;
			pattern++;
		}

		return *pattern == 0;
	}

	PUGI__FN const char_t* find_char(const char_t* s, char_t c)
	{
	#ifdef PUGIXML_WCHAR_MODE
		return wcschr(s, c);
	#else
		return strchr(s, c);
	#endif
	}

	PUGI__FN const char_t* find_substring(const char_t* s, const char_t* p)
	{
	#ifdef PUGIXML_WCHAR_MODE
		// MSVC6 wcsstr bug workaround (if s is empty it always returns 0)
		return (*p == 0) ? s : wcsstr(s, p);
	#else
		return strstr(s, p);
	#endif
	}

	// Converts symbol to lower case, if it is an ASCII one
	PUGI__FN char_t tolower_ascii(char_t ch)
	{
		return static_cast<unsigned int>(ch - 'A') < 26 ? static_cast<char_t>(ch | ' ') : ch;
	}

	PUGI__FN xpath_string string_value(const xpath_node& na, xpath_allocator* alloc)
	{
		if (na.attribute())
			return xpath_string_const(na.attribute().value());
		else
		{
			const xml_node& n = na.node();

			switch (n.type())
			{
			case node_pcdata:
			case node_cdata:
			case node_comment:
			case node_pi:
				return xpath_string_const(n.value());
			
			case node_document:
			case node_element:
			{
				xpath_string result;

				xml_node cur = n.first_child();
				
				while (cur && cur != n)
				{
					if (cur.type() == node_pcdata || cur.type() == node_cdata)
						result.append(xpath_string_const(cur.value()), alloc);

					if (cur.first_child())
						cur = cur.first_child();
					else if (cur.next_sibling())
						cur = cur.next_sibling();
					else
					{
						while (!cur.next_sibling() && cur != n)
							cur = cur.parent();

						if (cur != n) cur = cur.next_sibling();
					}
				}
				
				return result;
			}
			
			default:
				return xpath_string();
			}
		}
	}
	
	PUGI__FN unsigned int node_height(xml_node n)
	{
		unsigned int result = 0;
		
		while (n)
		{
			++result;
			n = n.parent();
		}
		
		return result;
	}
	
	PUGI__FN bool node_is_before(xml_node ln, unsigned int lh, xml_node rn, unsigned int rh)
	{
		// normalize heights
		for (unsigned int i = rh; i < lh; i++) ln = ln.parent();
		for (unsigned int j = lh; j < rh; j++) rn = rn.parent();
		
		// one node is the ancestor of the other
		if (ln == rn) return lh < rh;
		
		// find common ancestor
		while (ln.parent() != rn.parent())
		{
			ln = ln.parent();
			rn = rn.parent();
		}

		// there is no common ancestor (the shared parent is null), nodes are from different documents
		if (!ln.parent()) return ln < rn;

		// determine sibling order
		for (; ln; ln = ln.next_sibling())
			if (ln == rn)
				return true;
				
		return false;
	}

	PUGI__FN bool node_is_ancestor(xml_node parent, xml_node node)
	{
		while (node && node != parent) node = node.parent();

		return parent && node == parent;
	}

	PUGI__FN const void* document_order(const xpath_node& xnode)
	{
		xml_node_struct* node = xnode.node().internal_object();

		if (node)
		{
			if (node->name && (node->header & xml_memory_page_name_allocated_mask) == 0) return node->name;
			if (node->value && (node->header & xml_memory_page_value_allocated_mask) == 0) return node->value;
			return 0;
		}

		xml_attribute_struct* attr = xnode.attribute().internal_object();

		if (attr)
		{
			if ((attr->header & xml_memory_page_name_allocated_mask) == 0) return attr->name;
			if ((attr->header & xml_memory_page_value_allocated_mask) == 0) return attr->value;
			return 0;
		}

		return 0;
	}
	
	struct document_order_comparator
	{
		bool operator()(const xpath_node& lhs, const xpath_node& rhs) const
		{
			// optimized document order based check
			const void* lo = document_order(lhs);
			const void* ro = document_order(rhs);

			if (lo && ro) return lo < ro;

			// slow comparison
			xml_node ln = lhs.node(), rn = rhs.node();

			// compare attributes
			if (lhs.attribute() && rhs.attribute())
			{
				// shared parent
				if (lhs.parent() == rhs.parent())
				{
					// determine sibling order
					for (xml_attribute a = lhs.attribute(); a; a = a.next_attribute())
						if (a == rhs.attribute())
							return true;
					
					return false;
				}
				
				// compare attribute parents
				ln = lhs.parent();
				rn = rhs.parent();
			}
			else if (lhs.attribute())
			{
				// attributes go after the parent element
				if (lhs.parent() == rhs.node()) return false;
				
				ln = lhs.parent();
			}
			else if (rhs.attribute())
			{
				// attributes go after the parent element
				if (rhs.parent() == lhs.node()) return true;
				
				rn = rhs.parent();
			}

			if (ln == rn) return false;
			
			unsigned int lh = node_height(ln);
			unsigned int rh = node_height(rn);
			
			return node_is_before(ln, lh, rn, rh);
		}
	};

	struct duplicate_comparator
	{
		bool operator()(const xpath_node& lhs, const xpath_node& rhs) const
		{
			if (lhs.attribute()) return rhs.attribute() ? lhs.attribute() < rhs.attribute() : true;
			else return rhs.attribute() ? false : lhs.node() < rhs.node();
		}
	};
	
	PUGI__FN double gen_nan()
	{
	#if defined(__STDC_IEC_559__) || ((FLT_RADIX - 0 == 2) && (FLT_MAX_EXP - 0 == 128) && (FLT_MANT_DIG - 0 == 24))
		union { float f; uint32_t i; } u[sizeof(float) == sizeof(uint32_t) ? 1 : -1];
		u[0].i = 0x7fc00000;
		return u[0].f;
	#else
		// fallback
		const volatile double zero = 0.0;
		return zero / zero;
	#endif
	}
	
	PUGI__FN bool is_nan(double value)
	{
	#if defined(PUGI__MSVC_CRT_VERSION) || defined(__BORLANDC__)
		return !!_isnan(value);
	#elif defined(fpclassify) && defined(FP_NAN)
		return fpclassify(value) == FP_NAN;
	#else
		// fallback
		const volatile double v = value;
		return v != v;
	#endif
	}
	
	PUGI__FN const char_t* convert_number_to_string_special(double value)
	{
	#if defined(PUGI__MSVC_CRT_VERSION) || defined(__BORLANDC__)
		if (_finite(value)) return (value == 0) ? PUGIXML_TEXT("0") : 0;
		if (_isnan(value)) return PUGIXML_TEXT("NaN");
		return value > 0 ? PUGIXML_TEXT("Infinity") : PUGIXML_TEXT("-Infinity");
	#elif defined(fpclassify) && defined(FP_NAN) && defined(FP_INFINITE) && defined(FP_ZERO)
		switch (fpclassify(value))
		{
		case FP_NAN:
			return PUGIXML_TEXT("NaN");

		case FP_INFINITE:
			return value > 0 ? PUGIXML_TEXT("Infinity") : PUGIXML_TEXT("-Infinity");

		case FP_ZERO:
			return PUGIXML_TEXT("0");

		default:
			return 0;
		}
	#else
		// fallback
		const volatile double v = value;

		if (v == 0) return PUGIXML_TEXT("0");
		if (v != v) return PUGIXML_TEXT("NaN");
		if (v * 2 == v) return value > 0 ? PUGIXML_TEXT("Infinity") : PUGIXML_TEXT("-Infinity");
		return 0;
	#endif
	}
	
	PUGI__FN bool convert_number_to_boolean(double value)
	{
		return (value != 0 && !is_nan(value));
	}
	
	PUGI__FN void truncate_zeros(char* begin, char* end)
	{
		while (begin != end && end[-1] == '0') end--;

		*end = 0;
	}

	// gets mantissa digits in the form of 0.xxxxx with 0. implied and the exponent
#if defined(PUGI__MSVC_CRT_VERSION) && PUGI__MSVC_CRT_VERSION >= 1400 && !defined(_WIN32_WCE)
	PUGI__FN void convert_number_to_mantissa_exponent(double value, char* buffer, size_t buffer_size, char** out_mantissa, int* out_exponent)
	{
		// get base values
		int sign, exponent;
		_ecvt_s(buffer, buffer_size, value, DBL_DIG + 1, &exponent, &sign);

		// truncate redundant zeros
		truncate_zeros(buffer, buffer + strlen(buffer));

		// fill results
		*out_mantissa = buffer;
		*out_exponent = exponent;
	}
#else
	PUGI__FN void convert_number_to_mantissa_exponent(double value, char* buffer, size_t buffer_size, char** out_mantissa, int* out_exponent)
	{
		// get a scientific notation value with IEEE DBL_DIG decimals
		sprintf(buffer, "%.*e", DBL_DIG, value);
		assert(strlen(buffer) < buffer_size);
		(void)!buffer_size;

		// get the exponent (possibly negative)
		char* exponent_string = strchr(buffer, 'e');
		assert(exponent_string);

		int exponent = atoi(exponent_string + 1);

		// extract mantissa string: skip sign
		char* mantissa = buffer[0] == '-' ? buffer + 1 : buffer;
		assert(mantissa[0] != '0' && mantissa[1] == '.');

		// divide mantissa by 10 to eliminate integer part
		mantissa[1] = mantissa[0];
		mantissa++;
		exponent++;

		// remove extra mantissa digits and zero-terminate mantissa
		truncate_zeros(mantissa, exponent_string);

		// fill results
		*out_mantissa = mantissa;
		*out_exponent = exponent;
	}
#endif

	PUGI__FN xpath_string convert_number_to_string(double value, xpath_allocator* alloc)
	{
		// try special number conversion
		const char_t* special = convert_number_to_string_special(value);
		if (special) return xpath_string_const(special);

		// get mantissa + exponent form
		char mantissa_buffer[32];

		char* mantissa;
		int exponent;
		convert_number_to_mantissa_exponent(value, mantissa_buffer, sizeof(mantissa_buffer), &mantissa, &exponent);

		// allocate a buffer of suitable length for the number
		size_t result_size = strlen(mantissa_buffer) + (exponent > 0 ? exponent : -exponent) + 4;
		char_t* result = static_cast<char_t*>(alloc->allocate(sizeof(char_t) * result_size));
		assert(result);

		// make the number!
		char_t* s = result;

		// sign
		if (value < 0) *s++ = '-';

		// integer part
		if (exponent <= 0)
		{
			*s++ = '0';
		}
		else
		{
			while (exponent > 0)
			{
				assert(*mantissa == 0 || static_cast<unsigned int>(static_cast<unsigned int>(*mantissa) - '0') <= 9);
				*s++ = *mantissa ? *mantissa++ : '0';
				exponent--;
			}
		}

		// fractional part
		if (*mantissa)
		{
			// decimal point
			*s++ = '.';

			// extra zeroes from negative exponent
			while (exponent < 0)
			{
				*s++ = '0';
				exponent++;
			}

			// extra mantissa digits
			while (*mantissa)
			{
				assert(static_cast<unsigned int>(*mantissa - '0') <= 9);
				*s++ = *mantissa++;
			}
		}

		// zero-terminate
		assert(s < result + result_size);
		*s = 0;

		return xpath_string(result, true);
	}
	
	PUGI__FN bool check_string_to_number_format(const char_t* string)
	{
		// parse leading whitespace
		while (PUGI__IS_CHARTYPE(*string, ct_space)) ++string;

		// parse sign
		if (*string == '-') ++string;

		if (!*string) return false;

		// if there is no integer part, there should be a decimal part with at least one digit
		if (!PUGI__IS_CHARTYPEX(string[0], ctx_digit) && (string[0] != '.' || !PUGI__IS_CHARTYPEX(string[1], ctx_digit))) return false;

		// parse integer part
		while (PUGI__IS_CHARTYPEX(*string, ctx_digit)) ++string;

		// parse decimal part
		if (*string == '.')
		{
			++string;

			while (PUGI__IS_CHARTYPEX(*string, ctx_digit)) ++string;
		}

		// parse trailing whitespace
		while (PUGI__IS_CHARTYPE(*string, ct_space)) ++string;

		return *string == 0;
	}

	PUGI__FN double convert_string_to_number(const char_t* string)
	{
		// check string format
		if (!check_string_to_number_format(string)) return gen_nan();

		// parse string
	#ifdef PUGIXML_WCHAR_MODE
		return wcstod(string, 0);
	#else
		return atof(string);
	#endif
	}

	PUGI__FN bool convert_string_to_number_scratch(char_t (&buffer)[32], const char_t* begin, const char_t* end, double* out_result)
	{
		size_t length = static_cast<size_t>(end - begin);
		char_t* scratch = buffer;

		if (length >= sizeof(buffer) / sizeof(buffer[0]))
		{
			// need to make dummy on-heap copy
			scratch = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
			if (!scratch) return false;
		}

		// copy string to zero-terminated buffer and perform conversion
		memcpy(scratch, begin, length * sizeof(char_t));
		scratch[length] = 0;

		*out_result = convert_string_to_number(scratch);

		// free dummy buffer
		if (scratch != buffer) xml_memory::deallocate(scratch);

		return true;
	}
	
	PUGI__FN double round_nearest(double value)
	{
		return floor(value + 0.5);
	}

	PUGI__FN double round_nearest_nzero(double value)
	{
		// same as round_nearest, but returns -0 for [-0.5, -0]
		// ceil is used to differentiate between +0 and -0 (we return -0 for [-0.5, -0] and +0 for +0)
		return (value >= -0.5 && value <= 0) ? ceil(value) : floor(value + 0.5);
	}
	
	PUGI__FN const char_t* qualified_name(const xpath_node& node)
	{
		return node.attribute() ? node.attribute().name() : node.node().name();
	}
	
	PUGI__FN const char_t* local_name(const xpath_node& node)
	{
		const char_t* name = qualified_name(node);
		const char_t* p = find_char(name, ':');
		
		return p ? p + 1 : name;
	}

	struct namespace_uri_predicate
	{
		const char_t* prefix;
		size_t prefix_length;

		namespace_uri_predicate(const char_t* name)
		{
			const char_t* pos = find_char(name, ':');

			prefix = pos ? name : 0;
			prefix_length = pos ? static_cast<size_t>(pos - name) : 0;
		}

		bool operator()(const xml_attribute& a) const
		{
			const char_t* name = a.name();

			if (!starts_with(name, PUGIXML_TEXT("xmlns"))) return false;

			return prefix ? name[5] == ':' && strequalrange(name + 6, prefix, prefix_length) : name[5] == 0;
		}
	};

	PUGI__FN const char_t* namespace_uri(const xml_node& node)
	{
		namespace_uri_predicate pred = node.name();
		
		xml_node p = node;
		
		while (p)
		{
			xml_attribute a = p.find_attribute(pred);
			
			if (a) return a.value();
			
			p = p.parent();
		}
		
		return PUGIXML_TEXT("");
	}

	PUGI__FN const char_t* namespace_uri(const xml_attribute& attr, const xml_node& parent)
	{
		namespace_uri_predicate pred = attr.name();
		
		// Default namespace does not apply to attributes
		if (!pred.prefix) return PUGIXML_TEXT("");
		
		xml_node p = parent;
		
		while (p)
		{
			xml_attribute a = p.find_attribute(pred);
			
			if (a) return a.value();
			
			p = p.parent();
		}
		
		return PUGIXML_TEXT("");
	}

	PUGI__FN const char_t* namespace_uri(const xpath_node& node)
	{
		return node.attribute() ? namespace_uri(node.attribute(), node.parent()) : namespace_uri(node.node());
	}

	PUGI__FN void normalize_space(char_t* buffer)
	{
		char_t* write = buffer;

		for (char_t* it = buffer; *it; )
		{
			char_t ch = *it++;

			if (PUGI__IS_CHARTYPE(ch, ct_space))
			{
				// replace whitespace sequence with single space
				while (PUGI__IS_CHARTYPE(*it, ct_space)) it++;

				// avoid leading spaces
				if (write != buffer) *write++ = ' ';
			}
			else *write++ = ch;
		}

		// remove trailing space
		if (write != buffer && PUGI__IS_CHARTYPE(write[-1], ct_space)) write--;

		// zero-terminate
		*write = 0;
	}

	PUGI__FN void translate(char_t* buffer, const char_t* from, const char_t* to)
	{
		size_t to_length = strlength(to);

		char_t* write = buffer;

		while (*buffer)
		{
			PUGI__DMC_VOLATILE char_t ch = *buffer++;

			const char_t* pos = find_char(from, ch);

			if (!pos)
				*write++ = ch; // do not process
			else if (static_cast<size_t>(pos - from) < to_length)
				*write++ = to[pos - from]; // replace
		}

		// zero-terminate
		*write = 0;
	}

	struct xpath_variable_boolean: xpath_variable
	{
		xpath_variable_boolean(): value(false)
		{
		}

		bool value;
		char_t name[1];
	};

	struct xpath_variable_number: xpath_variable
	{
		xpath_variable_number(): value(0)
		{
		}

		double value;
		char_t name[1];
	};

	struct xpath_variable_string: xpath_variable
	{
		xpath_variable_string(): value(0)
		{
		}

		~xpath_variable_string()
		{
			if (value) xml_memory::deallocate(value);
		}

		char_t* value;
		char_t name[1];
	};

	struct xpath_variable_node_set: xpath_variable
	{
		xpath_node_set value;
		char_t name[1];
	};

	static const xpath_node_set dummy_node_set;

	PUGI__FN unsigned int hash_string(const char_t* str)
	{
		// Jenkins one-at-a-time hash (http://en.wikipedia.org/wiki/Jenkins_hash_function#one-at-a-time)
		unsigned int result = 0;

		while (*str)
		{
			result += static_cast<unsigned int>(*str++);
			result += result << 10;
			result ^= result >> 6;
		}
	
		result += result << 3;
		result ^= result >> 11;
		result += result << 15;
	
		return result;
	}

	template <typename T> PUGI__FN T* new_xpath_variable(const char_t* name)
	{
		size_t length = strlength(name);
		if (length == 0) return 0; // empty variable names are invalid

		// $$ we can't use offsetof(T, name) because T is non-POD, so we just allocate additional length characters
		void* memory = xml_memory::allocate(sizeof(T) + length * sizeof(char_t));
		if (!memory) return 0;

		T* result = new (memory) T();

		memcpy(result->name, name, (length + 1) * sizeof(char_t));

		return result;
	}

	PUGI__FN xpath_variable* new_xpath_variable(xpath_value_type type, const char_t* name)
	{
		switch (type)
		{
		case xpath_type_node_set:
			return new_xpath_variable<xpath_variable_node_set>(name);

		case xpath_type_number:
			return new_xpath_variable<xpath_variable_number>(name);

		case xpath_type_string:
			return new_xpath_variable<xpath_variable_string>(name);

		case xpath_type_boolean:
			return new_xpath_variable<xpath_variable_boolean>(name);

		default:
			return 0;
		}
	}

	template <typename T> PUGI__FN void delete_xpath_variable(T* var)
	{
		var->~T();
		xml_memory::deallocate(var);
	}

	PUGI__FN void delete_xpath_variable(xpath_value_type type, xpath_variable* var)
	{
		switch (type)
		{
		case xpath_type_node_set:
			delete_xpath_variable(static_cast<xpath_variable_node_set*>(var));
			break;

		case xpath_type_number:
			delete_xpath_variable(static_cast<xpath_variable_number*>(var));
			break;

		case xpath_type_string:
			delete_xpath_variable(static_cast<xpath_variable_string*>(var));
			break;

		case xpath_type_boolean:
			delete_xpath_variable(static_cast<xpath_variable_boolean*>(var));
			break;

		default:
			assert(!"Invalid variable type");
		}
	}

	PUGI__FN xpath_variable* get_variable_scratch(char_t (&buffer)[32], xpath_variable_set* set, const char_t* begin, const char_t* end)
	{
		size_t length = static_cast<size_t>(end - begin);
		char_t* scratch = buffer;

		if (length >= sizeof(buffer) / sizeof(buffer[0]))
		{
			// need to make dummy on-heap copy
			scratch = static_cast<char_t*>(xml_memory::allocate((length + 1) * sizeof(char_t)));
			if (!scratch) return 0;
		}

		// copy string to zero-terminated buffer and perform lookup
		memcpy(scratch, begin, length * sizeof(char_t));
		scratch[length] = 0;

		xpath_variable* result = set->get(scratch);

		// free dummy buffer
		if (scratch != buffer) xml_memory::deallocate(scratch);

		return result;
	}
PUGI__NS_END

// Internal node set class
PUGI__NS_BEGIN
	PUGI__FN xpath_node_set::type_t xpath_sort(xpath_node* begin, xpath_node* end, xpath_node_set::type_t type, bool rev)
	{
		xpath_node_set::type_t order = rev ? xpath_node_set::type_sorted_reverse : xpath_node_set::type_sorted;

		if (type == xpath_node_set::type_unsorted)
		{
			sort(begin, end, document_order_comparator());

			type = xpath_node_set::type_sorted;
		}
		
		if (type != order) reverse(begin, end);
			
		return order;
	}

	PUGI__FN xpath_node xpath_first(const xpath_node* begin, const xpath_node* end, xpath_node_set::type_t type)
	{
		if (begin == end) return xpath_node();

		switch (type)
		{
		case xpath_node_set::type_sorted:
			return *begin;

		case xpath_node_set::type_sorted_reverse:
			return *(end - 1);

		case xpath_node_set::type_unsorted:
			return *min_element(begin, end, document_order_comparator());

		default:
			assert(!"Invalid node set type");
			return xpath_node();
		}
	}

	class xpath_node_set_raw
	{
		xpath_node_set::type_t _type;

		xpath_node* _begin;
		xpath_node* _end;
		xpath_node* _eos;

	public:
		xpath_node_set_raw(): _type(xpath_node_set::type_unsorted), _begin(0), _end(0), _eos(0)
		{
		}

		xpath_node* begin() const
		{
			return _begin;
		}

		xpath_node* end() const
		{
			return _end;
		}

		bool empty() const
		{
			return _begin == _end;
		}

		size_t size() const
		{
			return static_cast<size_t>(_end - _begin);
		}

		xpath_node first() const
		{
			return xpath_first(_begin, _end, _type);
		}

		void push_back(const xpath_node& node, xpath_allocator* alloc)
		{
			if (_end == _eos)
			{
				size_t capacity = static_cast<size_t>(_eos - _begin);

				// get new capacity (1.5x rule)
				size_t new_capacity = capacity + capacity / 2 + 1;

				// reallocate the old array or allocate a new one
				xpath_node* data = static_cast<xpath_node*>(alloc->reallocate(_begin, capacity * sizeof(xpath_node), new_capacity * sizeof(xpath_node)));
				assert(data);

				// finalize
				_begin = data;
				_end = data + capacity;
				_eos = data + new_capacity;
			}

			*_end++ = node;
		}

		void append(const xpath_node* begin_, const xpath_node* end_, xpath_allocator* alloc)
		{
			size_t size_ = static_cast<size_t>(_end - _begin);
			size_t capacity = static_cast<size_t>(_eos - _begin);
			size_t count = static_cast<size_t>(end_ - begin_);

			if (size_ + count > capacity)
			{
				// reallocate the old array or allocate a new one
				xpath_node* data = static_cast<xpath_node*>(alloc->reallocate(_begin, capacity * sizeof(xpath_node), (size_ + count) * sizeof(xpath_node)));
				assert(data);

				// finalize
				_begin = data;
				_end = data + size_;
				_eos = data + size_ + count;
			}

			memcpy(_end, begin_, count * sizeof(xpath_node));
			_end += count;
		}

		void sort_do()
		{
			_type = xpath_sort(_begin, _end, _type, false);
		}

		void truncate(xpath_node* pos)
		{
			assert(_begin <= pos && pos <= _end);

			_end = pos;
		}

		void remove_duplicates()
		{
			if (_type == xpath_node_set::type_unsorted)
				sort(_begin, _end, duplicate_comparator());
		
			_end = unique(_begin, _end);
		}

		xpath_node_set::type_t type() const
		{
			return _type;
		}

		void set_type(xpath_node_set::type_t value)
		{
			_type = value;
		}
	};
PUGI__NS_END

PUGI__NS_BEGIN
	struct xpath_context
	{
		xpath_node n;
		size_t position, size;

		xpath_context(const xpath_node& n_, size_t position_, size_t size_): n(n_), position(position_), size(size_)
		{
		}
	};

	enum lexeme_t
	{
		lex_none = 0,
		lex_equal,
		lex_not_equal,
		lex_less,
		lex_greater,
		lex_less_or_equal,
		lex_greater_or_equal,
		lex_plus,
		lex_minus,
		lex_multiply,
		lex_union,
		lex_var_ref,
		lex_open_brace,
		lex_close_brace,
		lex_quoted_string,
		lex_number,
		lex_slash,
		lex_double_slash,
		lex_open_square_brace,
		lex_close_square_brace,
		lex_string,
		lex_comma,
		lex_axis_attribute,
		lex_dot,
		lex_double_dot,
		lex_double_colon,
		lex_eof
	};

	struct xpath_lexer_string
	{
		const char_t* begin;
		const char_t* end;

		xpath_lexer_string(): begin(0), end(0)
		{
		}

		bool operator==(const char_t* other) const
		{
			size_t length = static_cast<size_t>(end - begin);

			return strequalrange(other, begin, length);
		}
	};

	class xpath_lexer
	{
		const char_t* _cur;
		const char_t* _cur_lexeme_pos;
		xpath_lexer_string _cur_lexeme_contents;

		lexeme_t _cur_lexeme;

	public:
		explicit xpath_lexer(const char_t* query): _cur(query)
		{
			next();
		}
		
		const char_t* state() const
		{
			return _cur;
		}
		
		void next()
		{
			const char_t* cur = _cur;

			while (PUGI__IS_CHARTYPE(*cur, ct_space)) ++cur;

			// save lexeme position for error reporting
			_cur_lexeme_pos = cur;

			switch (*cur)
			{
			case 0:
				_cur_lexeme = lex_eof;
				break;
			
			case '>':
				if (*(cur+1) == '=')
				{
					cur += 2;
					_cur_lexeme = lex_greater_or_equal;
				}
				else
				{
					cur += 1;
					_cur_lexeme = lex_greater;
				}
				break;

			case '<':
				if (*(cur+1) == '=')
				{
					cur += 2;
					_cur_lexeme = lex_less_or_equal;
				}
				else
				{
					cur += 1;
					_cur_lexeme = lex_less;
				}
				break;

			case '!':
				if (*(cur+1) == '=')
				{
					cur += 2;
					_cur_lexeme = lex_not_equal;
				}
				else
				{
					_cur_lexeme = lex_none;
				}
				break;

			case '=':
				cur += 1;
				_cur_lexeme = lex_equal;

				break;
			
			case '+':
				cur += 1;
				_cur_lexeme = lex_plus;

				break;

			case '-':
				cur += 1;
				_cur_lexeme = lex_minus;

				break;

			case '*':
				cur += 1;
				_cur_lexeme = lex_multiply;

				break;

			case '|':
				cur += 1;
				_cur_lexeme = lex_union;

				break;
			
			case '$':
				cur += 1;

				if (PUGI__IS_CHARTYPEX(*cur, ctx_start_symbol))
				{
					_cur_lexeme_contents.begin = cur;

					while (PUGI__IS_CHARTYPEX(*cur, ctx_symbol)) cur++;

					if (cur[0] == ':' && PUGI__IS_CHARTYPEX(cur[1], ctx_symbol)) // qname
					{
						cur++; // :

						while (PUGI__IS_CHARTYPEX(*cur, ctx_symbol)) cur++;
					}

					_cur_lexeme_contents.end = cur;
				
					_cur_lexeme = lex_var_ref;
				}
				else
				{
					_cur_lexeme = lex_none;
				}

				break;

			case '(':
				cur += 1;
				_cur_lexeme = lex_open_brace;

				break;

			case ')':
				cur += 1;
				_cur_lexeme = lex_close_brace;

				break;
			
			case '[':
				cur += 1;
				_cur_lexeme = lex_open_square_brace;

				break;

			case ']':
				cur += 1;
				_cur_lexeme = lex_close_square_brace;

				break;

			case ',':
				cur += 1;
				_cur_lexeme = lex_comma;

				break;

			case '/':
				if (*(cur+1) == '/')
				{
					cur += 2;
					_cur_lexeme = lex_double_slash;
				}
				else
				{
					cur += 1;
					_cur_lexeme = lex_slash;
				}
				break;
		
			case '.':
				if (*(cur+1) == '.')
				{
					cur += 2;
					_cur_lexeme = lex_double_dot;
				}
				else if (PUGI__IS_CHARTYPEX(*(cur+1), ctx_digit))
				{
					_cur_lexeme_contents.begin = cur; // .

					++cur;

					while (PUGI__IS_CHARTYPEX(*cur, ctx_digit)) cur++;

					_cur_lexeme_contents.end = cur;
					
					_cur_lexeme = lex_number;
				}
				else
				{
					cur += 1;
					_cur_lexeme = lex_dot;
				}
				break;

			case '@':
				cur += 1;
				_cur_lexeme = lex_axis_attribute;

				break;

			case '"':
			case '\'':
			{
				char_t terminator = *cur;

				++cur;

				_cur_lexeme_contents.begin = cur;
				while (*cur && *cur != terminator) cur++;
				_cur_lexeme_contents.end = cur;
				
				if (!*cur)
					_cur_lexeme = lex_none;
				else
				{
					cur += 1;
					_cur_lexeme = lex_quoted_string;
				}

				break;
			}

			case ':':
				if (*(cur+1) == ':')
				{
					cur += 2;
					_cur_lexeme = lex_double_colon;
				}
				else
				{
					_cur_lexeme = lex_none;
				}
				break;

			default:
				if (PUGI__IS_CHARTYPEX(*cur, ctx_digit))
				{
					_cur_lexeme_contents.begin = cur;

					while (PUGI__IS_CHARTYPEX(*cur, ctx_digit)) cur++;
				
					if (*cur == '.')
					{
						cur++;

						while (PUGI__IS_CHARTYPEX(*cur, ctx_digit)) cur++;
					}

					_cur_lexeme_contents.end = cur;

					_cur_lexeme = lex_number;
				}
				else if (PUGI__IS_CHARTYPEX(*cur, ctx_start_symbol))
				{
					_cur_lexeme_contents.begin = cur;

					while (PUGI__IS_CHARTYPEX(*cur, ctx_symbol)) cur++;

					if (cur[0] == ':')
					{
						if (cur[1] == '*') // namespace test ncname:*
						{
							cur += 2; // :*
						}
						else if (PUGI__IS_CHARTYPEX(cur[1], ctx_symbol)) // namespace test qname
						{
							cur++; // :

							while (PUGI__IS_CHARTYPEX(*cur, ctx_symbol)) cur++;
						}
					}

					_cur_lexeme_contents.end = cur;
				
					_cur_lexeme = lex_string;
				}
				else
				{
					_cur_lexeme = lex_none;
				}
			}

			_cur = cur;
		}

		lexeme_t current() const
		{
			return _cur_lexeme;
		}

		const char_t* current_pos() const
		{
			return _cur_lexeme_pos;
		}

		const xpath_lexer_string& contents() const
		{
			assert(_cur_lexeme == lex_var_ref || _cur_lexeme == lex_number || _cur_lexeme == lex_string || _cur_lexeme == lex_quoted_string);

			return _cur_lexeme_contents;
		}
	};

	enum ast_type_t
	{
		ast_unknown,
		ast_op_or,						// left or right
		ast_op_and,						// left and right
		ast_op_equal,					// left = right
		ast_op_not_equal,				// left != right
		ast_op_less,					// left < right
		ast_op_greater,					// left > right
		ast_op_less_or_equal,			// left <= right
		ast_op_greater_or_equal,		// left >= right
		ast_op_add,						// left + right
		ast_op_subtract,				// left - right
		ast_op_multiply,				// left * right
		ast_op_divide,					// left / right
		ast_op_mod,						// left % right
		ast_op_negate,					// left - right
		ast_op_union,					// left | right
		ast_predicate,					// apply predicate to set; next points to next predicate
		ast_filter,						// select * from left where right
		ast_filter_posinv,				// select * from left where right; proximity position invariant
		ast_string_constant,			// string constant
		ast_number_constant,			// number constant
		ast_variable,					// variable
		ast_func_last,					// last()
		ast_func_position,				// position()
		ast_func_count,					// count(left)
		ast_func_id,					// id(left)
		ast_func_local_name_0,			// local-name()
		ast_func_local_name_1,			// local-name(left)
		ast_func_namespace_uri_0,		// namespace-uri()
		ast_func_namespace_uri_1,		// namespace-uri(left)
		ast_func_name_0,				// name()
		ast_func_name_1,				// name(left)
		ast_func_string_0,				// string()
		ast_func_string_1,				// string(left)
		ast_func_concat,				// concat(left, right, siblings)
		ast_func_starts_with,			// starts_with(left, right)
		ast_func_contains,				// contains(left, right)
		ast_func_substring_before,		// substring-before(left, right)
		ast_func_substring_after,		// substring-after(left, right)
		ast_func_substring_2,			// substring(left, right)
		ast_func_substring_3,			// substring(left, right, third)
		ast_func_string_length_0,		// string-length()
		ast_func_string_length_1,		// string-length(left)
		ast_func_normalize_space_0,		// normalize-space()
		ast_func_normalize_space_1,		// normalize-space(left)
		ast_func_translate,				// translate(left, right, third)
		ast_func_boolean,				// boolean(left)
		ast_func_not,					// not(left)
		ast_func_true,					// true()
		ast_func_false,					// false()
		ast_func_lang,					// lang(left)
		ast_func_number_0,				// number()
		ast_func_number_1,				// number(left)
		ast_func_sum,					// sum(left)
		ast_func_floor,					// floor(left)
		ast_func_ceiling,				// ceiling(left)
		ast_func_round,					// round(left)
		ast_step,						// process set left with step
		ast_step_root					// select root node
	};

	enum axis_t
	{
		axis_ancestor,
		axis_ancestor_or_self,
		axis_attribute,
		axis_child,
		axis_descendant,
		axis_descendant_or_self,
		axis_following,
		axis_following_sibling,
		axis_namespace,
		axis_parent,
		axis_preceding,
		axis_preceding_sibling,
		axis_self
	};
	
	enum nodetest_t
	{
		nodetest_none,
		nodetest_name,
		nodetest_type_node,
		nodetest_type_comment,
		nodetest_type_pi,
		nodetest_type_text,
		nodetest_pi,
		nodetest_all,
		nodetest_all_in_namespace
	};

	template <axis_t N> struct axis_to_type
	{
		static const axis_t axis;
	};

	template <axis_t N> const axis_t axis_to_type<N>::axis = N;
		
	class xpath_ast_node
	{
	private:
		// node type
		char _type;
		char _rettype;

		// for ast_step / ast_predicate
		char _axis;
		char _test;

		// tree node structure
		xpath_ast_node* _left;
		xpath_ast_node* _right;
		xpath_ast_node* _next;

		union
		{
			// value for ast_string_constant
			const char_t* string;
			// value for ast_number_constant
			double number;
			// variable for ast_variable
			xpath_variable* variable;
			// node test for ast_step (node name/namespace/node type/pi target)
			const char_t* nodetest;
		} _data;

		xpath_ast_node(const xpath_ast_node&);
		xpath_ast_node& operator=(const xpath_ast_node&);

		template <class Comp> static bool compare_eq(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)
		{
			xpath_value_type lt = lhs->rettype(), rt = rhs->rettype();

			if (lt != xpath_type_node_set && rt != xpath_type_node_set)
			{
				if (lt == xpath_type_boolean || rt == xpath_type_boolean)
					return comp(lhs->eval_boolean(c, stack), rhs->eval_boolean(c, stack));
				else if (lt == xpath_type_number || rt == xpath_type_number)
					return comp(lhs->eval_number(c, stack), rhs->eval_number(c, stack));
				else if (lt == xpath_type_string || rt == xpath_type_string)
				{
					xpath_allocator_capture cr(stack.result);

					xpath_string ls = lhs->eval_string(c, stack);
					xpath_string rs = rhs->eval_string(c, stack);

					return comp(ls, rs);
				}
			}
			else if (lt == xpath_type_node_set && rt == xpath_type_node_set)
			{
				xpath_allocator_capture cr(stack.result);

				xpath_node_set_raw ls = lhs->eval_node_set(c, stack);
				xpath_node_set_raw rs = rhs->eval_node_set(c, stack);

				for (const xpath_node* li = ls.begin(); li != ls.end(); ++li)
					for (const xpath_node* ri = rs.begin(); ri != rs.end(); ++ri)
					{
						xpath_allocator_capture cri(stack.result);

						if (comp(string_value(*li, stack.result), string_value(*ri, stack.result)))
							return true;
					}

				return false;
			}
			else
			{
				if (lt == xpath_type_node_set)
				{
					swap(lhs, rhs);
					swap(lt, rt);
				}

				if (lt == xpath_type_boolean)
					return comp(lhs->eval_boolean(c, stack), rhs->eval_boolean(c, stack));
				else if (lt == xpath_type_number)
				{
					xpath_allocator_capture cr(stack.result);

					double l = lhs->eval_number(c, stack);
					xpath_node_set_raw rs = rhs->eval_node_set(c, stack);

					for (const xpath_node* ri = rs.begin(); ri != rs.end(); ++ri)
					{
						xpath_allocator_capture cri(stack.result);

						if (comp(l, convert_string_to_number(string_value(*ri, stack.result).c_str())))
							return true;
					}

					return false;
				}
				else if (lt == xpath_type_string)
				{
					xpath_allocator_capture cr(stack.result);

					xpath_string l = lhs->eval_string(c, stack);
					xpath_node_set_raw rs = rhs->eval_node_set(c, stack);

					for (const xpath_node* ri = rs.begin(); ri != rs.end(); ++ri)
					{
						xpath_allocator_capture cri(stack.result);

						if (comp(l, string_value(*ri, stack.result)))
							return true;
					}

					return false;
				}
			}

			assert(!"Wrong types");
			return false;
		}

		template <class Comp> static bool compare_rel(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)
		{
			xpath_value_type lt = lhs->rettype(), rt = rhs->rettype();

			if (lt != xpath_type_node_set && rt != xpath_type_node_set)
				return comp(lhs->eval_number(c, stack), rhs->eval_number(c, stack));
			else if (lt == xpath_type_node_set && rt == xpath_type_node_set)
			{
				xpath_allocator_capture cr(stack.result);

				xpath_node_set_raw ls = lhs->eval_node_set(c, stack);
				xpath_node_set_raw rs = rhs->eval_node_set(c, stack);

				for (const xpath_node* li = ls.begin(); li != ls.end(); ++li)
				{
					xpath_allocator_capture cri(stack.result);

					double l = convert_string_to_number(string_value(*li, stack.result).c_str());

					for (const xpath_node* ri = rs.begin(); ri != rs.end(); ++ri)
					{
						xpath_allocator_capture crii(stack.result);

						if (comp(l, convert_string_to_number(string_value(*ri, stack.result).c_str())))
							return true;
					}
				}

				return false;
			}
			else if (lt != xpath_type_node_set && rt == xpath_type_node_set)
			{
				xpath_allocator_capture cr(stack.result);

				double l = lhs->eval_number(c, stack);
				xpath_node_set_raw rs = rhs->eval_node_set(c, stack);

				for (const xpath_node* ri = rs.begin(); ri != rs.end(); ++ri)
				{
					xpath_allocator_capture cri(stack.result);

					if (comp(l, convert_string_to_number(string_value(*ri, stack.result).c_str())))
						return true;
				}

				return false;
			}
			else if (lt == xpath_type_node_set && rt != xpath_type_node_set)
			{
				xpath_allocator_capture cr(stack.result);

				xpath_node_set_raw ls = lhs->eval_node_set(c, stack);
				double r = rhs->eval_number(c, stack);

				for (const xpath_node* li = ls.begin(); li != ls.end(); ++li)
				{
					xpath_allocator_capture cri(stack.result);

					if (comp(convert_string_to_number(string_value(*li, stack.result).c_str()), r))
						return true;
				}

				return false;
			}
			else
			{
				assert(!"Wrong types");
				return false;
			}
		}

		void apply_predicate(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack)
		{
			assert(ns.size() >= first);

			size_t i = 1;
			size_t size = ns.size() - first;
				
			xpath_node* last = ns.begin() + first;
				
			// remove_if... or well, sort of
			for (xpath_node* it = last; it != ns.end(); ++it, ++i)
			{
				xpath_context c(*it, i, size);
			
				if (expr->rettype() == xpath_type_number)
				{
					if (expr->eval_number(c, stack) == i)
						*last++ = *it;
				}
				else if (expr->eval_boolean(c, stack))
					*last++ = *it;
			}
			
			ns.truncate(last);
		}

		void apply_predicates(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack)
		{
			if (ns.size() == first) return;
			
			for (xpath_ast_node* pred = _right; pred; pred = pred->_next)
			{
				apply_predicate(ns, first, pred->_left, stack);
			}
		}

		void step_push(xpath_node_set_raw& ns, const xml_attribute& a, const xml_node& parent, xpath_allocator* alloc)
		{
			if (!a) return;

			const char_t* name = a.name();

			// There are no attribute nodes corresponding to attributes that declare namespaces
			// That is, "xmlns:..." or "xmlns"
			if (starts_with(name, PUGIXML_TEXT("xmlns")) && (name[5] == 0 || name[5] == ':')) return;
			
			switch (_test)
			{
			case nodetest_name:
				if (strequal(name, _data.nodetest)) ns.push_back(xpath_node(a, parent), alloc);
				break;
				
			case nodetest_type_node:
			case nodetest_all:
				ns.push_back(xpath_node(a, parent), alloc);
				break;
				
			case nodetest_all_in_namespace:
				if (starts_with(name, _data.nodetest))
					ns.push_back(xpath_node(a, parent), alloc);
				break;
			
			default:
				;
			}
		}
		
		void step_push(xpath_node_set_raw& ns, const xml_node& n, xpath_allocator* alloc)
		{
			if (!n) return;

			switch (_test)
			{
			case nodetest_name:
				if (n.type() == node_element && strequal(n.name(), _data.nodetest)) ns.push_back(n, alloc);
				break;
				
			case nodetest_type_node:
				ns.push_back(n, alloc);
				break;
				
			case nodetest_type_comment:
				if (n.type() == node_comment)
					ns.push_back(n, alloc);
				break;
				
			case nodetest_type_text:
				if (n.type() == node_pcdata || n.type() == node_cdata)
					ns.push_back(n, alloc);
				break;
				
			case nodetest_type_pi:
				if (n.type() == node_pi)
					ns.push_back(n, alloc);
				break;
									
			case nodetest_pi:
				if (n.type() == node_pi && strequal(n.name(), _data.nodetest))
					ns.push_back(n, alloc);
				break;
				
			case nodetest_all:
				if (n.type() == node_element)
					ns.push_back(n, alloc);
				break;
				
			case nodetest_all_in_namespace:
				if (n.type() == node_element && starts_with(n.name(), _data.nodetest))
					ns.push_back(n, alloc);
				break;

			default:
				assert(!"Unknown axis");
			} 
		}

		template <class T> void step_fill(xpath_node_set_raw& ns, const xml_node& n, xpath_allocator* alloc, T)
		{
			const axis_t axis = T::axis;

			switch (axis)
			{
			case axis_attribute:
			{
				for (xml_attribute a = n.first_attribute(); a; a = a.next_attribute())
					step_push(ns, a, n, alloc);
				
				break;
			}
			
			case axis_child:
			{
				for (xml_node c = n.first_child(); c; c = c.next_sibling())
					step_push(ns, c, alloc);
					
				break;
			}
			
			case axis_descendant:
			case axis_descendant_or_self:
			{
				if (axis == axis_descendant_or_self)
					step_push(ns, n, alloc);
					
				xml_node cur = n.first_child();
				
				while (cur && cur != n)
				{
					step_push(ns, cur, alloc);
					
					if (cur.first_child())
						cur = cur.first_child();
					else if (cur.next_sibling())
						cur = cur.next_sibling();
					else
					{
						while (!cur.next_sibling() && cur != n)
							cur = cur.parent();
					
						if (cur != n) cur = cur.next_sibling();
					}
				}
				
				break;
			}
			
			case axis_following_sibling:
			{
				for (xml_node c = n.next_sibling(); c; c = c.next_sibling())
					step_push(ns, c, alloc);
				
				break;
			}
			
			case axis_preceding_sibling:
			{
				for (xml_node c = n.previous_sibling(); c; c = c.previous_sibling())
					step_push(ns, c, alloc);
				
				break;
			}
			
			case axis_following:
			{
				xml_node cur = n;

				// exit from this node so that we don't include descendants
				while (cur && !cur.next_sibling()) cur = cur.parent();
				cur = cur.next_sibling();

				for (;;)
				{
					step_push(ns, cur, alloc);

					if (cur.first_child())
						cur = cur.first_child();
					else if (cur.next_sibling())
						cur = cur.next_sibling();
					else
					{
						while (cur && !cur.next_sibling()) cur = cur.parent();
						cur = cur.next_sibling();

						if (!cur) break;
					}
				}

				break;
			}

			case axis_preceding:
			{
				xml_node cur = n;

				while (cur && !cur.previous_sibling()) cur = cur.parent();
				cur = cur.previous_sibling();

				for (;;)
				{
					if (cur.last_child())
						cur = cur.last_child();
					else
					{
						// leaf node, can't be ancestor
						step_push(ns, cur, alloc);

						if (cur.previous_sibling())
							cur = cur.previous_sibling();
						else
						{
							do 
							{
								cur = cur.parent();
								if (!cur) break;

								if (!node_is_ancestor(cur, n)) step_push(ns, cur, alloc);
							}
							while (!cur.previous_sibling());

							cur = cur.previous_sibling();

							if (!cur) break;
						}
					}
				}

				break;
			}
			
			case axis_ancestor:
			case axis_ancestor_or_self:
			{
				if (axis == axis_ancestor_or_self)
					step_push(ns, n, alloc);

				xml_node cur = n.parent();
				
				while (cur)
				{
					step_push(ns, cur, alloc);
					
					cur = cur.parent();
				}
				
				break;
			}

			case axis_self:
			{
				step_push(ns, n, alloc);

				break;
			}

			case axis_parent:
			{
				if (n.parent()) step_push(ns, n.parent(), alloc);

				break;
			}
				
			default:
				assert(!"Unimplemented axis");
			}
		}
		
		template <class T> void step_fill(xpath_node_set_raw& ns, const xml_attribute& a, const xml_node& p, xpath_allocator* alloc, T v)
		{
			const axis_t axis = T::axis;

			switch (axis)
			{
			case axis_ancestor:
			case axis_ancestor_or_self:
			{
				if (axis == axis_ancestor_or_self && _test == nodetest_type_node) // reject attributes based on principal node type test
					step_push(ns, a, p, alloc);

				xml_node cur = p;
				
				while (cur)
				{
					step_push(ns, cur, alloc);
					
					cur = cur.parent();
				}
				
				break;
			}

			case axis_descendant_or_self:
			case axis_self:
			{
				if (_test == nodetest_type_node) // reject attributes based on principal node type test
					step_push(ns, a, p, alloc);

				break;
			}

			case axis_following:
			{
				xml_node cur = p;
				
				for (;;)
				{
					if (cur.first_child())
						cur = cur.first_child();
					else if (cur.next_sibling())
						cur = cur.next_sibling();
					else
					{
						while (cur && !cur.next_sibling()) cur = cur.parent();
						cur = cur.next_sibling();
						
						if (!cur) break;
					}

					step_push(ns, cur, alloc);
				}

				break;
			}

			case axis_parent:
			{
				step_push(ns, p, alloc);

				break;
			}

			case axis_preceding:
			{
				// preceding:: axis does not include attribute nodes and attribute ancestors (they are the same as parent's ancestors), so we can reuse node preceding
				step_fill(ns, p, alloc, v);
				break;
			}
			
			default:
				assert(!"Unimplemented axis");
			}
		}
		
		template <class T> xpath_node_set_raw step_do(const xpath_context& c, const xpath_stack& stack, T v)
		{
			const axis_t axis = T::axis;
			bool attributes = (axis == axis_ancestor || axis == axis_ancestor_or_self || axis == axis_descendant_or_self || axis == axis_following || axis == axis_parent || axis == axis_preceding || axis == axis_self);

			xpath_node_set_raw ns;
			ns.set_type((axis == axis_ancestor || axis == axis_ancestor_or_self || axis == axis_preceding || axis == axis_preceding_sibling) ? xpath_node_set::type_sorted_reverse : xpath_node_set::type_sorted);

			if (_left)
			{
				xpath_node_set_raw s = _left->eval_node_set(c, stack);

				// self axis preserves the original order
				if (axis == axis_self) ns.set_type(s.type());

				for (const xpath_node* it = s.begin(); it != s.end(); ++it)
				{
					size_t size = ns.size();

					// in general, all axes generate elements in a particular order, but there is no order guarantee if axis is applied to two nodes
					if (axis != axis_self && size != 0) ns.set_type(xpath_node_set::type_unsorted);
					
					if (it->node())
						step_fill(ns, it->node(), stack.result, v);
					else if (attributes)
						step_fill(ns, it->attribute(), it->parent(), stack.result, v);
						
					apply_predicates(ns, size, stack);
				}
			}
			else
			{
				if (c.n.node())
					step_fill(ns, c.n.node(), stack.result, v);
				else if (attributes)
					step_fill(ns, c.n.attribute(), c.n.parent(), stack.result, v);
				
				apply_predicates(ns, 0, stack);
			}

			// child, attribute and self axes always generate unique set of nodes
			// for other axis, if the set stayed sorted, it stayed unique because the traversal algorithms do not visit the same node twice
			if (axis != axis_child && axis != axis_attribute && axis != axis_self && ns.type() == xpath_node_set::type_unsorted)
				ns.remove_duplicates();

			return ns;
		}
		
	public:
		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, const char_t* value):
			_type(static_cast<char>(type)), _rettype(static_cast<char>(rettype_)), _axis(0), _test(0), _left(0), _right(0), _next(0)
		{
			assert(type == ast_string_constant);
			_data.string = value;
		}

		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, double value):
			_type(static_cast<char>(type)), _rettype(static_cast<char>(rettype_)), _axis(0), _test(0), _left(0), _right(0), _next(0)
		{
			assert(type == ast_number_constant);
			_data.number = value;
		}
		
		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, xpath_variable* value):
			_type(static_cast<char>(type)), _rettype(static_cast<char>(rettype_)), _axis(0), _test(0), _left(0), _right(0), _next(0)
		{
			assert(type == ast_variable);
			_data.variable = value;
		}
		
		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, xpath_ast_node* left = 0, xpath_ast_node* right = 0):
			_type(static_cast<char>(type)), _rettype(static_cast<char>(rettype_)), _axis(0), _test(0), _left(left), _right(right), _next(0)
		{
		}

		xpath_ast_node(ast_type_t type, xpath_ast_node* left, axis_t axis, nodetest_t test, const char_t* contents):
			_type(static_cast<char>(type)), _rettype(xpath_type_node_set), _axis(static_cast<char>(axis)), _test(static_cast<char>(test)), _left(left), _right(0), _next(0)
		{
			_data.nodetest = contents;
		}

		void set_next(xpath_ast_node* value)
		{
			_next = value;
		}

		void set_right(xpath_ast_node* value)
		{
			_right = value;
		}

		bool eval_boolean(const xpath_context& c, const xpath_stack& stack)
		{
			switch (_type)
			{
			case ast_op_or:
				return _left->eval_boolean(c, stack) || _right->eval_boolean(c, stack);
				
			case ast_op_and:
				return _left->eval_boolean(c, stack) && _right->eval_boolean(c, stack);
				
			case ast_op_equal:
				return compare_eq(_left, _right, c, stack, equal_to());

			case ast_op_not_equal:
				return compare_eq(_left, _right, c, stack, not_equal_to());
	
			case ast_op_less:
				return compare_rel(_left, _right, c, stack, less());
			
			case ast_op_greater:
				return compare_rel(_right, _left, c, stack, less());

			case ast_op_less_or_equal:
				return compare_rel(_left, _right, c, stack, less_equal());
			
			case ast_op_greater_or_equal:
				return compare_rel(_right, _left, c, stack, less_equal());

			case ast_func_starts_with:
			{
				xpath_allocator_capture cr(stack.result);

				xpath_string lr = _left->eval_string(c, stack);
				xpath_string rr = _right->eval_string(c, stack);

				return starts_with(lr.c_str(), rr.c_str());
			}

			case ast_func_contains:
			{
				xpath_allocator_capture cr(stack.result);

				xpath_string lr = _left->eval_string(c, stack);
				xpath_string rr = _right->eval_string(c, stack);

				return find_substring(lr.c_str(), rr.c_str()) != 0;
			}

			case ast_func_boolean:
				return _left->eval_boolean(c, stack);
				
			case ast_func_not:
				return !_left->eval_boolean(c, stack);
				
			case ast_func_true:
				return true;
				
			case ast_func_false:
				return false;

			case ast_func_lang:
			{
				if (c.n.attribute()) return false;
				
				xpath_allocator_capture cr(stack.result);

				xpath_string lang = _left->eval_string(c, stack);
				
				for (xml_node n = c.n.node(); n; n = n.parent())
				{
					xml_attribute a = n.attribute(PUGIXML_TEXT("xml:lang"));
					
					if (a)
					{
						const char_t* value = a.value();
						
						// strnicmp / strncasecmp is not portable
						for (const char_t* lit = lang.c_str(); *lit; ++lit)
						{
							if (tolower_ascii(*lit) != tolower_ascii(*value)) return false;
							++value;
						}
						
						return *value == 0 || *value == '-';
					}
				}
				
				return false;
			}

			case ast_variable:
			{
				assert(_rettype == _data.variable->type());

				if (_rettype == xpath_type_boolean)
					return _data.variable->get_boolean();

				// fallthrough to type conversion
			}

			default:
			{
				switch (_rettype)
				{
				case xpath_type_number:
					return convert_number_to_boolean(eval_number(c, stack));
					
				case xpath_type_string:
				{
					xpath_allocator_capture cr(stack.result);

					return !eval_string(c, stack).empty();
				}
					
				case xpath_type_node_set:				
				{
					xpath_allocator_capture cr(stack.result);

					return !eval_node_set(c, stack).empty();
				}

				default:
					assert(!"Wrong expression for return type boolean");
					return false;
				}
			}
			}
		}

		double eval_number(const xpath_context& c, const xpath_stack& stack)
		{
			switch (_type)
			{
			case ast_op_add:
				return _left->eval_number(c, stack) + _right->eval_number(c, stack);
				
			case ast_op_subtract:
				return _left->eval_number(c, stack) - _right->eval_number(c, stack);

			case ast_op_multiply:
				return _left->eval_number(c, stack) * _right->eval_number(c, stack);

			case ast_op_divide:
				return _left->eval_number(c, stack) / _right->eval_number(c, stack);

			case ast_op_mod:
				return fmod(_left->eval_number(c, stack), _right->eval_number(c, stack));

			case ast_op_negate:
				return -_left->eval_number(c, stack);

			case ast_number_constant:
				return _data.number;

			case ast_func_last:
				return static_cast<double>(c.size);
			
			case ast_func_position:
				return static_cast<double>(c.position);

			case ast_func_count:
			{
				xpath_allocator_capture cr(stack.result);

				return static_cast<double>(_left->eval_node_set(c, stack).size());
			}
			
			case ast_func_string_length_0:
			{
				xpath_allocator_capture cr(stack.result);

				return static_cast<double>(string_value(c.n, stack.result).length());
			}
			
			case ast_func_string_length_1:
			{
				xpath_allocator_capture cr(stack.result);

				return static_cast<double>(_left->eval_string(c, stack).length());
			}
			
			case ast_func_number_0:
			{
				xpath_allocator_capture cr(stack.result);

				return convert_string_to_number(string_value(c.n, stack.result).c_str());
			}
			
			case ast_func_number_1:
				return _left->eval_number(c, stack);

			case ast_func_sum:
			{
				xpath_allocator_capture cr(stack.result);

				double r = 0;
				
				xpath_node_set_raw ns = _left->eval_node_set(c, stack);
				
				for (const xpath_node* it = ns.begin(); it != ns.end(); ++it)
				{
					xpath_allocator_capture cri(stack.result);

					r += convert_string_to_number(string_value(*it, stack.result).c_str());
				}
			
				return r;
			}

			case ast_func_floor:
			{
				double r = _left->eval_number(c, stack);
				
				return r == r ? floor(r) : r;
			}

			case ast_func_ceiling:
			{
				double r = _left->eval_number(c, stack);
				
				return r == r ? ceil(r) : r;
			}

			case ast_func_round:
				return round_nearest_nzero(_left->eval_number(c, stack));
			
			case ast_variable:
			{
				assert(_rettype == _data.variable->type());

				if (_rettype == xpath_type_number)
					return _data.variable->get_number();

				// fallthrough to type conversion
			}

			default:
			{
				switch (_rettype)
				{
				case xpath_type_boolean:
					return eval_boolean(c, stack) ? 1 : 0;
					
				case xpath_type_string:
				{
					xpath_allocator_capture cr(stack.result);

					return convert_string_to_number(eval_string(c, stack).c_str());
				}
					
				case xpath_type_node_set:
				{
					xpath_allocator_capture cr(stack.result);

					return convert_string_to_number(eval_string(c, stack).c_str());
				}
					
				default:
					assert(!"Wrong expression for return type number");
					return 0;
				}
				
			}
			}
		}
		
		xpath_string eval_string_concat(const xpath_context& c, const xpath_stack& stack)
		{
			assert(_type == ast_func_concat);

			xpath_allocator_capture ct(stack.temp);

			// count the string number
			size_t count = 1;
			for (xpath_ast_node* nc = _right; nc; nc = nc->_next) count++;

			// gather all strings
			xpath_string static_buffer[4];
			xpath_string* buffer = static_buffer;

			// allocate on-heap for large concats
			if (count > sizeof(static_buffer) / sizeof(static_buffer[0]))
			{
				buffer = static_cast<xpath_string*>(stack.temp->allocate(count * sizeof(xpath_string)));
				assert(buffer);
			}

			// evaluate all strings to temporary stack
			xpath_stack swapped_stack = {stack.temp, stack.result};

			buffer[0] = _left->eval_string(c, swapped_stack);

			size_t pos = 1;
			for (xpath_ast_node* n = _right; n; n = n->_next, ++pos) buffer[pos] = n->eval_string(c, swapped_stack);
			assert(pos == count);

			// get total length
			size_t length = 0;
			for (size_t i = 0; i < count; ++i) length += buffer[i].length();

			// create final string
			char_t* result = static_cast<char_t*>(stack.result->allocate((length + 1) * sizeof(char_t)));
			assert(result);

			char_t* ri = result;

			for (size_t j = 0; j < count; ++j)
				for (const char_t* bi = buffer[j].c_str(); *bi; ++bi)
					*ri++ = *bi;

			*ri = 0;

			return xpath_string(result, true);
		}

		xpath_string eval_string(const xpath_context& c, const xpath_stack& stack)
		{
			switch (_type)
			{
			case ast_string_constant:
				return xpath_string_const(_data.string);
			
			case ast_func_local_name_0:
			{
				xpath_node na = c.n;
				
				return xpath_string_const(local_name(na));
			}

			case ast_func_local_name_1:
			{
				xpath_allocator_capture cr(stack.result);

				xpath_node_set_raw ns = _left->eval_node_set(c, stack);
				xpath_node na = ns.first();
				
				return xpath_string_const(local_name(na));
			}

			case ast_func_name_0:
			{
				xpath_node na = c.n;
				
				return xpath_string_const(qualified_name(na));
			}

			case ast_func_name_1:
			{
				xpath_allocator_capture cr(stack.result);

				xpath_node_set_raw ns = _left->eval_node_set(c, stack);
				xpath_node na = ns.first();
				
				return xpath_string_const(qualified_name(na));
			}

			case ast_func_namespace_uri_0:
			{
				xpath_node na = c.n;
				
				return xpath_string_const(namespace_uri(na));
			}

			case ast_func_namespace_uri_1:
			{
				xpath_allocator_capture cr(stack.result);

				xpath_node_set_raw ns = _left->eval_node_set(c, stack);
				xpath_node na = ns.first();
				
				return xpath_string_const(namespace_uri(na));
			}

			case ast_func_string_0:
				return string_value(c.n, stack.result);

			case ast_func_string_1:
				return _left->eval_string(c, stack);

			case ast_func_concat:
				return eval_string_concat(c, stack);

			case ast_func_substring_before:
			{
				xpath_allocator_capture cr(stack.temp);

				xpath_stack swapped_stack = {stack.temp, stack.result};

				xpath_string s = _left->eval_string(c, swapped_stack);
				xpath_string p = _right->eval_string(c, swapped_stack);

				const char_t* pos = find_substring(s.c_str(), p.c_str());
				
				return pos ? xpath_string(s.c_str(), pos, stack.result) : xpath_string();
			}
			
			case ast_func_substring_after:
			{
				xpath_allocator_capture cr(stack.temp);

				xpath_stack swapped_stack = {stack.temp, stack.result};

				xpath_string s = _left->eval_string(c, swapped_stack);
				xpath_string p = _right->eval_string(c, swapped_stack);
				
				const char_t* pos = find_substring(s.c_str(), p.c_str());
				if (!pos) return xpath_string();

				const char_t* result = pos + p.length();

				return s.uses_heap() ? xpath_string(result, stack.result) : xpath_string_const(result);
			}

			case ast_func_substring_2:
			{
				xpath_allocator_capture cr(stack.temp);

				xpath_stack swapped_stack = {stack.temp, stack.result};

				xpath_string s = _left->eval_string(c, swapped_stack);
				size_t s_length = s.length();

				double first = round_nearest(_right->eval_number(c, stack));
				
				if (is_nan(first)) return xpath_string(); // NaN
				else if (first >= s_length + 1) return xpath_string();
				
				size_t pos = first < 1 ? 1 : static_cast<size_t>(first);
				assert(1 <= pos && pos <= s_length + 1);

				const char_t* rbegin = s.c_str() + (pos - 1);
				
				return s.uses_heap() ? xpath_string(rbegin, stack.result) : xpath_string_const(rbegin);
			}
			
			case ast_func_substring_3:
			{
				xpath_allocator_capture cr(stack.temp);

				xpath_stack swapped_stack = {stack.temp, stack.result};

				xpath_string s = _left->eval_string(c, swapped_stack);
				size_t s_length = s.length();

				double first = round_nearest(_right->eval_number(c, stack));
				double last = first + round_nearest(_right->_next->eval_number(c, stack));
				
				if (is_nan(first) || is_nan(last)) return xpath_string();
				else if (first >= s_length + 1) return xpath_string();
				else if (first >= last) return xpath_string();
				else if (last < 1) return xpath_string();
				
				size_t pos = first < 1 ? 1 : static_cast<size_t>(first);
				size_t end = last >= s_length + 1 ? s_length + 1 : static_cast<size_t>(last);

				assert(1 <= pos && pos <= end && end <= s_length + 1);
				const char_t* rbegin = s.c_str() + (pos - 1);
				const char_t* rend = s.c_str() + (end - 1);

				return (end == s_length + 1 && !s.uses_heap()) ? xpath_string_const(rbegin) : xpath_string(rbegin, rend, stack.result);
			}

			case ast_func_normalize_space_0:
			{
				xpath_string s = string_value(c.n, stack.result);

				normalize_space(s.data(stack.result));

				return s;
			}

			case ast_func_normalize_space_1:
			{
				xpath_string s = _left->eval_string(c, stack);

				normalize_space(s.data(stack.result));
			
				return s;
			}

			case ast_func_translate:
			{
				xpath_allocator_capture cr(stack.temp);

				xpath_stack swapped_stack = {stack.temp, stack.result};

				xpath_string s = _left->eval_string(c, stack);
				xpath_string from = _right->eval_string(c, swapped_stack);
				xpath_string to = _right->_next->eval_string(c, swapped_stack);

				translate(s.data(stack.result), from.c_str(), to.c_str());

				return s;
			}

			case ast_variable:
			{
				assert(_rettype == _data.variable->type());

				if (_rettype == xpath_type_string)
					return xpath_string_const(_data.variable->get_string());

				// fallthrough to type conversion
			}

			default:
			{
				switch (_rettype)
				{
				case xpath_type_boolean:
					return xpath_string_const(eval_boolean(c, stack) ? PUGIXML_TEXT("true") : PUGIXML_TEXT("false"));
					
				case xpath_type_number:
					return convert_number_to_string(eval_number(c, stack), stack.result);
					
				case xpath_type_node_set:
				{
					xpath_allocator_capture cr(stack.temp);

					xpath_stack swapped_stack = {stack.temp, stack.result};

					xpath_node_set_raw ns = eval_node_set(c, swapped_stack);
					return ns.empty() ? xpath_string() : string_value(ns.first(), stack.result);
				}
				
				default:
					assert(!"Wrong expression for return type string");
					return xpath_string();
				}
			}
			}
		}

		xpath_node_set_raw eval_node_set(const xpath_context& c, const xpath_stack& stack)
		{
			switch (_type)
			{
			case ast_op_union:
			{
				xpath_allocator_capture cr(stack.temp);

				xpath_stack swapped_stack = {stack.temp, stack.result};

				xpath_node_set_raw ls = _left->eval_node_set(c, swapped_stack);
				xpath_node_set_raw rs = _right->eval_node_set(c, stack);
				
				// we can optimize merging two sorted sets, but this is a very rare operation, so don't bother
				rs.set_type(xpath_node_set::type_unsorted);

				rs.append(ls.begin(), ls.end(), stack.result);
				rs.remove_duplicates();
				
				return rs;
			}

			case ast_filter:
			case ast_filter_posinv:
			{
				xpath_node_set_raw set = _left->eval_node_set(c, stack);

				// either expression is a number or it contains position() call; sort by document order
				if (_type == ast_filter) set.sort_do();

				apply_predicate(set, 0, _right, stack);
			
				return set;
			}
			
			case ast_func_id:
				return xpath_node_set_raw();
			
			case ast_step:
			{
				switch (_axis)
				{
				case axis_ancestor:
					return step_do(c, stack, axis_to_type<axis_ancestor>());
					
				case axis_ancestor_or_self:
					return step_do(c, stack, axis_to_type<axis_ancestor_or_self>());

				case axis_attribute:
					return step_do(c, stack, axis_to_type<axis_attribute>());

				case axis_child:
					return step_do(c, stack, axis_to_type<axis_child>());
				
				case axis_descendant:
					return step_do(c, stack, axis_to_type<axis_descendant>());

				case axis_descendant_or_self:
					return step_do(c, stack, axis_to_type<axis_descendant_or_self>());

				case axis_following:
					return step_do(c, stack, axis_to_type<axis_following>());
				
				case axis_following_sibling:
					return step_do(c, stack, axis_to_type<axis_following_sibling>());
				
				case axis_namespace:
					// namespaced axis is not supported
					return xpath_node_set_raw();
				
				case axis_parent:
					return step_do(c, stack, axis_to_type<axis_parent>());
				
				case axis_preceding:
					return step_do(c, stack, axis_to_type<axis_preceding>());

				case axis_preceding_sibling:
					return step_do(c, stack, axis_to_type<axis_preceding_sibling>());
				
				case axis_self:
					return step_do(c, stack, axis_to_type<axis_self>());

				default:
					assert(!"Unknown axis");
					return xpath_node_set_raw();
				}
			}

			case ast_step_root:
			{
				assert(!_right); // root step can't have any predicates

				xpath_node_set_raw ns;

				ns.set_type(xpath_node_set::type_sorted);

				if (c.n.node()) ns.push_back(c.n.node().root(), stack.result);
				else if (c.n.attribute()) ns.push_back(c.n.parent().root(), stack.result);

				return ns;
			}

			case ast_variable:
			{
				assert(_rettype == _data.variable->type());

				if (_rettype == xpath_type_node_set)
				{
					const xpath_node_set& s = _data.variable->get_node_set();

					xpath_node_set_raw ns;

					ns.set_type(s.type());
					ns.append(s.begin(), s.end(), stack.result);

					return ns;
				}

				// fallthrough to type conversion
			}

			default:
				assert(!"Wrong expression for return type node set");
				return xpath_node_set_raw();
			}
		}
		
		bool is_posinv()
		{
			switch (_type)
			{
			case ast_func_position:
				return false;

			case ast_string_constant:
			case ast_number_constant:
			case ast_variable:
				return true;

			case ast_step:
			case ast_step_root:
				return true;

			case ast_predicate:
			case ast_filter:
			case ast_filter_posinv:
				return true;

			default:
				if (_left && !_left->is_posinv()) return false;
				
				for (xpath_ast_node* n = _right; n; n = n->_next)
					if (!n->is_posinv()) return false;
					
				return true;
			}
		}

		xpath_value_type rettype() const
		{
			return static_cast<xpath_value_type>(_rettype);
		}
	};

	struct xpath_parser
	{
		xpath_allocator* _alloc;
		xpath_lexer _lexer;

		const char_t* _query;
		xpath_variable_set* _variables;

		xpath_parse_result* _result;

		char_t _scratch[32];

	#ifdef PUGIXML_NO_EXCEPTIONS
		jmp_buf _error_handler;
	#endif

		void throw_error(const char* message)
		{
			_result->error = message;
			_result->offset = _lexer.current_pos() - _query;

		#ifdef PUGIXML_NO_EXCEPTIONS
			longjmp(_error_handler, 1);
		#else
			throw xpath_exception(*_result);
		#endif
		}

		void throw_error_oom()
		{
		#ifdef PUGIXML_NO_EXCEPTIONS
			throw_error("Out of memory");
		#else
			throw std::bad_alloc();
		#endif
		}

		void* alloc_node()
		{
			void* result = _alloc->allocate_nothrow(sizeof(xpath_ast_node));

			if (!result) throw_error_oom();

			return result;
		}

		const char_t* alloc_string(const xpath_lexer_string& value)
		{
			if (value.begin)
			{
				size_t length = static_cast<size_t>(value.end - value.begin);

				char_t* c = static_cast<char_t*>(_alloc->allocate_nothrow((length + 1) * sizeof(char_t)));
				if (!c) throw_error_oom();
				assert(c); // workaround for clang static analysis

				memcpy(c, value.begin, length * sizeof(char_t));
				c[length] = 0;

				return c;
			}
			else return 0;
		}

		xpath_ast_node* parse_function_helper(ast_type_t type0, ast_type_t type1, size_t argc, xpath_ast_node* args[2])
		{
			assert(argc <= 1);

			if (argc == 1 && args[0]->rettype() != xpath_type_node_set) throw_error("Function has to be applied to node set");

			return new (alloc_node()) xpath_ast_node(argc == 0 ? type0 : type1, xpath_type_string, args[0]);
		}

		xpath_ast_node* parse_function(const xpath_lexer_string& name, size_t argc, xpath_ast_node* args[2])
		{
			switch (name.begin[0])
			{
			case 'b':
				if (name == PUGIXML_TEXT("boolean") && argc == 1)
					return new (alloc_node()) xpath_ast_node(ast_func_boolean, xpath_type_boolean, args[0]);
					
				break;
			
			case 'c':
				if (name == PUGIXML_TEXT("count") && argc == 1)
				{
					if (args[0]->rettype() != xpath_type_node_set) throw_error("Function has to be applied to node set");
					return new (alloc_node()) xpath_ast_node(ast_func_count, xpath_type_number, args[0]);
				}
				else if (name == PUGIXML_TEXT("contains") && argc == 2)
					return new (alloc_node()) xpath_ast_node(ast_func_contains, xpath_type_boolean, args[0], args[1]);
				else if (name == PUGIXML_TEXT("concat") && argc >= 2)
					return new (alloc_node()) xpath_ast_node(ast_func_concat, xpath_type_string, args[0], args[1]);
				else if (name == PUGIXML_TEXT("ceiling") && argc == 1)
					return new (alloc_node()) xpath_ast_node(ast_func_ceiling, xpath_type_number, args[0]);
					
				break;
			
			case 'f':
				if (name == PUGIXML_TEXT("false") && argc == 0)
					return new (alloc_node()) xpath_ast_node(ast_func_false, xpath_type_boolean);
				else if (name == PUGIXML_TEXT("floor") && argc == 1)
					return new (alloc_node()) xpath_ast_node(ast_func_floor, xpath_type_number, args[0]);
					
				break;
			
			case 'i':
				if (name == PUGIXML_TEXT("id") && argc == 1)
					return new (alloc_node()) xpath_ast_node(ast_func_id, xpath_type_node_set, args[0]);
					
				break;
			
			case 'l':
				if (name == PUGIXML_TEXT("last") && argc == 0)
					return new (alloc_node()) xpath_ast_node(ast_func_last, xpath_type_number);
				else if (name == PUGIXML_TEXT("lang") && argc == 1)
					return new (alloc_node()) xpath_ast_node(ast_func_lang, xpath_type_boolean, args[0]);
				else if (name == PUGIXML_TEXT("local-name") && argc <= 1)
					return parse_function_helper(ast_func_local_name_0, ast_func_local_name_1, argc, args);
			
				break;
			
			case 'n':
				if (name == PUGIXML_TEXT("name") && argc <= 1)
					return parse_function_helper(ast_func_name_0, ast_func_name_1, argc, args);
				else if (name == PUGIXML_TEXT("namespace-uri") && argc <= 1)
					return parse_function_helper(ast_func_namespace_uri_0, ast_func_namespace_uri_1, argc, args);
				else if (name == PUGIXML_TEXT("normalize-space") && argc <= 1)
					return new (alloc_node()) xpath_ast_node(argc == 0 ? ast_func_normalize_space_0 : ast_func_normalize_space_1, xpath_type_string, args[0], args[1]);
				else if (name == PUGIXML_TEXT("not") && argc == 1)
					return new (alloc_node()) xpath_ast_node(ast_func_not, xpath_type_boolean, args[0]);
				else if (name == PUGIXML_TEXT("number") && argc <= 1)
					return new (alloc_node()) xpath_ast_node(argc == 0 ? ast_func_number_0 : ast_func_number_1, xpath_type_number, args[0]);
			
				break;
			
			case 'p':
				if (name == PUGIXML_TEXT("position") && argc == 0)
					return new (alloc_node()) xpath_ast_node(ast_func_position, xpath_type_number);
				
				break;
			
			case 'r':
				if (name == PUGIXML_TEXT("round") && argc == 1)
					return new (alloc_node()) xpath_ast_node(ast_func_round, xpath_type_number, args[0]);

				break;
			
			case 's':
				if (name == PUGIXML_TEXT("string") && argc <= 1)
					return new (alloc_node()) xpath_ast_node(argc == 0 ? ast_func_string_0 : ast_func_string_1, xpath_type_string, args[0]);
				else if (name == PUGIXML_TEXT("string-length") && argc <= 1)
					return new (alloc_node()) xpath_ast_node(argc == 0 ? ast_func_string_length_0 : ast_func_string_length_1, xpath_type_number, args[0]);
				else if (name == PUGIXML_TEXT("starts-with") && argc == 2)
					return new (alloc_node()) xpath_ast_node(ast_func_starts_with, xpath_type_boolean, args[0], args[1]);
				else if (name == PUGIXML_TEXT("substring-before") && argc == 2)
					return new (alloc_node()) xpath_ast_node(ast_func_substring_before, xpath_type_string, args[0], args[1]);
				else if (name == PUGIXML_TEXT("substring-after") && argc == 2)
					return new (alloc_node()) xpath_ast_node(ast_func_substring_after, xpath_type_string, args[0], args[1]);
				else if (name == PUGIXML_TEXT("substring") && (argc == 2 || argc == 3))
					return new (alloc_node()) xpath_ast_node(argc == 2 ? ast_func_substring_2 : ast_func_substring_3, xpath_type_string, args[0], args[1]);
				else if (name == PUGIXML_TEXT("sum") && argc == 1)
				{
					if (args[0]->rettype() != xpath_type_node_set) throw_error("Function has to be applied to node set");
					return new (alloc_node()) xpath_ast_node(ast_func_sum, xpath_type_number, args[0]);
				}

				break;
			
			case 't':
				if (name == PUGIXML_TEXT("translate") && argc == 3)
					return new (alloc_node()) xpath_ast_node(ast_func_translate, xpath_type_string, args[0], args[1]);
				else if (name == PUGIXML_TEXT("true") && argc == 0)
					return new (alloc_node()) xpath_ast_node(ast_func_true, xpath_type_boolean);
					
				break;

			default:
				break;
			}

			throw_error("Unrecognized function or wrong parameter count");

			return 0;
		}

		axis_t parse_axis_name(const xpath_lexer_string& name, bool& specified)
		{
			specified = true;

			switch (name.begin[0])
			{
			case 'a':
				if (name == PUGIXML_TEXT("ancestor"))
					return axis_ancestor;
				else if (name == PUGIXML_TEXT("ancestor-or-self"))
					return axis_ancestor_or_self;
				else if (name == PUGIXML_TEXT("attribute"))
					return axis_attribute;
				
				break;
			
			case 'c':
				if (name == PUGIXML_TEXT("child"))
					return axis_child;
				
				break;
			
			case 'd':
				if (name == PUGIXML_TEXT("descendant"))
					return axis_descendant;
				else if (name == PUGIXML_TEXT("descendant-or-self"))
					return axis_descendant_or_self;
				
				break;
			
			case 'f':
				if (name == PUGIXML_TEXT("following"))
					return axis_following;
				else if (name == PUGIXML_TEXT("following-sibling"))
					return axis_following_sibling;
				
				break;
			
			case 'n':
				if (name == PUGIXML_TEXT("namespace"))
					return axis_namespace;
				
				break;
			
			case 'p':
				if (name == PUGIXML_TEXT("parent"))
					return axis_parent;
				else if (name == PUGIXML_TEXT("preceding"))
					return axis_preceding;
				else if (name == PUGIXML_TEXT("preceding-sibling"))
					return axis_preceding_sibling;
				
				break;
			
			case 's':
				if (name == PUGIXML_TEXT("self"))
					return axis_self;
				
				break;

			default:
				break;
			}

			specified = false;
			return axis_child;
		}

		nodetest_t parse_node_test_type(const xpath_lexer_string& name)
		{
			switch (name.begin[0])
			{
			case 'c':
				if (name == PUGIXML_TEXT("comment"))
					return nodetest_type_comment;

				break;

			case 'n':
				if (name == PUGIXML_TEXT("node"))
					return nodetest_type_node;

				break;

			case 'p':
				if (name == PUGIXML_TEXT("processing-instruction"))
					return nodetest_type_pi;

				break;

			case 't':
				if (name == PUGIXML_TEXT("text"))
					return nodetest_type_text;

				break;
			
			default:
				break;
			}

			return nodetest_none;
		}

		// PrimaryExpr ::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall
		xpath_ast_node* parse_primary_expression()
		{
			switch (_lexer.current())
			{
			case lex_var_ref:
			{
				xpath_lexer_string name = _lexer.contents();

				if (!_variables)
					throw_error("Unknown variable: variable set is not provided");

				xpath_variable* var = get_variable_scratch(_scratch, _variables, name.begin, name.end);

				if (!var)
					throw_error("Unknown variable: variable set does not contain the given name");

				_lexer.next();

				return new (alloc_node()) xpath_ast_node(ast_variable, var->type(), var);
			}

			case lex_open_brace:
			{
				_lexer.next();

				xpath_ast_node* n = parse_expression();

				if (_lexer.current() != lex_close_brace)
					throw_error("Unmatched braces");

				_lexer.next();

				return n;
			}

			case lex_quoted_string:
			{
				const char_t* value = alloc_string(_lexer.contents());

				xpath_ast_node* n = new (alloc_node()) xpath_ast_node(ast_string_constant, xpath_type_string, value);
				_lexer.next();

				return n;
			}

			case lex_number:
			{
				double value = 0;

				if (!convert_string_to_number_scratch(_scratch, _lexer.contents().begin, _lexer.contents().end, &value))
					throw_error_oom();

				xpath_ast_node* n = new (alloc_node()) xpath_ast_node(ast_number_constant, xpath_type_number, value);
				_lexer.next();

				return n;
			}

			case lex_string:
			{
				xpath_ast_node* args[2] = {0};
				size_t argc = 0;
				
				xpath_lexer_string function = _lexer.contents();
				_lexer.next();
				
				xpath_ast_node* last_arg = 0;
				
				if (_lexer.current() != lex_open_brace)
					throw_error("Unrecognized function call");
				_lexer.next();

				if (_lexer.current() != lex_close_brace)
					args[argc++] = parse_expression();

				while (_lexer.current() != lex_close_brace)
				{
					if (_lexer.current() != lex_comma)
						throw_error("No comma between function arguments");
					_lexer.next();
					
					xpath_ast_node* n = parse_expression();
					
					if (argc < 2) args[argc] = n;
					else last_arg->set_next(n);

					argc++;
					last_arg = n;
				}
				
				_lexer.next();

				return parse_function(function, argc, args);
			}

			default:
				throw_error("Unrecognizable primary expression");

				return 0;
			}
		}
		
		// FilterExpr ::= PrimaryExpr | FilterExpr Predicate
		// Predicate ::= '[' PredicateExpr ']'
		// PredicateExpr ::= Expr
		xpath_ast_node* parse_filter_expression()
		{
			xpath_ast_node* n = parse_primary_expression();

			while (_lexer.current() == lex_open_square_brace)
			{
				_lexer.next();

				xpath_ast_node* expr = parse_expression();

				if (n->rettype() != xpath_type_node_set) throw_error("Predicate has to be applied to node set");

				bool posinv = expr->rettype() != xpath_type_number && expr->is_posinv();

				n = new (alloc_node()) xpath_ast_node(posinv ? ast_filter_posinv : ast_filter, xpath_type_node_set, n, expr);

				if (_lexer.current() != lex_close_square_brace)
					throw_error("Unmatched square brace");
			
				_lexer.next();
			}
			
			return n;
		}
		
		// Step ::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep
		// AxisSpecifier ::= AxisName '::' | '@'?
		// NodeTest ::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'
		// NameTest ::= '*' | NCName ':' '*' | QName
		// AbbreviatedStep ::= '.' | '..'
		xpath_ast_node* parse_step(xpath_ast_node* set)
		{
			if (set && set->rettype() != xpath_type_node_set)
				throw_error("Step has to be applied to node set");

			bool axis_specified = false;
			axis_t axis = axis_child; // implied child axis

			if (_lexer.current() == lex_axis_attribute)
			{
				axis = axis_attribute;
				axis_specified = true;
				
				_lexer.next();
			}
			else if (_lexer.current() == lex_dot)
			{
				_lexer.next();
				
				return new (alloc_node()) xpath_ast_node(ast_step, set, axis_self, nodetest_type_node, 0);
			}
			else if (_lexer.current() == lex_double_dot)
			{
				_lexer.next();
				
				return new (alloc_node()) xpath_ast_node(ast_step, set, axis_parent, nodetest_type_node, 0);
			}
		
			nodetest_t nt_type = nodetest_none;
			xpath_lexer_string nt_name;
			
			if (_lexer.current() == lex_string)
			{
				// node name test
				nt_name = _lexer.contents();
				_lexer.next();

				// was it an axis name?
				if (_lexer.current() == lex_double_colon)
				{
					// parse axis name
					if (axis_specified) throw_error("Two axis specifiers in one step");

					axis = parse_axis_name(nt_name, axis_specified);

					if (!axis_specified) throw_error("Unknown axis");

					// read actual node test
					_lexer.next();

					if (_lexer.current() == lex_multiply)
					{
						nt_type = nodetest_all;
						nt_name = xpath_lexer_string();
						_lexer.next();
					}
					else if (_lexer.current() == lex_string)
					{
						nt_name = _lexer.contents();
						_lexer.next();
					}
					else throw_error("Unrecognized node test");
				}
				
				if (nt_type == nodetest_none)
				{
					// node type test or processing-instruction
					if (_lexer.current() == lex_open_brace)
					{
						_lexer.next();
						
						if (_lexer.current() == lex_close_brace)
						{
							_lexer.next();

							nt_type = parse_node_test_type(nt_name);

							if (nt_type == nodetest_none) throw_error("Unrecognized node type");
							
							nt_name = xpath_lexer_string();
						}
						else if (nt_name == PUGIXML_TEXT("processing-instruction"))
						{
							if (_lexer.current() != lex_quoted_string)
								throw_error("Only literals are allowed as arguments to processing-instruction()");
						
							nt_type = nodetest_pi;
							nt_name = _lexer.contents();
							_lexer.next();
							
							if (_lexer.current() != lex_close_brace)
								throw_error("Unmatched brace near processing-instruction()");
							_lexer.next();
						}
						else
							throw_error("Unmatched brace near node type test");

					}
					// QName or NCName:*
					else
					{
						if (nt_name.end - nt_name.begin > 2 && nt_name.end[-2] == ':' && nt_name.end[-1] == '*') // NCName:*
						{
							nt_name.end--; // erase *
							
							nt_type = nodetest_all_in_namespace;
						}
						else nt_type = nodetest_name;
					}
				}
			}
			else if (_lexer.current() == lex_multiply)
			{
				nt_type = nodetest_all;
				_lexer.next();
			}
			else throw_error("Unrecognized node test");
			
			xpath_ast_node* n = new (alloc_node()) xpath_ast_node(ast_step, set, axis, nt_type, alloc_string(nt_name));
			
			xpath_ast_node* last = 0;
			
			while (_lexer.current() == lex_open_square_brace)
			{
				_lexer.next();
				
				xpath_ast_node* expr = parse_expression();

				xpath_ast_node* pred = new (alloc_node()) xpath_ast_node(ast_predicate, xpath_type_node_set, expr);
				
				if (_lexer.current() != lex_close_square_brace)
					throw_error("Unmatched square brace");
				_lexer.next();
				
				if (last) last->set_next(pred);
				else n->set_right(pred);
				
				last = pred;
			}
			
			return n;
		}
		
		// RelativeLocationPath ::= Step | RelativeLocationPath '/' Step | RelativeLocationPath '//' Step
		xpath_ast_node* parse_relative_location_path(xpath_ast_node* set)
		{
			xpath_ast_node* n = parse_step(set);
			
			while (_lexer.current() == lex_slash || _lexer.current() == lex_double_slash)
			{
				lexeme_t l = _lexer.current();
				_lexer.next();

				if (l == lex_double_slash)
					n = new (alloc_node()) xpath_ast_node(ast_step, n, axis_descendant_or_self, nodetest_type_node, 0);
				
				n = parse_step(n);
			}
			
			return n;
		}
		
		// LocationPath ::= RelativeLocationPath | AbsoluteLocationPath
		// AbsoluteLocationPath ::= '/' RelativeLocationPath? | '//' RelativeLocationPath
		xpath_ast_node* parse_location_path()
		{
			if (_lexer.current() == lex_slash)
			{
				_lexer.next();
				
				xpath_ast_node* n = new (alloc_node()) xpath_ast_node(ast_step_root, xpath_type_node_set);

				// relative location path can start from axis_attribute, dot, double_dot, multiply and string lexemes; any other lexeme means standalone root path
				lexeme_t l = _lexer.current();

				if (l == lex_string || l == lex_axis_attribute || l == lex_dot || l == lex_double_dot || l == lex_multiply)
					return parse_relative_location_path(n);
				else
					return n;
			}
			else if (_lexer.current() == lex_double_slash)
			{
				_lexer.next();
				
				xpath_ast_node* n = new (alloc_node()) xpath_ast_node(ast_step_root, xpath_type_node_set);
				n = new (alloc_node()) xpath_ast_node(ast_step, n, axis_descendant_or_self, nodetest_type_node, 0);
				
				return parse_relative_location_path(n);
			}

			// else clause moved outside of if because of bogus warning 'control may reach end of non-void function being inlined' in gcc 4.0.1
			return parse_relative_location_path(0);
		}
		
		// PathExpr ::= LocationPath
		//				| FilterExpr
		//				| FilterExpr '/' RelativeLocationPath
		//				| FilterExpr '//' RelativeLocationPath
		// UnionExpr ::= PathExpr | UnionExpr '|' PathExpr
		// UnaryExpr ::= UnionExpr | '-' UnaryExpr
		xpath_ast_node* parse_path_or_unary_expression()
		{
			// Clarification.
			// PathExpr begins with either LocationPath or FilterExpr.
			// FilterExpr begins with PrimaryExpr
			// PrimaryExpr begins with '$' in case of it being a variable reference,
			// '(' in case of it being an expression, string literal, number constant or
			// function call.

			if (_lexer.current() == lex_var_ref || _lexer.current() == lex_open_brace || 
				_lexer.current() == lex_quoted_string || _lexer.current() == lex_number ||
				_lexer.current() == lex_string)
			{
				if (_lexer.current() == lex_string)
				{
					// This is either a function call, or not - if not, we shall proceed with location path
					const char_t* state = _lexer.state();
					
					while (PUGI__IS_CHARTYPE(*state, ct_space)) ++state;
					
					if (*state != '(') return parse_location_path();

					// This looks like a function call; however this still can be a node-test. Check it.
					if (parse_node_test_type(_lexer.contents()) != nodetest_none) return parse_location_path();
				}
				
				xpath_ast_node* n = parse_filter_expression();

				if (_lexer.current() == lex_slash || _lexer.current() == lex_double_slash)
				{
					lexeme_t l = _lexer.current();
					_lexer.next();
					
					if (l == lex_double_slash)
					{
						if (n->rettype() != xpath_type_node_set) throw_error("Step has to be applied to node set");

						n = new (alloc_node()) xpath_ast_node(ast_step, n, axis_descendant_or_self, nodetest_type_node, 0);
					}
	
					// select from location path
					return parse_relative_location_path(n);
				}

				return n;
			}
			else if (_lexer.current() == lex_minus)
			{
				_lexer.next();

				// precedence 7+ - only parses union expressions
				xpath_ast_node* expr = parse_expression_rec(parse_path_or_unary_expression(), 7);

				return new (alloc_node()) xpath_ast_node(ast_op_negate, xpath_type_number, expr);
			}
			else
				return parse_location_path();
		}

		struct binary_op_t
		{
			ast_type_t asttype;
			xpath_value_type rettype;
			int precedence;

			binary_op_t(): asttype(ast_unknown), rettype(xpath_type_none), precedence(0)
			{
			}

			binary_op_t(ast_type_t asttype_, xpath_value_type rettype_, int precedence_): asttype(asttype_), rettype(rettype_), precedence(precedence_)
			{
			}

			static binary_op_t parse(xpath_lexer& lexer)
			{
				switch (lexer.current())
				{
				case lex_string:
					if (lexer.contents() == PUGIXML_TEXT("or"))
						return binary_op_t(ast_op_or, xpath_type_boolean, 1);
					else if (lexer.contents() == PUGIXML_TEXT("and"))
						return binary_op_t(ast_op_and, xpath_type_boolean, 2);
					else if (lexer.contents() == PUGIXML_TEXT("div"))
						return binary_op_t(ast_op_divide, xpath_type_number, 6);
					else if (lexer.contents() == PUGIXML_TEXT("mod"))
						return binary_op_t(ast_op_mod, xpath_type_number, 6);
					else
						return binary_op_t();

				case lex_equal:
					return binary_op_t(ast_op_equal, xpath_type_boolean, 3);

				case lex_not_equal:
					return binary_op_t(ast_op_not_equal, xpath_type_boolean, 3);

				case lex_less:
					return binary_op_t(ast_op_less, xpath_type_boolean, 4);

				case lex_greater:
					return binary_op_t(ast_op_greater, xpath_type_boolean, 4);

				case lex_less_or_equal:
					return binary_op_t(ast_op_less_or_equal, xpath_type_boolean, 4);

				case lex_greater_or_equal:
					return binary_op_t(ast_op_greater_or_equal, xpath_type_boolean, 4);

				case lex_plus:
					return binary_op_t(ast_op_add, xpath_type_number, 5);

				case lex_minus:
					return binary_op_t(ast_op_subtract, xpath_type_number, 5);

				case lex_multiply:
					return binary_op_t(ast_op_multiply, xpath_type_number, 6);

				case lex_union:
					return binary_op_t(ast_op_union, xpath_type_node_set, 7);

				default:
					return binary_op_t();
				}
			}
		};

		xpath_ast_node* parse_expression_rec(xpath_ast_node* lhs, int limit)
		{
			binary_op_t op = binary_op_t::parse(_lexer);

			while (op.asttype != ast_unknown && op.precedence >= limit)
			{
				_lexer.next();

				xpath_ast_node* rhs = parse_path_or_unary_expression();

				binary_op_t nextop = binary_op_t::parse(_lexer);

				while (nextop.asttype != ast_unknown && nextop.precedence > op.precedence)
				{
					rhs = parse_expression_rec(rhs, nextop.precedence);

					nextop = binary_op_t::parse(_lexer);
				}

				if (op.asttype == ast_op_union && (lhs->rettype() != xpath_type_node_set || rhs->rettype() != xpath_type_node_set))
					throw_error("Union operator has to be applied to node sets");

				lhs = new (alloc_node()) xpath_ast_node(op.asttype, op.rettype, lhs, rhs);

				op = binary_op_t::parse(_lexer);
			}

			return lhs;
		}

		// Expr ::= OrExpr
		// OrExpr ::= AndExpr | OrExpr 'or' AndExpr
		// AndExpr ::= EqualityExpr | AndExpr 'and' EqualityExpr
		// EqualityExpr ::= RelationalExpr
		//					| EqualityExpr '=' RelationalExpr
		//					| EqualityExpr '!=' RelationalExpr
		// RelationalExpr ::= AdditiveExpr
		//					  | RelationalExpr '<' AdditiveExpr
		//					  | RelationalExpr '>' AdditiveExpr
		//					  | RelationalExpr '<=' AdditiveExpr
		//					  | RelationalExpr '>=' AdditiveExpr
		// AdditiveExpr ::= MultiplicativeExpr
		//					| AdditiveExpr '+' MultiplicativeExpr
		//					| AdditiveExpr '-' MultiplicativeExpr
		// MultiplicativeExpr ::= UnaryExpr
		//						  | MultiplicativeExpr '*' UnaryExpr
		//						  | MultiplicativeExpr 'div' UnaryExpr
		//						  | MultiplicativeExpr 'mod' UnaryExpr
		xpath_ast_node* parse_expression()
		{
			return parse_expression_rec(parse_path_or_unary_expression(), 0);
		}

		xpath_parser(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result): _alloc(alloc), _lexer(query), _query(query), _variables(variables), _result(result)
		{
		}

		xpath_ast_node* parse()
		{
			xpath_ast_node* result = parse_expression();
			
			if (_lexer.current() != lex_eof)
			{
				// there are still unparsed tokens left, error
				throw_error("Incorrect query");
			}
			
			return result;
		}

		static xpath_ast_node* parse(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result)
		{
			xpath_parser parser(query, variables, alloc, result);

		#ifdef PUGIXML_NO_EXCEPTIONS
			int error = setjmp(parser._error_handler);

			return (error == 0) ? parser.parse() : 0;
		#else
			return parser.parse();
		#endif
		}
	};

	struct xpath_query_impl
	{
		static xpath_query_impl* create()
		{
			void* memory = xml_memory::allocate(sizeof(xpath_query_impl));

			return new (memory) xpath_query_impl();
		}

		static void destroy(void* ptr)
		{
			if (!ptr) return;
			
			// free all allocated pages
			static_cast<xpath_query_impl*>(ptr)->alloc.release();

			// free allocator memory (with the first page)
			xml_memory::deallocate(ptr);
		}

		xpath_query_impl(): root(0), alloc(&block)
		{
			block.next = 0;
		}

		xpath_ast_node* root;
		xpath_allocator alloc;
		xpath_memory_block block;
	};

	PUGI__FN xpath_string evaluate_string_impl(xpath_query_impl* impl, const xpath_node& n, xpath_stack_data& sd)
	{
		if (!impl) return xpath_string();

	#ifdef PUGIXML_NO_EXCEPTIONS
		if (setjmp(sd.error_handler)) return xpath_string();
	#endif

		xpath_context c(n, 1, 1);

		return impl->root->eval_string(c, sd.stack);
	}
PUGI__NS_END

namespace pugi
{
#ifndef PUGIXML_NO_EXCEPTIONS
	PUGI__FN xpath_exception::xpath_exception(const xpath_parse_result& result_): _result(result_)
	{
		assert(_result.error);
	}
	
	PUGI__FN const char* xpath_exception::what() const throw()
	{
		return _result.error;
	}

	PUGI__FN const xpath_parse_result& xpath_exception::result() const
	{
		return _result;
	}
#endif
	
	PUGI__FN xpath_node::xpath_node()
	{
	}
		
	PUGI__FN xpath_node::xpath_node(const xml_node& node_): _node(node_)
	{
	}
		
	PUGI__FN xpath_node::xpath_node(const xml_attribute& attribute_, const xml_node& parent_): _node(attribute_ ? parent_ : xml_node()), _attribute(attribute_)
	{
	}

	PUGI__FN xml_node xpath_node::node() const
	{
		return _attribute ? xml_node() : _node;
	}
		
	PUGI__FN xml_attribute xpath_node::attribute() const
	{
		return _attribute;
	}
	
	PUGI__FN xml_node xpath_node::parent() const
	{
		return _attribute ? _node : _node.parent();
	}

	PUGI__FN static void unspecified_bool_xpath_node(xpath_node***)
	{
	}

	PUGI__FN xpath_node::operator xpath_node::unspecified_bool_type() const
	{
		return (_node || _attribute) ? unspecified_bool_xpath_node : 0;
	}
	
	PUGI__FN bool xpath_node::operator!() const
	{
		return !(_node || _attribute);
	}

	PUGI__FN bool xpath_node::operator==(const xpath_node& n) const
	{
		return _node == n._node && _attribute == n._attribute;
	}
	
	PUGI__FN bool xpath_node::operator!=(const xpath_node& n) const
	{
		return _node != n._node || _attribute != n._attribute;
	}

#ifdef __BORLANDC__
	PUGI__FN bool operator&&(const xpath_node& lhs, bool rhs)
	{
		return (bool)lhs && rhs;
	}

	PUGI__FN bool operator||(const xpath_node& lhs, bool rhs)
	{
		return (bool)lhs || rhs;
	}
#endif

	PUGI__FN void xpath_node_set::_assign(const_iterator begin_, const_iterator end_)
	{
		assert(begin_ <= end_);

		size_t size_ = static_cast<size_t>(end_ - begin_);

		if (size_ <= 1)
		{
			// deallocate old buffer
			if (_begin != &_storage) impl::xml_memory::deallocate(_begin);

			// use internal buffer
			if (begin_ != end_) _storage = *begin_;

			_begin = &_storage;
			_end = &_storage + size_;
		}
		else
		{
			// make heap copy
			xpath_node* storage = static_cast<xpath_node*>(impl::xml_memory::allocate(size_ * sizeof(xpath_node)));

			if (!storage)
			{
			#ifdef PUGIXML_NO_EXCEPTIONS
				return;
			#else
				throw std::bad_alloc();
			#endif
			}

			memcpy(storage, begin_, size_ * sizeof(xpath_node));
			
			// deallocate old buffer
			if (_begin != &_storage) impl::xml_memory::deallocate(_begin);

			// finalize
			_begin = storage;
			_end = storage + size_;
		}
	}

	PUGI__FN xpath_node_set::xpath_node_set(): _type(type_unsorted), _begin(&_storage), _end(&_storage)
	{
	}

	PUGI__FN xpath_node_set::xpath_node_set(const_iterator begin_, const_iterator end_, type_t type_): _type(type_), _begin(&_storage), _end(&_storage)
	{
		_assign(begin_, end_);
	}

	PUGI__FN xpath_node_set::~xpath_node_set()
	{
		if (_begin != &_storage) impl::xml_memory::deallocate(_begin);
	}
		
	PUGI__FN xpath_node_set::xpath_node_set(const xpath_node_set& ns): _type(ns._type), _begin(&_storage), _end(&_storage)
	{
		_assign(ns._begin, ns._end);
	}
	
	PUGI__FN xpath_node_set& xpath_node_set::operator=(const xpath_node_set& ns)
	{
		if (this == &ns) return *this;
		
		_type = ns._type;
		_assign(ns._begin, ns._end);

		return *this;
	}

	PUGI__FN xpath_node_set::type_t xpath_node_set::type() const
	{
		return _type;
	}
		
	PUGI__FN size_t xpath_node_set::size() const
	{
		return _end - _begin;
	}
		
	PUGI__FN bool xpath_node_set::empty() const
	{
		return _begin == _end;
	}
		
	PUGI__FN const xpath_node& xpath_node_set::operator[](size_t index) const
	{
		assert(index < size());
		return _begin[index];
	}

	PUGI__FN xpath_node_set::const_iterator xpath_node_set::begin() const
	{
		return _begin;
	}
		
	PUGI__FN xpath_node_set::const_iterator xpath_node_set::end() const
	{
		return _end;
	}
	
	PUGI__FN void xpath_node_set::sort(bool reverse)
	{
		_type = impl::xpath_sort(_begin, _end, _type, reverse);
	}

	PUGI__FN xpath_node xpath_node_set::first() const
	{
		return impl::xpath_first(_begin, _end, _type);
	}

	PUGI__FN xpath_parse_result::xpath_parse_result(): error("Internal error"), offset(0)
	{
	}

	PUGI__FN xpath_parse_result::operator bool() const
	{
		return error == 0;
	}

	PUGI__FN const char* xpath_parse_result::description() const
	{
		return error ? error : "No error";
	}

	PUGI__FN xpath_variable::xpath_variable(): _type(xpath_type_none), _next(0)
	{
	}

	PUGI__FN const char_t* xpath_variable::name() const
	{
		switch (_type)
		{
		case xpath_type_node_set:
			return static_cast<const impl::xpath_variable_node_set*>(this)->name;

		case xpath_type_number:
			return static_cast<const impl::xpath_variable_number*>(this)->name;

		case xpath_type_string:
			return static_cast<const impl::xpath_variable_string*>(this)->name;

		case xpath_type_boolean:
			return static_cast<const impl::xpath_variable_boolean*>(this)->name;

		default:
			assert(!"Invalid variable type");
			return 0;
		}
	}

	PUGI__FN xpath_value_type xpath_variable::type() const
	{
		return _type;
	}

	PUGI__FN bool xpath_variable::get_boolean() const
	{
		return (_type == xpath_type_boolean) ? static_cast<const impl::xpath_variable_boolean*>(this)->value : false;
	}

	PUGI__FN double xpath_variable::get_number() const
	{
		return (_type == xpath_type_number) ? static_cast<const impl::xpath_variable_number*>(this)->value : impl::gen_nan();
	}

	PUGI__FN const char_t* xpath_variable::get_string() const
	{
		const char_t* value = (_type == xpath_type_string) ? static_cast<const impl::xpath_variable_string*>(this)->value : 0;
		return value ? value : PUGIXML_TEXT("");
	}

	PUGI__FN const xpath_node_set& xpath_variable::get_node_set() const
	{
		return (_type == xpath_type_node_set) ? static_cast<const impl::xpath_variable_node_set*>(this)->value : impl::dummy_node_set;
	}

	PUGI__FN bool xpath_variable::set(bool value)
	{
		if (_type != xpath_type_boolean) return false;

		static_cast<impl::xpath_variable_boolean*>(this)->value = value;
		return true;
	}

	PUGI__FN bool xpath_variable::set(double value)
	{
		if (_type != xpath_type_number) return false;

		static_cast<impl::xpath_variable_number*>(this)->value = value;
		return true;
	}

	PUGI__FN bool xpath_variable::set(const char_t* value)
	{
		if (_type != xpath_type_string) return false;

		impl::xpath_variable_string* var = static_cast<impl::xpath_variable_string*>(this);

		// duplicate string
		size_t size = (impl::strlength(value) + 1) * sizeof(char_t);

		char_t* copy = static_cast<char_t*>(impl::xml_memory::allocate(size));
		if (!copy) return false;

		memcpy(copy, value, size);

		// replace old string
		if (var->value) impl::xml_memory::deallocate(var->value);
		var->value = copy;

		return true;
	}

	PUGI__FN bool xpath_variable::set(const xpath_node_set& value)
	{
		if (_type != xpath_type_node_set) return false;

		static_cast<impl::xpath_variable_node_set*>(this)->value = value;
		return true;
	}

	PUGI__FN xpath_variable_set::xpath_variable_set()
	{
		for (size_t i = 0; i < sizeof(_data) / sizeof(_data[0]); ++i) _data[i] = 0;
	}

	PUGI__FN xpath_variable_set::~xpath_variable_set()
	{
		for (size_t i = 0; i < sizeof(_data) / sizeof(_data[0]); ++i)
		{
			xpath_variable* var = _data[i];

			while (var)
			{
				xpath_variable* next = var->_next;

				impl::delete_xpath_variable(var->_type, var);

				var = next;
			}
		}
	}

	PUGI__FN xpath_variable* xpath_variable_set::find(const char_t* name) const
	{
		const size_t hash_size = sizeof(_data) / sizeof(_data[0]);
		size_t hash = impl::hash_string(name) % hash_size;

		// look for existing variable
		for (xpath_variable* var = _data[hash]; var; var = var->_next)
			if (impl::strequal(var->name(), name))
				return var;

		return 0;
	}

	PUGI__FN xpath_variable* xpath_variable_set::add(const char_t* name, xpath_value_type type)
	{
		const size_t hash_size = sizeof(_data) / sizeof(_data[0]);
		size_t hash = impl::hash_string(name) % hash_size;

		// look for existing variable
		for (xpath_variable* var = _data[hash]; var; var = var->_next)
			if (impl::strequal(var->name(), name))
				return var->type() == type ? var : 0;

		// add new variable
		xpath_variable* result = impl::new_xpath_variable(type, name);

		if (result)
		{
			result->_type = type;
			result->_next = _data[hash];

			_data[hash] = result;
		}

		return result;
	}

	PUGI__FN bool xpath_variable_set::set(const char_t* name, bool value)
	{
		xpath_variable* var = add(name, xpath_type_boolean);
		return var ? var->set(value) : false;
	}

	PUGI__FN bool xpath_variable_set::set(const char_t* name, double value)
	{
		xpath_variable* var = add(name, xpath_type_number);
		return var ? var->set(value) : false;
	}

	PUGI__FN bool xpath_variable_set::set(const char_t* name, const char_t* value)
	{
		xpath_variable* var = add(name, xpath_type_string);
		return var ? var->set(value) : false;
	}

	PUGI__FN bool xpath_variable_set::set(const char_t* name, const xpath_node_set& value)
	{
		xpath_variable* var = add(name, xpath_type_node_set);
		return var ? var->set(value) : false;
	}

	PUGI__FN xpath_variable* xpath_variable_set::get(const char_t* name)
	{
		return find(name);
	}

	PUGI__FN const xpath_variable* xpath_variable_set::get(const char_t* name) const
	{
		return find(name);
	}

	PUGI__FN xpath_query::xpath_query(const char_t* query, xpath_variable_set* variables): _impl(0)
	{
		impl::xpath_query_impl* qimpl = impl::xpath_query_impl::create();

		if (!qimpl)
		{
		#ifdef PUGIXML_NO_EXCEPTIONS
			_result.error = "Out of memory";
		#else
			throw std::bad_alloc();
		#endif
		}
		else
		{
			impl::buffer_holder impl_holder(qimpl, impl::xpath_query_impl::destroy);

			qimpl->root = impl::xpath_parser::parse(query, variables, &qimpl->alloc, &_result);

			if (qimpl->root)
			{
				_impl = static_cast<impl::xpath_query_impl*>(impl_holder.release());
				_result.error = 0;
			}
		}
	}

	PUGI__FN xpath_query::~xpath_query()
	{
		impl::xpath_query_impl::destroy(_impl);
	}

	PUGI__FN xpath_value_type xpath_query::return_type() const
	{
		if (!_impl) return xpath_type_none;

		return static_cast<impl::xpath_query_impl*>(_impl)->root->rettype();
	}

	PUGI__FN bool xpath_query::evaluate_boolean(const xpath_node& n) const
	{
		if (!_impl) return false;
		
		impl::xpath_context c(n, 1, 1);
		impl::xpath_stack_data sd;

	#ifdef PUGIXML_NO_EXCEPTIONS
		if (setjmp(sd.error_handler)) return false;
	#endif
		
		return static_cast<impl::xpath_query_impl*>(_impl)->root->eval_boolean(c, sd.stack);
	}
	
	PUGI__FN double xpath_query::evaluate_number(const xpath_node& n) const
	{
		if (!_impl) return impl::gen_nan();
		
		impl::xpath_context c(n, 1, 1);
		impl::xpath_stack_data sd;

	#ifdef PUGIXML_NO_EXCEPTIONS
		if (setjmp(sd.error_handler)) return impl::gen_nan();
	#endif

		return static_cast<impl::xpath_query_impl*>(_impl)->root->eval_number(c, sd.stack);
	}

#ifndef PUGIXML_NO_STL
	PUGI__FN string_t xpath_query::evaluate_string(const xpath_node& n) const
	{
		impl::xpath_stack_data sd;

		return impl::evaluate_string_impl(static_cast<impl::xpath_query_impl*>(_impl), n, sd).c_str();
	}
#endif

	PUGI__FN size_t xpath_query::evaluate_string(char_t* buffer, size_t capacity, const xpath_node& n) const
	{
		impl::xpath_stack_data sd;

		impl::xpath_string r = impl::evaluate_string_impl(static_cast<impl::xpath_query_impl*>(_impl), n, sd);

		size_t full_size = r.length() + 1;
		
		if (capacity > 0)
		{
			size_t size = (full_size < capacity) ? full_size : capacity;
			assert(size > 0);

			memcpy(buffer, r.c_str(), (size - 1) * sizeof(char_t));
			buffer[size - 1] = 0;
		}
		
		return full_size;
	}

	PUGI__FN xpath_node_set xpath_query::evaluate_node_set(const xpath_node& n) const
	{
		if (!_impl) return xpath_node_set();

		impl::xpath_ast_node* root = static_cast<impl::xpath_query_impl*>(_impl)->root;

		if (root->rettype() != xpath_type_node_set)
		{
		#ifdef PUGIXML_NO_EXCEPTIONS
			return xpath_node_set();
		#else
			xpath_parse_result res;
			res.error = "Expression does not evaluate to node set";

			throw xpath_exception(res);
		#endif
		}
		
		impl::xpath_context c(n, 1, 1);
		impl::xpath_stack_data sd;

	#ifdef PUGIXML_NO_EXCEPTIONS
		if (setjmp(sd.error_handler)) return xpath_node_set();
	#endif

		impl::xpath_node_set_raw r = root->eval_node_set(c, sd.stack);

		return xpath_node_set(r.begin(), r.end(), r.type());
	}

	PUGI__FN const xpath_parse_result& xpath_query::result() const
	{
		return _result;
	}

	PUGI__FN static void unspecified_bool_xpath_query(xpath_query***)
	{
	}

	PUGI__FN xpath_query::operator xpath_query::unspecified_bool_type() const
	{
		return _impl ? unspecified_bool_xpath_query : 0;
	}

	PUGI__FN bool xpath_query::operator!() const
	{
		return !_impl;
	}

	PUGI__FN xpath_node xml_node::select_single_node(const char_t* query, xpath_variable_set* variables) const
	{
		xpath_query q(query, variables);
		return select_single_node(q);
	}

	PUGI__FN xpath_node xml_node::select_single_node(const xpath_query& query) const
	{
		xpath_node_set s = query.evaluate_node_set(*this);
		return s.empty() ? xpath_node() : s.first();
	}

	PUGI__FN xpath_node_set xml_node::select_nodes(const char_t* query, xpath_variable_set* variables) const
	{
		xpath_query q(query, variables);
		return select_nodes(q);
	}

	PUGI__FN xpath_node_set xml_node::select_nodes(const xpath_query& query) const
	{
		return query.evaluate_node_set(*this);
	}
}

#endif

#ifdef __BORLANDC__
#	pragma option pop
#endif

// Intel C++ does not properly keep warning state for function templates,
// so popping warning state at the end of translation unit leads to warnings in the middle.
#if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
#	pragma warning(pop)
#endif

// Undefine all local macros (makes sure we're not leaking macros in header-only mode)
#undef PUGI__NO_INLINE
#undef PUGI__STATIC_ASSERT
#undef PUGI__DMC_VOLATILE
#undef PUGI__MSVC_CRT_VERSION
#undef PUGI__NS_BEGIN
#undef PUGI__NS_END
#undef PUGI__FN
#undef PUGI__FN_NO_INLINE
#undef PUGI__IS_CHARTYPE_IMPL
#undef PUGI__IS_CHARTYPE
#undef PUGI__IS_CHARTYPEX
#undef PUGI__SKIPWS
#undef PUGI__OPTSET
#undef PUGI__PUSHNODE
#undef PUGI__POPNODE
#undef PUGI__SCANFOR
#undef PUGI__SCANWHILE
#undef PUGI__ENDSEG
#undef PUGI__THROW_ERROR
#undef PUGI__CHECK_ERROR

#endif

/**
 * Copyright (c) 2006-2014 Arseny Kapoulkine
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
**************FILE************ ./source/0.9.0.0/infra/pugixml/readme.txt
pugixml 1.4 - an XML processing library

Copyright (C) 2006-2014, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
Report bugs and download new versions at http://pugixml.org/

This is the distribution of pugixml, which is a C++ XML processing library,
which consists of a DOM-like interface with rich traversal/modification
capabilities, an extremely fast XML parser which constructs the DOM tree from
an XML file/buffer, and an XPath 1.0 implementation for complex data-driven
tree queries. Full Unicode support is also available, with Unicode interface
variants and conversions between different Unicode encodings (which happen
automatically during parsing/saving).

The distribution contains the following folders:

	contrib/ - various contributions to pugixml

	docs/ - documentation
		docs/samples - pugixml usage examples
		docs/quickstart.html - quick start guide
		docs/manual.html - complete manual

	scripts/ - project files for IDE/build systems

	src/ - header and source files

	readme.txt - this file.

This library is distributed under the MIT License:

Copyright (c) 2006-2014 Arseny Kapoulkine

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml.xcodeproj
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml.xcodeproj/project.pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 45;
	objects = {

/* Begin PBXBuildFile section */
		0424128F67AB5C730232235E /* pugixml.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 47481C4F0E03673E0E780637 /* pugixml.cpp */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		0B66463C5F896E6449051D38 /* pugiconfig.hpp */ = {isa = PBXFileReference; lastKnownFileType = text; name = "pugiconfig.hpp"; path = "pugiconfig.hpp"; sourceTree = "<group>"; };
		47481C4F0E03673E0E780637 /* pugixml.cpp */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.cpp.cpp; name = "pugixml.cpp"; path = "pugixml.cpp"; sourceTree = "<group>"; };
		6C911F0460FC44CD3B1B5624 /* pugixml.hpp */ = {isa = PBXFileReference; lastKnownFileType = text; name = "pugixml.hpp"; path = "pugixml.hpp"; sourceTree = "<group>"; };
		1DA04ADC64C3566D16C45B6D /* libpugixmld.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; name = "libpugixmld.a"; path = "libpugixmld.a"; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		2BA00212518037166623673F /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		19E0517F3CF26ED63AE23641 /* pugixml */ = {
			isa = PBXGroup;
			children = (
				578963B4309E714F05E01D71 /* src */,
				219F66186DDF392149043810 /* Products */,
			);
			name = "pugixml";
			sourceTree = "<group>";
		};
		578963B4309E714F05E01D71 /* src */ = {
			isa = PBXGroup;
			children = (
				0B66463C5F896E6449051D38 /* pugiconfig.hpp */,
				47481C4F0E03673E0E780637 /* pugixml.cpp */,
				6C911F0460FC44CD3B1B5624 /* pugixml.hpp */,
			);
			name = "src";
			path = ../src;
			sourceTree = "<group>";
		};
		219F66186DDF392149043810 /* Products */ = {
			isa = PBXGroup;
			children = (
				1DA04ADC64C3566D16C45B6D /* libpugixmld.a */,
			);
			name = "Products";
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		6B55152571905B6C3A6F39D0 /* pugixml */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 73BF376C14AA1ECC0AC517ED /* Build configuration list for PBXNativeTarget "pugixml" */;
			buildPhases = (
				6CA66B9B6252229A36E8733C /* Resources */,
				287808486FBF545206A47CC1 /* Sources */,
				2BA00212518037166623673F /* Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = "pugixml";
			productName = "pugixml";
			productReference = 1DA04ADC64C3566D16C45B6D /* libpugixmld.a */;
			productType = "com.apple.product-type.library.static";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		08FB7793FE84155DC02AAC07 /* Project object */ = {
			isa = PBXProject;
			buildConfigurationList = 1DEB928908733DD80010E9CD /* Build configuration list for PBXProject "pugixml" */;
			compatibilityVersion = "Xcode 3.1";
			hasScannedForEncodings = 1;
			mainGroup = 19E0517F3CF26ED63AE23641 /* pugixml */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				6B55152571905B6C3A6F39D0 /* libpugixmld.a */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		6CA66B9B6252229A36E8733C /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		287808486FBF545206A47CC1 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				0424128F67AB5C730232235E /* pugixml.cpp in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXVariantGroup section */
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		4FDB54E4253E36FC55CE27E8 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CONFIGURATION_BUILD_DIR = xcode3;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_MODEL_TUNING = G5;
				INSTALL_PATH = /usr/local/lib;
				PRODUCT_NAME = "pugixmld";
			};
			name = "Debug";
		};
		0A4C28F553990E0405306C15 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CONFIGURATION_BUILD_DIR = xcode3;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_MODEL_TUNING = G5;
				INSTALL_PATH = /usr/local/lib;
				PRODUCT_NAME = "pugixml";
			};
			name = "Release";
		};
		65DB0F6D27EA20852B6E3BB4 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ARCHS = "$(ARCHS_STANDARD_32_64_BIT)";
				CONFIGURATION_BUILD_DIR = "$(SYMROOT)";
				CONFIGURATION_TEMP_DIR = "$(OBJROOT)";
				COPY_PHASE_STRIP = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"_DEBUG",
				);
				GCC_WARN_ABOUT_RETURN_TYPE = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				OBJROOT = "xcode3/Universal/Debug";
				ONLY_ACTIVE_ARCH = NO;
				PREBINDING = NO;
				SYMROOT = "xcode3";
			};
			name = "Debug";
		};
		5314084032B57C1A11945858 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ARCHS = "$(ARCHS_STANDARD_32_64_BIT)";
				CONFIGURATION_BUILD_DIR = "$(SYMROOT)";
				CONFIGURATION_TEMP_DIR = "$(OBJROOT)";
				COPY_PHASE_STRIP = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_OPTIMIZATION_LEVEL = s;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"NDEBUG",
				);
				GCC_WARN_ABOUT_RETURN_TYPE = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				OBJROOT = "xcode3/Universal/Release";
				ONLY_ACTIVE_ARCH = NO;
				PREBINDING = NO;
				SYMROOT = "xcode3";
			};
			name = "Release";
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		73BF376C14AA1ECC0AC517ED /* Build configuration list for PBXNativeTarget "libpugixmld.a" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				4FDB54E4253E36FC55CE27E8 /* Debug */,
				0A4C28F553990E0405306C15 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = "Debug";
		};
		1DEB928908733DD80010E9CD /* Build configuration list for PBXProject "pugixml" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				65DB0F6D27EA20852B6E3BB4 /* Debug */,
				5314084032B57C1A11945858 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = "Debug";
		};
/* End XCConfigurationList section */

	};
	rootObject = 08FB7793FE84155DC02AAC07 /* Project object */;
}
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml_vs2010.vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<ItemGroup Label="ProjectConfigurations">
		<ProjectConfiguration Include="Debug|Win32">
			<Configuration>Debug</Configuration>
			<Platform>Win32</Platform>
		</ProjectConfiguration>
		<ProjectConfiguration Include="Debug|x64">
			<Configuration>Debug</Configuration>
			<Platform>x64</Platform>
		</ProjectConfiguration>
		<ProjectConfiguration Include="Release|Win32">
			<Configuration>Release</Configuration>
			<Platform>Win32</Platform>
		</ProjectConfiguration>
		<ProjectConfiguration Include="Release|x64">
			<Configuration>Release</Configuration>
			<Platform>x64</Platform>
		</ProjectConfiguration>
	</ItemGroup>
	<PropertyGroup Label="Globals">
		<ProjectGuid>{89A1E353-E2DC-495C-B403-742BE206ACED}</ProjectGuid>
		<RootNamespace>pugixml</RootNamespace>
		<Keyword>Win32Proj</Keyword>
	</PropertyGroup>
	<Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
		<ConfigurationType>StaticLibrary</ConfigurationType>
		<CharacterSet>MultiByte</CharacterSet>
		<UseDebugLibraries>true</UseDebugLibraries>
	</PropertyGroup>
	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
		<ConfigurationType>StaticLibrary</ConfigurationType>
		<CharacterSet>MultiByte</CharacterSet>
		<UseDebugLibraries>true</UseDebugLibraries>
	</PropertyGroup>
	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
		<ConfigurationType>StaticLibrary</ConfigurationType>
		<CharacterSet>MultiByte</CharacterSet>
		<WholeProgramOptimization>true</WholeProgramOptimization>
		<UseDebugLibraries>false</UseDebugLibraries>
	</PropertyGroup>
	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
		<ConfigurationType>StaticLibrary</ConfigurationType>
		<CharacterSet>MultiByte</CharacterSet>
		<WholeProgramOptimization>true</WholeProgramOptimization>
		<UseDebugLibraries>false</UseDebugLibraries>
	</PropertyGroup>
	<Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
	<ImportGroup Label="ExtensionSettings">
	</ImportGroup>
	<ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
		<Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
	</ImportGroup>
	<ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
		<Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
	</ImportGroup>
	<ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
		<Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
	</ImportGroup>
	<ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
		<Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
	</ImportGroup>
	<PropertyGroup Label="UserMacros" />
	<PropertyGroup>
		<_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
		<OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">vs2010\x32\</OutDir>
		<IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">vs2010\x32\Debug\</IntDir>
		<TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">pugixmld</TargetName>
		<OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">vs2010\x64\</OutDir>
		<IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">vs2010\x64\Debug\</IntDir>
		<TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pugixmld</TargetName>
		<OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">vs2010\x32\</OutDir>
		<IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">vs2010\x32\Release\</IntDir>
		<TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">pugixml</TargetName>
		<OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">vs2010\x64\</OutDir>
		<IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">vs2010\x64\Release\</IntDir>
		<TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pugixml</TargetName>
	</PropertyGroup>
	<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
		<ClCompile>
			<Optimization>Disabled</Optimization>
			<PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<MinimalRebuild>false</MinimalRebuild>
			<BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
			<RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
			<FunctionLevelLinking>true</FunctionLevelLinking>
			<PrecompiledHeader></PrecompiledHeader>
			<WarningLevel>Level3</WarningLevel>
			<DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
		</ClCompile>
		<ResourceCompile>
			<PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
		</ResourceCompile>
	<Lib>
		<OutputFile>$(OutDir)pugixmld.lib</OutputFile>
	</Lib>
		<Link>
			<SubSystem>Windows</SubSystem>
			<GenerateDebugInformation>true</GenerateDebugInformation>
			<ProgramDataBaseFileName>$(OutDir)pugixmld.pdb</ProgramDataBaseFileName>
		</Link>
	</ItemDefinitionGroup>
	<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
		<ClCompile>
			<Optimization>Disabled</Optimization>
			<PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<MinimalRebuild>false</MinimalRebuild>
			<BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
			<RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
			<FunctionLevelLinking>true</FunctionLevelLinking>
			<PrecompiledHeader></PrecompiledHeader>
			<WarningLevel>Level3</WarningLevel>
			<DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
		</ClCompile>
		<ResourceCompile>
			<PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
		</ResourceCompile>
	<Lib>
		<OutputFile>$(OutDir)pugixmld.lib</OutputFile>
	</Lib>
		<Link>
			<SubSystem>Windows</SubSystem>
			<GenerateDebugInformation>true</GenerateDebugInformation>
			<ProgramDataBaseFileName>$(OutDir)pugixmld.pdb</ProgramDataBaseFileName>
		</Link>
	</ItemDefinitionGroup>
	<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
		<ClCompile>
			<Optimization>Full</Optimization>
			<PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<MinimalRebuild>false</MinimalRebuild>
			<StringPooling>true</StringPooling>
			<RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
			<FunctionLevelLinking>true</FunctionLevelLinking>
			<PrecompiledHeader></PrecompiledHeader>
			<WarningLevel>Level3</WarningLevel>
			<DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
		</ClCompile>
		<ResourceCompile>
			<PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
		</ResourceCompile>
	<Lib>
		<OutputFile>$(OutDir)pugixml.lib</OutputFile>
	</Lib>
		<Link>
			<SubSystem>Windows</SubSystem>
			<GenerateDebugInformation>true</GenerateDebugInformation>
			<OptimizeReferences>true</OptimizeReferences>
			<EnableCOMDATFolding>true</EnableCOMDATFolding>
			<ProgramDataBaseFileName>$(OutDir)pugixml.pdb</ProgramDataBaseFileName>
		</Link>
	</ItemDefinitionGroup>
	<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
		<ClCompile>
			<Optimization>Full</Optimization>
			<PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<MinimalRebuild>false</MinimalRebuild>
			<StringPooling>true</StringPooling>
			<RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
			<FunctionLevelLinking>true</FunctionLevelLinking>
			<PrecompiledHeader></PrecompiledHeader>
			<WarningLevel>Level3</WarningLevel>
			<DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
		</ClCompile>
		<ResourceCompile>
			<PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
		</ResourceCompile>
	<Lib>
		<OutputFile>$(OutDir)pugixml.lib</OutputFile>
	</Lib>
		<Link>
			<SubSystem>Windows</SubSystem>
			<GenerateDebugInformation>true</GenerateDebugInformation>
			<OptimizeReferences>true</OptimizeReferences>
			<EnableCOMDATFolding>true</EnableCOMDATFolding>
			<ProgramDataBaseFileName>$(OutDir)pugixml.pdb</ProgramDataBaseFileName>
		</Link>
	</ItemDefinitionGroup>
	<ItemGroup>
		<ClInclude Include="..\src\pugixml.hpp" />
		<ClInclude Include="..\src\pugiconfig.hpp" />
	</ItemGroup>
	<ItemGroup>
		<ClCompile Include="..\src\pugixml.cpp">
		</ClCompile>
	</ItemGroup>
	<Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
	<ImportGroup Label="ExtensionTargets">
	</ImportGroup>
</Project>
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/premake4.lua
-- Reset RNG seed to get consistent results across runs (i.e. XCode)
math.randomseed(12345)

local static = _ARGS[1] == 'static'
local action = premake.action.current()

if string.startswith(_ACTION, "vs") then
	if action then
		-- Disable solution generation
		function action.onsolution(sln)
			sln.vstudio_configs = premake.vstudio_buildconfigs(sln)
		end

		-- Rename output file
		function action.onproject(prj)
            local name = "%%_" .. _ACTION .. (static and "_static" or "")

            if static then
                for k, v in pairs(prj.project.__configs) do
                    v.objectsdir = v.objectsdir .. "Static"
                end
            end

            if _ACTION == "vs2010" then
                premake.generate(prj, name .. ".vcxproj", premake.vs2010_vcxproj)
            else
                premake.generate(prj, name .. ".vcproj", premake.vs200x_vcproj)
            end
		end
	end
elseif _ACTION == "codeblocks" then
	action.onsolution = nil

	function action.onproject(prj)
		premake.generate(prj, "%%_" .. _ACTION .. ".cbp", premake.codeblocks_cbp)
	end
elseif _ACTION == "codelite" then
	action.onsolution = nil

	function action.onproject(prj)
		premake.generate(prj, "%%_" .. _ACTION .. ".project", premake.codelite_project)
	end
end

solution "pugixml"
	objdir(_ACTION)
	targetdir(_ACTION)

if string.startswith(_ACTION, "vs") then
	if _ACTION ~= "vs2002" and _ACTION ~= "vs2003" then
		platforms { "x32", "x64" }

		configuration "x32" targetdir(_ACTION .. "/x32")
		configuration "x64" targetdir(_ACTION .. "/x64")
	end

	configurations { "Debug", "Release" }

    if static then
        configuration "Debug" targetsuffix "sd"
        configuration "Release" targetsuffix "s"
    else
        configuration "Debug" targetsuffix "d"
    end
else
	if _ACTION == "xcode3" then
		platforms "universal"
	end

	configurations { "Debug", "Release" }

	configuration "Debug" targetsuffix "d"
end

project "pugixml"
	kind "StaticLib"
	language "C++"
	files { "../src/pugixml.hpp", "../src/pugiconfig.hpp", "../src/pugixml.cpp" }
	flags { "NoPCH", "NoMinimalRebuild", "NoEditAndContinue", "Symbols" }
	uuid "89A1E353-E2DC-495C-B403-742BE206ACED"

configuration "Debug"
	defines { "_DEBUG" }

configuration "Release"
	defines { "NDEBUG" }
	flags { "Optimize" }

if static then
    configuration "*"
        flags { "StaticRuntime" }
end
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml_vs2005.vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="pugixml"
	ProjectGUID="{89A1E353-E2DC-495C-B403-742BE206ACED}"
	RootNamespace="pugixml"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="vs2005\x32"
			IntermediateDirectory="vs2005\x32\Debug"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="_DEBUG"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				ProgramDataBaseFileName="$(OutDir)\pugixmld.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmld.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="vs2005\x64"
			IntermediateDirectory="vs2005\x64\Debug"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="_DEBUG"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				ProgramDataBaseFileName="$(OutDir)\pugixmld.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmld.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="vs2005\x32"
			IntermediateDirectory="vs2005\x32\Release"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="NDEBUG"
				StringPooling="true"
				RuntimeLibrary="2"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				ProgramDataBaseFileName="$(OutDir)\pugixml.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixml.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="vs2005\x64"
			IntermediateDirectory="vs2005\x64\Release"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="NDEBUG"
				StringPooling="true"
				RuntimeLibrary="2"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				ProgramDataBaseFileName="$(OutDir)\pugixml.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixml.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="src"
			Filter=""
			>
			<File
				RelativePath="..\src\pugixml.hpp"
				>
			</File>
			<File
				RelativePath="..\src\pugiconfig.hpp"
				>
			</File>
			<File
				RelativePath="..\src\pugixml.cpp"
				>
			</File>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/CMakeLists.txt
project(pugixml)

cmake_minimum_required(VERSION 2.6)
set(BUILD_SHARED_LIBS OFF CACHE BOOL "Build shared instead of static library")

if(NOT DEFINED CMAKE_INSTALL_LIBDIR)
    SET(CMAKE_INSTALL_LIBDIR lib CACHE PATH "Output directory for libraries")
endif()

set(HEADERS ../src/pugixml.hpp ../src/pugiconfig.hpp)
set(SOURCES ${HEADERS} ../src/pugixml.cpp)

if(BUILD_SHARED_LIBS)
    add_library(pugixml SHARED ${SOURCES})
else()
    add_library(pugixml STATIC ${SOURCES})
endif()

set_target_properties(pugixml PROPERTIES VERSION 1.4 SOVERSION 1)

install(TARGETS pugixml LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
install(FILES ${HEADERS} DESTINATION include)
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml_vs2008_static.vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9.00"
	Name="pugixml"
	ProjectGUID="{89A1E353-E2DC-495C-B403-742BE206ACED}"
	RootNamespace="pugixml"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="vs2008\x32"
			IntermediateDirectory="vs2008\x32\DebugStatic"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="_DEBUG"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				ProgramDataBaseFileName="$(OutDir)\pugixmlsd.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmlsd.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="vs2008\x64"
			IntermediateDirectory="vs2008\x64\DebugStatic"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="_DEBUG"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				ProgramDataBaseFileName="$(OutDir)\pugixmlsd.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmlsd.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="vs2008\x32"
			IntermediateDirectory="vs2008\x32\ReleaseStatic"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="NDEBUG"
				StringPooling="true"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				ProgramDataBaseFileName="$(OutDir)\pugixmls.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmls.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="vs2008\x64"
			IntermediateDirectory="vs2008\x64\ReleaseStatic"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="NDEBUG"
				StringPooling="true"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				ProgramDataBaseFileName="$(OutDir)\pugixmls.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmls.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="src"
			Filter=""
			>
			<File
				RelativePath="..\src\pugixml.hpp"
				>
			</File>
			<File
				RelativePath="..\src\pugiconfig.hpp"
				>
			</File>
			<File
				RelativePath="..\src\pugixml.cpp"
				>
			</File>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml_vs2010_static.vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<ItemGroup Label="ProjectConfigurations">
		<ProjectConfiguration Include="Debug|Win32">
			<Configuration>Debug</Configuration>
			<Platform>Win32</Platform>
		</ProjectConfiguration>
		<ProjectConfiguration Include="Debug|x64">
			<Configuration>Debug</Configuration>
			<Platform>x64</Platform>
		</ProjectConfiguration>
		<ProjectConfiguration Include="Release|Win32">
			<Configuration>Release</Configuration>
			<Platform>Win32</Platform>
		</ProjectConfiguration>
		<ProjectConfiguration Include="Release|x64">
			<Configuration>Release</Configuration>
			<Platform>x64</Platform>
		</ProjectConfiguration>
	</ItemGroup>
	<PropertyGroup Label="Globals">
		<ProjectGuid>{89A1E353-E2DC-495C-B403-742BE206ACED}</ProjectGuid>
		<RootNamespace>pugixml</RootNamespace>
		<Keyword>Win32Proj</Keyword>
	</PropertyGroup>
	<Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
		<ConfigurationType>StaticLibrary</ConfigurationType>
		<CharacterSet>MultiByte</CharacterSet>
		<UseDebugLibraries>true</UseDebugLibraries>
	</PropertyGroup>
	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
		<ConfigurationType>StaticLibrary</ConfigurationType>
		<CharacterSet>MultiByte</CharacterSet>
		<UseDebugLibraries>true</UseDebugLibraries>
	</PropertyGroup>
	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
		<ConfigurationType>StaticLibrary</ConfigurationType>
		<CharacterSet>MultiByte</CharacterSet>
		<WholeProgramOptimization>true</WholeProgramOptimization>
		<UseDebugLibraries>false</UseDebugLibraries>
	</PropertyGroup>
	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
		<ConfigurationType>StaticLibrary</ConfigurationType>
		<CharacterSet>MultiByte</CharacterSet>
		<WholeProgramOptimization>true</WholeProgramOptimization>
		<UseDebugLibraries>false</UseDebugLibraries>
	</PropertyGroup>
	<Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
	<ImportGroup Label="ExtensionSettings">
	</ImportGroup>
	<ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
		<Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
	</ImportGroup>
	<ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
		<Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
	</ImportGroup>
	<ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
		<Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
	</ImportGroup>
	<ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
		<Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
	</ImportGroup>
	<PropertyGroup Label="UserMacros" />
	<PropertyGroup>
		<_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
		<OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">vs2010\x32\</OutDir>
		<IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">vs2010\x32\DebugStatic\</IntDir>
		<TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">pugixmlsd</TargetName>
		<OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">vs2010\x64\</OutDir>
		<IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">vs2010\x64\DebugStatic\</IntDir>
		<TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pugixmlsd</TargetName>
		<OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">vs2010\x32\</OutDir>
		<IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">vs2010\x32\ReleaseStatic\</IntDir>
		<TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">pugixmls</TargetName>
		<OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">vs2010\x64\</OutDir>
		<IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">vs2010\x64\ReleaseStatic\</IntDir>
		<TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pugixmls</TargetName>
	</PropertyGroup>
	<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
		<ClCompile>
			<Optimization>Disabled</Optimization>
			<PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<MinimalRebuild>false</MinimalRebuild>
			<BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
			<RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
			<FunctionLevelLinking>true</FunctionLevelLinking>
			<PrecompiledHeader></PrecompiledHeader>
			<WarningLevel>Level3</WarningLevel>
			<DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
		</ClCompile>
		<ResourceCompile>
			<PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
		</ResourceCompile>
	<Lib>
		<OutputFile>$(OutDir)pugixmlsd.lib</OutputFile>
	</Lib>
		<Link>
			<SubSystem>Windows</SubSystem>
			<GenerateDebugInformation>true</GenerateDebugInformation>
			<ProgramDataBaseFileName>$(OutDir)pugixmlsd.pdb</ProgramDataBaseFileName>
		</Link>
	</ItemDefinitionGroup>
	<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
		<ClCompile>
			<Optimization>Disabled</Optimization>
			<PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<MinimalRebuild>false</MinimalRebuild>
			<BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
			<RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
			<FunctionLevelLinking>true</FunctionLevelLinking>
			<PrecompiledHeader></PrecompiledHeader>
			<WarningLevel>Level3</WarningLevel>
			<DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
		</ClCompile>
		<ResourceCompile>
			<PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
		</ResourceCompile>
	<Lib>
		<OutputFile>$(OutDir)pugixmlsd.lib</OutputFile>
	</Lib>
		<Link>
			<SubSystem>Windows</SubSystem>
			<GenerateDebugInformation>true</GenerateDebugInformation>
			<ProgramDataBaseFileName>$(OutDir)pugixmlsd.pdb</ProgramDataBaseFileName>
		</Link>
	</ItemDefinitionGroup>
	<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
		<ClCompile>
			<Optimization>Full</Optimization>
			<PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<MinimalRebuild>false</MinimalRebuild>
			<StringPooling>true</StringPooling>
			<RuntimeLibrary>MultiThreaded</RuntimeLibrary>
			<FunctionLevelLinking>true</FunctionLevelLinking>
			<PrecompiledHeader></PrecompiledHeader>
			<WarningLevel>Level3</WarningLevel>
			<DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
		</ClCompile>
		<ResourceCompile>
			<PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
		</ResourceCompile>
	<Lib>
		<OutputFile>$(OutDir)pugixmls.lib</OutputFile>
	</Lib>
		<Link>
			<SubSystem>Windows</SubSystem>
			<GenerateDebugInformation>true</GenerateDebugInformation>
			<OptimizeReferences>true</OptimizeReferences>
			<EnableCOMDATFolding>true</EnableCOMDATFolding>
			<ProgramDataBaseFileName>$(OutDir)pugixmls.pdb</ProgramDataBaseFileName>
		</Link>
	</ItemDefinitionGroup>
	<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
		<ClCompile>
			<Optimization>Full</Optimization>
			<PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<MinimalRebuild>false</MinimalRebuild>
			<StringPooling>true</StringPooling>
			<RuntimeLibrary>MultiThreaded</RuntimeLibrary>
			<FunctionLevelLinking>true</FunctionLevelLinking>
			<PrecompiledHeader></PrecompiledHeader>
			<WarningLevel>Level3</WarningLevel>
			<DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
		</ClCompile>
		<ResourceCompile>
			<PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
		</ResourceCompile>
	<Lib>
		<OutputFile>$(OutDir)pugixmls.lib</OutputFile>
	</Lib>
		<Link>
			<SubSystem>Windows</SubSystem>
			<GenerateDebugInformation>true</GenerateDebugInformation>
			<OptimizeReferences>true</OptimizeReferences>
			<EnableCOMDATFolding>true</EnableCOMDATFolding>
			<ProgramDataBaseFileName>$(OutDir)pugixmls.pdb</ProgramDataBaseFileName>
		</Link>
	</ItemDefinitionGroup>
	<ItemGroup>
		<ClInclude Include="..\src\pugixml.hpp" />
		<ClInclude Include="..\src\pugiconfig.hpp" />
	</ItemGroup>
	<ItemGroup>
		<ClCompile Include="..\src\pugixml.cpp">
		</ClCompile>
	</ItemGroup>
	<Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
	<ImportGroup Label="ExtensionTargets">
	</ImportGroup>
</Project>
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml_airplay.mkf
includepaths
{
"../src"
}

files
{
("../src")
pugiconfig.hpp
pugixml.cpp
pugixml.hpp
}

**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml_vs2008.vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9.00"
	Name="pugixml"
	ProjectGUID="{89A1E353-E2DC-495C-B403-742BE206ACED}"
	RootNamespace="pugixml"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="vs2008\x32"
			IntermediateDirectory="vs2008\x32\Debug"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="_DEBUG"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				ProgramDataBaseFileName="$(OutDir)\pugixmld.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmld.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="vs2008\x64"
			IntermediateDirectory="vs2008\x64\Debug"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="_DEBUG"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				ProgramDataBaseFileName="$(OutDir)\pugixmld.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmld.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="vs2008\x32"
			IntermediateDirectory="vs2008\x32\Release"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="NDEBUG"
				StringPooling="true"
				RuntimeLibrary="2"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				ProgramDataBaseFileName="$(OutDir)\pugixml.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixml.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="vs2008\x64"
			IntermediateDirectory="vs2008\x64\Release"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="NDEBUG"
				StringPooling="true"
				RuntimeLibrary="2"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				ProgramDataBaseFileName="$(OutDir)\pugixml.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixml.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="src"
			Filter=""
			>
			<File
				RelativePath="..\src\pugixml.hpp"
				>
			</File>
			<File
				RelativePath="..\src\pugiconfig.hpp"
				>
			</File>
			<File
				RelativePath="..\src\pugixml.cpp"
				>
			</File>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml_vs2005_static.vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="pugixml"
	ProjectGUID="{89A1E353-E2DC-495C-B403-742BE206ACED}"
	RootNamespace="pugixml"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="vs2005\x32"
			IntermediateDirectory="vs2005\x32\DebugStatic"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="_DEBUG"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				ProgramDataBaseFileName="$(OutDir)\pugixmlsd.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmlsd.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="vs2005\x64"
			IntermediateDirectory="vs2005\x64\DebugStatic"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="_DEBUG"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				ProgramDataBaseFileName="$(OutDir)\pugixmlsd.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmlsd.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="vs2005\x32"
			IntermediateDirectory="vs2005\x32\ReleaseStatic"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="NDEBUG"
				StringPooling="true"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				ProgramDataBaseFileName="$(OutDir)\pugixmls.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmls.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="vs2005\x64"
			IntermediateDirectory="vs2005\x64\ReleaseStatic"
			ConfigurationType="4"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="NDEBUG"
				StringPooling="true"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				ProgramDataBaseFileName="$(OutDir)\pugixmls.pdb"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\pugixmls.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="src"
			Filter=""
			>
			<File
				RelativePath="..\src\pugixml.hpp"
				>
			</File>
			<File
				RelativePath="..\src\pugiconfig.hpp"
				>
			</File>
			<File
				RelativePath="..\src\pugixml.cpp"
				>
			</File>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>
**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml_codeblocks.cbp
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_project_file>
	<FileVersion major="1" minor="6" />
	<Project>
		<Option title="pugixml" />
		<Option pch_mode="2" />
		<Option compiler="gcc" />
		<Build>
			<Target title="Debug">
				<Option output="codeblocks/libpugixmld.a" prefix_auto="0" extension_auto="0" />
				<Option object_output="codeblocks/Debug" />
				<Option type="2" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-g" />
					<Add option="-D_DEBUG" />
				</Compiler>
				<Linker>
				</Linker>
			</Target>
			<Target title="Release">
				<Option output="codeblocks/libpugixml.a" prefix_auto="0" extension_auto="0" />
				<Option object_output="codeblocks/Release" />
				<Option type="2" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-g" />
					<Add option="-O2" />
					<Add option="-DNDEBUG" />
				</Compiler>
				<Linker>
				</Linker>
			</Target>
		</Build>
		<Unit filename="../src/pugixml.hpp">
		</Unit>
		<Unit filename="../src/pugiconfig.hpp">
		</Unit>
		<Unit filename="../src/pugixml.cpp">
		</Unit>
		<Extensions />
	</Project>
</CodeBlocks_project_file>

**************FILE************ ./source/0.9.0.0/infra/pugixml/scripts/pugixml_codelite.project
<?xml version="1.0" encoding="utf-8"?>
<CodeLite_Project Name="pugixml">
  <VirtualDirectory Name="src">
    <File Name="../src/pugixml.hpp"/>
    <File Name="../src/pugiconfig.hpp"/>
    <File Name="../src/pugixml.cpp"/>
  </VirtualDirectory>
  <Settings Type="Static Library">
    <Configuration Name="Debug" CompilerType="gnu g++" DebuggerType="GNU gdb debugger" Type="Static Library">
      <General OutputFile="codelite/libpugixmld.a" IntermediateDirectory="codelite/Debug" Command="./libpugixmld.a" CommandArguments="" WorkingDirectory="codelite" PauseExecWhenProcTerminates="yes"/>
      <Compiler Required="yes" Options="-g">
        <Preprocessor Value="_DEBUG"/>
      </Compiler>
      <Linker Required="yes" Options="">
      </Linker>
      <ResourceCompiler Required="no" Options=""/>
      <CustomBuild Enabled="no">
        <CleanCommand></CleanCommand>
        <BuildCommand></BuildCommand>
        <SingleFileCommand></SingleFileCommand>
        <MakefileGenerationCommand></MakefileGenerationCommand>
        <ThirdPartyToolName>None</ThirdPartyToolName>
        <WorkingDirectory></WorkingDirectory>
      </CustomBuild>
      <AdditionalRules>
        <CustomPostBuild></CustomPostBuild>
        <CustomPreBuild></CustomPreBuild>
      </AdditionalRules>
    </Configuration>
    <Configuration Name="Release" CompilerType="gnu g++" DebuggerType="GNU gdb debugger" Type="Static Library">
      <General OutputFile="codelite/libpugixml.a" IntermediateDirectory="codelite/Release" Command="./libpugixml.a" CommandArguments="" WorkingDirectory="codelite" PauseExecWhenProcTerminates="yes"/>
      <Compiler Required="yes" Options="-g;-O2">
        <Preprocessor Value="NDEBUG"/>
      </Compiler>
      <Linker Required="yes" Options="">
      </Linker>
      <ResourceCompiler Required="no" Options=""/>
      <CustomBuild Enabled="no">
        <CleanCommand></CleanCommand>
        <BuildCommand></BuildCommand>
        <SingleFileCommand></SingleFileCommand>
        <MakefileGenerationCommand></MakefileGenerationCommand>
        <ThirdPartyToolName>None</ThirdPartyToolName>
        <WorkingDirectory></WorkingDirectory>
      </CustomBuild>
      <AdditionalRules>
        <CustomPostBuild></CustomPostBuild>
        <CustomPreBuild></CustomPreBuild>
      </AdditionalRules>
    </Configuration>
  </Settings>
  <Dependencies name="Debug">
  </Dependencies>
  <Dependencies name="Release">
  </Dependencies>
</CodeLite_Project>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/quickstart.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>pugixml 1.4</title>
<link rel="stylesheet" href="pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="quickstart.html" title="pugixml 1.4">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="article">
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="quickstart.main"></a><a class="link" href="quickstart.html#quickstart.main" title="pugixml 1.4 quick start guide">pugixml 1.4 quick start guide</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="quickstart.html#quickstart.main.introduction">Introduction</a></span></dt>
<dt><span class="section"><a href="quickstart.html#quickstart.main.install">Installation</a></span></dt>
<dt><span class="section"><a href="quickstart.html#quickstart.main.dom">Document object model</a></span></dt>
<dt><span class="section"><a href="quickstart.html#quickstart.main.loading">Loading document</a></span></dt>
<dt><span class="section"><a href="quickstart.html#quickstart.main.access">Accessing document data</a></span></dt>
<dt><span class="section"><a href="quickstart.html#quickstart.main.modify">Modifying document data</a></span></dt>
<dt><span class="section"><a href="quickstart.html#quickstart.main.saving">Saving document</a></span></dt>
<dt><span class="section"><a href="quickstart.html#quickstart.main.feedback">Feedback</a></span></dt>
<dt><span class="section"><a href="quickstart.html#quickstart.main.license">License</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="quickstart.main.introduction"></a><a class="link" href="quickstart.html#quickstart.main.introduction" title="Introduction">Introduction</a>
</h3></div></div></div>
<p>
        <a href="http://pugixml.org/" target="_top">pugixml</a> is a light-weight C++ XML
        processing library. It consists of a DOM-like interface with rich traversal/modification
        capabilities, an extremely fast XML parser which constructs the DOM tree
        from an XML file/buffer, and an XPath 1.0 implementation for complex data-driven
        tree queries. Full Unicode support is also available, with Unicode interface
        variants and conversions between different Unicode encodings (which happen
        automatically during parsing/saving). The library is extremely portable and
        easy to integrate and use. pugixml is developed and maintained since 2006
        and has many users. All code is distributed under the <a class="link" href="quickstart.html#quickstart.main.license" title="License">MIT
        license</a>, making it completely free to use in both open-source and
        proprietary applications.
      </p>
<p>
        pugixml enables very fast, convenient and memory-efficient XML document processing.
        However, since pugixml has a DOM parser, it can't process XML documents that
        do not fit in memory; also the parser is a non-validating one, so if you
        need DTD/Schema validation, the library is not for you.
      </p>
<p>
        This is the quick start guide for pugixml, which purpose is to enable you
        to start using the library quickly. Many important library features are either
        not described at all or only mentioned briefly; for more complete information
        you <a href="manual.html" target="_top">should read the complete manual</a>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          No documentation is perfect, neither is this one. If you encounter a description
          that is unclear, please file an issue as described in <a class="xref" href="quickstart.html#quickstart.main.feedback" title="Feedback">Feedback</a>. Also if
          you can spare the time for a full proof-reading, including spelling and
          grammar, that would be great! Please <a class="link" href="quickstart.html#email">send me an e-mail</a>;
          as a token of appreciation, your name will be included into the corresponding
          section of the manual.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="quickstart.main.install"></a><a class="link" href="quickstart.html#quickstart.main.install" title="Installation">Installation</a>
</h3></div></div></div>
<p>
        pugixml is distributed in source form. You can download a source distribution
        via one of the following links:
      </p>
<pre class="programlisting"><a href="https://github.com/zeux/pugixml/releases/download/v1.4/pugixml-1.4.zip" target="_top">https://github.com/zeux/pugixml/releases/download/v1.4/pugixml-1.4.zip</a>
<a href="https://github.com/zeux/pugixml/releases/download/v1.4/pugixml-1.4.tar.gz" target="_top">https://github.com/zeux/pugixml/releases/download/v1.4/pugixml-1.4.tar.gz</a>
</pre>
<p>
        The distribution contains library source, documentation (the guide you're
        reading now and the manual) and some code examples. After downloading the
        distribution, install pugixml by extracting all files from the compressed
        archive. The files have different line endings depending on the archive format
        - <code class="filename">.zip</code> archive has Windows line endings, <code class="filename">.tar.gz</code> archive has Unix line endings.
        Otherwise the files in both archives are identical.
      </p>
<p>
        The complete pugixml source consists of three files - one source file, <code class="filename">pugixml.cpp</code>,
        and two header files, <code class="filename">pugixml.hpp</code> and <code class="filename">pugiconfig.hpp</code>. <code class="filename">pugixml.hpp</code> is the primary
        header which you need to include in order to use pugixml classes/functions.
        The rest of this guide assumes that <code class="filename">pugixml.hpp</code> is either in the current directory
        or in one of include directories of your projects, so that <code class="computeroutput"><span class="preprocessor">#include</span> <span class="string">"pugixml.hpp"</span></code>
        can find the header; however you can also use relative path (i.e. <code class="computeroutput"><span class="preprocessor">#include</span> <span class="string">"../libs/pugixml/src/pugixml.hpp"</span></code>)
        or include directory-relative path (i.e. <code class="computeroutput"><span class="preprocessor">#include</span>
        <span class="special">&lt;</span><span class="identifier">xml</span><span class="special">/</span><span class="identifier">thirdparty</span><span class="special">/</span><span class="identifier">pugixml</span><span class="special">/</span><span class="identifier">src</span><span class="special">/</span><span class="identifier">pugixml</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>).
      </p>
<p>
        The easiest way to build pugixml is to compile the source file, <code class="filename">pugixml.cpp</code>,
        along with the existing library/executable. This process depends on the method
        of building your application; for example, if you're using Microsoft Visual
        Studio<a href="#ftn.trademarks" class="footnote" name="trademarks"><sup class="footnote">[1]</sup></a>,
        Apple Xcode, Code::Blocks or any other IDE, just add <code class="filename">pugixml.cpp</code> to one of
        your projects. There are other building methods available, including building
        pugixml as a standalone static/shared library; <a href="manual/install.html#manual.install.building" target="_top">read
        the manual</a> for further information.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="quickstart.main.dom"></a><a class="link" href="quickstart.html#quickstart.main.dom" title="Document object model">Document object model</a>
</h3></div></div></div>
<p>
        pugixml stores XML data in DOM-like way: the entire XML document (both document
        structure and element data) is stored in memory as a tree. The tree can be
        loaded from character stream (file, string, C++ I/O stream), then traversed
        via special API or XPath expressions. The whole tree is mutable: both node
        structure and node/attribute data can be changed at any time. Finally, the
        result of document transformations can be saved to a character stream (file,
        C++ I/O stream or custom transport).
      </p>
<p>
        The root of the tree is the document itself, which corresponds to C++ type
        <code class="computeroutput"><span class="identifier">xml_document</span></code>. Document has
        one or more child nodes, which correspond to C++ type <code class="computeroutput"><span class="identifier">xml_node</span></code>.
        Nodes have different types; depending on a type, a node can have a collection
        of child nodes, a collection of attributes, which correspond to C++ type
        <code class="computeroutput"><span class="identifier">xml_attribute</span></code>, and some additional
        data (i.e. name).
      </p>
<p>
        The most common node types are:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Document node (<code class="computeroutput"><span class="identifier">node_document</span></code>)
            - this is the root of the tree, which consists of several child nodes.
            This node corresponds to <code class="computeroutput"><span class="identifier">xml_document</span></code>
            class; note that <code class="computeroutput"><span class="identifier">xml_document</span></code>
            is a sub-class of <code class="computeroutput"><span class="identifier">xml_node</span></code>,
            so the entire node interface is also available.
          </li>
<li class="listitem">
            Element/tag node (<code class="computeroutput"><span class="identifier">node_element</span></code>)
            - this is the most common type of node, which represents XML elements.
            Element nodes have a name, a collection of attributes and a collection
            of child nodes (both of which may be empty). The attribute is a simple
            name/value pair.
          </li>
<li class="listitem">
            Plain character data nodes (<code class="computeroutput"><span class="identifier">node_pcdata</span></code>)
            represent plain text in XML. PCDATA nodes have a value, but do not have
            name or children/attributes. Note that <span class="bold"><strong>plain character
            data is not a part of the element node but instead has its own node</strong></span>;
            for example, an element node can have several child PCDATA nodes.
          </li>
</ul></div>
<p>
        Despite the fact that there are several node types, there are only three
        C++ types representing the tree (<code class="computeroutput"><span class="identifier">xml_document</span></code>,
        <code class="computeroutput"><span class="identifier">xml_node</span></code>, <code class="computeroutput"><span class="identifier">xml_attribute</span></code>);
        some operations on <code class="computeroutput"><span class="identifier">xml_node</span></code>
        are only valid for certain node types. They are described below.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          All pugixml classes and functions are located in <code class="computeroutput"><span class="identifier">pugi</span></code>
          namespace; you have to either use explicit name qualification (i.e. <code class="computeroutput"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span></code>), or to gain access to relevant
          symbols via <code class="computeroutput"><span class="keyword">using</span></code> directive
          (i.e. <code class="computeroutput"><span class="keyword">using</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span><span class="special">;</span></code> or <code class="computeroutput"><span class="keyword">using</span>
          <span class="keyword">namespace</span> <span class="identifier">pugi</span><span class="special">;</span></code>).
        </p></td></tr>
</table></div>
<p>
        <code class="computeroutput"><span class="identifier">xml_document</span></code> is the owner
        of the entire document structure; destroying the document destroys the whole
        tree. The interface of <code class="computeroutput"><span class="identifier">xml_document</span></code>
        consists of loading functions, saving functions and the entire interface
        of <code class="computeroutput"><span class="identifier">xml_node</span></code>, which allows
        for document inspection and/or modification. Note that while <code class="computeroutput"><span class="identifier">xml_document</span></code> is a sub-class of <code class="computeroutput"><span class="identifier">xml_node</span></code>, <code class="computeroutput"><span class="identifier">xml_node</span></code>
        is not a polymorphic type; the inheritance is present only to simplify usage.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">xml_node</span></code> is the handle to
        document node; it can point to any node in the document, including document
        itself. There is a common interface for nodes of all types. Note that <code class="computeroutput"><span class="identifier">xml_node</span></code> is only a handle to the actual
        node, not the node itself - you can have several <code class="computeroutput"><span class="identifier">xml_node</span></code>
        handles pointing to the same underlying object. Destroying <code class="computeroutput"><span class="identifier">xml_node</span></code> handle does not destroy the node
        and does not remove it from the tree.
      </p>
<p>
        There is a special value of <code class="computeroutput"><span class="identifier">xml_node</span></code>
        type, known as null node or empty node. It does not correspond to any node
        in any document, and thus resembles null pointer. However, all operations
        are defined on empty nodes; generally the operations don't do anything and
        return empty nodes/attributes or empty strings as their result. This is useful
        for chaining calls; i.e. you can get the grandparent of a node like so:
        <code class="computeroutput"><span class="identifier">node</span><span class="special">.</span><span class="identifier">parent</span><span class="special">().</span><span class="identifier">parent</span><span class="special">()</span></code>;
        if a node is a null node or it does not have a parent, the first <code class="computeroutput"><span class="identifier">parent</span><span class="special">()</span></code>
        call returns null node; the second <code class="computeroutput"><span class="identifier">parent</span><span class="special">()</span></code> call then also returns null node, so you
        don't have to check for errors twice. You can test if a handle is null via
        implicit boolean cast: <code class="computeroutput"><span class="keyword">if</span> <span class="special">(</span><span class="identifier">node</span><span class="special">)</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>
        or <code class="computeroutput"><span class="keyword">if</span> <span class="special">(!</span><span class="identifier">node</span><span class="special">)</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">xml_attribute</span></code> is the handle
        to an XML attribute; it has the same semantics as <code class="computeroutput"><span class="identifier">xml_node</span></code>,
        i.e. there can be several <code class="computeroutput"><span class="identifier">xml_attribute</span></code>
        handles pointing to the same underlying object and there is a special null
        attribute value, which propagates to function results.
      </p>
<p>
        There are two choices of interface and internal representation when configuring
        pugixml: you can either choose the UTF-8 (also called char) interface or
        UTF-16/32 (also called wchar_t) one. The choice is controlled via <code class="computeroutput"><span class="identifier">PUGIXML_WCHAR_MODE</span></code> define; you can set
        it via <code class="filename">pugiconfig.hpp</code> or via preprocessor options. All tree functions that
        work with strings work with either C-style null terminated strings or STL
        strings of the selected character type. <a href="manual/dom.html#manual.dom.unicode" target="_top">Read
        the manual</a> for additional information on Unicode interface.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="quickstart.main.loading"></a><a class="link" href="quickstart.html#quickstart.main.loading" title="Loading document">Loading document</a>
</h3></div></div></div>
<p>
        pugixml provides several functions for loading XML data from various places
        - files, C++ iostreams, memory buffers. All functions use an extremely fast
        non-validating parser. This parser is not fully W3C conformant - it can load
        any valid XML document, but does not perform some well-formedness checks.
        While considerable effort is made to reject invalid XML documents, some validation
        is not performed because of performance reasons. XML data is always converted
        to internal character format before parsing. pugixml supports all popular
        Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and
        little endian); UCS-2 is naturally supported since it's a strict subset of
        UTF-16) and handles all encoding conversions automatically.
      </p>
<p>
        The most common source of XML data is files; pugixml provides a separate
        function for loading XML document from file. This function accepts file path
        as its first argument, and also two optional arguments, which specify parsing
        options and input data encoding, which are described in the manual.
      </p>
<p>
        This is an example of loading XML document from file (<a href="samples/load_file.cpp" target="_top">samples/load_file.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span> <span class="identifier">doc</span><span class="special">;</span>

<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_file</span><span class="special">(</span><span class="string">"tree.xml"</span><span class="special">);</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Load result: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">description</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">", mesh name: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"mesh"</span><span class="special">).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"name"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        <code class="computeroutput"><span class="identifier">load_file</span></code>, as well as other
        loading functions, destroys the existing document tree and then tries to
        load the new tree from the specified file. The result of the operation is
        returned in an <code class="computeroutput"><span class="identifier">xml_parse_result</span></code>
        object; this object contains the operation status, and the related information
        (i.e. last successfully parsed position in the input file, if parsing fails).
      </p>
<p>
        Parsing result object can be implicitly converted to <code class="computeroutput"><span class="keyword">bool</span></code>;
        if you do not want to handle parsing errors thoroughly, you can just check
        the return value of load functions as if it was a <code class="computeroutput"><span class="keyword">bool</span></code>:
        <code class="computeroutput"><span class="keyword">if</span> <span class="special">(</span><span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_file</span><span class="special">(</span><span class="string">"file.xml"</span><span class="special">))</span> <span class="special">{</span> <span class="special">...</span>
        <span class="special">}</span> <span class="keyword">else</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>.
        Otherwise you can use the <code class="computeroutput"><span class="identifier">status</span></code>
        member to get parsing status, or the <code class="computeroutput"><span class="identifier">description</span><span class="special">()</span></code> member function to get the status in a
        string form.
      </p>
<p>
        This is an example of handling loading errors (<a href="samples/load_error_handling.cpp" target="_top">samples/load_error_handling.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span> <span class="identifier">doc</span><span class="special">;</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="identifier">source</span><span class="special">);</span>

<span class="keyword">if</span> <span class="special">(</span><span class="identifier">result</span><span class="special">)</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"XML ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">source</span> <span class="special">&lt;&lt;</span> <span class="string">"] parsed without errors, attr value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"node"</span><span class="special">).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"attr"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n\n"</span><span class="special">;</span>
<span class="keyword">else</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"XML ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">source</span> <span class="special">&lt;&lt;</span> <span class="string">"] parsed with errors, attr value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"node"</span><span class="special">).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"attr"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Error description: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">description</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Error offset: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">offset</span> <span class="special">&lt;&lt;</span> <span class="string">" (error at [..."</span> <span class="special">&lt;&lt;</span> <span class="special">(</span><span class="identifier">source</span> <span class="special">+</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">offset</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        Sometimes XML data should be loaded from some other source than file, i.e.
        HTTP URL; also you may want to load XML data from file using non-standard
        functions, i.e. to use your virtual file system facilities or to load XML
        from gzip-compressed files. These scenarios either require loading document
        from memory, in which case you should prepare a contiguous memory block with
        all XML data and to pass it to one of buffer loading functions, or loading
        document from C++ IOstream, in which case you should provide an object which
        implements <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span></code> or <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">wistream</span></code>
        interface.
      </p>
<p>
        There are different functions for loading document from memory; they treat
        the passed buffer as either an immutable one (<code class="computeroutput"><span class="identifier">load_buffer</span></code>),
        a mutable buffer which is owned by the caller (<code class="computeroutput"><span class="identifier">load_buffer_inplace</span></code>),
        or a mutable buffer which ownership belongs to pugixml (<code class="computeroutput"><span class="identifier">load_buffer_inplace_own</span></code>).
        There is also a simple helper function, <code class="computeroutput"><span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load</span></code>,
        for cases when you want to load the XML document from null-terminated character
        string.
      </p>
<p>
        This is an example of loading XML document from memory using one of these
        functions (<a href="samples/load_memory.cpp" target="_top">samples/load_memory.cpp</a>);
        read the sample code for more examples:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">char</span> <span class="identifier">source</span><span class="special">[]</span> <span class="special">=</span> <span class="string">"&lt;mesh name='sphere'&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;"</span><span class="special">;</span>
<span class="identifier">size_t</span> <span class="identifier">size</span> <span class="special">=</span> <span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">source</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// You can use load_buffer_inplace to load document from mutable memory block; the block's lifetime must exceed that of document</span>
<span class="keyword">char</span><span class="special">*</span> <span class="identifier">buffer</span> <span class="special">=</span> <span class="keyword">new</span> <span class="keyword">char</span><span class="special">[</span><span class="identifier">size</span><span class="special">];</span>
<span class="identifier">memcpy</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">source</span><span class="special">,</span> <span class="identifier">size</span><span class="special">);</span>

<span class="comment">// The block can be allocated by any method; the block is modified during parsing</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_buffer_inplace</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">size</span><span class="special">);</span>

<span class="comment">// You have to destroy the block yourself after the document is no longer used</span>
<span class="keyword">delete</span><span class="special">[]</span> <span class="identifier">buffer</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        This is a simple example of loading XML document from file using streams
        (<a href="samples/load_stream.cpp" target="_top">samples/load_stream.cpp</a>); read
        the sample code for more complex examples involving wide streams and locales:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ifstream</span> <span class="identifier">stream</span><span class="special">(</span><span class="string">"weekly-utf-8.xml"</span><span class="special">);</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="identifier">stream</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="quickstart.main.access"></a><a class="link" href="quickstart.html#quickstart.main.access" title="Accessing document data">Accessing document data</a>
</h3></div></div></div>
<p>
        pugixml features an extensive interface for getting various types of data
        from the document and for traversing the document. You can use various accessors
        to get node/attribute data, you can traverse the child node/attribute lists
        via accessors or iterators, you can do depth-first traversals with <code class="computeroutput"><span class="identifier">xml_tree_walker</span></code> objects, and you can use
        XPath for complex data-driven queries.
      </p>
<p>
        You can get node or attribute name via <code class="computeroutput"><span class="identifier">name</span><span class="special">()</span></code> accessor, and value via <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code> accessor. Note that both functions never
        return null pointers - they either return a string with the relevant content,
        or an empty string if name/value is absent or if the handle is null. Also
        there are two notable things for reading values:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            It is common to store data as text contents of some node - i.e. <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;&lt;</span><span class="identifier">description</span><span class="special">&gt;</span><span class="identifier">This</span>
            <span class="identifier">is</span> <span class="identifier">a</span>
            <span class="identifier">node</span><span class="special">&lt;/</span><span class="identifier">description</span><span class="special">&gt;&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span></code>.
            In this case, <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">description</span><span class="special">&gt;</span></code> node does not have a value, but instead
            has a child of type <code class="computeroutput"><span class="identifier">node_pcdata</span></code>
            with value <code class="computeroutput"><span class="string">"This is a node"</span></code>.
            pugixml provides <code class="computeroutput"><span class="identifier">child_value</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">text</span><span class="special">()</span></code> helper functions to parse such data.
          </li>
<li class="listitem">
            In many cases attribute values have types that are not strings - i.e.
            an attribute may always contain values that should be treated as integers,
            despite the fact that they are represented as strings in XML. pugixml
            provides several accessors that convert attribute value to some other
            type.
          </li>
</ul></div>
<p>
        This is an example of using these functions (<a href="samples/traverse_base.cpp" target="_top">samples/traverse_base.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">);</span> <span class="identifier">tool</span><span class="special">;</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">))</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool "</span> <span class="special">&lt;&lt;</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">": AllowRemote "</span> <span class="special">&lt;&lt;</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"AllowRemote"</span><span class="special">).</span><span class="identifier">as_bool</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", Timeout "</span> <span class="special">&lt;&lt;</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Timeout"</span><span class="special">).</span><span class="identifier">as_int</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", Description '"</span> <span class="special">&lt;&lt;</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">child_value</span><span class="special">(</span><span class="string">"Description"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"'\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        Since a lot of document traversal consists of finding the node/attribute
        with the correct name, there are special functions for that purpose. For
        example, <code class="computeroutput"><span class="identifier">child</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">)</span></code>
        returns the first node which has the name <code class="computeroutput"><span class="string">"Tool"</span></code>,
        or null handle if there is no such node. This is an example of using such
        functions (<a href="samples/traverse_base.cpp" target="_top">samples/traverse_base.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool for *.dae generation: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">find_child_by_attribute</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">,</span> <span class="string">"OutputFileMasks"</span><span class="special">,</span> <span class="string">"*.dae"</span><span class="special">).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>

<span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">);</span> <span class="identifier">tool</span><span class="special">;</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">))</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool "</span> <span class="special">&lt;&lt;</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        Child node lists and attribute lists are simply double-linked lists; while
        you can use <code class="computeroutput"><span class="identifier">previous_sibling</span></code>/<code class="computeroutput"><span class="identifier">next_sibling</span></code> and other such functions for
        iteration, pugixml additionally provides node and attribute iterators, so
        that you can treat nodes as containers of other nodes or attributes. All
        iterators are bidirectional and support all usual iterator operations. The
        iterators are invalidated if the node/attribute objects they're pointing
        to are removed from the tree; adding nodes/attributes does not invalidate
        any iterators.
      </p>
<p>
        Here is an example of using iterators for document traversal (<a href="samples/traverse_iter.cpp" target="_top">samples/traverse_iter.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node_iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">it</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool:"</span><span class="special">;</span>

    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_attribute_iterator</span> <span class="identifier">ait</span> <span class="special">=</span> <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">attributes_begin</span><span class="special">();</span> <span class="identifier">ait</span> <span class="special">!=</span> <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">attributes_end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">ait</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ait</span><span class="special">-&gt;</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"="</span> <span class="special">&lt;&lt;</span> <span class="identifier">ait</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        If your C++ compiler supports range-based for-loop (this is a C++11 feature,
        at the time of writing it's supported by Microsoft Visual Studio 11 Beta,
        GCC 4.6 and Clang 3.0), you can use it to enumerate nodes/attributes. Additional
        helpers are provided to support this; note that they are also compatible
        with <a href="http://www.boost.org/libs/foreach/" target="_top">Boost Foreach</a>,
        and possibly other pre-C++11 foreach facilities.
      </p>
<p>
        Here is an example of using C++11 range-based for loop for document traversal
        (<a href="samples/traverse_rangefor.cpp" target="_top">samples/traverse_rangefor.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">tool</span><span class="special">:</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">children</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">))</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool:"</span><span class="special">;</span>

    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_attribute</span> <span class="identifier">attr</span><span class="special">:</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">attributes</span><span class="special">())</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"="</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">value</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">child</span><span class="special">:</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">children</span><span class="special">())</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", child "</span> <span class="special">&lt;&lt;</span> <span class="identifier">child</span><span class="special">.</span><span class="identifier">name</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        The methods described above allow traversal of immediate children of some
        node; if you want to do a deep tree traversal, you'll have to do it via a
        recursive function or some equivalent method. However, pugixml provides a
        helper for depth-first traversal of a subtree. In order to use it, you have
        to implement <code class="computeroutput"><span class="identifier">xml_tree_walker</span></code>
        interface and to call <code class="computeroutput"><span class="identifier">traverse</span></code>
        function.
      </p>
<p>
        This is an example of traversing tree hierarchy with xml_tree_walker (<a href="samples/traverse_walker.cpp" target="_top">samples/traverse_walker.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">simple_walker</span><span class="special">:</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_tree_walker</span>
<span class="special">{</span>
    <span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="identifier">for_each</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">depth</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"  "</span><span class="special">;</span> <span class="comment">// indentation</span>

        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">node_types</span><span class="special">[</span><span class="identifier">node</span><span class="special">.</span><span class="identifier">type</span><span class="special">()]</span> <span class="special">&lt;&lt;</span> <span class="string">": name='"</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"', value='"</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"'\n"</span><span class="special">;</span>

        <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span> <span class="comment">// continue traversal</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">simple_walker</span> <span class="identifier">walker</span><span class="special">;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">traverse</span><span class="special">(</span><span class="identifier">walker</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Finally, for complex queries often a higher-level DSL is needed. pugixml
        provides an implementation of XPath 1.0 language for such queries. The complete
        description of XPath usage can be found in the manual, but here are some
        examples:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node_set</span> <span class="identifier">tools</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">select_nodes</span><span class="special">(</span><span class="string">"/Profile/Tools/Tool[@AllowRemote='true' and @DeriveCaptionFrom='lastparam']"</span><span class="special">);</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tools:\n"</span><span class="special">;</span>

<span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">it</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node</span> <span class="identifier">node</span> <span class="special">=</span> <span class="special">*</span><span class="identifier">it</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">node</span><span class="special">().</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node</span> <span class="identifier">build_tool</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">select_single_node</span><span class="special">(</span><span class="string">"//Tool[contains(Description, 'build system')]"</span><span class="special">);</span>

<span class="keyword">if</span> <span class="special">(</span><span class="identifier">build_tool</span><span class="special">)</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Build tool: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">build_tool</span><span class="special">.</span><span class="identifier">node</span><span class="special">().</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
</pre>
<p>
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          XPath functions throw <code class="computeroutput"><span class="identifier">xpath_exception</span></code>
          objects on error; the sample above does not catch these exceptions.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="quickstart.main.modify"></a><a class="link" href="quickstart.html#quickstart.main.modify" title="Modifying document data">Modifying document data</a>
</h3></div></div></div>
<p>
        The document in pugixml is fully mutable: you can completely change the document
        structure and modify the data of nodes/attributes. All functions take care
        of memory management and structural integrity themselves, so they always
        result in structurally valid tree - however, it is possible to create an
        invalid XML tree (for example, by adding two attributes with the same name
        or by setting attribute/node name to empty/invalid string). Tree modification
        is optimized for performance and for memory consumption, so if you have enough
        memory you can create documents from scratch with pugixml and later save
        them to file/stream instead of relying on error-prone manual text writing
        and without too much overhead.
      </p>
<p>
        All member functions that change node/attribute data or structure are non-constant
        and thus can not be called on constant handles. However, you can easily convert
        constant handle to non-constant one by simple assignment: <code class="computeroutput"><span class="keyword">void</span>
        <span class="identifier">foo</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">nc</span> <span class="special">=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">}</span></code>, so const-correctness
        here mainly provides additional documentation.
      </p>
<p>
        As discussed before, nodes can have name and value, both of which are strings.
        Depending on node type, name or value may be absent. You can use <code class="computeroutput"><span class="identifier">set_name</span></code> and <code class="computeroutput"><span class="identifier">set_value</span></code>
        member functions to set them. Similar functions are available for attributes;
        however, the <code class="computeroutput"><span class="identifier">set_value</span></code> function
        is overloaded for some other types except strings, like floating-point numbers.
        Also, attribute value can be set using an assignment operator. This is an
        example of setting node/attribute name and value (<a href="samples/modify_base.cpp" target="_top">samples/modify_base.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"node"</span><span class="special">);</span>

<span class="comment">// change node name</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">set_name</span><span class="special">(</span><span class="string">"notnode"</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", new node name: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// change comment text</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">last_child</span><span class="special">().</span><span class="identifier">set_value</span><span class="special">(</span><span class="string">"useless comment"</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", new comment text: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">last_child</span><span class="special">().</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// we can't change value of the element or name of the comment</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span><span class="string">"1"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">last_child</span><span class="special">().</span><span class="identifier">set_name</span><span class="special">(</span><span class="string">"2"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_attribute</span> <span class="identifier">attr</span> <span class="special">=</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"id"</span><span class="special">);</span>

<span class="comment">// change attribute name/value</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">set_name</span><span class="special">(</span><span class="string">"key"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span><span class="string">"345"</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", new attribute: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"="</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// we can use numbers or booleans</span>
<span class="identifier">attr</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span><span class="number">1.234</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"new attribute value: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// we can also use assignment operators for more concise code</span>
<span class="identifier">attr</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"final attribute value: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        Nodes and attributes do not exist without a document tree, so you can't create
        them without adding them to some document. A node or attribute can be created
        at the end of node/attribute list or before/after some other node. All insertion
        functions return the handle to newly created object on success, and null
        handle on failure. Even if the operation fails (for example, if you're trying
        to add a child node to PCDATA node), the document remains in consistent state,
        but the requested node/attribute is not added.
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          attribute() and child() functions do not add attributes or nodes to the
          tree, so code like <code class="computeroutput"><span class="identifier">node</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"id"</span><span class="special">)</span> <span class="special">=</span> <span class="number">123</span><span class="special">;</span></code> will not do anything if <code class="computeroutput"><span class="identifier">node</span></code> does not have an attribute with
          name <code class="computeroutput"><span class="string">"id"</span></code>. Make sure
          you're operating with existing attributes/nodes by adding them if necessary.
        </p></td></tr>
</table></div>
<p>
        This is an example of adding new attributes/nodes to the document (<a href="samples/modify_add.cpp" target="_top">samples/modify_add.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// add node with some name</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">append_child</span><span class="special">(</span><span class="string">"node"</span><span class="special">);</span>

<span class="comment">// add description node with text child</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">descr</span> <span class="special">=</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">append_child</span><span class="special">(</span><span class="string">"description"</span><span class="special">);</span>
<span class="identifier">descr</span><span class="special">.</span><span class="identifier">append_child</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">node_pcdata</span><span class="special">).</span><span class="identifier">set_value</span><span class="special">(</span><span class="string">"Simple node"</span><span class="special">);</span>

<span class="comment">// add param node before the description</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">param</span> <span class="special">=</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">insert_child_before</span><span class="special">(</span><span class="string">"param"</span><span class="special">,</span> <span class="identifier">descr</span><span class="special">);</span>

<span class="comment">// add attributes to param node</span>
<span class="identifier">param</span><span class="special">.</span><span class="identifier">append_attribute</span><span class="special">(</span><span class="string">"name"</span><span class="special">)</span> <span class="special">=</span> <span class="string">"version"</span><span class="special">;</span>
<span class="identifier">param</span><span class="special">.</span><span class="identifier">append_attribute</span><span class="special">(</span><span class="string">"value"</span><span class="special">)</span> <span class="special">=</span> <span class="number">1.1</span><span class="special">;</span>
<span class="identifier">param</span><span class="special">.</span><span class="identifier">insert_attribute_after</span><span class="special">(</span><span class="string">"type"</span><span class="special">,</span> <span class="identifier">param</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"name"</span><span class="special">))</span> <span class="special">=</span> <span class="string">"float"</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        If you do not want your document to contain some node or attribute, you can
        remove it with <code class="computeroutput"><span class="identifier">remove_attribute</span></code>
        and <code class="computeroutput"><span class="identifier">remove_child</span></code> functions.
        Removing the attribute or node invalidates all handles to the same underlying
        object, and also invalidates all iterators pointing to the same object. Removing
        node also invalidates all past-the-end iterators to its attribute or child
        node list. Be careful to ensure that all such handles and iterators either
        do not exist or are not used after the attribute/node is removed.
      </p>
<p>
        This is an example of removing attributes/nodes from the document (<a href="samples/modify_remove.cpp" target="_top">samples/modify_remove.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// remove description node with the whole subtree</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"node"</span><span class="special">);</span>
<span class="identifier">node</span><span class="special">.</span><span class="identifier">remove_child</span><span class="special">(</span><span class="string">"description"</span><span class="special">);</span>

<span class="comment">// remove id attribute</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">param</span> <span class="special">=</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"param"</span><span class="special">);</span>
<span class="identifier">param</span><span class="special">.</span><span class="identifier">remove_attribute</span><span class="special">(</span><span class="string">"value"</span><span class="special">);</span>

<span class="comment">// we can also remove nodes/attributes by handles</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_attribute</span> <span class="identifier">id</span> <span class="special">=</span> <span class="identifier">param</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"name"</span><span class="special">);</span>
<span class="identifier">param</span><span class="special">.</span><span class="identifier">remove_attribute</span><span class="special">(</span><span class="identifier">id</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="quickstart.main.saving"></a><a class="link" href="quickstart.html#quickstart.main.saving" title="Saving document">Saving document</a>
</h3></div></div></div>
<p>
        Often after creating a new document or loading the existing one and processing
        it, it is necessary to save the result back to file. Also it is occasionally
        useful to output the whole document or a subtree to some stream; use cases
        include debug printing, serialization via network or other text-oriented
        medium, etc. pugixml provides several functions to output any subtree of
        the document to a file, stream or another generic transport interface; these
        functions allow to customize the output format, and also perform necessary
        encoding conversions.
      </p>
<p>
        Before writing to the destination the node/attribute data is properly formatted
        according to the node type; all special XML symbols, such as &lt; and &amp;,
        are properly escaped. In order to guard against forgotten node/attribute
        names, empty node/attribute names are printed as <code class="computeroutput"><span class="string">":anonymous"</span></code>.
        For well-formed output, make sure all node and attribute names are set to
        meaningful values.
      </p>
<p>
        If you want to save the whole document to a file, you can use the <code class="computeroutput"><span class="identifier">save_file</span></code> function, which returns <code class="computeroutput"><span class="keyword">true</span></code> on success. This is a simple example
        of saving XML document to file (<a href="samples/save_file.cpp" target="_top">samples/save_file.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// save document to file</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Saving result: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">save_file</span><span class="special">(</span><span class="string">"save_file_output.xml"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        To enhance interoperability pugixml provides functions for saving document
        to any object which implements C++ <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span></code>
        interface. This allows you to save documents to any standard C++ stream (i.e.
        file stream) or any third-party compliant implementation (i.e. Boost Iostreams).
        Most notably, this allows for easy debug output, since you can use <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span></code>
        stream as saving target. There are two functions, one works with narrow character
        streams, another handles wide character ones.
      </p>
<p>
        This is a simple example of saving XML document to standard output (<a href="samples/save_stream.cpp" target="_top">samples/save_stream.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// save document to standard output</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Document:\n"</span><span class="special">;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        All of the above saving functions are implemented in terms of writer interface.
        This is a simple interface with a single function, which is called several
        times during output process with chunks of document data as input. In order
        to output the document via some custom transport, for example sockets, you
        should create an object which implements <code class="computeroutput"><span class="identifier">xml_writer_file</span></code>
        interface and pass it to <code class="computeroutput"><span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">save</span></code>
        function.
      </p>
<p>
        This is a simple example of custom writer for saving document data to STL
        string (<a href="samples/save_custom_writer.cpp" target="_top">samples/save_custom_writer.cpp</a>);
        read the sample code for more complex examples:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">xml_string_writer</span><span class="special">:</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_writer</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">result</span><span class="special">;</span>

    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">write</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">void</span><span class="special">*</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">result</span> <span class="special">+=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*&gt;(</span><span class="identifier">data</span><span class="special">),</span> <span class="identifier">size</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        While the previously described functions save the whole document to the destination,
        it is easy to save a single subtree. Instead of calling <code class="computeroutput"><span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">save</span></code>,
        just call <code class="computeroutput"><span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">print</span></code> function on the target node. You
        can save node contents to C++ IOstream object or custom writer in this way.
        Saving a subtree slightly differs from saving the whole document; <a href="manual/saving.html#manual.saving.subtree" target="_top">read the manual</a> for
        more information.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="quickstart.main.feedback"></a><a class="link" href="quickstart.html#quickstart.main.feedback" title="Feedback">Feedback</a>
</h3></div></div></div>
<p>
        If you believe you've found a bug in pugixml, please file an issue via <a href="http://code.google.com/p/pugixml/issues/entry" target="_top">issue submission form</a>.
        Be sure to include the relevant information so that the bug can be reproduced:
        the version of pugixml, compiler version and target architecture, the code
        that uses pugixml and exhibits the bug, etc. Feature requests and contributions
        can be filed as issues, too.
      </p>
<p>
        <a name="email"></a>If filing an issue is not possible due to privacy or
        other concerns, you can contact pugixml author by e-mail directly: <a href="mailto:arseny.kapoulkine@gmail.com" target="_top">arseny.kapoulkine@gmail.com</a>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="quickstart.main.license"></a><a class="link" href="quickstart.html#quickstart.main.license" title="License">License</a>
</h3></div></div></div>
<p>
        The pugixml library is distributed under the MIT license:
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          Copyright (c) 2006-2014 Arseny Kapoulkine
        </p>
<p>
          Permission is hereby granted, free of charge, to any person obtaining a
          copy of this software and associated documentation files (the "Software"),
          to deal in the Software without restriction, including without limitation
          the rights to use, copy, modify, merge, publish, distribute, sublicense,
          and/or sell copies of the Software, and to permit persons to whom the Software
          is furnished to do so, subject to the following conditions:
        </p>
<p>
          The above copyright notice and this permission notice shall be included
          in all copies or substantial portions of the Software.
        </p>
<p>
          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
          EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
          THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
          LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
          FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
          IN THE SOFTWARE.
        </p>
</blockquote></div>
<p>
        This means that you can freely use pugixml in your applications, both open-source
        and proprietary. If you use pugixml in a product, it is sufficient to add
        an acknowledgment like this to the product distribution:
      </p>
<div class="blockquote"><blockquote class="blockquote"><p>
          This software is based on pugixml library (http://pugixml.org).<br>
pugixml
          is Copyright (C) 2006-2014 Arseny Kapoulkine.
        </p></blockquote></div>
</div>
</div>
<div class="footnotes">
<br><hr style="width:100; text-align:left;margin-left: 0">
<div id="ftn.trademarks" class="footnote"><p><a href="#trademarks" class="para"><sup class="para">[1] </sup></a>All trademarks used are properties of their respective owners.</p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"><p><small>Last revised: February 28, 2014 at 03:52:54 GMT</small></p></td>
<td align="right"><div class="copyright-footer"></div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>pugixml 1.4</title>
<link rel="stylesheet" href="pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="manual.html" title="pugixml 1.4">
<link rel="next" href="manual/install.html" title="Installation">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<b>Overview</b> |
		<a href="manual/install.html">Installation</a> |
		Document:
		<a href="manual/dom.html">Object model</a> &middot; <a href="manual/loading.html">Loading</a> &middot; <a href="manual/access.html">Accessing</a> &middot; <a href="manual/modify.html">Modifying</a> &middot; <a href="manual/saving.html">Saving</a> |
		<a href="manual/xpath.html">XPath</a> |
		<a href="manual/apiref.html">API Reference</a> |
		<a href="manual/toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav"><a accesskey="n" href="manual/install.html"><img src="images/next.png" alt="Next"></a></div></td>
</tr></table>
<hr>
<div class="book"><div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.overview"></a><a class="link" href="manual.html#manual.overview" title="Overview">Overview</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="manual.html#manual.overview.introduction">Introduction</a></span></dt>
<dt><span class="section"><a href="manual.html#manual.overview.feedback">Feedback</a></span></dt>
<dt><span class="section"><a href="manual.html#manual.overview.thanks">Acknowledgments</a></span></dt>
<dt><span class="section"><a href="manual.html#manual.overview.license">License</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.overview.introduction"></a><a class="link" href="manual.html#manual.overview.introduction" title="Introduction">Introduction</a>
</h3></div></div></div>
<p>
        <a href="http://pugixml.org/" target="_top">pugixml</a> is a light-weight C++ XML
        processing library. It consists of a DOM-like interface with rich traversal/modification
        capabilities, an extremely fast XML parser which constructs the DOM tree
        from an XML file/buffer, and an <a class="link" href="manual/xpath.html" title="XPath">XPath 1.0 implementation</a>
        for complex data-driven tree queries. Full Unicode support is also available,
        with <a class="link" href="manual/dom.html#manual.dom.unicode" title="Unicode interface">two Unicode interface variants</a>
        and conversions between different Unicode encodings (which happen automatically
        during parsing/saving). The library is <a class="link" href="manual/install.html#manual.install.portability" title="Portability">extremely
        portable</a> and easy to integrate and use. pugixml is developed and maintained
        since 2006 and has many users. All code is distributed under the <a class="link" href="manual.html#manual.overview.license" title="License">MIT
        license</a>, making it completely free to use in both open-source and
        proprietary applications.
      </p>
<p>
        pugixml enables very fast, convenient and memory-efficient XML document processing.
        However, since pugixml has a DOM parser, it can't process XML documents that
        do not fit in memory; also the parser is a non-validating one, so if you
        need DTD or XML Schema validation, the library is not for you.
      </p>
<p>
        This is the complete manual for pugixml, which describes all features of
        the library in detail. If you want to start writing code as quickly as possible,
        you are advised to <a href="quickstart.html" target="_top">read the quick start guide
        first</a>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          No documentation is perfect, neither is this one. If you encounter a description
          that is unclear, please file an issue as described in <a class="xref" href="manual.html#manual.overview.feedback" title="Feedback">Feedback</a>.
          Also if you can spare the time for a full proof-reading, including spelling
          and grammar, that would be great! Please <a class="link" href="manual.html#email">send me
          an e-mail</a>; as a token of appreciation, your name will be included
          into the <a class="link" href="manual.html#manual.overview.thanks" title="Acknowledgments">corresponding section</a>
          of this documentation.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.overview.feedback"></a><a class="link" href="manual.html#manual.overview.feedback" title="Feedback">Feedback</a>
</h3></div></div></div>
<p>
        If you believe you've found a bug in pugixml (bugs include compilation problems
        (errors/warnings), crashes, performance degradation and incorrect behavior),
        please file an issue via <a href="http://code.google.com/p/pugixml/issues/entry" target="_top">issue
        submission form</a>. Be sure to include the relevant information so that
        the bug can be reproduced: the version of pugixml, compiler version and target
        architecture, the code that uses pugixml and exhibits the bug, etc.
      </p>
<p>
        Feature requests can be reported the same way as bugs, so if you're missing
        some functionality in pugixml or if the API is rough in some places and you
        can suggest an improvement, <a href="http://code.google.com/p/pugixml/issues/entry?template=Feature%20request" target="_top">file
        an issue</a>. However please note that there are many factors when considering
        API changes (compatibility with previous versions, API redundancy, etc.),
        so generally features that can be implemented via a small function without
        pugixml modification are not accepted. However, all rules have exceptions.
      </p>
<p>
        If you have a contribution to pugixml, such as build script for some build
        system/IDE, or a well-designed set of helper functions, or a binding to some
        language other than C++, please <a href="http://code.google.com/p/pugixml/issues/entry?template=Feature%20request" target="_top">file
        an issue</a>. You can include the relevant patches as issue attachments.
        Your contribution has to be distributed under the terms of a license that's
        compatible with pugixml license; i.e. GPL/LGPL licensed code is not accepted.
      </p>
<p>
        <a name="email"></a>If filing an issue is not possible due to privacy or
        other concerns, you can contact pugixml author by e-mail directly: <a href="mailto:arseny.kapoulkine@gmail.com" target="_top">arseny.kapoulkine@gmail.com</a>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.overview.thanks"></a><a class="link" href="manual.html#manual.overview.thanks" title="Acknowledgments">Acknowledgments</a>
</h3></div></div></div>
<p>
        pugixml could not be developed without the help from many people; some of
        them are listed in this section. If you've played a part in pugixml development
        and you can not find yourself on this list, I'm truly sorry; please <a class="link" href="manual.html#email">send me an e-mail</a> so I can fix this.
      </p>
<p>
        Thanks to <span class="bold"><strong>Kristen Wegner</strong></span> for pugxml parser,
        which was used as a basis for pugixml.
      </p>
<p>
        Thanks to <span class="bold"><strong>Neville Franks</strong></span> for contributions
        to pugxml parser.
      </p>
<p>
        Thanks to <span class="bold"><strong>Artyom Palvelev</strong></span> for suggesting
        a lazy gap contraction approach.
      </p>
<p>
        Thanks to <span class="bold"><strong>Vyacheslav Egorov</strong></span> for documentation
        proofreading.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.overview.license"></a><a class="link" href="manual.html#manual.overview.license" title="License">License</a>
</h3></div></div></div>
<p>
        The pugixml library is distributed under the MIT license:
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          Copyright (c) 2006-2014 Arseny Kapoulkine
        </p>
<p>
          Permission is hereby granted, free of charge, to any person obtaining a
          copy of this software and associated documentation files (the "Software"),
          to deal in the Software without restriction, including without limitation
          the rights to use, copy, modify, merge, publish, distribute, sublicense,
          and/or sell copies of the Software, and to permit persons to whom the Software
          is furnished to do so, subject to the following conditions:
        </p>
<p>
          The above copyright notice and this permission notice shall be included
          in all copies or substantial portions of the Software.
        </p>
<p>
          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
          EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
          THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
          LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
          FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
          IN THE SOFTWARE.
        </p>
</blockquote></div>
<p>
        This means that you can freely use pugixml in your applications, both open-source
        and proprietary. If you use pugixml in a product, it is sufficient to add
        an acknowledgment like this to the product distribution:
      </p>
<div class="blockquote"><blockquote class="blockquote"><p>
          This software is based on pugixml library (http://pugixml.org).<br>
pugixml
          is Copyright (C) 2006-2014 Arseny Kapoulkine.
        </p></blockquote></div>
</div>
</div></div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"><p><small>Last revised: February 28, 2014 at 06:00:02 GMT</small></p></td>
<td align="right"><div class="copyright-footer"></div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<b>Overview</b> |
		<a href="manual/install.html">Installation</a> |
		Document:
		<a href="manual/dom.html">Object model</a> &middot; <a href="manual/loading.html">Loading</a> &middot; <a href="manual/access.html">Accessing</a> &middot; <a href="manual/modify.html">Modifying</a> &middot; <a href="manual/saving.html">Saving</a> |
		<a href="manual/xpath.html">XPath</a> |
		<a href="manual/apiref.html">API Reference</a> |
		<a href="manual/toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav"><a accesskey="n" href="manual/install.html"><img src="images/next.png" alt="Next"></a></div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual/install.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Installation</title>
<link rel="stylesheet" href="../pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../manual.html" title="pugixml 1.4">
<link rel="up" href="../manual.html" title="pugixml 1.4">
<link rel="prev" href="../manual.html" title="pugixml 1.4">
<link rel="next" href="dom.html" title="Document object model">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<b>Installation</b> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="../manual.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="dom.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
<hr>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.install"></a><a class="link" href="install.html" title="Installation">Installation</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="install.html#manual.install.getting">Getting pugixml</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="install.html#manual.install.getting.source">Source distributions</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.getting.subversion">Subversion repository</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.getting.git">Git repository</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="install.html#manual.install.building">Building pugixml</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="install.html#manual.install.building.embed">Building pugixml as
        a part of another static library/executable</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.building.static">Building pugixml as
        a standalone static library</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.building.shared">Building pugixml as
        a standalone shared library</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.building.header">Using
        pugixml in header-only mode</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.building.config">Additional configuration
        options</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="install.html#manual.install.portability">Portability</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.install.getting"></a><a class="link" href="install.html#manual.install.getting" title="Getting pugixml">Getting pugixml</a>
</h3></div></div></div>
<p>
        pugixml is distributed in source form. You can either download a source distribution
        or checkout the Subversion repository.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.install.getting.source"></a><a class="link" href="install.html#manual.install.getting.source" title="Source distributions">Source distributions</a>
</h4></div></div></div>
<p>
          You can download the latest source distribution via one of the following
          links:
        </p>
<pre class="programlisting"><a href="https://github.com/zeux/pugixml/releases/download/v1.4/pugixml-1.4.zip" target="_top">https://github.com/zeux/pugixml/releases/download/v1.4/pugixml-1.4.zip</a>
<a href="https://github.com/zeux/pugixml/releases/download/v1.4/pugixml-1.4.tar.gz" target="_top">https://github.com/zeux/pugixml/releases/download/v1.4/pugixml-1.4.tar.gz</a>
</pre>
<p>
          The distribution contains library source, documentation (the manual you're
          reading now and the quick start guide) and some code examples. After downloading
          the distribution, install pugixml by extracting all files from the compressed
          archive. The files have different line endings depending on the archive
          format - <code class="filename">.zip</code> archive has Windows line endings, <code class="filename">.tar.gz</code> archive has Unix
          line endings. Otherwise the files in both archives are identical.
        </p>
<p>
          If you need an older version, you can download it from the <a href="http://code.google.com/p/pugixml/downloads/list" target="_top">version
          archive</a>.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.install.getting.subversion"></a><a class="link" href="install.html#manual.install.getting.subversion" title="Subversion repository">Subversion repository</a>
</h4></div></div></div>
<p>
          The Subversion repository is located at <a href="http://pugixml.googlecode.com/svn/" target="_top">http://pugixml.googlecode.com/svn/</a>.
          There is a Subversion tag "release-{version}" for each version;
          also there is the "latest" tag, which always points to the latest
          stable release.
        </p>
<p>
          For example, to checkout the current version, you can use this command:
        </p>
<pre class="programlisting">svn checkout http://pugixml.googlecode.com/svn/tags/release-1.4 pugixml</pre>
<p>
          To checkout the latest version, you can use this command:
        </p>
<pre class="programlisting">svn checkout http://pugixml.googlecode.com/svn/tags/latest pugixml</pre>
<p>
          The repository contains library source, documentation, code examples and
          full unit test suite.
        </p>
<p>
          Use latest version tag if you want to automatically get new versions via
          <code class="literal">svn update</code>. Use other tags if you want to switch to
          new versions only explicitly (for example, using <code class="literal">svn switch</code>
          command). Also please note that Subversion trunk contains the work-in-progress
          version of the code; while this means that you can get new features and
          bug fixes from trunk without waiting for a new release, this also means
          that occasionally the code can be broken in some configurations.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.install.getting.git"></a><a class="link" href="install.html#manual.install.getting.git" title="Git repository">Git repository</a>
</h4></div></div></div>
<p>
          The Subversion repository is mirrored by a Git repository at <a href="https://github.com/zeux/pugixml" target="_top">https://github.com/zeux/pugixml</a>.
          The mirror is frequently updated and has the same structure in terms of
          tags and contents as Subversion repository.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.install.building"></a><a class="link" href="install.html#manual.install.building" title="Building pugixml">Building pugixml</a>
</h3></div></div></div>
<p>
        pugixml is distributed in source form without any pre-built binaries; you
        have to build them yourself.
      </p>
<p>
        The complete pugixml source consists of three files - one source file, <code class="filename">pugixml.cpp</code>,
        and two header files, <code class="filename">pugixml.hpp</code> and <code class="filename">pugiconfig.hpp</code>. <code class="filename">pugixml.hpp</code> is the primary
        header which you need to include in order to use pugixml classes/functions;
        <code class="filename">pugiconfig.hpp</code> is a supplementary configuration file (see <a class="xref" href="install.html#manual.install.building.config" title="Additional configuration options">Additional configuration
        options</a>).
        The rest of this guide assumes that <code class="filename">pugixml.hpp</code> is either in the current directory
        or in one of include directories of your projects, so that <code class="computeroutput"><span class="preprocessor">#include</span> <span class="string">"pugixml.hpp"</span></code>
        can find the header; however you can also use relative path (i.e. <code class="computeroutput"><span class="preprocessor">#include</span> <span class="string">"../libs/pugixml/src/pugixml.hpp"</span></code>)
        or include directory-relative path (i.e. <code class="computeroutput"><span class="preprocessor">#include</span>
        <span class="special">&lt;</span><span class="identifier">xml</span><span class="special">/</span><span class="identifier">thirdparty</span><span class="special">/</span><span class="identifier">pugixml</span><span class="special">/</span><span class="identifier">src</span><span class="special">/</span><span class="identifier">pugixml</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>).
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.install.building.embed"></a><a class="link" href="install.html#manual.install.building.embed" title="Building pugixml as a part of another static library/executable">Building pugixml as
        a part of another static library/executable</a>
</h4></div></div></div>
<p>
          The easiest way to build pugixml is to compile the source file, <code class="filename">pugixml.cpp</code>,
          along with the existing library/executable. This process depends on the
          method of building your application; for example, if you're using Microsoft
          Visual Studio<a href="#ftn.trademarks" class="footnote" name="trademarks"><sup class="footnote">[1]</sup></a>, Apple Xcode, Code::Blocks or any other IDE, just add <code class="filename">pugixml.cpp</code> to
          one of your projects.
        </p>
<p>
          If you're using Microsoft Visual Studio and the project has precompiled
          headers turned on, you'll see the following error messages:
        </p>
<pre class="programlisting">pugixml.cpp(3477) : fatal error C1010: unexpected end of file while looking for precompiled header. Did you forget to add '#include "stdafx.h"' to your source?</pre>
<p>
          The correct way to resolve this is to disable precompiled headers for <code class="filename">pugixml.cpp</code>;
          you have to set "Create/Use Precompiled Header" option (Properties
          dialog -&gt; C/C++ -&gt; Precompiled Headers -&gt; Create/Use Precompiled
          Header) to "Not Using Precompiled Headers". You'll have to do
          it for all project configurations/platforms (you can select Configuration
          "All Configurations" and Platform "All Platforms" before
          editing the option):
        </p>
<div class="informaltable"><table class="table">
<colgroup><col></colgroup>
<tbody><tr><td>
                  <p>
                    <a href="../images/vs2005_pch1.png" target="_top"><span class="inlinemediaobject"><img src="../images/vs2005_pch1_thumb.png" alt="vs2005_pch1_thumb"></span></a> <span class="inlinemediaobject"><img src="../images/next.png" alt="next"></span> <a href="../images/vs2005_pch2.png" target="_top"><span class="inlinemediaobject"><img src="../images/vs2005_pch2_thumb.png" alt="vs2005_pch2_thumb"></span></a> <span class="inlinemediaobject"><img src="../images/next.png" alt="next"></span> <a href="../images/vs2005_pch3.png" target="_top"><span class="inlinemediaobject"><img src="../images/vs2005_pch3_thumb.png" alt="vs2005_pch3_thumb"></span></a> <span class="inlinemediaobject"><img src="../images/next.png" alt="next"></span> <a href="../images/vs2005_pch4.png" target="_top"><span class="inlinemediaobject"><img src="../images/vs2005_pch4_thumb.png" alt="vs2005_pch4_thumb"></span></a>
                  </p>
                </td></tr></tbody>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.install.building.static"></a><a class="link" href="install.html#manual.install.building.static" title="Building pugixml as a standalone static library">Building pugixml as
        a standalone static library</a>
</h4></div></div></div>
<p>
          It's possible to compile pugixml as a standalone static library. This process
          depends on the method of building your application; pugixml distribution
          comes with project files for several popular IDEs/build systems. There
          are project files for Apple XCode3, Code::Blocks, Codelite, Microsoft Visual
          Studio 2005, 2008, 2010, and configuration scripts for CMake and premake4.
          You're welcome to submit project files/build scripts for other software;
          see <a class="xref" href="../manual.html#manual.overview.feedback" title="Feedback">Feedback</a>.
        </p>
<p>
          There are two projects for each version of Microsoft Visual Studio: one
          for dynamically linked CRT, which has a name like <code class="filename">pugixml_vs2008.vcproj</code>,
          and another one for statically linked CRT, which has a name like <code class="filename">pugixml_vs2008_static.vcproj</code>.
          You should select the version that matches the CRT used in your application;
          the default option for new projects created by Microsoft Visual Studio
          is dynamically linked CRT, so unless you changed the defaults, you should
          use the version with dynamic CRT (i.e. <code class="filename">pugixml_vs2008.vcproj</code> for Microsoft
          Visual Studio 2008).
        </p>
<p>
          In addition to adding pugixml project to your workspace, you'll have to
          make sure that your application links with pugixml library. If you're using
          Microsoft Visual Studio 2005/2008, you can add a dependency from your application
          project to pugixml one. If you're using Microsoft Visual Studio 2010, you'll
          have to add a reference to your application project instead. For other
          IDEs/systems, consult the relevant documentation.
        </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Microsoft Visual Studio 2005/2008
                  </p>
                </th>
<th>
                  <p>
                    Microsoft Visual Studio 2010
                  </p>
                </th>
</tr></thead>
<tbody><tr>
<td>
                  <p>
                    <a href="../images/vs2005_link1.png" target="_top"><span class="inlinemediaobject"><img src="../images/vs2005_link1_thumb.png" alt="vs2005_link1_thumb"></span></a> <span class="inlinemediaobject"><img src="../images/next.png" alt="next"></span> <a href="../images/vs2005_link2.png" target="_top"><span class="inlinemediaobject"><img src="../images/vs2005_link2_thumb.png" alt="vs2005_link2_thumb"></span></a>
                  </p>
                </td>
<td>
                  <p>
                    <a href="../images/vs2010_link1.png" target="_top"><span class="inlinemediaobject"><img src="../images/vs2010_link1_thumb.png" alt="vs2010_link1_thumb"></span></a> <span class="inlinemediaobject"><img src="../images/next.png" alt="next"></span> <a href="../images/vs2010_link2.png" target="_top"><span class="inlinemediaobject"><img src="../images/vs2010_link2_thumb.png" alt="vs2010_link2_thumb"></span></a>
                  </p>
                </td>
</tr></tbody>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.install.building.shared"></a><a class="link" href="install.html#manual.install.building.shared" title="Building pugixml as a standalone shared library">Building pugixml as
        a standalone shared library</a>
</h4></div></div></div>
<p>
          It's possible to compile pugixml as a standalone shared library. The process
          is usually similar to the static library approach; however, no preconfigured
          projects/scripts are included into pugixml distribution, so you'll have
          to do it yourself. Generally, if you're using GCC-based toolchain, the
          process does not differ from building any other library as DLL (adding
          -shared to compilation flags should suffice); if you're using MSVC-based
          toolchain, you'll have to explicitly mark exported symbols with a declspec
          attribute. You can do it by defining <a class="link" href="install.html#PUGIXML_API">PUGIXML_API</a>
          macro, i.e. via <code class="filename">pugiconfig.hpp</code>:
        </p>
<pre class="programlisting"><span class="preprocessor">#ifdef</span> <span class="identifier">_DLL</span>
<span class="preprocessor">#define</span> <span class="identifier">PUGIXML_API</span> <span class="identifier">__declspec</span><span class="special">(</span><span class="identifier">dllexport</span><span class="special">)</span>
<span class="preprocessor">#else</span>
<span class="preprocessor">#define</span> <span class="identifier">PUGIXML_API</span> <span class="identifier">__declspec</span><span class="special">(</span><span class="identifier">dllimport</span><span class="special">)</span>
<span class="preprocessor">#endif</span>
</pre>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
            If you're using STL-related functions, you should use the shared runtime
            library to ensure that a single heap is used for STL allocations in your
            application and in pugixml; in MSVC, this means selecting the 'Multithreaded
            DLL' or 'Multithreaded Debug DLL' to 'Runtime library' property (/MD
            or /MDd linker switch). You should also make sure that your runtime library
            choice is consistent between different projects.
          </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.install.building.header"></a><a name="PUGIXML_HEADER_ONLY"></a><a class="link" href="install.html#manual.install.building.header" title="Using pugixml in header-only mode">Using
        pugixml in header-only mode</a>
</h4></div></div></div>
<p>
          It's possible to use pugixml in header-only mode. This means that all source
          code for pugixml will be included in every translation unit that includes
          <code class="filename">pugixml.hpp</code>. This is how most of Boost and STL libraries work.
        </p>
<p>
          Note that there are advantages and drawbacks of this approach. Header mode
          may improve tree traversal/modification performance (because many simple
          functions will be inlined), if your compiler toolchain does not support
          link-time optimization, or if you have it turned off (with link-time optimization
          the performance should be similar to non-header mode). However, since compiler
          now has to compile pugixml source once for each translation unit that includes
          it, compilation times may increase noticeably. If you want to use pugixml
          in header mode but do not need XPath support, you can consider disabling
          it by using <a class="link" href="install.html#PUGIXML_NO_XPATH">PUGIXML_NO_XPATH</a> define
          to improve compilation time.
        </p>
<p>
          Enabling header-only mode is a two-step process:
        </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
              You have to define <code class="computeroutput"><span class="identifier">PUGIXML_HEADER_ONLY</span></code>
            </li>
<li class="listitem">
              You have to include <code class="filename">pugixml.cpp</code> whenever you include pugixml.hpp
            </li>
</ol></div>
<p>
          Both of these are best done via <code class="filename">pugiconfig.hpp</code> like this:
        </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">PUGIXML_HEADER_ONLY</span>
<span class="preprocessor">#include</span> <span class="string">"pugixml.cpp"</span>
</pre>
<p>
          Note that it is safe to compile <code class="filename">pugixml.cpp</code> if <code class="computeroutput"><span class="identifier">PUGIXML_HEADER_ONLY</span></code>
          is defined - so if you want to i.e. use header-only mode only in Release
          configuration, you can include pugixml.cpp in your project (see <a class="xref" href="install.html#manual.install.building.embed" title="Building pugixml as a part of another static library/executable">Building pugixml as
        a part of another static library/executable</a>),
          and conditionally enable header-only mode in <code class="filename">pugiconfig.hpp</code>, i.e.:
        </p>
<pre class="programlisting"><span class="preprocessor">#ifndef</span> <span class="identifier">_DEBUG</span>
    <span class="preprocessor">#define</span> <span class="identifier">PUGIXML_HEADER_ONLY</span>
    <span class="preprocessor">#include</span> <span class="string">"pugixml.cpp"</span>
<span class="preprocessor">#endif</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.install.building.config"></a><a class="link" href="install.html#manual.install.building.config" title="Additional configuration options">Additional configuration
        options</a>
</h4></div></div></div>
<p>
          pugixml uses several defines to control the compilation process. There
          are two ways to define them: either put the needed definitions to <code class="filename">pugiconfig.hpp</code> (it
          has some examples that are commented out) or provide them via compiler
          command-line. Consistency is important: the definitions should match in
          all source files that include <code class="filename">pugixml.hpp</code> (including pugixml sources) throughout
          the application. Adding defines to <code class="filename">pugiconfig.hpp</code> lets you guarantee this,
          unless your macro definition is wrapped in preprocessor <code class="computeroutput"><span class="preprocessor">#if</span></code>/<code class="computeroutput"><span class="preprocessor">#ifdef</span></code> directive and this directive
          is not consistent. <code class="filename">pugiconfig.hpp</code> will never contain anything but comments,
          which means that when upgrading to a new version, you can safely leave
          your modified version intact.
        </p>
<p>
          <a name="PUGIXML_WCHAR_MODE"></a><code class="literal">PUGIXML_WCHAR_MODE</code> define toggles
          between UTF-8 style interface (the in-memory text encoding is assumed to
          be UTF-8, most functions use <code class="computeroutput"><span class="keyword">char</span></code>
          as character type) and UTF-16/32 style interface (the in-memory text encoding
          is assumed to be UTF-16/32, depending on <code class="computeroutput"><span class="keyword">wchar_t</span></code>
          size, most functions use <code class="computeroutput"><span class="keyword">wchar_t</span></code>
          as character type). See <a class="xref" href="dom.html#manual.dom.unicode" title="Unicode interface">Unicode interface</a> for more details.
        </p>
<p>
          <a name="PUGIXML_NO_XPATH"></a><code class="literal">PUGIXML_NO_XPATH</code> define disables XPath.
          Both XPath interfaces and XPath implementation are excluded from compilation.
          This option is provided in case you do not need XPath functionality and
          need to save code space.
        </p>
<p>
          <a name="PUGIXML_NO_STL"></a><code class="literal">PUGIXML_NO_STL</code> define disables use of
          STL in pugixml. The functions that operate on STL types are no longer present
          (i.e. load/save via iostream) if this macro is defined. This option is
          provided in case your target platform does not have a standard-compliant
          STL implementation.
        </p>
<p>
          <a name="PUGIXML_NO_EXCEPTIONS"></a><code class="literal">PUGIXML_NO_EXCEPTIONS</code> define disables
          use of exceptions in pugixml. This option is provided in case your target
          platform does not have exception handling capabilities.
        </p>
<p>
          <a name="PUGIXML_API"></a><code class="literal">PUGIXML_API</code>, <a name="PUGIXML_CLASS"></a><code class="literal">PUGIXML_CLASS</code>
          and <a name="PUGIXML_FUNCTION"></a><code class="literal">PUGIXML_FUNCTION</code> defines let you
          specify custom attributes (i.e. declspec or calling conventions) for pugixml
          classes and non-member functions. In absence of <code class="computeroutput"><span class="identifier">PUGIXML_CLASS</span></code>
          or <code class="computeroutput"><span class="identifier">PUGIXML_FUNCTION</span></code> definitions,
          <code class="computeroutput"><span class="identifier">PUGIXML_API</span></code> definition
          is used instead. For example, to specify fixed calling convention, you
          can define <code class="computeroutput"><span class="identifier">PUGIXML_FUNCTION</span></code>
          to i.e. <code class="computeroutput"><span class="identifier">__fastcall</span></code>. Another
          example is DLL import/export attributes in MSVC (see <a class="xref" href="install.html#manual.install.building.shared" title="Building pugixml as a standalone shared library">Building pugixml as
        a standalone shared library</a>).
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            In that example <code class="computeroutput"><span class="identifier">PUGIXML_API</span></code>
            is inconsistent between several source files; this is an exception to
            the consistency rule.
          </p></td></tr>
</table></div>
<p>
          <a name="PUGIXML_MEMORY_PAGE_SIZE"></a><code class="literal">PUGIXML_MEMORY_PAGE_SIZE</code>, <a name="PUGIXML_MEMORY_OUTPUT_STACK"></a><code class="literal">PUGIXML_MEMORY_OUTPUT_STACK</code>
          and <a name="PUGIXML_MEMORY_XPATH_PAGE_SIZE"></a><code class="literal">PUGIXML_MEMORY_XPATH_PAGE_SIZE</code>
          can be used to customize certain important sizes to optimize memory usage
          for the application-specific patterns. For details see <a class="xref" href="dom.html#manual.dom.memory.tuning" title="Memory consumption tuning">Memory consumption tuning</a>.
        </p>
<p>
          <a name="PUGIXML_HAS_LONG_LONG"></a><code class="literal">PUGIXML_HAS_LONG_LONG</code> define enables
          support for <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
          type in pugixml. This define is automatically enabled if your platform
          is known to have <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
          support (i.e. has C++-11 support or uses a reasonably modern version of
          a known compiler); if pugixml does not recognize that your platform supports
          <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
          but in fact it does, you can enable the define manually.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.install.portability"></a><a class="link" href="install.html#manual.install.portability" title="Portability">Portability</a>
</h3></div></div></div>
<p>
        pugixml is written in standard-compliant C++ with some compiler-specific
        workarounds where appropriate. pugixml is compatible with the C++11 standard,
        but does not require C++11 support. Each version is tested with a unit test
        suite (with code coverage about 99%) on the following platforms:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Microsoft Windows:
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  Borland C++ Compiler 5.82
                </li>
<li class="listitem">
                  Digital Mars C++ Compiler 8.51
                </li>
<li class="listitem">
                  Intel C++ Compiler 8.0, 9.0 x86/x64, 10.0 x86/x64, 11.0 x86/x64
                </li>
<li class="listitem">
                  Metrowerks CodeWarrior 8.0
                </li>
<li class="listitem">
                  Microsoft Visual C++ 6.0, 7.0 (2002), 7.1 (2003), 8.0 (2005) x86/x64,
                  9.0 (2008) x86/x64, 10.0 (2010) x86/x64, 11.0 (2011) x86/x64/ARM,
                  12.0 (2013) x86/x64/ARM and some CLR versions
                </li>
<li class="listitem">
                  MinGW (GCC) 3.4, 4.4, 4.5, 4.6 x64
                </li>
</ul></div>
          </li>
<li class="listitem">
            Linux (GCC 4.4.3 x86/x64, GCC 4.8.1 x64, Clang 3.2 x64)
          </li>
<li class="listitem">
            FreeBSD (GCC 4.2.1 x86/x64)
          </li>
<li class="listitem">
            Apple MacOSX (GCC 4.0.1 x86/x64/PowerPC)
          </li>
<li class="listitem">
            Sun Solaris (sunCC x86/x64)
          </li>
<li class="listitem">
            Microsoft Xbox 360
          </li>
<li class="listitem">
            Nintendo Wii (Metrowerks CodeWarrior 4.1)
          </li>
<li class="listitem">
            Sony Playstation Portable (GCC 3.4.2)
          </li>
<li class="listitem">
            Sony Playstation 3 (GCC 4.1.1, SNC 310.1)
          </li>
<li class="listitem">
            Various portable platforms (Android NDK, BlackBerry NDK, Samsung bada,
            Windows CE)
          </li>
</ul></div>
</div>
<div class="footnotes">
<br><hr style="width:100; text-align:left;margin-left: 0">
<div id="ftn.trademarks" class="footnote"><p><a href="#trademarks" class="para"><sup class="para">[1] </sup></a>All trademarks used are properties of their respective
          owners.</p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Arseny Kapoulkine<p>
        Distributed under the MIT License
      </p>
</div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<b>Installation</b> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="../manual.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="dom.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual/toc.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Table of Contents</title>
<link rel="stylesheet" href="../pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../manual.html" title="pugixml 1.4">
<link rel="up" href="../manual.html" title="pugixml 1.4">
<link rel="prev" href="apiref.html" title="API Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<b>Table of Contents</b>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="apiref.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a>
</div></td>
</tr></table>
<hr>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.toc"></a><a class="link" href="toc.html" title="Table of Contents">Table of Contents</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="../manual.html#manual.overview">Overview</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="../manual.html#manual.overview.introduction">Introduction</a></span></dt>
<dt><span class="section"><a href="../manual.html#manual.overview.feedback">Feedback</a></span></dt>
<dt><span class="section"><a href="../manual.html#manual.overview.thanks">Acknowledgments</a></span></dt>
<dt><span class="section"><a href="../manual.html#manual.overview.license">License</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="install.html">Installation</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="install.html#manual.install.getting">Getting pugixml</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="install.html#manual.install.getting.source">Source distributions</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.getting.subversion">Subversion repository</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.getting.git">Git repository</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="install.html#manual.install.building">Building pugixml</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="install.html#manual.install.building.embed">Building pugixml as
        a part of another static library/executable</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.building.static">Building pugixml as
        a standalone static library</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.building.shared">Building pugixml as
        a standalone shared library</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.building.header">Using
        pugixml in header-only mode</a></span></dt>
<dt><span class="section"><a href="install.html#manual.install.building.config">Additional configuration
        options</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="install.html#manual.install.portability">Portability</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="dom.html">Document object model</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="dom.html#manual.dom.tree">Tree structure</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.cpp">C++ interface</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.unicode">Unicode interface</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.thread">Thread-safety guarantees</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.exception">Exception guarantees</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.memory">Memory management</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="dom.html#manual.dom.memory.custom">Custom memory allocation/deallocation
        functions</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.memory.tuning">Memory consumption tuning</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.memory.internals">Document memory management
        internals</a></span></dt>
</dl></dd>
</dl></dd>
<dt><span class="section"><a href="loading.html">Loading document</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="loading.html#manual.loading.file">Loading document from file</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.memory">Loading document from memory</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.stream">Loading document from C++ IOstreams</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.errors">Handling parsing errors</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.options">Parsing options</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.encoding">Encodings</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.w3c">Conformance to W3C specification</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="access.html">Accessing document data</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="access.html#manual.access.basic">Basic traversal functions</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.nodedata">Getting node data</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.attrdata">Getting attribute data</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.contents">Contents-based traversal functions</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.rangefor">Range-based for-loop support</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.iterators">Traversing node/attribute lists
      via iterators</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.walker">Recursive traversal with xml_tree_walker</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.predicate">Searching for nodes/attributes
      with predicates</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.text">Working with text contents</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.misc">Miscellaneous functions</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="modify.html">Modifying document data</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="modify.html#manual.modify.nodedata">Setting node data</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.attrdata">Setting attribute data</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.add">Adding nodes/attributes</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.remove">Removing nodes/attributes</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.text">Working with text contents</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.clone">Cloning nodes/attributes</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.fragments">Assembling document from fragments</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="saving.html">Saving document</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="saving.html#manual.saving.file">Saving document to a file</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.stream">Saving document to C++ IOstreams</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.writer">Saving document via writer interface</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.subtree">Saving a single subtree</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.options">Output options</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.encoding">Encodings</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.declaration">Customizing document declaration</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="xpath.html">XPath</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="xpath.html#manual.xpath.types">XPath types</a></span></dt>
<dt><span class="section"><a href="xpath.html#manual.xpath.select">Selecting nodes via XPath expression</a></span></dt>
<dt><span class="section"><a href="xpath.html#manual.xpath.query">Using query objects</a></span></dt>
<dt><span class="section"><a href="xpath.html#manual.xpath.variables">Using variables</a></span></dt>
<dt><span class="section"><a href="xpath.html#manual.xpath.errors">Error handling</a></span></dt>
<dt><span class="section"><a href="xpath.html#manual.xpath.w3c">Conformance to W3C specification</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="changes.html">Changelog</a></span></dt>
<dt><span class="section"><a href="apiref.html">API Reference</a></span></dt>
<dt><span class="section"><a href="toc.html">Table of Contents</a></span></dt>
</dl></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Arseny Kapoulkine<p>
        Distributed under the MIT License
      </p>
</div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<b>Table of Contents</b>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="apiref.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a>
</div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual/loading.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Loading document</title>
<link rel="stylesheet" href="../pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../manual.html" title="pugixml 1.4">
<link rel="up" href="../manual.html" title="pugixml 1.4">
<link rel="prev" href="dom.html" title="Document object model">
<link rel="next" href="access.html" title="Accessing document data">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <b>Loading</b> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="dom.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="access.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
<hr>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.loading"></a><a class="link" href="loading.html" title="Loading document">Loading document</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="loading.html#manual.loading.file">Loading document from file</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.memory">Loading document from memory</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.stream">Loading document from C++ IOstreams</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.errors">Handling parsing errors</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.options">Parsing options</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.encoding">Encodings</a></span></dt>
<dt><span class="section"><a href="loading.html#manual.loading.w3c">Conformance to W3C specification</a></span></dt>
</dl></div>
<p>
      pugixml provides several functions for loading XML data from various places
      - files, C++ iostreams, memory buffers. All functions use an extremely fast
      non-validating parser. This parser is not fully W3C conformant - it can load
      any valid XML document, but does not perform some well-formedness checks. While
      considerable effort is made to reject invalid XML documents, some validation
      is not performed for performance reasons. Also some XML transformations (i.e.
      EOL handling or attribute value normalization) can impact parsing speed and
      thus can be disabled. However for vast majority of XML documents there is no
      performance difference between different parsing options. Parsing options also
      control whether certain XML nodes are parsed; see <a class="xref" href="loading.html#manual.loading.options" title="Parsing options">Parsing options</a> for
      more information.
    </p>
<p>
      XML data is always converted to internal character format (see <a class="xref" href="dom.html#manual.dom.unicode" title="Unicode interface">Unicode interface</a>)
      before parsing. pugixml supports all popular Unicode encodings (UTF-8, UTF-16
      (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally
      supported since it's a strict subset of UTF-16) and handles all encoding conversions
      automatically. Unless explicit encoding is specified, loading functions perform
      automatic encoding detection based on first few characters of XML data, so
      in almost all cases you do not have to specify document encoding. Encoding
      conversion is described in more detail in <a class="xref" href="loading.html#manual.loading.encoding" title="Encodings">Encodings</a>.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.loading.file"></a><a class="link" href="loading.html#manual.loading.file" title="Loading document from file">Loading document from file</a>
</h3></div></div></div>
<p>
        <a name="xml_document::load_file"></a><a name="xml_document::load_file_wide"></a>The
        most common source of XML data is files; pugixml provides dedicated functions
        for loading an XML document from file:
      </p>
<pre class="programlisting"><span class="identifier">xml_parse_result</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load_file</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">path</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">options</span> <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span>
<span class="identifier">xml_parse_result</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load_file</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*</span> <span class="identifier">path</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">options</span> <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span>
</pre>
<p>
        These functions accept the file path as its first argument, and also two
        optional arguments, which specify parsing options (see <a class="xref" href="loading.html#manual.loading.options" title="Parsing options">Parsing options</a>)
        and input data encoding (see <a class="xref" href="loading.html#manual.loading.encoding" title="Encodings">Encodings</a>). The path has the target
        operating system format, so it can be a relative or absolute one, it should
        have the delimiters of the target system, it should have the exact case if
        the target file system is case-sensitive, etc.
      </p>
<p>
        File path is passed to the system file opening function as is in case of
        the first function (which accepts <code class="computeroutput"><span class="keyword">const</span>
        <span class="keyword">char</span><span class="special">*</span> <span class="identifier">path</span></code>); the second function either uses
        a special file opening function if it is provided by the runtime library
        or converts the path to UTF-8 and uses the system file opening function.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">load_file</span></code> destroys the existing
        document tree and then tries to load the new tree from the specified file.
        The result of the operation is returned in an <a class="link" href="loading.html#xml_parse_result">xml_parse_result</a>
        object; this object contains the operation status and the related information
        (i.e. last successfully parsed position in the input file, if parsing fails).
        See <a class="xref" href="loading.html#manual.loading.errors" title="Handling parsing errors">Handling parsing errors</a> for error handling details.
      </p>
<p>
        This is an example of loading XML document from file (<a href="../samples/load_file.cpp" target="_top">samples/load_file.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span> <span class="identifier">doc</span><span class="special">;</span>

<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_file</span><span class="special">(</span><span class="string">"tree.xml"</span><span class="special">);</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Load result: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">description</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">", mesh name: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"mesh"</span><span class="special">).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"name"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.loading.memory"></a><a class="link" href="loading.html#manual.loading.memory" title="Loading document from memory">Loading document from memory</a>
</h3></div></div></div>
<p>
        <a name="xml_document::load_buffer"></a><a name="xml_document::load_buffer_inplace"></a><a name="xml_document::load_buffer_inplace_own"></a>Sometimes XML data should be
        loaded from some other source than a file, i.e. HTTP URL; also you may want
        to load XML data from file using non-standard functions, i.e. to use your
        virtual file system facilities or to load XML from gzip-compressed files.
        All these scenarios require loading document from memory. First you should
        prepare a contiguous memory block with all XML data; then you have to invoke
        one of buffer loading functions. These functions will handle the necessary
        encoding conversions, if any, and then will parse the data into the corresponding
        XML tree. There are several buffer loading functions, which differ in the
        behavior and thus in performance/memory usage:
      </p>
<pre class="programlisting"><span class="identifier">xml_parse_result</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load_buffer</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">void</span><span class="special">*</span> <span class="identifier">contents</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">options</span> <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span>
<span class="identifier">xml_parse_result</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load_buffer_inplace</span><span class="special">(</span><span class="keyword">void</span><span class="special">*</span> <span class="identifier">contents</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">options</span> <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span>
<span class="identifier">xml_parse_result</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load_buffer_inplace_own</span><span class="special">(</span><span class="keyword">void</span><span class="special">*</span> <span class="identifier">contents</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">options</span> <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span>
</pre>
<p>
        All functions accept the buffer which is represented by a pointer to XML
        data, <code class="computeroutput"><span class="identifier">contents</span></code>, and data
        size in bytes. Also there are two optional arguments, which specify parsing
        options (see <a class="xref" href="loading.html#manual.loading.options" title="Parsing options">Parsing options</a>) and input data encoding (see <a class="xref" href="loading.html#manual.loading.encoding" title="Encodings">Encodings</a>).
        The buffer does not have to be zero-terminated.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">load_buffer</span></code> function works
        with immutable buffer - it does not ever modify the buffer. Because of this
        restriction it has to create a private buffer and copy XML data to it before
        parsing (applying encoding conversions if necessary). This copy operation
        carries a performance penalty, so inplace functions are provided - <code class="computeroutput"><span class="identifier">load_buffer_inplace</span></code> and <code class="computeroutput"><span class="identifier">load_buffer_inplace_own</span></code>
        store the document data in the buffer, modifying it in the process. In order
        for the document to stay valid, you have to make sure that the buffer's lifetime
        exceeds that of the tree if you're using inplace functions. In addition to
        that, <code class="computeroutput"><span class="identifier">load_buffer_inplace</span></code>
        does not assume ownership of the buffer, so you'll have to destroy it yourself;
        <code class="computeroutput"><span class="identifier">load_buffer_inplace_own</span></code> assumes
        ownership of the buffer and destroys it once it is not needed. This means
        that if you're using <code class="computeroutput"><span class="identifier">load_buffer_inplace_own</span></code>,
        you have to allocate memory with pugixml allocation function (you can get
        it via <a class="link" href="dom.html#get_memory_allocation_function">get_memory_allocation_function</a>).
      </p>
<p>
        The best way from the performance/memory point of view is to load document
        using <code class="computeroutput"><span class="identifier">load_buffer_inplace_own</span></code>;
        this function has maximum control of the buffer with XML data so it is able
        to avoid redundant copies and reduce peak memory usage while parsing. This
        is the recommended function if you have to load the document from memory
        and performance is critical.
      </p>
<p>
        <a name="xml_document::load_string"></a>There is also a simple helper function
        for cases when you want to load the XML document from null-terminated character
        string:
      </p>
<pre class="programlisting"><span class="identifier">xml_parse_result</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">contents</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">options</span> <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">);</span>
</pre>
<p>
        It is equivalent to calling <code class="computeroutput"><span class="identifier">load_buffer</span></code>
        with <code class="computeroutput"><span class="identifier">size</span></code> being either <code class="computeroutput"><span class="identifier">strlen</span><span class="special">(</span><span class="identifier">contents</span><span class="special">)</span></code>
        or <code class="computeroutput"><span class="identifier">wcslen</span><span class="special">(</span><span class="identifier">contents</span><span class="special">)</span> <span class="special">*</span> <span class="keyword">sizeof</span><span class="special">(</span><span class="keyword">wchar_t</span><span class="special">)</span></code>,
        depending on the character type. This function assumes native encoding for
        input data, so it does not do any encoding conversion. In general, this function
        is fine for loading small documents from string literals, but has more overhead
        and less functionality than the buffer loading functions.
      </p>
<p>
        This is an example of loading XML document from memory using different functions
        (<a href="../samples/load_memory.cpp" target="_top">samples/load_memory.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">char</span> <span class="identifier">source</span><span class="special">[]</span> <span class="special">=</span> <span class="string">"&lt;mesh name='sphere'&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;"</span><span class="special">;</span>
<span class="identifier">size_t</span> <span class="identifier">size</span> <span class="special">=</span> <span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">source</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// You can use load_buffer to load document from immutable memory block:</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_buffer</span><span class="special">(</span><span class="identifier">source</span><span class="special">,</span> <span class="identifier">size</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// You can use load_buffer_inplace to load document from mutable memory block; the block's lifetime must exceed that of document</span>
<span class="keyword">char</span><span class="special">*</span> <span class="identifier">buffer</span> <span class="special">=</span> <span class="keyword">new</span> <span class="keyword">char</span><span class="special">[</span><span class="identifier">size</span><span class="special">];</span>
<span class="identifier">memcpy</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">source</span><span class="special">,</span> <span class="identifier">size</span><span class="special">);</span>

<span class="comment">// The block can be allocated by any method; the block is modified during parsing</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_buffer_inplace</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">size</span><span class="special">);</span>

<span class="comment">// You have to destroy the block yourself after the document is no longer used</span>
<span class="keyword">delete</span><span class="special">[]</span> <span class="identifier">buffer</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// You can use load_buffer_inplace_own to load document from mutable memory block and to pass the ownership of this block</span>
<span class="comment">// The block has to be allocated via pugixml allocation function - using i.e. operator new here is incorrect</span>
<span class="keyword">char</span><span class="special">*</span> <span class="identifier">buffer</span> <span class="special">=</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">*&gt;(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">get_memory_allocation_function</span><span class="special">()(</span><span class="identifier">size</span><span class="special">));</span>
<span class="identifier">memcpy</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">source</span><span class="special">,</span> <span class="identifier">size</span><span class="special">);</span>

<span class="comment">// The block will be deleted by the document</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_buffer_inplace_own</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">size</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// You can use load to load document from null-terminated strings, for example literals:</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="string">"&lt;mesh name='sphere'&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;"</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.loading.stream"></a><a class="link" href="loading.html#manual.loading.stream" title="Loading document from C++ IOstreams">Loading document from C++ IOstreams</a>
</h3></div></div></div>
<p>
        <a name="xml_document::load_stream"></a>To enhance interoperability, pugixml
        provides functions for loading document from any object which implements
        C++ <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span></code> interface. This allows you to load
        documents from any standard C++ stream (i.e. file stream) or any third-party
        compliant implementation (i.e. Boost Iostreams). There are two functions,
        one works with narrow character streams, another handles wide character ones:
      </p>
<pre class="programlisting"><span class="identifier">xml_parse_result</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">options</span> <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span>
<span class="identifier">xml_parse_result</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">wistream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">options</span> <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">);</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">load</span></code> with <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span></code>
        argument loads the document from stream from the current read position to
        the end, treating the stream contents as a byte stream of the specified encoding
        (with encoding autodetection as necessary). Thus calling <code class="computeroutput"><span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load</span></code>
        on an opened <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ifstream</span></code> object is equivalent to calling
        <code class="computeroutput"><span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">load_file</span></code>.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">load</span></code> with <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">wstream</span></code>
        argument treats the stream contents as a wide character stream (encoding
        is always <a class="link" href="loading.html#encoding_wchar">encoding_wchar</a>). Because
        of this, using <code class="computeroutput"><span class="identifier">load</span></code> with
        wide character streams requires careful (usually platform-specific) stream
        setup (i.e. using the <code class="computeroutput"><span class="identifier">imbue</span></code>
        function). Generally use of wide streams is discouraged, however it provides
        you the ability to load documents from non-Unicode encodings, i.e. you can
        load Shift-JIS encoded data if you set the correct locale.
      </p>
<p>
        This is a simple example of loading XML document from file using streams
        (<a href="../samples/load_stream.cpp" target="_top">samples/load_stream.cpp</a>); read
        the sample code for more complex examples involving wide streams and locales:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ifstream</span> <span class="identifier">stream</span><span class="special">(</span><span class="string">"weekly-utf-8.xml"</span><span class="special">);</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="identifier">stream</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.loading.errors"></a><a class="link" href="loading.html#manual.loading.errors" title="Handling parsing errors">Handling parsing errors</a>
</h3></div></div></div>
<p>
        <a name="xml_parse_result"></a>All document loading functions return the
        parsing result via <code class="computeroutput"><span class="identifier">xml_parse_result</span></code>
        object. It contains parsing status, the offset of last successfully parsed
        character from the beginning of the source stream, and the encoding of the
        source stream:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">xml_parse_result</span>
<span class="special">{</span>
    <span class="identifier">xml_parse_status</span> <span class="identifier">status</span><span class="special">;</span>
    <span class="identifier">ptrdiff_t</span> <span class="identifier">offset</span><span class="special">;</span>
    <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span><span class="special">;</span>

    <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">description</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
        <a name="xml_parse_status"></a><a name="xml_parse_result::status"></a>Parsing
        status is represented as the <code class="computeroutput"><span class="identifier">xml_parse_status</span></code>
        enumeration and can be one of the following:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a name="status_ok"></a><code class="literal">status_ok</code> means that no error was encountered
            during parsing; the source stream represents the valid XML document which
            was fully parsed and converted to a tree. <br><br>
          </li>
<li class="listitem">
            <a name="status_file_not_found"></a><code class="literal">status_file_not_found</code> is only
            returned by <code class="computeroutput"><span class="identifier">load_file</span></code>
            function and means that file could not be opened.
          </li>
<li class="listitem">
            <a name="status_io_error"></a><code class="literal">status_io_error</code> is returned by <code class="computeroutput"><span class="identifier">load_file</span></code> function and by <code class="computeroutput"><span class="identifier">load</span></code> functions with <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span></code>/<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">wstream</span></code> arguments; it means that some
            I/O error has occurred during reading the file/stream.
          </li>
<li class="listitem">
            <a name="status_out_of_memory"></a><code class="literal">status_out_of_memory</code> means that
            there was not enough memory during some allocation; any allocation failure
            during parsing results in this error.
          </li>
<li class="listitem">
            <a name="status_internal_error"></a><code class="literal">status_internal_error</code> means that
            something went horribly wrong; currently this error does not occur <br><br>
          </li>
<li class="listitem">
            <a name="status_unrecognized_tag"></a><code class="literal">status_unrecognized_tag</code> means
            that parsing stopped due to a tag with either an empty name or a name
            which starts with incorrect character, such as <code class="literal">#</code>.
          </li>
<li class="listitem">
            <a name="status_bad_pi"></a><code class="literal">status_bad_pi</code> means that parsing stopped
            due to incorrect document declaration/processing instruction
          </li>
<li class="listitem">
            <a name="status_bad_comment"></a><code class="literal">status_bad_comment</code>, <a name="status_bad_cdata"></a><code class="literal">status_bad_cdata</code>,
            <a name="status_bad_doctype"></a><code class="literal">status_bad_doctype</code> and <a name="status_bad_pcdata"></a><code class="literal">status_bad_pcdata</code>
            mean that parsing stopped due to the invalid construct of the respective
            type
          </li>
<li class="listitem">
            <a name="status_bad_start_element"></a><code class="literal">status_bad_start_element</code> means
            that parsing stopped because starting tag either had no closing <code class="computeroutput"><span class="special">&gt;</span></code> symbol or contained some incorrect
            symbol
          </li>
<li class="listitem">
            <a name="status_bad_attribute"></a><code class="literal">status_bad_attribute</code> means that
            parsing stopped because there was an incorrect attribute, such as an
            attribute without value or with value that is not quoted (note that
            <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span>
            <span class="identifier">attr</span><span class="special">=</span><span class="number">1</span><span class="special">&gt;</span></code> is
            incorrect in XML)
          </li>
<li class="listitem">
            <a name="status_bad_end_element"></a><code class="literal">status_bad_end_element</code> means
            that parsing stopped because ending tag had incorrect syntax (i.e. extra
            non-whitespace symbols between tag name and <code class="computeroutput"><span class="special">&gt;</span></code>)
          </li>
<li class="listitem">
            <a name="status_end_element_mismatch"></a><code class="literal">status_end_element_mismatch</code>
            means that parsing stopped because the closing tag did not match the
            opening one (i.e. <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;&lt;/</span><span class="identifier">nedo</span><span class="special">&gt;</span></code>) or because some tag was not closed
            at all
          </li>
<li class="listitem">
            <a name="status_no_document_element"></a><code class="literal">status_no_document_element</code>
            means that no element nodes were discovered during parsing; this usually
            indicates an empty or invalid document
          </li>
</ul></div>
<p>
        <a name="xml_parse_result::description"></a><code class="computeroutput"><span class="identifier">description</span><span class="special">()</span></code> member function can be used to convert
        parsing status to a string; the returned message is always in English, so
        you'll have to write your own function if you need a localized string. However
        please note that the exact messages returned by <code class="computeroutput"><span class="identifier">description</span><span class="special">()</span></code> function may change from version to version,
        so any complex status handling should be based on <code class="computeroutput"><span class="identifier">status</span></code>
        value. Note that <code class="computeroutput"><span class="identifier">description</span><span class="special">()</span></code> returns a <code class="computeroutput"><span class="keyword">char</span></code>
        string even in <code class="computeroutput"><span class="identifier">PUGIXML_WCHAR_MODE</span></code>;
        you'll have to call <a class="link" href="dom.html#as_wide">as_wide</a> to get the <code class="computeroutput"><span class="keyword">wchar_t</span></code> string.
      </p>
<p>
        If parsing failed because the source data was not a valid XML, the resulting
        tree is not destroyed - despite the fact that load function returns error,
        you can use the part of the tree that was successfully parsed. Obviously,
        the last element may have an unexpected name/value; for example, if the attribute
        value does not end with the necessary quotation mark, like in <code class="literal">&lt;node
        attr="value&gt;some data&lt;/node&gt;</code> example, the value of
        attribute <code class="computeroutput"><span class="identifier">attr</span></code> will contain
        the string <code class="computeroutput"><span class="identifier">value</span><span class="special">&gt;</span><span class="identifier">some</span> <span class="identifier">data</span><span class="special">&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span></code>.
      </p>
<p>
        <a name="xml_parse_result::offset"></a>In addition to the status code, parsing
        result has an <code class="computeroutput"><span class="identifier">offset</span></code> member,
        which contains the offset of last successfully parsed character if parsing
        failed because of an error in source data; otherwise <code class="computeroutput"><span class="identifier">offset</span></code>
        is 0. For parsing efficiency reasons, pugixml does not track the current
        line during parsing; this offset is in units of <a class="link" href="dom.html#char_t">pugi::char_t</a>
        (bytes for character mode, wide characters for wide character mode). Many
        text editors support 'Go To Position' feature - you can use it to locate
        the exact error position. Alternatively, if you're loading the document from
        memory, you can display the error chunk along with the error description
        (see the example code below).
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          Offset is calculated in the XML buffer in native encoding; if encoding
          conversion is performed during parsing, offset can not be used to reliably
          track the error position.
        </p></td></tr>
</table></div>
<p>
        <a name="xml_parse_result::encoding"></a>Parsing result also has an <code class="computeroutput"><span class="identifier">encoding</span></code> member, which can be used to check
        that the source data encoding was correctly guessed. It is equal to the exact
        encoding used during parsing (i.e. with the exact endianness); see <a class="xref" href="loading.html#manual.loading.encoding" title="Encodings">Encodings</a> for
        more information.
      </p>
<p>
        <a name="xml_parse_result::bool"></a>Parsing result object can be implicitly
        converted to <code class="computeroutput"><span class="keyword">bool</span></code>; if you do
        not want to handle parsing errors thoroughly, you can just check the return
        value of load functions as if it was a <code class="computeroutput"><span class="keyword">bool</span></code>:
        <code class="computeroutput"><span class="keyword">if</span> <span class="special">(</span><span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_file</span><span class="special">(</span><span class="string">"file.xml"</span><span class="special">))</span> <span class="special">{</span> <span class="special">...</span>
        <span class="special">}</span> <span class="keyword">else</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>.
      </p>
<p>
        This is an example of handling loading errors (<a href="../samples/load_error_handling.cpp" target="_top">samples/load_error_handling.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span> <span class="identifier">doc</span><span class="special">;</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="identifier">source</span><span class="special">);</span>

<span class="keyword">if</span> <span class="special">(</span><span class="identifier">result</span><span class="special">)</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"XML ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">source</span> <span class="special">&lt;&lt;</span> <span class="string">"] parsed without errors, attr value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"node"</span><span class="special">).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"attr"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n\n"</span><span class="special">;</span>
<span class="keyword">else</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"XML ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">source</span> <span class="special">&lt;&lt;</span> <span class="string">"] parsed with errors, attr value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"node"</span><span class="special">).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"attr"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Error description: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">description</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Error offset: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">offset</span> <span class="special">&lt;&lt;</span> <span class="string">" (error at [..."</span> <span class="special">&lt;&lt;</span> <span class="special">(</span><span class="identifier">source</span> <span class="special">+</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">offset</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.loading.options"></a><a class="link" href="loading.html#manual.loading.options" title="Parsing options">Parsing options</a>
</h3></div></div></div>
<p>
        All document loading functions accept the optional parameter <code class="computeroutput"><span class="identifier">options</span></code>. This is a bitmask that customizes
        the parsing process: you can select the node types that are parsed and various
        transformations that are performed with the XML text. Disabling certain transformations
        can improve parsing performance for some documents; however, the code for
        all transformations is very well optimized, and thus the majority of documents
        won't get any performance benefit. As a rule of thumb, only modify parsing
        flags if you want to get some nodes in the document that are excluded by
        default (i.e. declaration or comment nodes).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          You should use the usual bitwise arithmetics to manipulate the bitmask:
          to enable a flag, use <code class="computeroutput"><span class="identifier">mask</span> <span class="special">|</span> <span class="identifier">flag</span></code>;
          to disable a flag, use <code class="computeroutput"><span class="identifier">mask</span> <span class="special">&amp;</span> <span class="special">~</span><span class="identifier">flag</span></code>.
        </p></td></tr>
</table></div>
<p>
        These flags control the resulting tree contents:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a name="parse_declaration"></a><code class="literal">parse_declaration</code> determines if XML
            document declaration (node with type <a class="link" href="dom.html#node_declaration">node_declaration</a>)
            is to be put in DOM tree. If this flag is off, it is not put in the tree,
            but is still parsed and checked for correctness. This flag is <span class="bold"><strong>off</strong></span> by default. <br><br>
          </li>
<li class="listitem">
            <a name="parse_doctype"></a><code class="literal">parse_doctype</code> determines if XML document
            type declaration (node with type <a class="link" href="dom.html#node_doctype">node_doctype</a>)
            is to be put in DOM tree. If this flag is off, it is not put in the tree,
            but is still parsed and checked for correctness. This flag is <span class="bold"><strong>off</strong></span> by default. <br><br>
          </li>
<li class="listitem">
            <a name="parse_pi"></a><code class="literal">parse_pi</code> determines if processing instructions
            (nodes with type <a class="link" href="dom.html#node_pi">node_pi</a>) are to be put
            in DOM tree. If this flag is off, they are not put in the tree, but are
            still parsed and checked for correctness. Note that <code class="computeroutput"><span class="special">&lt;?</span><span class="identifier">xml</span> <span class="special">...?&gt;</span></code>
            (document declaration) is not considered to be a PI. This flag is <span class="bold"><strong>off</strong></span> by default. <br><br>
          </li>
<li class="listitem">
            <a name="parse_comments"></a><code class="literal">parse_comments</code> determines if comments
            (nodes with type <a class="link" href="dom.html#node_comment">node_comment</a>) are
            to be put in DOM tree. If this flag is off, they are not put in the tree,
            but are still parsed and checked for correctness. This flag is <span class="bold"><strong>off</strong></span> by default. <br><br>
          </li>
<li class="listitem">
            <a name="parse_cdata"></a><code class="literal">parse_cdata</code> determines if CDATA sections
            (nodes with type <a class="link" href="dom.html#node_cdata">node_cdata</a>) are to
            be put in DOM tree. If this flag is off, they are not put in the tree,
            but are still parsed and checked for correctness. This flag is <span class="bold"><strong>on</strong></span> by default. <br><br>
          </li>
<li class="listitem">
            <a name="parse_trim_pcdata"></a><code class="literal">parse_trim_pcdata</code> determines if leading
            and trailing whitespace characters are to be removed from PCDATA nodes.
            While for some applications leading/trailing whitespace is significant,
            often the application only cares about the non-whitespace contents so
            it's easier to trim whitespace from text during parsing. This flag is
            <span class="bold"><strong>off</strong></span> by default. <br><br>
          </li>
<li class="listitem">
            <a name="parse_ws_pcdata"></a><code class="literal">parse_ws_pcdata</code> determines if PCDATA
            nodes (nodes with type <a class="link" href="dom.html#node_pcdata">node_pcdata</a>)
            that consist only of whitespace characters are to be put in DOM tree.
            Often whitespace-only data is not significant for the application, and
            the cost of allocating and storing such nodes (both memory and speed-wise)
            can be significant. For example, after parsing XML string <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;</span> <span class="special">&lt;</span><span class="identifier">a</span><span class="special">/&gt;</span> <span class="special">&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span></code>, <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;</span></code>
            element will have three children when <code class="computeroutput"><span class="identifier">parse_ws_pcdata</span></code>
            is set (child with type <a class="link" href="dom.html#node_pcdata">node_pcdata</a>
            and value <code class="computeroutput"><span class="string">" "</span></code>,
            child with type <a class="link" href="dom.html#node_element">node_element</a> and
            name <code class="computeroutput"><span class="string">"a"</span></code>, and another
            child with type <a class="link" href="dom.html#node_pcdata">node_pcdata</a> and value
            <code class="computeroutput"><span class="string">" "</span></code>), and only
            one child when <code class="computeroutput"><span class="identifier">parse_ws_pcdata</span></code>
            is not set. This flag is <span class="bold"><strong>off</strong></span> by default.
            <br><br>
          </li>
<li class="listitem">
            <a name="parse_ws_pcdata_single"></a><code class="literal">parse_ws_pcdata_single</code> determines
            if whitespace-only PCDATA nodes that have no sibling nodes are to be
            put in DOM tree. In some cases application needs to parse the whitespace-only
            contents of nodes, i.e. <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;</span>
            <span class="special">&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span></code>, but is not interested in whitespace
            markup elsewhere. It is possible to use <a class="link" href="loading.html#parse_ws_pcdata">parse_ws_pcdata</a>
            flag in this case, but it results in excessive allocations and complicates
            document processing in some cases; this flag is intended to avoid that.
            As an example, after parsing XML string <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;</span>
            <span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;</span> <span class="special">&lt;/</span><span class="identifier">a</span><span class="special">&gt;</span> <span class="special">&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span></code> with <code class="computeroutput"><span class="identifier">parse_ws_pcdata_single</span></code>
            flag set, <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;</span></code> element will have one child <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;</span></code>, and <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;</span></code>
            element will have one child with type <a class="link" href="dom.html#node_pcdata">node_pcdata</a>
            and value <code class="computeroutput"><span class="string">" "</span></code>.
            This flag has no effect if <a class="link" href="loading.html#parse_ws_pcdata">parse_ws_pcdata</a>
            is enabled. This flag is <span class="bold"><strong>off</strong></span> by default.
            <br><br>
          </li>
<li class="listitem">
            <a name="parse_fragment"></a><code class="literal">parse_fragment</code> determines if document
            should be treated as a fragment of a valid XML. Parsing document as a
            fragment leads to top-level PCDATA content (i.e. text that is not located
            inside a node) to be added to a tree, and additionally treats documents
            without element nodes as valid. This flag is <span class="bold"><strong>off</strong></span>
            by default.
          </li>
</ul></div>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          Using in-place parsing (<a class="link" href="loading.html#xml_document::load_buffer_inplace">load_buffer_inplace</a>)
          with <code class="computeroutput"><span class="identifier">parse_fragment</span></code> flag
          may result in the loss of the last character of the buffer if it is a part
          of PCDATA. Since PCDATA values are null-terminated strings, the only way
          to resolve this is to provide a null-terminated buffer as an input to
          <code class="computeroutput"><span class="identifier">load_buffer_inplace</span></code> - i.e.
          <code class="computeroutput"><span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_buffer_inplace</span><span class="special">(</span><span class="string">"test\0"</span><span class="special">,</span>
          <span class="number">5</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">parse_default</span> <span class="special">|</span>
          <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">parse_fragment</span><span class="special">)</span></code>.
        </p></td></tr>
</table></div>
<p>
        These flags control the transformation of tree element contents:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a name="parse_escapes"></a><code class="literal">parse_escapes</code> determines if character
            and entity references are to be expanded during the parsing process.
            Character references have the form <code class="literal">&amp;#...;</code> or
            <code class="literal">&amp;#x...;</code> (<code class="literal">...</code> is Unicode numeric
            representation of character in either decimal (<code class="literal">&amp;#...;</code>)
            or hexadecimal (<code class="literal">&amp;#x...;</code>) form), entity references
            are <code class="literal">&amp;lt;</code>, <code class="literal">&amp;gt;</code>, <code class="literal">&amp;amp;</code>,
            <code class="literal">&amp;apos;</code> and <code class="literal">&amp;quot;</code> (note
            that as pugixml does not handle DTD, the only allowed entities are predefined
            ones). If character/entity reference can not be expanded, it is left
            as is, so you can do additional processing later. Reference expansion
            is performed on attribute values and PCDATA content. This flag is <span class="bold"><strong>on</strong></span> by default. <br><br>
          </li>
<li class="listitem">
            <a name="parse_eol"></a><code class="literal">parse_eol</code> determines if EOL handling (that
            is, replacing sequences <code class="computeroutput"><span class="number">0x0d</span> <span class="number">0x0a</span></code> by a single <code class="computeroutput"><span class="number">0x0a</span></code>
            character, and replacing all standalone <code class="computeroutput"><span class="number">0x0d</span></code>
            characters by <code class="computeroutput"><span class="number">0x0a</span></code>) is to
            be performed on input data (that is, comments contents, PCDATA/CDATA
            contents and attribute values). This flag is <span class="bold"><strong>on</strong></span>
            by default. <br><br>
          </li>
<li class="listitem">
            <a name="parse_wconv_attribute"></a><code class="literal">parse_wconv_attribute</code> determines
            if attribute value normalization should be performed for all attributes.
            This means, that whitespace characters (new line, tab and space) are
            replaced with space (<code class="computeroutput"><span class="char">' '</span></code>).
            New line characters are always treated as if <a class="link" href="loading.html#parse_eol">parse_eol</a>
            is set, i.e. <code class="computeroutput"><span class="special">\</span><span class="identifier">r</span><span class="special">\</span><span class="identifier">n</span></code>
            is converted to a single space. This flag is <span class="bold"><strong>on</strong></span>
            by default. <br><br>
          </li>
<li class="listitem">
            <a name="parse_wnorm_attribute"></a><code class="literal">parse_wnorm_attribute</code> determines
            if extended attribute value normalization should be performed for all
            attributes. This means, that after attribute values are normalized as
            if <a class="link" href="loading.html#parse_wconv_attribute">parse_wconv_attribute</a>
            was set, leading and trailing space characters are removed, and all sequences
            of space characters are replaced by a single space character. <a class="link" href="loading.html#parse_wconv_attribute">parse_wconv_attribute</a>
            has no effect if this flag is on. This flag is <span class="bold"><strong>off</strong></span>
            by default.
          </li>
</ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><span class="identifier">parse_wconv_attribute</span></code> option
          performs transformations that are required by W3C specification for attributes
          that are declared as <code class="literal">CDATA</code>; <a class="link" href="loading.html#parse_wnorm_attribute">parse_wnorm_attribute</a>
          performs transformations required for <code class="literal">NMTOKENS</code> attributes.
          In the absence of document type declaration all attributes should behave
          as if they are declared as <code class="literal">CDATA</code>, thus <a class="link" href="loading.html#parse_wconv_attribute">parse_wconv_attribute</a>
          is the default option.
        </p></td></tr>
</table></div>
<p>
        Additionally there are three predefined option masks:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a name="parse_minimal"></a><code class="literal">parse_minimal</code> has all options turned
            off. This option mask means that pugixml does not add declaration nodes,
            document type declaration nodes, PI nodes, CDATA sections and comments
            to the resulting tree and does not perform any conversion for input data,
            so theoretically it is the fastest mode. However, as mentioned above,
            in practice <a class="link" href="loading.html#parse_default">parse_default</a> is usually
            equally fast. <br><br>
          </li>
<li class="listitem">
            <a name="parse_default"></a><code class="literal">parse_default</code> is the default set of flags,
            i.e. it has all options set to their default values. It includes parsing
            CDATA sections (comments/PIs are not parsed), performing character and
            entity reference expansion, replacing whitespace characters with spaces
            in attribute values and performing EOL handling. Note, that PCDATA sections
            consisting only of whitespace characters are not parsed (by default)
            for performance reasons. <br><br>
          </li>
<li class="listitem">
            <a name="parse_full"></a><code class="literal">parse_full</code> is the set of flags which adds
            nodes of all types to the resulting tree and performs default conversions
            for input data. It includes parsing CDATA sections, comments, PI nodes,
            document declaration node and document type declaration node, performing
            character and entity reference expansion, replacing whitespace characters
            with spaces in attribute values and performing EOL handling. Note, that
            PCDATA sections consisting only of whitespace characters are not parsed
            in this mode.
          </li>
</ul></div>
<p>
        This is an example of using different parsing options (<a href="../samples/load_options.cpp" target="_top">samples/load_options.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">source</span> <span class="special">=</span> <span class="string">"&lt;!--comment--&gt;&lt;node&gt;&amp;lt;&lt;/node&gt;"</span><span class="special">;</span>

<span class="comment">// Parsing with default options; note that comment node is not added to the tree, and entity reference &amp;lt; is expanded</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="identifier">source</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"First node value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">first_child</span><span class="special">().</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"], node child value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child_value</span><span class="special">(</span><span class="string">"node"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n"</span><span class="special">;</span>

<span class="comment">// Parsing with additional parse_comments option; comment node is now added to the tree</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="identifier">source</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">parse_default</span> <span class="special">|</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">parse_comments</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"First node value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">first_child</span><span class="special">().</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"], node child value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child_value</span><span class="special">(</span><span class="string">"node"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n"</span><span class="special">;</span>

<span class="comment">// Parsing with additional parse_comments option and without the (default) parse_escapes option; &amp;lt; is not expanded</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="identifier">source</span><span class="special">,</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">parse_default</span> <span class="special">|</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">parse_comments</span><span class="special">)</span> <span class="special">&amp;</span> <span class="special">~</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">parse_escapes</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"First node value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">first_child</span><span class="special">().</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"], node child value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child_value</span><span class="special">(</span><span class="string">"node"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n"</span><span class="special">;</span>

<span class="comment">// Parsing with minimal option mask; comment node is not added to the tree, and &amp;lt; is not expanded</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="identifier">source</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">parse_minimal</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"First node value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">first_child</span><span class="special">().</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"], node child value: ["</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child_value</span><span class="special">(</span><span class="string">"node"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n"</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.loading.encoding"></a><a class="link" href="loading.html#manual.loading.encoding" title="Encodings">Encodings</a>
</h3></div></div></div>
<p>
        <a name="xml_encoding"></a>pugixml supports all popular Unicode encodings
        (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2
        is naturally supported since it's a strict subset of UTF-16) and handles
        all encoding conversions. Most loading functions accept the optional parameter
        <code class="computeroutput"><span class="identifier">encoding</span></code>. This is a value
        of enumeration type <code class="computeroutput"><span class="identifier">xml_encoding</span></code>,
        that can have the following values:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a name="encoding_auto"></a><code class="literal">encoding_auto</code> means that pugixml will
            try to guess the encoding based on source XML data. The algorithm is
            a modified version of the one presented in Appendix F.1 of XML recommendation;
            it tries to match the first few bytes of input data with the following
            patterns in strict order: <br><br>
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  If first four bytes match UTF-32 BOM (Byte Order Mark), encoding
                  is assumed to be UTF-32 with the endianness equal to that of BOM;
                </li>
<li class="listitem">
                  If first two bytes match UTF-16 BOM, encoding is assumed to be
                  UTF-16 with the endianness equal to that of BOM;
                </li>
<li class="listitem">
                  If first three bytes match UTF-8 BOM, encoding is assumed to be
                  UTF-8;
                </li>
<li class="listitem">
                  If first four bytes match UTF-32 representation of <code class="literal">&lt;</code>,
                  encoding is assumed to be UTF-32 with the corresponding endianness;
                </li>
<li class="listitem">
                  If first four bytes match UTF-16 representation of <code class="literal">&lt;?</code>,
                  encoding is assumed to be UTF-16 with the corresponding endianness;
                </li>
<li class="listitem">
                  If first two bytes match UTF-16 representation of <code class="literal">&lt;</code>,
                  encoding is assumed to be UTF-16 with the corresponding endianness
                  (this guess may yield incorrect result, but it's better than UTF-8);
                </li>
<li class="listitem">
                  Otherwise encoding is assumed to be UTF-8. <br><br>
                </li>
</ul></div>
          </li>
<li class="listitem">
            <a name="encoding_utf8"></a><code class="literal">encoding_utf8</code> corresponds to UTF-8 encoding
            as defined in the Unicode standard; UTF-8 sequences with length equal
            to 5 or 6 are not standard and are rejected.
          </li>
<li class="listitem">
            <a name="encoding_utf16_le"></a><code class="literal">encoding_utf16_le</code> corresponds to
            little-endian UTF-16 encoding as defined in the Unicode standard; surrogate
            pairs are supported.
          </li>
<li class="listitem">
            <a name="encoding_utf16_be"></a><code class="literal">encoding_utf16_be</code> corresponds to
            big-endian UTF-16 encoding as defined in the Unicode standard; surrogate
            pairs are supported.
          </li>
<li class="listitem">
            <a name="encoding_utf16"></a><code class="literal">encoding_utf16</code> corresponds to UTF-16
            encoding as defined in the Unicode standard; the endianness is assumed
            to be that of the target platform.
          </li>
<li class="listitem">
            <a name="encoding_utf32_le"></a><code class="literal">encoding_utf32_le</code> corresponds to
            little-endian UTF-32 encoding as defined in the Unicode standard.
          </li>
<li class="listitem">
            <a name="encoding_utf32_be"></a><code class="literal">encoding_utf32_be</code> corresponds to
            big-endian UTF-32 encoding as defined in the Unicode standard.
          </li>
<li class="listitem">
            <a name="encoding_utf32"></a><code class="literal">encoding_utf32</code> corresponds to UTF-32
            encoding as defined in the Unicode standard; the endianness is assumed
            to be that of the target platform.
          </li>
<li class="listitem">
            <a name="encoding_wchar"></a><code class="literal">encoding_wchar</code> corresponds to the encoding
            of <code class="computeroutput"><span class="keyword">wchar_t</span></code> type; it has
            the same meaning as either <code class="computeroutput"><span class="identifier">encoding_utf16</span></code>
            or <code class="computeroutput"><span class="identifier">encoding_utf32</span></code>, depending
            on <code class="computeroutput"><span class="keyword">wchar_t</span></code> size.
          </li>
<li class="listitem">
            <a name="encoding_latin1"></a><code class="literal">encoding_latin1</code> corresponds to ISO-8859-1
            encoding (also known as Latin-1).
          </li>
</ul></div>
<p>
        The algorithm used for <code class="computeroutput"><span class="identifier">encoding_auto</span></code>
        correctly detects any supported Unicode encoding for all well-formed XML
        documents (since they start with document declaration) and for all other
        XML documents that start with <code class="literal">&lt;</code>; if your XML document
        does not start with <code class="literal">&lt;</code> and has encoding that is different
        from UTF-8, use the specific encoding.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          The current behavior for Unicode conversion is to skip all invalid UTF
          sequences during conversion. This behavior should not be relied upon; moreover,
          in case no encoding conversion is performed, the invalid sequences are
          not removed, so you'll get them as is in node/attribute contents.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.loading.w3c"></a><a class="link" href="loading.html#manual.loading.w3c" title="Conformance to W3C specification">Conformance to W3C specification</a>
</h3></div></div></div>
<p>
        pugixml is not fully W3C conformant - it can load any valid XML document,
        but does not perform some well-formedness checks. While considerable effort
        is made to reject invalid XML documents, some validation is not performed
        because of performance reasons.
      </p>
<p>
        There is only one non-conformant behavior when dealing with valid XML documents:
        pugixml does not use information supplied in document type declaration for
        parsing. This means that entities declared in DOCTYPE are not expanded, and
        all attribute/PCDATA values are always processed in a uniform way that depends
        only on parsing options.
      </p>
<p>
        As for rejecting invalid XML documents, there are a number of incompatibilities
        with W3C specification, including:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Multiple attributes of the same node can have equal names.
          </li>
<li class="listitem">
            All non-ASCII characters are treated in the same way as symbols of English
            alphabet, so some invalid tag names are not rejected.
          </li>
<li class="listitem">
            Attribute values which contain <code class="literal">&lt;</code> are not rejected.
          </li>
<li class="listitem">
            Invalid entity/character references are not rejected and are instead
            left as is.
          </li>
<li class="listitem">
            Comment values can contain <code class="literal">--</code>.
          </li>
<li class="listitem">
            XML data is not required to begin with document declaration; additionally,
            document declaration can appear after comments and other nodes.
          </li>
<li class="listitem">
            Invalid document type declarations are silently ignored in some cases.
          </li>
</ul></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Arseny Kapoulkine<p>
        Distributed under the MIT License
      </p>
</div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <b>Loading</b> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="dom.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="access.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual/modify.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Modifying document data</title>
<link rel="stylesheet" href="../pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../manual.html" title="pugixml 1.4">
<link rel="up" href="../manual.html" title="pugixml 1.4">
<link rel="prev" href="access.html" title="Accessing document data">
<link rel="next" href="saving.html" title="Saving document">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <b>Modifying</b> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="access.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="saving.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
<hr>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.modify"></a><a class="link" href="modify.html" title="Modifying document data">Modifying document data</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="modify.html#manual.modify.nodedata">Setting node data</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.attrdata">Setting attribute data</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.add">Adding nodes/attributes</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.remove">Removing nodes/attributes</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.text">Working with text contents</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.clone">Cloning nodes/attributes</a></span></dt>
<dt><span class="section"><a href="modify.html#manual.modify.fragments">Assembling document from fragments</a></span></dt>
</dl></div>
<p>
      The document in pugixml is fully mutable: you can completely change the document
      structure and modify the data of nodes/attributes. This section provides documentation
      for the relevant functions. All functions take care of memory management and
      structural integrity themselves, so they always result in structurally valid
      tree - however, it is possible to create an invalid XML tree (for example,
      by adding two attributes with the same name or by setting attribute/node name
      to empty/invalid string). Tree modification is optimized for performance and
      for memory consumption, so if you have enough memory you can create documents
      from scratch with pugixml and later save them to file/stream instead of relying
      on error-prone manual text writing and without too much overhead.
    </p>
<p>
      All member functions that change node/attribute data or structure are non-constant
      and thus can not be called on constant handles. However, you can easily convert
      constant handle to non-constant one by simple assignment: <code class="computeroutput"><span class="keyword">void</span>
      <span class="identifier">foo</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span>
      <span class="special">{</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">nc</span> <span class="special">=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">}</span></code>, so const-correctness
      here mainly provides additional documentation.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.modify.nodedata"></a><a class="link" href="modify.html#manual.modify.nodedata" title="Setting node data">Setting node data</a>
</h3></div></div></div>
<p>
        <a name="xml_node::set_name"></a><a name="xml_node::set_value"></a>As discussed
        before, nodes can have name and value, both of which are strings. Depending
        on node type, name or value may be absent. <a class="link" href="dom.html#node_document">node_document</a>
        nodes do not have a name or value, <a class="link" href="dom.html#node_element">node_element</a>
        and <a class="link" href="dom.html#node_declaration">node_declaration</a> nodes always
        have a name but never have a value, <a class="link" href="dom.html#node_pcdata">node_pcdata</a>,
        <a class="link" href="dom.html#node_cdata">node_cdata</a>, <a class="link" href="dom.html#node_comment">node_comment</a>
        and <a class="link" href="dom.html#node_doctype">node_doctype</a> nodes never have a name
        but always have a value (it may be empty though), <a class="link" href="dom.html#node_pi">node_pi</a>
        nodes always have a name and a value (again, value may be empty). In order
        to set node's name or value, you can use the following functions:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">set_name</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">set_value</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<p>
        Both functions try to set the name/value to the specified string, and return
        the operation result. The operation fails if the node can not have name or
        value (for instance, when trying to call <code class="computeroutput"><span class="identifier">set_name</span></code>
        on a <a class="link" href="dom.html#node_pcdata">node_pcdata</a> node), if the node handle
        is null, or if there is insufficient memory to handle the request. The provided
        string is copied into document managed memory and can be destroyed after
        the function returns (for example, you can safely pass stack-allocated buffers
        to these functions). The name/value content is not verified, so take care
        to use only valid XML names, or the document may become malformed.
      </p>
<p>
        There is no equivalent of <a class="link" href="access.html#xml_node::child_value">child_value</a>
        function for modifying text children of the node.
      </p>
<p>
        This is an example of setting node name and value (<a href="../samples/modify_base.cpp" target="_top">samples/modify_base.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"node"</span><span class="special">);</span>

<span class="comment">// change node name</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">set_name</span><span class="special">(</span><span class="string">"notnode"</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", new node name: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// change comment text</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">last_child</span><span class="special">().</span><span class="identifier">set_value</span><span class="special">(</span><span class="string">"useless comment"</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", new comment text: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">last_child</span><span class="special">().</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// we can't change value of the element or name of the comment</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span><span class="string">"1"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">last_child</span><span class="special">().</span><span class="identifier">set_name</span><span class="special">(</span><span class="string">"2"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.modify.attrdata"></a><a class="link" href="modify.html#manual.modify.attrdata" title="Setting attribute data">Setting attribute data</a>
</h3></div></div></div>
<p>
        <a name="xml_attribute::set_name"></a><a name="xml_attribute::set_value"></a>All
        attributes have name and value, both of which are strings (value may be empty).
        You can set them with the following functions:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">set_name</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">set_value</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<p>
        Both functions try to set the name/value to the specified string, and return
        the operation result. The operation fails if the attribute handle is null,
        or if there is insufficient memory to handle the request. The provided string
        is copied into document managed memory and can be destroyed after the function
        returns (for example, you can safely pass stack-allocated buffers to these
        functions). The name/value content is not verified, so take care to use only
        valid XML names, or the document may become malformed.
      </p>
<p>
        In addition to string functions, several functions are provided for handling
        attributes with numbers and booleans as values:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">set_value</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">set_value</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">set_value</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">set_value</span><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">set_value</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">set_value</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<p>
        The above functions convert the argument to string and then call the base
        <code class="computeroutput"><span class="identifier">set_value</span></code> function. Integers
        are converted to a decimal form, floating-point numbers are converted to
        either decimal or scientific form, depending on the number magnitude, boolean
        values are converted to either <code class="computeroutput"><span class="string">"true"</span></code>
        or <code class="computeroutput"><span class="string">"false"</span></code>.
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          Number conversion functions depend on current C locale as set with <code class="computeroutput"><span class="identifier">setlocale</span></code>, so may generate unexpected
          results if the locale is different from <code class="computeroutput"><span class="string">"C"</span></code>.
        </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><span class="identifier">set_value</span></code> overloads with
          <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
          type are only available if your platform has reliable support for the type,
          including string conversions.
        </p></td></tr>
</table></div>
<p>
        <a name="xml_attribute::assign"></a>For convenience, all <code class="computeroutput"><span class="identifier">set_value</span></code>
        functions have the corresponding assignment operators:
      </p>
<pre class="programlisting"><span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">double</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">bool</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<p>
        These operators simply call the right <code class="computeroutput"><span class="identifier">set_value</span></code>
        function and return the attribute they're called on; the return value of
        <code class="computeroutput"><span class="identifier">set_value</span></code> is ignored, so
        errors are ignored.
      </p>
<p>
        This is an example of setting attribute name and value (<a href="../samples/modify_base.cpp" target="_top">samples/modify_base.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_attribute</span> <span class="identifier">attr</span> <span class="special">=</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"id"</span><span class="special">);</span>

<span class="comment">// change attribute name/value</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">set_name</span><span class="special">(</span><span class="string">"key"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span><span class="string">"345"</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", new attribute: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"="</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// we can use numbers or booleans</span>
<span class="identifier">attr</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span><span class="number">1.234</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"new attribute value: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// we can also use assignment operators for more concise code</span>
<span class="identifier">attr</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"final attribute value: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.modify.add"></a><a class="link" href="modify.html#manual.modify.add" title="Adding nodes/attributes">Adding nodes/attributes</a>
</h3></div></div></div>
<p>
        <a name="xml_node::prepend_attribute"></a><a name="xml_node::append_attribute"></a><a name="xml_node::insert_attribute_after"></a><a name="xml_node::insert_attribute_before"></a><a name="xml_node::prepend_child"></a><a name="xml_node::append_child"></a><a name="xml_node::insert_child_after"></a><a name="xml_node::insert_child_before"></a>Nodes
        and attributes do not exist without a document tree, so you can't create
        them without adding them to some document. A node or attribute can be created
        at the end of node/attribute list or before/after some other node:
      </p>
<pre class="programlisting"><span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">append_attribute</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">);</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">prepend_attribute</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">);</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">insert_attribute_after</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">attr</span><span class="special">);</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">insert_attribute_before</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">attr</span><span class="special">);</span>

<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">append_child</span><span class="special">(</span><span class="identifier">xml_node_type</span> <span class="identifier">type</span> <span class="special">=</span> <span class="identifier">node_element</span><span class="special">);</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">prepend_child</span><span class="special">(</span><span class="identifier">xml_node_type</span> <span class="identifier">type</span> <span class="special">=</span> <span class="identifier">node_element</span><span class="special">);</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">insert_child_after</span><span class="special">(</span><span class="identifier">xml_node_type</span> <span class="identifier">type</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">insert_child_before</span><span class="special">(</span><span class="identifier">xml_node_type</span> <span class="identifier">type</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span>

<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">append_child</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">);</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">prepend_child</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">);</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">insert_child_after</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">insert_child_before</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">append_attribute</span></code> and <code class="computeroutput"><span class="identifier">append_child</span></code> create a new node/attribute
        at the end of the corresponding list of the node the method is called on;
        <code class="computeroutput"><span class="identifier">prepend_attribute</span></code> and <code class="computeroutput"><span class="identifier">prepend_child</span></code> create a new node/attribute
        at the beginning of the list; <code class="computeroutput"><span class="identifier">insert_attribute_after</span></code>,
        <code class="computeroutput"><span class="identifier">insert_attribute_before</span></code>,
        <code class="computeroutput"><span class="identifier">insert_child_after</span></code> and <code class="computeroutput"><span class="identifier">insert_attribute_before</span></code> add the node/attribute
        before or after the specified node/attribute.
      </p>
<p>
        Attribute functions create an attribute with the specified name; you can
        specify the empty name and change the name later if you want to. Node functions
        with the <code class="computeroutput"><span class="identifier">type</span></code> argument create
        the node with the specified type; since node type can't be changed, you have
        to know the desired type beforehand. Also note that not all types can be
        added as children; see below for clarification. Node functions with the
        <code class="computeroutput"><span class="identifier">name</span></code> argument create the
        element node (<a class="link" href="dom.html#node_element">node_element</a>) with the
        specified name.
      </p>
<p>
        All functions return the handle to the created object on success, and null
        handle on failure. There are several reasons for failure:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Adding fails if the target node is null;
          </li>
<li class="listitem">
            Only <a class="link" href="dom.html#node_element">node_element</a> nodes can contain
            attributes, so attribute adding fails if node is not an element;
          </li>
<li class="listitem">
            Only <a class="link" href="dom.html#node_document">node_document</a> and <a class="link" href="dom.html#node_element">node_element</a>
            nodes can contain children, so child node adding fails if the target
            node is not an element or a document;
          </li>
<li class="listitem">
            <a class="link" href="dom.html#node_document">node_document</a> and <a class="link" href="dom.html#node_null">node_null</a>
            nodes can not be inserted as children, so passing <a class="link" href="dom.html#node_document">node_document</a>
            or <a class="link" href="dom.html#node_null">node_null</a> value as <code class="computeroutput"><span class="identifier">type</span></code> results in operation failure;
          </li>
<li class="listitem">
            <a class="link" href="dom.html#node_declaration">node_declaration</a> nodes can only
            be added as children of the document node; attempt to insert declaration
            node as a child of an element node fails;
          </li>
<li class="listitem">
            Adding node/attribute results in memory allocation, which may fail;
          </li>
<li class="listitem">
            Insertion functions fail if the specified node or attribute is null or
            is not in the target node's children/attribute list.
          </li>
</ul></div>
<p>
        Even if the operation fails, the document remains in consistent state, but
        the requested node/attribute is not added.
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          attribute() and child() functions do not add attributes or nodes to the
          tree, so code like <code class="computeroutput"><span class="identifier">node</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"id"</span><span class="special">)</span> <span class="special">=</span> <span class="number">123</span><span class="special">;</span></code> will not do anything if <code class="computeroutput"><span class="identifier">node</span></code> does not have an attribute with
          name <code class="computeroutput"><span class="string">"id"</span></code>. Make sure
          you're operating with existing attributes/nodes by adding them if necessary.
        </p></td></tr>
</table></div>
<p>
        This is an example of adding new attributes/nodes to the document (<a href="../samples/modify_add.cpp" target="_top">samples/modify_add.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// add node with some name</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">append_child</span><span class="special">(</span><span class="string">"node"</span><span class="special">);</span>

<span class="comment">// add description node with text child</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">descr</span> <span class="special">=</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">append_child</span><span class="special">(</span><span class="string">"description"</span><span class="special">);</span>
<span class="identifier">descr</span><span class="special">.</span><span class="identifier">append_child</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">node_pcdata</span><span class="special">).</span><span class="identifier">set_value</span><span class="special">(</span><span class="string">"Simple node"</span><span class="special">);</span>

<span class="comment">// add param node before the description</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">param</span> <span class="special">=</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">insert_child_before</span><span class="special">(</span><span class="string">"param"</span><span class="special">,</span> <span class="identifier">descr</span><span class="special">);</span>

<span class="comment">// add attributes to param node</span>
<span class="identifier">param</span><span class="special">.</span><span class="identifier">append_attribute</span><span class="special">(</span><span class="string">"name"</span><span class="special">)</span> <span class="special">=</span> <span class="string">"version"</span><span class="special">;</span>
<span class="identifier">param</span><span class="special">.</span><span class="identifier">append_attribute</span><span class="special">(</span><span class="string">"value"</span><span class="special">)</span> <span class="special">=</span> <span class="number">1.1</span><span class="special">;</span>
<span class="identifier">param</span><span class="special">.</span><span class="identifier">insert_attribute_after</span><span class="special">(</span><span class="string">"type"</span><span class="special">,</span> <span class="identifier">param</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"name"</span><span class="special">))</span> <span class="special">=</span> <span class="string">"float"</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.modify.remove"></a><a class="link" href="modify.html#manual.modify.remove" title="Removing nodes/attributes">Removing nodes/attributes</a>
</h3></div></div></div>
<p>
        <a name="xml_node::remove_attribute"></a><a name="xml_node::remove_child"></a>If
        you do not want your document to contain some node or attribute, you can
        remove it with one of the following functions:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">remove_attribute</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">a</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">remove_child</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">);</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">remove_attribute</span></code> removes
        the attribute from the attribute list of the node, and returns the operation
        result. <code class="computeroutput"><span class="identifier">remove_child</span></code> removes
        the child node with the entire subtree (including all descendant nodes and
        attributes) from the document, and returns the operation result. Removing
        fails if one of the following is true:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            The node the function is called on is null;
          </li>
<li class="listitem">
            The attribute/node to be removed is null;
          </li>
<li class="listitem">
            The attribute/node to be removed is not in the node's attribute/child
            list.
          </li>
</ul></div>
<p>
        Removing the attribute or node invalidates all handles to the same underlying
        object, and also invalidates all iterators pointing to the same object. Removing
        node also invalidates all past-the-end iterators to its attribute or child
        node list. Be careful to ensure that all such handles and iterators either
        do not exist or are not used after the attribute/node is removed.
      </p>
<p>
        If you want to remove the attribute or child node by its name, two additional
        helper functions are available:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">remove_attribute</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">remove_child</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">);</span>
</pre>
<p>
        These functions look for the first attribute or child with the specified
        name, and then remove it, returning the result. If there is no attribute
        or child with such name, the function returns <code class="computeroutput"><span class="keyword">false</span></code>;
        if there are two nodes with the given name, only the first node is deleted.
        If you want to delete all nodes with the specified name, you can use code
        like this: <code class="computeroutput"><span class="keyword">while</span> <span class="special">(</span><span class="identifier">node</span><span class="special">.</span><span class="identifier">remove_child</span><span class="special">(</span><span class="string">"tool"</span><span class="special">))</span> <span class="special">;</span></code>.
      </p>
<p>
        This is an example of removing attributes/nodes from the document (<a href="../samples/modify_remove.cpp" target="_top">samples/modify_remove.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// remove description node with the whole subtree</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"node"</span><span class="special">);</span>
<span class="identifier">node</span><span class="special">.</span><span class="identifier">remove_child</span><span class="special">(</span><span class="string">"description"</span><span class="special">);</span>

<span class="comment">// remove id attribute</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">param</span> <span class="special">=</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"param"</span><span class="special">);</span>
<span class="identifier">param</span><span class="special">.</span><span class="identifier">remove_attribute</span><span class="special">(</span><span class="string">"value"</span><span class="special">);</span>

<span class="comment">// we can also remove nodes/attributes by handles</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_attribute</span> <span class="identifier">id</span> <span class="special">=</span> <span class="identifier">param</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"name"</span><span class="special">);</span>
<span class="identifier">param</span><span class="special">.</span><span class="identifier">remove_attribute</span><span class="special">(</span><span class="identifier">id</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.modify.text"></a><a class="link" href="modify.html#manual.modify.text" title="Working with text contents">Working with text contents</a>
</h3></div></div></div>
<p>
        pugixml provides a special class, <code class="computeroutput"><span class="identifier">xml_text</span></code>,
        to work with text contents stored as a value of some node, i.e. <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;&lt;</span><span class="identifier">description</span><span class="special">&gt;</span><span class="identifier">This</span> <span class="identifier">is</span> <span class="identifier">a</span> <span class="identifier">node</span><span class="special">&lt;/</span><span class="identifier">description</span><span class="special">&gt;&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span></code>.
        Working with text objects to retrieve data is described in <a class="link" href="access.html#manual.access.text" title="Working with text contents">the
        documentation for accessing document data</a>; this section describes
        the modification interface of <code class="computeroutput"><span class="identifier">xml_text</span></code>.
      </p>
<p>
        <a name="xml_text::set"></a>Once you have an <code class="computeroutput"><span class="identifier">xml_text</span></code>
        object, you can set the text contents using the following function:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<p>
        This function tries to set the contents to the specified string, and returns
        the operation result. The operation fails if the text object was retrieved
        from a node that can not have a value and is not an element node (i.e. it
        is a <a class="link" href="dom.html#node_declaration">node_declaration</a> node), if the
        text object is empty, or if there is insufficient memory to handle the request.
        The provided string is copied into document managed memory and can be destroyed
        after the function returns (for example, you can safely pass stack-allocated
        buffers to this function). Note that if the text object was retrieved from
        an element node, this function creates the PCDATA child node if necessary
        (i.e. if the element node does not have a PCDATA/CDATA child already).
      </p>
<p>
        <a name="xml_text::set_value"></a>In addition to a string function, several
        functions are provided for handling text with numbers and booleans as contents:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<p>
        The above functions convert the argument to string and then call the base
        <code class="computeroutput"><span class="identifier">set</span></code> function. These functions
        have the same semantics as similar <code class="computeroutput"><span class="identifier">xml_attribute</span></code>
        functions. You can <a class="link" href="modify.html#xml_attribute::set_value">refer to documentation
        for the attribute functions</a> for details.
      </p>
<p>
        <a name="xml_text::assign"></a>For convenience, all <code class="computeroutput"><span class="identifier">set</span></code>
        functions have the corresponding assignment operators:
      </p>
<pre class="programlisting"><span class="identifier">xml_text</span><span class="special">&amp;</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_text</span><span class="special">&amp;</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_text</span><span class="special">&amp;</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_text</span><span class="special">&amp;</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">double</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_text</span><span class="special">&amp;</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">bool</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_text</span><span class="special">&amp;</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span>
<span class="identifier">xml_text</span><span class="special">&amp;</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<p>
        These operators simply call the right <code class="computeroutput"><span class="identifier">set</span></code>
        function and return the attribute they're called on; the return value of
        <code class="computeroutput"><span class="identifier">set</span></code> is ignored, so errors
        are ignored.
      </p>
<p>
        This is an example of using <code class="computeroutput"><span class="identifier">xml_text</span></code>
        object to modify text contents (<a href="../samples/text.cpp" target="_top">samples/text.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// change project version</span>
<span class="identifier">project</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"version"</span><span class="special">).</span><span class="identifier">text</span><span class="special">()</span> <span class="special">=</span> <span class="number">1.2</span><span class="special">;</span>

<span class="comment">// add description element and set the contents</span>
<span class="comment">// note that we do not have to explicitly add the node_pcdata child</span>
<span class="identifier">project</span><span class="special">.</span><span class="identifier">append_child</span><span class="special">(</span><span class="string">"description"</span><span class="special">).</span><span class="identifier">text</span><span class="special">().</span><span class="identifier">set</span><span class="special">(</span><span class="string">"a test project"</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.modify.clone"></a><a class="link" href="modify.html#manual.modify.clone" title="Cloning nodes/attributes">Cloning nodes/attributes</a>
</h3></div></div></div>
<p>
        <a name="xml_node::prepend_copy"></a><a name="xml_node::append_copy"></a><a name="xml_node::insert_copy_after"></a><a name="xml_node::insert_copy_before"></a>With
        the help of previously described functions, it is possible to create trees
        with any contents and structure, including cloning the existing data. However
        since this is an often needed operation, pugixml provides built-in node/attribute
        cloning facilities. Since nodes and attributes do not exist without a document
        tree, you can't create a standalone copy - you have to immediately insert
        it somewhere in the tree. For this, you can use one of the following functions:
      </p>
<pre class="programlisting"><span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">append_copy</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">proto</span><span class="special">);</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">prepend_copy</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">proto</span><span class="special">);</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">insert_copy_after</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">proto</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">attr</span><span class="special">);</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">insert_copy_before</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">proto</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">attr</span><span class="special">);</span>

<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">append_copy</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">proto</span><span class="special">);</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">prepend_copy</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">proto</span><span class="special">);</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">insert_copy_after</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">proto</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">insert_copy_before</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">proto</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span>
</pre>
<p>
        These functions mirror the structure of <code class="computeroutput"><span class="identifier">append_child</span></code>,
        <code class="computeroutput"><span class="identifier">prepend_child</span></code>, <code class="computeroutput"><span class="identifier">insert_child_before</span></code> and related functions
        - they take the handle to the prototype object, which is to be cloned, insert
        a new attribute/node at the appropriate place, and then copy the attribute
        data or the whole node subtree to the new object. The functions return the
        handle to the resulting duplicate object, or null handle on failure.
      </p>
<p>
        The attribute is copied along with the name and value; the node is copied
        along with its type, name and value; additionally attribute list and all
        children are recursively cloned, resulting in the deep subtree clone. The
        prototype object can be a part of the same document, or a part of any other
        document.
      </p>
<p>
        The failure conditions resemble those of <code class="computeroutput"><span class="identifier">append_child</span></code>,
        <code class="computeroutput"><span class="identifier">insert_child_before</span></code> and related
        functions, <a class="link" href="modify.html#xml_node::append_child">consult their documentation
        for more information</a>. There are additional caveats specific to cloning
        functions:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Cloning null handles results in operation failure;
          </li>
<li class="listitem">
            Node cloning starts with insertion of the node of the same type as that
            of the prototype; for this reason, cloning functions can not be directly
            used to clone entire documents, since <a class="link" href="dom.html#node_document">node_document</a>
            is not a valid insertion type. The example below provides a workaround.
          </li>
<li class="listitem">
            It is possible to copy a subtree as a child of some node inside this
            subtree, i.e. <code class="computeroutput"><span class="identifier">node</span><span class="special">.</span><span class="identifier">append_copy</span><span class="special">(</span><span class="identifier">node</span><span class="special">.</span><span class="identifier">parent</span><span class="special">().</span><span class="identifier">parent</span><span class="special">());</span></code>.
            This is a valid operation, and it results in a clone of the subtree in
            the state before cloning started, i.e. no infinite recursion takes place.
          </li>
</ul></div>
<p>
        This is an example with one possible implementation of include tags in XML
        (<a href="../samples/include.cpp" target="_top">samples/include.cpp</a>). It illustrates
        node cloning and usage of other document modification functions:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">load_preprocess</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span><span class="special">&amp;</span> <span class="identifier">doc</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">path</span><span class="special">);</span>

<span class="keyword">bool</span> <span class="identifier">preprocess</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">child</span> <span class="special">=</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">first_child</span><span class="special">();</span> <span class="identifier">child</span><span class="special">;</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">child</span><span class="special">.</span><span class="identifier">type</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">node_pi</span> <span class="special">&amp;&amp;</span> <span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">child</span><span class="special">.</span><span class="identifier">name</span><span class="special">(),</span> <span class="string">"include"</span><span class="special">)</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">include</span> <span class="special">=</span> <span class="identifier">child</span><span class="special">;</span>

            <span class="comment">// load new preprocessed document (note: ideally this should handle relative paths)</span>
            <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">path</span> <span class="special">=</span> <span class="identifier">include</span><span class="special">.</span><span class="identifier">value</span><span class="special">();</span>

            <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span> <span class="identifier">doc</span><span class="special">;</span>
            <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">load_preprocess</span><span class="special">(</span><span class="identifier">doc</span><span class="special">,</span> <span class="identifier">path</span><span class="special">))</span> <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>

            <span class="comment">// insert the comment marker above include directive</span>
            <span class="identifier">node</span><span class="special">.</span><span class="identifier">insert_child_before</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">node_comment</span><span class="special">,</span> <span class="identifier">include</span><span class="special">).</span><span class="identifier">set_value</span><span class="special">(</span><span class="identifier">path</span><span class="special">);</span>

            <span class="comment">// copy the document above the include directive (this retains the original order!)</span>
            <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">ic</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">first_child</span><span class="special">();</span> <span class="identifier">ic</span><span class="special">;</span> <span class="identifier">ic</span> <span class="special">=</span> <span class="identifier">ic</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">())</span>
            <span class="special">{</span>
                <span class="identifier">node</span><span class="special">.</span><span class="identifier">insert_copy_before</span><span class="special">(</span><span class="identifier">ic</span><span class="special">,</span> <span class="identifier">include</span><span class="special">);</span>
            <span class="special">}</span>

            <span class="comment">// remove the include node and move to the next child</span>
            <span class="identifier">child</span> <span class="special">=</span> <span class="identifier">child</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">();</span>

            <span class="identifier">node</span><span class="special">.</span><span class="identifier">remove_child</span><span class="special">(</span><span class="identifier">include</span><span class="special">);</span>
        <span class="special">}</span>
        <span class="keyword">else</span>
        <span class="special">{</span>
            <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">preprocess</span><span class="special">(</span><span class="identifier">child</span><span class="special">))</span> <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>

            <span class="identifier">child</span> <span class="special">=</span> <span class="identifier">child</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">();</span>
        <span class="special">}</span>
    <span class="special">}</span>

    <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">bool</span> <span class="identifier">load_preprocess</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span><span class="special">&amp;</span> <span class="identifier">doc</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">path</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_parse_result</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_file</span><span class="special">(</span><span class="identifier">path</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">parse_default</span> <span class="special">|</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">parse_pi</span><span class="special">);</span> <span class="comment">// for &lt;?include?&gt;</span>

    <span class="keyword">return</span> <span class="identifier">result</span> <span class="special">?</span> <span class="identifier">preprocess</span><span class="special">(</span><span class="identifier">doc</span><span class="special">)</span> <span class="special">:</span> <span class="keyword">false</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.modify.fragments"></a><a class="link" href="modify.html#manual.modify.fragments" title="Assembling document from fragments">Assembling document from fragments</a>
</h3></div></div></div>
<p>
        <a name="xml_node::append_buffer"></a>pugixml provides several ways to assemble
        an XML document from other XML documents. Assuming there is a set of document
        fragments, represented as in-memory buffers, the implementation choices are
        as follows:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Use a temporary document to parse the data from a string, then clone
            the nodes to a destination node. For example:
          </li></ul></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">append_fragment</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">target</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span> <span class="identifier">doc</span><span class="special">;</span>
    <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">doc</span><span class="special">.</span><span class="identifier">load_buffer</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">size</span><span class="special">))</span> <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>

    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">child</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">first_child</span><span class="special">();</span> <span class="identifier">child</span><span class="special">;</span> <span class="identifier">child</span> <span class="special">=</span> <span class="identifier">child</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">())</span>
        <span class="identifier">target</span><span class="special">.</span><span class="identifier">append_copy</span><span class="special">(</span><span class="identifier">child</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Cache the parsing step - instead of keeping in-memory buffers, keep document
            objects that already contain the parsed fragment:
          </li></ul></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">append_fragment</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">target</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span><span class="special">&amp;</span> <span class="identifier">cached_fragment</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">child</span> <span class="special">=</span> <span class="identifier">cached_fragment</span><span class="special">.</span><span class="identifier">first_child</span><span class="special">();</span> <span class="identifier">child</span><span class="special">;</span> <span class="identifier">child</span> <span class="special">=</span> <span class="identifier">child</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">())</span>
        <span class="identifier">target</span><span class="special">.</span><span class="identifier">append_copy</span><span class="special">(</span><span class="identifier">child</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Use xml_node::append_buffer directly:
          </li></ul></div>
<pre class="programlisting"><span class="identifier">xml_parse_result</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">append_buffer</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">void</span><span class="special">*</span> <span class="identifier">contents</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">options</span> <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span>
</pre>
<p>
        The first method is more convenient, but slower than the other two. The relative
        performance of <code class="computeroutput"><span class="identifier">append_copy</span></code>
        and <code class="computeroutput"><span class="identifier">append_buffer</span></code> depends
        on the buffer format - usually <code class="computeroutput"><span class="identifier">append_buffer</span></code>
        is faster if the buffer is in native encoding (UTF-8 or wchar_t, depending
        on <code class="computeroutput"><span class="identifier">PUGIXML_WCHAR_MODE</span></code>). At
        the same time it might be less efficient in terms of memory usage - the implementation
        makes a copy of the provided buffer, and the copy has the same lifetime as
        the document - the memory used by that copy will be reclaimed after the document
        is destroyed, but no sooner. Even deleting all nodes in the document, including
        the appended ones, won't reclaim the memory.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">append_buffer</span></code> behaves in
        the same way as <a class="link" href="loading.html#xml_document::load_buffer">xml_document::load_buffer</a>
        - the input buffer is a byte buffer, with size in bytes; the buffer is not
        modified and can be freed after the function returns.
      </p>
<p>
        <a name="status_append_invalid_root"></a>Since <code class="computeroutput"><span class="identifier">append_buffer</span></code>
        needs to append child nodes to the current node, it only works if the current
        node is either document or element node. Calling <code class="computeroutput"><span class="identifier">append_buffer</span></code>
        on a node with any other type results in an error with <code class="computeroutput"><span class="identifier">status_append_invalid_root</span></code>
        status.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Arseny Kapoulkine<p>
        Distributed under the MIT License
      </p>
</div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <b>Modifying</b> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="access.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="saving.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual/apiref.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>API Reference</title>
<link rel="stylesheet" href="../pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../manual.html" title="pugixml 1.4">
<link rel="up" href="../manual.html" title="pugixml 1.4">
<link rel="prev" href="changes.html" title="Changelog">
<link rel="next" href="toc.html" title="Table of Contents">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<b>API Reference</b> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="changes.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="toc.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
<hr>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.apiref"></a><a class="link" href="apiref.html" title="API Reference">API Reference</a>
</h2></div></div></div>
<p>
      This is the reference for all macros, types, enumerations, classes and functions
      in pugixml. Each symbol is a link that leads to the relevant section of the
      manual.
    </p>
<p>
      Macros:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_WCHAR_MODE">PUGIXML_WCHAR_MODE</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_NO_XPATH">PUGIXML_NO_XPATH</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_NO_STL">PUGIXML_NO_STL</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_NO_EXCEPTIONS">PUGIXML_NO_EXCEPTIONS</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_API">PUGIXML_API</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_CLASS">PUGIXML_CLASS</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_FUNCTION">PUGIXML_FUNCTION</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_MEMORY_PAGE_SIZE">PUGIXML_MEMORY_PAGE_SIZE</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_MEMORY_OUTPUT_STACK">PUGIXML_MEMORY_OUTPUT_STACK</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_MEMORY_XPATH_PAGE_SIZE">PUGIXML_MEMORY_XPATH_PAGE_SIZE</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_HEADER_ONLY">PUGIXML_HEADER_ONLY</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="preprocessor">#define</span> </code><a class="link" href="install.html#PUGIXML_HAS_LONG_LONG">PUGIXML_HAS_LONG_LONG</a>
        </li>
</ul></div>
<p>
      Types:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <code class="computeroutput"><span class="keyword">typedef</span> </code><span class="emphasis"><em>configuration-defined
          type</em></span><code class="computeroutput"> </code><a class="link" href="dom.html#char_t">char_t</a><code class="computeroutput"><span class="special">;</span></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">typedef</span> </code><span class="emphasis"><em>configuration-defined
          type</em></span><code class="computeroutput"> </code><a class="link" href="dom.html#string_t">string_t</a><code class="computeroutput"><span class="special">;</span></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">typedef</span> <span class="keyword">void</span><span class="special">*</span> <span class="special">(*</span></code><a class="link" href="dom.html#allocation_function">allocation_function</a><code class="computeroutput"><span class="special">)(</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">);</span></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">typedef</span> <span class="keyword">void</span>
          <span class="special">(*</span></code><a class="link" href="dom.html#deallocation_function">deallocation_function</a><code class="computeroutput"><span class="special">)(</span><span class="keyword">void</span><span class="special">*</span>
          <span class="identifier">ptr</span><span class="special">);</span></code>
        </li>
</ul></div>
<p>
      Enumerations:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <code class="computeroutput"><span class="keyword">enum</span> </code><a class="link" href="dom.html#xml_node_type">xml_node_type</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="dom.html#node_null">node_null</a>
              </li>
<li class="listitem">
                <a class="link" href="dom.html#node_document">node_document</a>
              </li>
<li class="listitem">
                <a class="link" href="dom.html#node_element">node_element</a>
              </li>
<li class="listitem">
                <a class="link" href="dom.html#node_pcdata">node_pcdata</a>
              </li>
<li class="listitem">
                <a class="link" href="dom.html#node_cdata">node_cdata</a>
              </li>
<li class="listitem">
                <a class="link" href="dom.html#node_comment">node_comment</a>
              </li>
<li class="listitem">
                <a class="link" href="dom.html#node_pi">node_pi</a>
              </li>
<li class="listitem">
                <a class="link" href="dom.html#node_declaration">node_declaration</a>
              </li>
<li class="listitem">
                <a class="link" href="dom.html#node_doctype">node_doctype</a> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">enum</span> </code><a class="link" href="loading.html#xml_parse_status">xml_parse_status</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="loading.html#status_ok">status_ok</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_file_not_found">status_file_not_found</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_io_error">status_io_error</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_out_of_memory">status_out_of_memory</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_internal_error">status_internal_error</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_unrecognized_tag">status_unrecognized_tag</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_bad_pi">status_bad_pi</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_bad_comment">status_bad_comment</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_bad_cdata">status_bad_cdata</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_bad_doctype">status_bad_doctype</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_bad_pcdata">status_bad_pcdata</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_bad_start_element">status_bad_start_element</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_bad_attribute">status_bad_attribute</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_bad_end_element">status_bad_end_element</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_end_element_mismatch">status_end_element_mismatch</a>
              </li>
<li class="listitem">
                <a class="link" href="modify.html#status_append_invalid_root">status_append_invalid_root</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#status_no_document_element">status_no_document_element</a>
                <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">enum</span> </code><a class="link" href="loading.html#xml_encoding">xml_encoding</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="loading.html#encoding_auto">encoding_auto</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#encoding_utf8">encoding_utf8</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#encoding_utf16_le">encoding_utf16_le</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#encoding_utf16_be">encoding_utf16_be</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#encoding_utf16">encoding_utf16</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#encoding_utf32_le">encoding_utf32_le</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#encoding_utf32_be">encoding_utf32_be</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#encoding_utf32">encoding_utf32</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#encoding_wchar">encoding_wchar</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#encoding_latin1">encoding_latin1</a> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">enum</span> </code><a class="link" href="xpath.html#xpath_value_type">xpath_value_type</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="xpath.html#xpath_type_none">xpath_type_none</a>
              </li>
<li class="listitem">
                <a class="link" href="xpath.html#xpath_type_node_set">xpath_type_node_set</a>
              </li>
<li class="listitem">
                <a class="link" href="xpath.html#xpath_type_number">xpath_type_number</a>
              </li>
<li class="listitem">
                <a class="link" href="xpath.html#xpath_type_string">xpath_type_string</a>
              </li>
<li class="listitem">
                <a class="link" href="xpath.html#xpath_type_boolean">xpath_type_boolean</a>
              </li>
</ul></div>
        </li>
</ul></div>
<p>
      Constants:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Formatting options bit flags:
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="saving.html#format_default">format_default</a>
              </li>
<li class="listitem">
                <a class="link" href="saving.html#format_indent">format_indent</a>
              </li>
<li class="listitem">
                <a class="link" href="saving.html#format_no_declaration">format_no_declaration</a>
              </li>
<li class="listitem">
                <a class="link" href="saving.html#format_no_escapes">format_no_escapes</a>
              </li>
<li class="listitem">
                <a class="link" href="saving.html#format_raw">format_raw</a>
              </li>
<li class="listitem">
                <a class="link" href="saving.html#format_save_file_text">format_save_file_text</a>
              </li>
<li class="listitem">
                <a class="link" href="saving.html#format_write_bom">format_write_bom</a> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          Parsing options bit flags:
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="loading.html#parse_cdata">parse_cdata</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_comments">parse_comments</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_declaration">parse_declaration</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_default">parse_default</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_doctype">parse_doctype</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_eol">parse_eol</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_escapes">parse_escapes</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_fragment">parse_fragment</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_full">parse_full</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_minimal">parse_minimal</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_pi">parse_pi</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_trim_pcdata">parse_trim_pcdata</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_ws_pcdata">parse_ws_pcdata</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_ws_pcdata_single">parse_ws_pcdata_single</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_wconv_attribute">parse_wconv_attribute</a>
              </li>
<li class="listitem">
                <a class="link" href="loading.html#parse_wnorm_attribute">parse_wnorm_attribute</a>
              </li>
</ul></div>
        </li>
</ul></div>
<p>
      Classes:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="dom.html#xml_attribute">xml_attribute</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="dom.html#xml_attribute::ctor">xml_attribute</a><code class="computeroutput"><span class="special">();</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_attribute::empty">empty</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">operator</span> </code><a class="link" href="dom.html#xml_attribute::unspecified_bool_type">unspecified_bool_type</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_attribute::comparison">operator==</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_attribute::comparison">operator!=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_attribute::comparison">operator&lt;</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_attribute::comparison">operator&gt;</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_attribute::comparison">operator&lt;=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_attribute::comparison">operator&gt;=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">size_t</span> </code><a class="link" href="dom.html#xml_attribute::hash_value">hash_value</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="access.html#xml_attribute::next_attribute">next_attribute</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="access.html#xml_attribute::previous_attribute">previous_attribute</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="access.html#xml_attribute::name">name</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="access.html#xml_attribute::value">value</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="access.html#xml_attribute::as_string">as_string</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">def</span> <span class="special">=</span>
                <span class="string">""</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">int</span> </code><a class="link" href="access.html#xml_attribute::as_int">as_int</a><code class="computeroutput"><span class="special">(</span><span class="keyword">int</span> <span class="identifier">def</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span>
                </code><a class="link" href="access.html#xml_attribute::as_uint">as_uint</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">def</span>
                <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">double</span> </code><a class="link" href="access.html#xml_attribute::as_double">as_double</a><code class="computeroutput"><span class="special">(</span><span class="keyword">double</span>
                <span class="identifier">def</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">float</span> </code><a class="link" href="access.html#xml_attribute::as_float">as_float</a><code class="computeroutput"><span class="special">(</span><span class="keyword">float</span> <span class="identifier">def</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="access.html#xml_attribute::as_bool">as_bool</a><code class="computeroutput"><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">def</span> <span class="special">=</span>
                <span class="keyword">false</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span>
                </code><a class="link" href="access.html#xml_attribute::as_llong">as_llong</a><code class="computeroutput"><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">def</span>
                <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">long</span>
                <span class="keyword">long</span> </code><a class="link" href="access.html#xml_attribute::as_ullong">as_ullong</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">long</span> <span class="keyword">long</span>
                <span class="identifier">def</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_attribute::set_name">set_name</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_attribute::set_value">set_value</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_attribute::set_value">set_value</a><code class="computeroutput"><span class="special">(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_attribute::set_value">set_value</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_attribute::set_value">set_value</a><code class="computeroutput"><span class="special">(</span><span class="keyword">double</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_attribute::set_value">set_value</a><code class="computeroutput"><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_attribute::set_value">set_value</a><code class="computeroutput"><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_attribute::set_value">set_value</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">long</span> <span class="keyword">long</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_attribute::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_attribute::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_attribute::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_attribute::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">double</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_attribute::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_attribute::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_attribute::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="identifier">unsnigned</span>
                <span class="keyword">long</span> <span class="keyword">long</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
                <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="dom.html#xml_node">xml_node</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="dom.html#xml_node::ctor">xml_node</a><code class="computeroutput"><span class="special">();</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_node::empty">empty</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">operator</span> </code><a class="link" href="dom.html#xml_node::unspecified_bool_type">unspecified_bool_type</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_node::comparison">operator==</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_node::comparison">operator!=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_node::comparison">operator&lt;</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_node::comparison">operator&gt;</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_node::comparison">operator&lt;=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="dom.html#xml_node::comparison">operator&gt;=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">r</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">size_t</span> </code><a class="link" href="dom.html#xml_node::hash_value">hash_value</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node_type</span> </code><a class="link" href="dom.html#xml_node::type">type</a><code class="computeroutput"><span class="special">()</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="access.html#xml_node::name">name</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="access.html#xml_node::value">value</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::parent">parent</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::first_child">first_child</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::last_child">last_child</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::next_sibling">next_sibling</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::previous_sibling">previous_sibling</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="access.html#xml_node::first_attribute">first_attribute</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="access.html#xml_node::last_attribute">last_attribute</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <span class="emphasis"><em>implementation-defined type</em></span> <a class="link" href="access.html#xml_node::children">children</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <span class="emphasis"><em>implementation-defined type</em></span> <a class="link" href="access.html#xml_node::children">children</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <span class="emphasis"><em>implementation-defined type</em></span> <a class="link" href="access.html#xml_node::attributes">attributes</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::child">child</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="access.html#xml_node::attribute">attribute</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::next_sibling_name">next_sibling</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::previous_sibling_name">previous_sibling</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::find_child_by_attribute">find_child_by_attribute</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">attr_name</span><span class="special">,</span> <span class="keyword">const</span>
                <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">attr_value</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::find_child_by_attribute">find_child_by_attribute</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">attr_name</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">attr_value</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="access.html#xml_node::child_value">child_value</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="access.html#xml_node::child_value">child_value</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_text</span> </code><a class="link" href="access.html#xml_node::text">text</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">typedef</span> <span class="identifier">xml_node_iterator</span>
                </code><a class="link" href="access.html#xml_node_iterator">iterator</a><code class="computeroutput"><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">iterator</span> </code><a class="link" href="access.html#xml_node::begin">begin</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">iterator</span> </code><a class="link" href="access.html#xml_node::end">end</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">typedef</span> <span class="identifier">xml_attribute_iterator</span>
                </code><a class="link" href="access.html#xml_attribute_iterator">attribute_iterator</a><code class="computeroutput"><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">attribute_iterator</span> </code><a class="link" href="access.html#xml_node::attributes_begin">attributes_begin</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">attribute_iterator</span> </code><a class="link" href="access.html#xml_node::attributes_end">attributes_end</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="access.html#xml_node::traverse">traverse</a><code class="computeroutput"><span class="special">(</span><span class="identifier">xml_tree_walker</span><span class="special">&amp;</span> <span class="identifier">walker</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="identifier">xml_attribute</span>
                </code><a class="link" href="access.html#xml_node::find_attribute">find_attribute</a><code class="computeroutput"><span class="special">(</span><span class="identifier">Predicate</span>
                <span class="identifier">pred</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="identifier">xml_node</span>
                </code><a class="link" href="access.html#xml_node::find_child">find_child</a><code class="computeroutput"><span class="special">(</span><span class="identifier">Predicate</span>
                <span class="identifier">pred</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="identifier">xml_node</span>
                </code><a class="link" href="access.html#xml_node::find_node">find_node</a><code class="computeroutput"><span class="special">(</span><span class="identifier">Predicate</span>
                <span class="identifier">pred</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">string_t</span> </code><a class="link" href="access.html#xml_node::path">path</a><code class="computeroutput"><span class="special">(</span><span class="identifier">char_t</span>
                <span class="identifier">delimiter</span> <span class="special">=</span>
                <span class="char">'/'</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::first_element_by_path">xml_node::first_element_by_path</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">path</span><span class="special">,</span>
                <span class="identifier">char_t</span> <span class="identifier">delimiter</span>
                <span class="special">=</span> <span class="char">'/'</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_node::root">root</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">ptrdiff_t</span> </code><a class="link" href="access.html#xml_node::offset_debug">offset_debug</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_node::set_name">set_name</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_node::set_value">set_value</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="modify.html#xml_node::append_attribute">append_attribute</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="modify.html#xml_node::prepend_attribute">prepend_attribute</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="modify.html#xml_node::insert_attribute_after">insert_attribute_after</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">attr</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="modify.html#xml_node::insert_attribute_before">insert_attribute_before</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">attr</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::append_child">append_child</a><code class="computeroutput"><span class="special">(</span><span class="identifier">xml_node_type</span>
                <span class="identifier">type</span> <span class="special">=</span>
                <span class="identifier">node_element</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::prepend_child">prepend_child</a><code class="computeroutput"><span class="special">(</span><span class="identifier">xml_node_type</span>
                <span class="identifier">type</span> <span class="special">=</span>
                <span class="identifier">node_element</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::insert_child_after">insert_child_after</a><code class="computeroutput"><span class="special">(</span><span class="identifier">xml_node_type</span>
                <span class="identifier">type</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::insert_child_before">insert_child_before</a><code class="computeroutput"><span class="special">(</span><span class="identifier">xml_node_type</span>
                <span class="identifier">type</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::append_child">append_child</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::prepend_child">prepend_child</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::insert_child_after">insert_child_after</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::insert_child_before">insert_child_before</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="modify.html#xml_node::append_copy">append_copy</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">proto</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="modify.html#xml_node::prepend_copy">prepend_copy</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                <span class="identifier">proto</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="modify.html#xml_node::insert_copy_after">insert_copy_after</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                <span class="identifier">proto</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">attr</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="modify.html#xml_node::insert_copy_before">insert_copy_before</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                <span class="identifier">proto</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">attr</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::append_copy">append_copy</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">proto</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::prepend_copy">prepend_copy</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">proto</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::insert_copy_after">insert_copy_after</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">proto</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="modify.html#xml_node::insert_copy_before">insert_copy_before</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">proto</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_node::remove_attribute">remove_attribute</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span>
                <span class="identifier">a</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_node::remove_attribute">remove_attribute</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_node::remove_child">remove_child</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">n</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_node::remove_child">remove_child</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_parse_result</span> </code><a class="link" href="modify.html#xml_node::append_buffer">append_buffer</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="keyword">void</span><span class="special">*</span> <span class="identifier">contents</span><span class="special">,</span>
                <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">,</span> <span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">options</span>
                <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span>
                <span class="identifier">encoding</span> <span class="special">=</span>
                <span class="identifier">encoding_auto</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">void</span> </code><a class="link" href="saving.html#xml_node::print">print</a><code class="computeroutput"><span class="special">(</span><span class="identifier">xml_writer</span><span class="special">&amp;</span> <span class="identifier">writer</span><span class="special">,</span> <span class="keyword">const</span>
                <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">indent</span> <span class="special">=</span>
                <span class="string">"\t"</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">flags</span> <span class="special">=</span>
                <span class="identifier">format_default</span><span class="special">,</span>
                <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span>
                <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">,</span> <span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">depth</span>
                <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">void</span> </code><a class="link" href="saving.html#xml_node::print_stream">print</a><code class="computeroutput"><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">os</span><span class="special">,</span> <span class="keyword">const</span>
                <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">indent</span> <span class="special">=</span>
                <span class="string">"\t"</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">flags</span> <span class="special">=</span>
                <span class="identifier">format_default</span><span class="special">,</span>
                <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span>
                <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">,</span> <span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">depth</span>
                <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">void</span> </code><a class="link" href="saving.html#xml_node::print_stream">print</a><code class="computeroutput"><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">wostream</span><span class="special">&amp;</span> <span class="identifier">os</span><span class="special">,</span> <span class="keyword">const</span>
                <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">indent</span> <span class="special">=</span>
                <span class="string">"\t"</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">flags</span> <span class="special">=</span>
                <span class="identifier">format_default</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">depth</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xpath_node</span> </code><a class="link" href="xpath.html#xml_node::select_single_node">select_single_node</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">query</span><span class="special">,</span>
                <span class="identifier">xpath_variable_set</span><span class="special">*</span>
                <span class="identifier">variables</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xpath_node</span> </code><a class="link" href="xpath.html#xml_node::select_single_node_precomp">select_single_node</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_query</span><span class="special">&amp;</span>
                <span class="identifier">query</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xpath_node_set</span> </code><a class="link" href="xpath.html#xml_node::select_nodes">select_nodes</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">query</span><span class="special">,</span>
                <span class="identifier">xpath_variable_set</span><span class="special">*</span>
                <span class="identifier">variables</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xpath_node_set</span> </code><a class="link" href="xpath.html#xml_node::select_nodes_precomp">select_nodes</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_query</span><span class="special">&amp;</span>
                <span class="identifier">query</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="dom.html#xml_document">xml_document</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="dom.html#xml_document::ctor">xml_document</a><code class="computeroutput"><span class="special">();</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="special">~</span></code><a class="link" href="dom.html#xml_document::dtor">xml_document</a><code class="computeroutput"><span class="special">();</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">void</span> </code><a class="link" href="dom.html#xml_document::reset">reset</a><code class="computeroutput"><span class="special">();</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">void</span> </code><a class="link" href="dom.html#xml_document::reset">reset</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_document</span><span class="special">&amp;</span>
                <span class="identifier">proto</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_parse_result</span> </code><a class="link" href="loading.html#xml_document::load_stream">load</a><code class="computeroutput"><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span><span class="special">&amp;</span>
                <span class="identifier">stream</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">options</span> <span class="special">=</span>
                <span class="identifier">parse_default</span><span class="special">,</span>
                <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span>
                <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_parse_result</span> </code><a class="link" href="loading.html#xml_document::load_stream">load</a><code class="computeroutput"><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">wistream</span><span class="special">&amp;</span>
                <span class="identifier">stream</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">options</span> <span class="special">=</span>
                <span class="identifier">parse_default</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_parse_result</span> </code><a class="link" href="loading.html#xml_document::load_string">load</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">contents</span><span class="special">,</span> <span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">options</span>
                <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_parse_result</span> </code><a class="link" href="loading.html#xml_document::load_file">load_file</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">path</span><span class="special">,</span> <span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">options</span>
                <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span>
                <span class="identifier">encoding</span> <span class="special">=</span>
                <span class="identifier">encoding_auto</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_parse_result</span> </code><a class="link" href="loading.html#xml_document::load_file_wide">load_file</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*</span>
                <span class="identifier">path</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">options</span> <span class="special">=</span>
                <span class="identifier">parse_default</span><span class="special">,</span>
                <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span>
                <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_parse_result</span> </code><a class="link" href="loading.html#xml_document::load_buffer">load_buffer</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="keyword">void</span><span class="special">*</span> <span class="identifier">contents</span><span class="special">,</span>
                <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">,</span> <span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">options</span>
                <span class="special">=</span> <span class="identifier">parse_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span>
                <span class="identifier">encoding</span> <span class="special">=</span>
                <span class="identifier">encoding_auto</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_parse_result</span> </code><a class="link" href="loading.html#xml_document::load_buffer_inplace">load_buffer_inplace</a><code class="computeroutput"><span class="special">(</span><span class="keyword">void</span><span class="special">*</span> <span class="identifier">contents</span><span class="special">,</span> <span class="identifier">size_t</span>
                <span class="identifier">size</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">options</span> <span class="special">=</span>
                <span class="identifier">parse_default</span><span class="special">,</span>
                <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span>
                <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_parse_result</span> </code><a class="link" href="loading.html#xml_document::load_buffer_inplace_own">load_buffer_inplace_own</a><code class="computeroutput"><span class="special">(</span><span class="keyword">void</span><span class="special">*</span> <span class="identifier">contents</span><span class="special">,</span> <span class="identifier">size_t</span>
                <span class="identifier">size</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">options</span> <span class="special">=</span>
                <span class="identifier">parse_default</span><span class="special">,</span>
                <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span>
                <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="saving.html#xml_document::save_file">save_file</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">path</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">indent</span>
                <span class="special">=</span> <span class="string">"\t"</span><span class="special">,</span> <span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">flags</span>
                <span class="special">=</span> <span class="identifier">format_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span>
                <span class="identifier">encoding</span> <span class="special">=</span>
                <span class="identifier">encoding_auto</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="saving.html#xml_document::save_file_wide">save_file</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*</span>
                <span class="identifier">path</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">indent</span>
                <span class="special">=</span> <span class="string">"\t"</span><span class="special">,</span> <span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">flags</span>
                <span class="special">=</span> <span class="identifier">format_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span>
                <span class="identifier">encoding</span> <span class="special">=</span>
                <span class="identifier">encoding_auto</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">void</span> </code><a class="link" href="saving.html#xml_document::save_stream">save</a><code class="computeroutput"><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="keyword">const</span>
                <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">indent</span> <span class="special">=</span>
                <span class="string">"\t"</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">flags</span> <span class="special">=</span>
                <span class="identifier">format_default</span><span class="special">,</span>
                <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span>
                <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">void</span> </code><a class="link" href="saving.html#xml_document::save_stream">save</a><code class="computeroutput"><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">wostream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="keyword">const</span>
                <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">indent</span> <span class="special">=</span>
                <span class="string">"\t"</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">flags</span> <span class="special">=</span>
                <span class="identifier">format_default</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">void</span> </code><a class="link" href="saving.html#xml_document::save">save</a><code class="computeroutput"><span class="special">(</span><span class="identifier">xml_writer</span><span class="special">&amp;</span> <span class="identifier">writer</span><span class="special">,</span> <span class="keyword">const</span>
                <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">indent</span> <span class="special">=</span>
                <span class="string">"\t"</span><span class="special">,</span>
                <span class="keyword">unsigned</span> <span class="keyword">int</span>
                <span class="identifier">flags</span> <span class="special">=</span>
                <span class="identifier">format_default</span><span class="special">,</span>
                <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span>
                <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="dom.html#xml_document::document_element">document_element</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">struct</span> </code><a class="link" href="loading.html#xml_parse_result">xml_parse_result</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_parse_status</span> </code><a class="link" href="loading.html#xml_parse_result::status">status</a><code class="computeroutput"><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">ptrdiff_t</span> </code><a class="link" href="loading.html#xml_parse_result::offset">offset</a><code class="computeroutput"><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_encoding</span> </code><a class="link" href="loading.html#xml_parse_result::encoding">encoding</a><code class="computeroutput"><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">operator</span> </code><a class="link" href="loading.html#xml_parse_result::bool">bool</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> </code><a class="link" href="loading.html#xml_parse_result::description">description</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="access.html#xml_node_iterator">xml_node_iterator</a>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="access.html#xml_attribute_iterator">xml_attribute_iterator</a>
          <br><br>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="access.html#xml_tree_walker">xml_tree_walker</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <code class="computeroutput"><span class="keyword">virtual</span> <span class="keyword">bool</span>
                </code><a class="link" href="access.html#xml_tree_walker::begin">begin</a><code class="computeroutput"><span class="special">(</span><span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">virtual</span> <span class="keyword">bool</span>
                </code><a class="link" href="access.html#xml_tree_walker::for_each">for_each</a><code class="computeroutput"><span class="special">(</span><span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">)</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">virtual</span> <span class="keyword">bool</span>
                </code><a class="link" href="access.html#xml_tree_walker::end">end</a><code class="computeroutput"><span class="special">(</span><span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">int</span> </code><a class="link" href="access.html#xml_tree_walker::depth">depth</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="access.html#xml_text">xml_text</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="access.html#xml_text::empty">empty</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">operator</span> </code><a class="link" href="access.html#xml_text::unspecified_bool_type">xml_text::unspecified_bool_type</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="access.html#xml_text::get">xml_text::get</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="access.html#xml_text::as_string">as_string</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">def</span> <span class="special">=</span>
                <span class="string">""</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">int</span> </code><a class="link" href="access.html#xml_text::as_int">as_int</a><code class="computeroutput"><span class="special">(</span><span class="keyword">int</span> <span class="identifier">def</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span>
                </code><a class="link" href="access.html#xml_text::as_uint">as_uint</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">def</span>
                <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">double</span> </code><a class="link" href="access.html#xml_text::as_double">as_double</a><code class="computeroutput"><span class="special">(</span><span class="keyword">double</span>
                <span class="identifier">def</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">float</span> </code><a class="link" href="access.html#xml_text::as_float">as_float</a><code class="computeroutput"><span class="special">(</span><span class="keyword">float</span> <span class="identifier">def</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="access.html#xml_text::as_bool">as_bool</a><code class="computeroutput"><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">def</span> <span class="special">=</span>
                <span class="keyword">false</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span>
                </code><a class="link" href="access.html#xml_text::as_llong">as_llong</a><code class="computeroutput"><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">def</span>
                <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">long</span>
                <span class="keyword">long</span> </code><a class="link" href="access.html#xml_text::as_ullong">as_ullong</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">long</span> <span class="keyword">long</span>
                <span class="identifier">def</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_text::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_text::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_text::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_text::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">double</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_text::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_text::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="modify.html#xml_text::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">long</span> <span class="keyword">long</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_text</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_text::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_text</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_text::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_text</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_text::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_text</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_text::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">double</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_text</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_text::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_text</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_text::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">rhs</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_text</span><span class="special">&amp;</span>
                </code><a class="link" href="modify.html#xml_text::assign">operator=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span>
                <span class="keyword">long</span> <span class="keyword">long</span>
                <span class="identifier">rhs</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="access.html#xml_text::data">data</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="saving.html#xml_writer">xml_writer</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
                <code class="computeroutput"><span class="keyword">virtual</span> <span class="keyword">void</span>
                </code><a class="link" href="saving.html#xml_writer::write">write</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="keyword">void</span><span class="special">*</span> <span class="identifier">data</span><span class="special">,</span>
                <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">)</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span></code>
                <br><br>
              </li></ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="saving.html#xml_writer_file">xml_writer_file</a><code class="computeroutput"><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">xml_writer</span></code>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
                <a class="link" href="saving.html#xml_writer_file">xml_writer_file</a><code class="computeroutput"><span class="special">(</span><span class="keyword">void</span><span class="special">*</span> <span class="identifier">file</span><span class="special">);</span></code> <br><br>
              </li></ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="saving.html#xml_writer_stream">xml_writer_stream</a><code class="computeroutput"><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">xml_writer</span></code>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="saving.html#xml_writer_stream">xml_writer_stream</a><code class="computeroutput"><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <a class="link" href="saving.html#xml_writer_stream">xml_writer_stream</a><code class="computeroutput"><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">wostream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">);</span></code> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">struct</span> </code><a class="link" href="xpath.html#xpath_parse_result">xpath_parse_result</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> </code><a class="link" href="xpath.html#xpath_parse_result::error">error</a><code class="computeroutput"><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">ptrdiff_t</span> </code><a class="link" href="xpath.html#xpath_parse_result::offset">offset</a><code class="computeroutput"><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">operator</span> </code><a class="link" href="xpath.html#xpath_parse_result::bool">bool</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> </code><a class="link" href="xpath.html#xpath_parse_result::description">description</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="xpath.html#xpath_query">xpath_query</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <code class="computeroutput"><span class="keyword">explicit</span> </code><a class="link" href="xpath.html#xpath_query::ctor">xpath_query</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">query</span><span class="special">,</span>
                <span class="identifier">xpath_variable_set</span><span class="special">*</span>
                <span class="identifier">variables</span> <span class="special">=</span>
                <span class="number">0</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_query::evaluate_boolean">evaluate_boolean</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span>
                <span class="identifier">n</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">double</span> </code><a class="link" href="xpath.html#xpath_query::evaluate_number">evaluate_number</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span>
                <span class="identifier">n</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">string_t</span> </code><a class="link" href="xpath.html#xpath_query::evaluate_string">evaluate_string</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span>
                <span class="identifier">n</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">size_t</span> </code><a class="link" href="xpath.html#xpath_query::evaluate_string_buffer">evaluate_string</a><code class="computeroutput"><span class="special">(</span><span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">size_t</span>
                <span class="identifier">capacity</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xpath_node_set</span> </code><a class="link" href="xpath.html#xpath_query::evaluate_node_set">evaluate_node_set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span>
                <span class="identifier">n</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xpath_value_type</span> </code><a class="link" href="xpath.html#xpath_query::return_type">return_type</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">xpath_parse_result</span><span class="special">&amp;</span> </code><a class="link" href="xpath.html#xpath_query::result">result</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">operator</span> </code><a class="link" href="xpath.html#xpath_query::unspecified_bool_type">unspecified_bool_type</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="xpath.html#xpath_exception">xpath_exception</a><code class="computeroutput"><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception</span></code>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <code class="computeroutput"><span class="keyword">virtual</span> <span class="keyword">const</span>
                <span class="keyword">char</span><span class="special">*</span>
                </code><a class="link" href="xpath.html#xpath_exception::what">what</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span>
                <span class="keyword">throw</span><span class="special">();</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">xpath_parse_result</span><span class="special">&amp;</span> </code><a class="link" href="xpath.html#xpath_exception::result">result</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="xpath.html#xpath_node">xpath_node</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="xpath.html#xpath_node::ctor">xpath_node</a><code class="computeroutput"><span class="special">();</span></code>
              </li>
<li class="listitem">
                <a class="link" href="xpath.html#xpath_node::ctor">xpath_node</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <a class="link" href="xpath.html#xpath_node::ctor">xpath_node</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xml_attribute</span><span class="special">&amp;</span> <span class="identifier">attribute</span><span class="special">,</span> <span class="keyword">const</span>
                <span class="identifier">xml_node</span><span class="special">&amp;</span>
                <span class="identifier">parent</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="xpath.html#xpath_node::node">node</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_attribute</span> </code><a class="link" href="xpath.html#xpath_node::attribute">attribute</a><code class="computeroutput"><span class="special">()</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xml_node</span> </code><a class="link" href="xpath.html#xpath_node::parent">parent</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">operator</span> </code><a class="link" href="xpath.html#xpath_node::unspecified_bool_type">unspecified_bool_type</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_node::comparison">operator==</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span>
                <span class="identifier">n</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_node::comparison">operator!=</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span>
                <span class="identifier">n</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="xpath.html#xpath_node_set">xpath_node_set</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <a class="link" href="xpath.html#xpath_node_set::ctor">xpath_node_set</a><code class="computeroutput"><span class="special">();</span></code>
              </li>
<li class="listitem">
                <a class="link" href="xpath.html#xpath_node_set::ctor">xpath_node_set</a><code class="computeroutput"><span class="special">(</span><span class="identifier">const_iterator</span>
                <span class="identifier">begin</span><span class="special">,</span>
                <span class="identifier">const_iterator</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">type_t</span>
                <span class="identifier">type</span> <span class="special">=</span>
                <span class="identifier">type_unsorted</span><span class="special">);</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">typedef</span> <span class="keyword">const</span>
                <span class="identifier">xpath_node</span><span class="special">*</span>
                </code><a class="link" href="xpath.html#xpath_node_set::const_iterator">const_iterator</a><code class="computeroutput"><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">const_iterator</span> </code><a class="link" href="xpath.html#xpath_node_set::begin">begin</a><code class="computeroutput"><span class="special">()</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">const_iterator</span> </code><a class="link" href="xpath.html#xpath_node_set::end">end</a><code class="computeroutput"><span class="special">()</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span> </code><a class="link" href="xpath.html#xpath_node_set::index">operator[]</a><code class="computeroutput"><span class="special">(</span><span class="identifier">size_t</span>
                <span class="identifier">index</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">size_t</span> </code><a class="link" href="xpath.html#xpath_node_set::size">size</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_node_set::empty">empty</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xpath_node</span> </code><a class="link" href="xpath.html#xpath_node_set::first">first</a><code class="computeroutput"><span class="special">()</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">enum</span> <span class="identifier">type_t</span>
                <span class="special">{</span></code><a class="link" href="xpath.html#xpath_node_set::type_unsorted">type_unsorted</a>,
                <a class="link" href="xpath.html#xpath_node_set::type_sorted">type_sorted</a>,
                <a class="link" href="xpath.html#xpath_node_set::type_sorted_reverse">type_sorted_reverse</a><code class="computeroutput"><span class="special">};</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">type_t</span> </code><a class="link" href="xpath.html#xpath_node_set::type">type</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">void</span> </code><a class="link" href="xpath.html#xpath_node_set::sort">sort</a><code class="computeroutput"><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">reverse</span> <span class="special">=</span>
                <span class="keyword">false</span><span class="special">);</span></code>
                <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="xpath.html#xpath_variable">xpath_variable</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="xpath.html#xpath_variable::name">name</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xpath_value_type</span> </code><a class="link" href="xpath.html#xpath_variable::type">type</a><code class="computeroutput"><span class="special">()</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_variable::get_boolean">get_boolean</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">double</span> </code><a class="link" href="xpath.html#xpath_variable::get_number">get_number</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> </code><a class="link" href="xpath.html#xpath_variable::get_string">get_string</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">xpath_node_set</span><span class="special">&amp;</span> </code><a class="link" href="xpath.html#xpath_variable::get_node_set">get_node_set</a><code class="computeroutput"><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_variable::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">value</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_variable::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">double</span>
                <span class="identifier">value</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_variable::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">value</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_variable::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node_set</span><span class="special">&amp;</span>
                <span class="identifier">value</span><span class="special">);</span></code>
                <br><br>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">class</span> </code><a class="link" href="xpath.html#xpath_variable_set">xpath_variable_set</a>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xpath_variable</span><span class="special">*</span>
                </code><a class="link" href="xpath.html#xpath_variable_set::add">add</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">,</span>
                <span class="identifier">xpath_value_type</span> <span class="identifier">type</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_variable_set::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">,</span>
                <span class="keyword">bool</span> <span class="identifier">value</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_variable_set::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">,</span>
                <span class="keyword">double</span> <span class="identifier">value</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_variable_set::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">value</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">bool</span> </code><a class="link" href="xpath.html#xpath_variable_set::set">set</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">xpath_node_set</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">);</span></code> <br><br>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="identifier">xpath_variable</span><span class="special">*</span>
                </code><a class="link" href="xpath.html#xpath_variable_set::get">get</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">);</span></code>
              </li>
<li class="listitem">
                <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">xpath_variable</span><span class="special">*</span> </code><a class="link" href="xpath.html#xpath_variable_set::get">get</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span>
                <span class="identifier">name</span><span class="special">)</span>
                <span class="keyword">const</span><span class="special">;</span></code>
                <br><br>
              </li>
</ul></div>
        </li>
</ul></div>
<p>
      Functions:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> </code><a class="link" href="dom.html#as_utf8">as_utf8</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*</span> <span class="identifier">str</span><span class="special">);</span></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> </code><a class="link" href="dom.html#as_utf8">as_utf8</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span><span class="special">&amp;</span>
          <span class="identifier">str</span><span class="special">);</span></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span> </code><a class="link" href="dom.html#as_wide">as_wide</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">str</span><span class="special">);</span></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span> </code><a class="link" href="dom.html#as_wide">as_wide</a><code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span>
          <span class="identifier">str</span><span class="special">);</span></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">void</span> </code><a class="link" href="dom.html#set_memory_management_functions">set_memory_management_functions</a><code class="computeroutput"><span class="special">(</span><span class="identifier">allocation_function</span>
          <span class="identifier">allocate</span><span class="special">,</span>
          <span class="identifier">deallocation_function</span> <span class="identifier">deallocate</span><span class="special">);</span></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">allocation_function</span> </code><a class="link" href="dom.html#get_memory_allocation_function">get_memory_allocation_function</a><code class="computeroutput"><span class="special">();</span></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">deallocation_function</span> </code><a class="link" href="dom.html#get_memory_deallocation_function">get_memory_deallocation_function</a><code class="computeroutput"><span class="special">();</span></code>
        </li>
</ul></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Arseny Kapoulkine<p>
        Distributed under the MIT License
      </p>
</div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<b>API Reference</b> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="changes.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="toc.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual/access.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Accessing document data</title>
<link rel="stylesheet" href="../pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../manual.html" title="pugixml 1.4">
<link rel="up" href="../manual.html" title="pugixml 1.4">
<link rel="prev" href="loading.html" title="Loading document">
<link rel="next" href="modify.html" title="Modifying document data">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <b>Accessing</b> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="loading.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="modify.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
<hr>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.access"></a><a class="link" href="access.html" title="Accessing document data">Accessing document data</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="access.html#manual.access.basic">Basic traversal functions</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.nodedata">Getting node data</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.attrdata">Getting attribute data</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.contents">Contents-based traversal functions</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.rangefor">Range-based for-loop support</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.iterators">Traversing node/attribute lists
      via iterators</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.walker">Recursive traversal with xml_tree_walker</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.predicate">Searching for nodes/attributes
      with predicates</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.text">Working with text contents</a></span></dt>
<dt><span class="section"><a href="access.html#manual.access.misc">Miscellaneous functions</a></span></dt>
</dl></div>
<p>
      pugixml features an extensive interface for getting various types of data from
      the document and for traversing the document. This section provides documentation
      for all such functions that do not modify the tree except for XPath-related
      functions; see <a class="xref" href="xpath.html" title="XPath">XPath</a> for XPath reference. As discussed in <a class="xref" href="dom.html#manual.dom.cpp" title="C++ interface">C++ interface</a>,
      there are two types of handles to tree data - <a class="link" href="dom.html#xml_node">xml_node</a>
      and <a class="link" href="dom.html#xml_attribute">xml_attribute</a>. The handles have special
      null (empty) values which propagate through various functions and thus are
      useful for writing more concise code; see <a class="link" href="dom.html#node_null">this description</a>
      for details. The documentation in this section will explicitly state the results
      of all function in case of null inputs.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.access.basic"></a><a class="link" href="access.html#manual.access.basic" title="Basic traversal functions">Basic traversal functions</a>
</h3></div></div></div>
<p>
        <a name="xml_node::parent"></a><a name="xml_node::first_child"></a><a name="xml_node::last_child"></a><a name="xml_node::next_sibling"></a><a name="xml_node::previous_sibling"></a><a name="xml_node::first_attribute"></a><a name="xml_node::last_attribute"></a><a name="xml_attribute::next_attribute"></a><a name="xml_attribute::previous_attribute"></a>The
        internal representation of the document is a tree, where each node has a
        list of child nodes (the order of children corresponds to their order in
        the XML representation), and additionally element nodes have a list of attributes,
        which is also ordered. Several functions are provided in order to let you
        get from one node in the tree to the other. These functions roughly correspond
        to the internal representation, and thus are usually building blocks for
        other methods of traversing (i.e. XPath traversals are based on these functions).
      </p>
<pre class="programlisting"><span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">parent</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">first_child</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">last_child</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">next_sibling</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">previous_sibling</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

<span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">first_attribute</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">last_attribute</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">next_attribute</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">previous_attribute</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">parent</span></code> function returns the
        node's parent; all non-null nodes except the document have non-null parent.
        <code class="computeroutput"><span class="identifier">first_child</span></code> and <code class="computeroutput"><span class="identifier">last_child</span></code> return the first and last child
        of the node, respectively; note that only document nodes and element nodes
        can have non-empty child node list. If node has no children, both functions
        return null nodes. <code class="computeroutput"><span class="identifier">next_sibling</span></code>
        and <code class="computeroutput"><span class="identifier">previous_sibling</span></code> return
        the node that's immediately to the right/left of this node in the children
        list, respectively - for example, in <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">a</span><span class="special">/&gt;&lt;</span><span class="identifier">b</span><span class="special">/&gt;&lt;</span><span class="identifier">c</span><span class="special">/&gt;</span></code>,
        calling <code class="computeroutput"><span class="identifier">next_sibling</span></code> for
        a handle that points to <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">b</span><span class="special">/&gt;</span></code>
        results in a handle pointing to <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">c</span><span class="special">/&gt;</span></code>,
        and calling <code class="computeroutput"><span class="identifier">previous_sibling</span></code>
        results in handle pointing to <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">a</span><span class="special">/&gt;</span></code>.
        If node does not have next/previous sibling (this happens if it is the last/first
        node in the list, respectively), the functions return null nodes. <code class="computeroutput"><span class="identifier">first_attribute</span></code>, <code class="computeroutput"><span class="identifier">last_attribute</span></code>,
        <code class="computeroutput"><span class="identifier">next_attribute</span></code> and <code class="computeroutput"><span class="identifier">previous_attribute</span></code> functions behave similarly
        to the corresponding child node functions and allow to iterate through attribute
        list in the same way.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Because of memory consumption reasons, attributes do not have a link to
          their parent nodes. Thus there is no <code class="computeroutput"><span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">parent</span><span class="special">()</span></code> function.
        </p></td></tr>
</table></div>
<p>
        Calling any of the functions above on the null handle results in a null handle
        - i.e. <code class="computeroutput"><span class="identifier">node</span><span class="special">.</span><span class="identifier">first_child</span><span class="special">().</span><span class="identifier">next_sibling</span><span class="special">()</span></code>
        returns the second child of <code class="computeroutput"><span class="identifier">node</span></code>,
        and null handle if <code class="computeroutput"><span class="identifier">node</span></code> is
        null, has no children at all or if it has only one child node.
      </p>
<p>
        With these functions, you can iterate through all child nodes and display
        all attributes like this (<a href="../samples/traverse_base.cpp" target="_top">samples/traverse_base.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">first_child</span><span class="special">();</span> <span class="identifier">tool</span><span class="special">;</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool:"</span><span class="special">;</span>

    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_attribute</span> <span class="identifier">attr</span> <span class="special">=</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">first_attribute</span><span class="special">();</span> <span class="identifier">attr</span><span class="special">;</span> <span class="identifier">attr</span> <span class="special">=</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">next_attribute</span><span class="special">())</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"="</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">value</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.access.nodedata"></a><a class="link" href="access.html#manual.access.nodedata" title="Getting node data">Getting node data</a>
</h3></div></div></div>
<p>
        <a name="xml_node::name"></a><a name="xml_node::value"></a>Apart from structural
        information (parent, child nodes, attributes), nodes can have name and value,
        both of which are strings. Depending on node type, name or value may be absent.
        <a class="link" href="dom.html#node_document">node_document</a> nodes do not have a name
        or value, <a class="link" href="dom.html#node_element">node_element</a> and <a class="link" href="dom.html#node_declaration">node_declaration</a>
        nodes always have a name but never have a value, <a class="link" href="dom.html#node_pcdata">node_pcdata</a>,
        <a class="link" href="dom.html#node_cdata">node_cdata</a>, <a class="link" href="dom.html#node_comment">node_comment</a>
        and <a class="link" href="dom.html#node_doctype">node_doctype</a> nodes never have a name
        but always have a value (it may be empty though), <a class="link" href="dom.html#node_pi">node_pi</a>
        nodes always have a name and a value (again, value may be empty). In order
        to get node's name or value, you can use the following functions:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">name</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        In case node does not have a name or value or if the node handle is null,
        both functions return empty strings - they never return null pointers.
      </p>
<p>
        <a name="xml_node::child_value"></a>It is common to store data as text contents
        of some node - i.e. <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;&lt;</span><span class="identifier">description</span><span class="special">&gt;</span><span class="identifier">This</span> <span class="identifier">is</span> <span class="identifier">a</span> <span class="identifier">node</span><span class="special">&lt;/</span><span class="identifier">description</span><span class="special">&gt;&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span></code>.
        In this case, <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">description</span><span class="special">&gt;</span></code> node does not have a value, but instead
        has a child of type <a class="link" href="dom.html#node_pcdata">node_pcdata</a> with value
        <code class="computeroutput"><span class="string">"This is a node"</span></code>. pugixml
        provides several helper functions to parse such data:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">child_value</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">child_value</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_text</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">text</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">child_value</span><span class="special">()</span></code>
        returns the value of the first child with type <a class="link" href="dom.html#node_pcdata">node_pcdata</a>
        or <a class="link" href="dom.html#node_cdata">node_cdata</a>; <code class="computeroutput"><span class="identifier">child_value</span><span class="special">(</span><span class="identifier">name</span><span class="special">)</span></code>
        is a simple wrapper for <code class="computeroutput"><span class="identifier">child</span><span class="special">(</span><span class="identifier">name</span><span class="special">).</span><span class="identifier">child_value</span><span class="special">()</span></code>.
        For the above example, calling <code class="computeroutput"><span class="identifier">node</span><span class="special">.</span><span class="identifier">child_value</span><span class="special">(</span><span class="string">"description"</span><span class="special">)</span></code> and <code class="computeroutput"><span class="identifier">description</span><span class="special">.</span><span class="identifier">child_value</span><span class="special">()</span></code> will both produce string <code class="computeroutput"><span class="string">"This is a node"</span></code>. If there is no
        child with relevant type, or if the handle is null, <code class="computeroutput"><span class="identifier">child_value</span></code>
        functions return empty string.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">text</span><span class="special">()</span></code>
        returns a special object that can be used for working with PCDATA contents
        in more complex cases than just retrieving the value; it is described in
        <a class="xref" href="access.html#manual.access.text" title="Working with text contents">Working with text contents</a> sections.
      </p>
<p>
        There is an example of using some of these functions <a class="link" href="access.html#code_traverse_base_data">at
        the end of the next section</a>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.access.attrdata"></a><a class="link" href="access.html#manual.access.attrdata" title="Getting attribute data">Getting attribute data</a>
</h3></div></div></div>
<p>
        <a name="xml_attribute::name"></a><a name="xml_attribute::value"></a>All
        attributes have name and value, both of which are strings (value may be empty).
        There are two corresponding accessors, like for <code class="computeroutput"><span class="identifier">xml_node</span></code>:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">name</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        In case the attribute handle is null, both functions return empty strings
        - they never return null pointers.
      </p>
<p>
        <a name="xml_attribute::as_string"></a>If you need a non-empty string if
        the attribute handle is null (for example, you need to get the option value
        from XML attribute, but if it is not specified, you need it to default to
        <code class="computeroutput"><span class="string">"sorted"</span></code> instead of
        <code class="computeroutput"><span class="string">""</span></code>), you can use <code class="computeroutput"><span class="identifier">as_string</span></code> accessor:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">as_string</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">def</span> <span class="special">=</span> <span class="string">""</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        It returns <code class="computeroutput"><span class="identifier">def</span></code> argument if
        the attribute handle is null. If you do not specify the argument, the function
        is equivalent to <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code>.
      </p>
<p>
        <a name="xml_attribute::as_int"></a><a name="xml_attribute::as_uint"></a><a name="xml_attribute::as_double"></a><a name="xml_attribute::as_float"></a><a name="xml_attribute::as_bool"></a><a name="xml_attribute::as_llong"></a><a name="xml_attribute::as_ullong"></a>In many cases attribute values have types
        that are not strings - i.e. an attribute may always contain values that should
        be treated as integers, despite the fact that they are represented as strings
        in XML. pugixml provides several accessors that convert attribute value to
        some other type:
      </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">as_int</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">as_uint</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">double</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">as_double</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">float</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">as_float</span><span class="special">(</span><span class="keyword">float</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">as_bool</span><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">def</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">as_llong</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">as_ullong</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">as_int</span></code>, <code class="computeroutput"><span class="identifier">as_uint</span></code>,
        <code class="computeroutput"><span class="identifier">as_llong</span></code>, <code class="computeroutput"><span class="identifier">as_ullong</span></code>,
        <code class="computeroutput"><span class="identifier">as_double</span></code> and <code class="computeroutput"><span class="identifier">as_float</span></code> convert attribute values to numbers.
        If attribute handle is null or attribute value is empty, <code class="computeroutput"><span class="identifier">def</span></code>
        argument is returned (which is 0 by default). Otherwise, all leading whitespace
        characters are truncated, and the remaining string is parsed as an integer
        number in either decimal or hexadecimal form (applicable to <code class="computeroutput"><span class="identifier">as_int</span></code>, <code class="computeroutput"><span class="identifier">as_uint</span></code>,
        <code class="computeroutput"><span class="identifier">as_llong</span></code> and <code class="computeroutput"><span class="identifier">as_ullong</span></code>; hexadecimal format is used if
        the number has <code class="computeroutput"><span class="number">0</span><span class="identifier">x</span></code>
        or <code class="computeroutput"><span class="number">0</span><span class="identifier">X</span></code>
        prefix) or as a floating point number in either decimal or scientific form
        (<code class="computeroutput"><span class="identifier">as_double</span></code> or <code class="computeroutput"><span class="identifier">as_float</span></code>). Any extra characters are silently
        discarded, i.e. <code class="computeroutput"><span class="identifier">as_int</span></code> will
        return <code class="computeroutput"><span class="number">1</span></code> for string <code class="computeroutput"><span class="string">"1abc"</span></code>.
      </p>
<p>
        In case the input string contains a number that is out of the target numeric
        range, the result is undefined.
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          Number conversion functions depend on current C locale as set with <code class="computeroutput"><span class="identifier">setlocale</span></code>, so may return unexpected results
          if the locale is different from <code class="computeroutput"><span class="string">"C"</span></code>.
        </p></td></tr>
</table></div>
<p>
        <code class="computeroutput"><span class="identifier">as_bool</span></code> converts attribute
        value to boolean as follows: if attribute handle is null, <code class="computeroutput"><span class="identifier">def</span></code>
        argument is returned (which is <code class="computeroutput"><span class="keyword">false</span></code>
        by default). If attribute value is empty, <code class="computeroutput"><span class="keyword">false</span></code>
        is returned. Otherwise, <code class="computeroutput"><span class="keyword">true</span></code>
        is returned if the first character is one of <code class="computeroutput"><span class="char">'1'</span><span class="special">,</span> <span class="char">'t'</span><span class="special">,</span>
        <span class="char">'T'</span><span class="special">,</span> <span class="char">'y'</span><span class="special">,</span> <span class="char">'Y'</span></code>.
        This means that strings like <code class="computeroutput"><span class="string">"true"</span></code>
        and <code class="computeroutput"><span class="string">"yes"</span></code> are recognized
        as <code class="computeroutput"><span class="keyword">true</span></code>, while strings like
        <code class="computeroutput"><span class="string">"false"</span></code> and <code class="computeroutput"><span class="string">"no"</span></code> are recognized as <code class="computeroutput"><span class="keyword">false</span></code>. For more complex matching you'll have
        to write your own function.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><span class="identifier">as_llong</span></code> and <code class="computeroutput"><span class="identifier">as_ullong</span></code> are only available if your
          platform has reliable support for the <code class="computeroutput"><span class="keyword">long</span>
          <span class="keyword">long</span></code> type, including string conversions.
        </p></td></tr>
</table></div>
<p>
        <a name="code_traverse_base_data"></a>This is an example of using these functions,
        along with node data retrieval ones (<a href="../samples/traverse_base.cpp" target="_top">samples/traverse_base.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">);</span> <span class="identifier">tool</span><span class="special">;</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">))</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool "</span> <span class="special">&lt;&lt;</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">": AllowRemote "</span> <span class="special">&lt;&lt;</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"AllowRemote"</span><span class="special">).</span><span class="identifier">as_bool</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", Timeout "</span> <span class="special">&lt;&lt;</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Timeout"</span><span class="special">).</span><span class="identifier">as_int</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", Description '"</span> <span class="special">&lt;&lt;</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">child_value</span><span class="special">(</span><span class="string">"Description"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"'\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.access.contents"></a><a class="link" href="access.html#manual.access.contents" title="Contents-based traversal functions">Contents-based traversal functions</a>
</h3></div></div></div>
<p>
        <a name="xml_node::child"></a><a name="xml_node::attribute"></a><a name="xml_node::next_sibling_name"></a><a name="xml_node::previous_sibling_name"></a>Since a lot of document traversal consists
        of finding the node/attribute with the correct name, there are special functions
        for that purpose:
      </p>
<pre class="programlisting"><span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">child</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">attribute</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">next_sibling</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">previous_sibling</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">child</span></code> and <code class="computeroutput"><span class="identifier">attribute</span></code>
        return the first child/attribute with the specified name; <code class="computeroutput"><span class="identifier">next_sibling</span></code>
        and <code class="computeroutput"><span class="identifier">previous_sibling</span></code> return
        the first sibling in the corresponding direction with the specified name.
        All string comparisons are case-sensitive. In case the node handle is null
        or there is no node/attribute with the specified name, null handle is returned.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">child</span></code> and <code class="computeroutput"><span class="identifier">next_sibling</span></code>
        functions can be used together to loop through all child nodes with the desired
        name like this:
      </p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">);</span> <span class="identifier">tool</span><span class="special">;</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">))</span>
</pre>
<p>
        <a name="xml_node::find_child_by_attribute"></a>Occasionally the needed node
        is specified not by the unique name but instead by the value of some attribute;
        for example, it is common to have node collections with each node having
        a unique id: <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">group</span><span class="special">&gt;&lt;</span><span class="identifier">item</span>
        <span class="identifier">id</span><span class="special">=</span><span class="string">"1"</span><span class="special">/&gt;</span>
        <span class="special">&lt;</span><span class="identifier">item</span>
        <span class="identifier">id</span><span class="special">=</span><span class="string">"2"</span><span class="special">/&gt;&lt;/</span><span class="identifier">group</span><span class="special">&gt;</span></code>.
        There are two functions for finding child nodes based on the attribute values:
      </p>
<pre class="programlisting"><span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">find_child_by_attribute</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">attr_name</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">attr_value</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">find_child_by_attribute</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">attr_name</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">attr_value</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        The three-argument function returns the first child node with the specified
        name which has an attribute with the specified name/value; the two-argument
        function skips the name test for the node, which can be useful for searching
        in heterogeneous collections. If the node handle is null or if no node is
        found, null handle is returned. All string comparisons are case-sensitive.
      </p>
<p>
        In all of the above functions, all arguments have to be valid strings; passing
        null pointers results in undefined behavior.
      </p>
<p>
        This is an example of using these functions (<a href="../samples/traverse_base.cpp" target="_top">samples/traverse_base.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool for *.dae generation: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">find_child_by_attribute</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">,</span> <span class="string">"OutputFileMasks"</span><span class="special">,</span> <span class="string">"*.dae"</span><span class="special">).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>

<span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">);</span> <span class="identifier">tool</span><span class="special">;</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">))</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool "</span> <span class="special">&lt;&lt;</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.access.rangefor"></a><a class="link" href="access.html#manual.access.rangefor" title="Range-based for-loop support">Range-based for-loop support</a>
</h3></div></div></div>
<p>
        <a name="xml_node::children"></a><a name="xml_node::attributes"></a>If your
        C++ compiler supports range-based for-loop (this is a C++11 feature, at the
        time of writing it's supported by Microsoft Visual Studio 11 Beta, GCC 4.6
        and Clang 3.0), you can use it to enumerate nodes/attributes. Additional
        helpers are provided to support this; note that they are also compatible
        with <a href="http://www.boost.org/libs/foreach/" target="_top">Boost Foreach</a>,
        and possibly other pre-C++11 foreach facilities.
      </p>
<pre class="programlisting"><span class="emphasis"><em>implementation-defined type</em></span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">children</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="emphasis"><em>implementation-defined type</em></span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">children</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="emphasis"><em>implementation-defined type</em></span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">attributes</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">children</span></code> function allows
        you to enumerate all child nodes; <code class="computeroutput"><span class="identifier">children</span></code>
        function with <code class="computeroutput"><span class="identifier">name</span></code> argument
        allows you to enumerate all child nodes with a specific name; <code class="computeroutput"><span class="identifier">attributes</span></code> function allows you to enumerate
        all attributes of the node. Note that you can also use node object itself
        in a range-based for construct, which is equivalent to using <code class="computeroutput"><span class="identifier">children</span><span class="special">()</span></code>.
      </p>
<p>
        This is an example of using these functions (<a href="../samples/traverse_rangefor.cpp" target="_top">samples/traverse_rangefor.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">tool</span><span class="special">:</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">children</span><span class="special">(</span><span class="string">"Tool"</span><span class="special">))</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool:"</span><span class="special">;</span>

    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_attribute</span> <span class="identifier">attr</span><span class="special">:</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">attributes</span><span class="special">())</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" "</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"="</span> <span class="special">&lt;&lt;</span> <span class="identifier">attr</span><span class="special">.</span><span class="identifier">value</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">child</span><span class="special">:</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">children</span><span class="special">())</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">", child "</span> <span class="special">&lt;&lt;</span> <span class="identifier">child</span><span class="special">.</span><span class="identifier">name</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.access.iterators"></a><a class="link" href="access.html#manual.access.iterators" title="Traversing node/attribute lists via iterators">Traversing node/attribute lists
      via iterators</a>
</h3></div></div></div>
<p>
        <a name="xml_node_iterator"></a><a name="xml_attribute_iterator"></a><a name="xml_node::begin"></a><a name="xml_node::end"></a><a name="xml_node::attributes_begin"></a><a name="xml_node::attributes_end"></a>Child node lists and attribute lists are simply
        double-linked lists; while you can use <code class="computeroutput"><span class="identifier">previous_sibling</span></code>/<code class="computeroutput"><span class="identifier">next_sibling</span></code> and other such functions for
        iteration, pugixml additionally provides node and attribute iterators, so
        that you can treat nodes as containers of other nodes or attributes:
      </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">xml_node_iterator</span><span class="special">;</span>
<span class="keyword">class</span> <span class="identifier">xml_attribute_iterator</span><span class="special">;</span>

<span class="keyword">typedef</span> <span class="identifier">xml_node_iterator</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">;</span>
<span class="identifier">iterator</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">begin</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">iterator</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">end</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

<span class="keyword">typedef</span> <span class="identifier">xml_attribute_iterator</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">attribute_iterator</span><span class="special">;</span>
<span class="identifier">attribute_iterator</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">attributes_begin</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">attribute_iterator</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">attributes_end</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">begin</span></code> and <code class="computeroutput"><span class="identifier">attributes_begin</span></code>
        return iterators that point to the first node/attribute, respectively; <code class="computeroutput"><span class="identifier">end</span></code> and <code class="computeroutput"><span class="identifier">attributes_end</span></code>
        return past-the-end iterator for node/attribute list, respectively - this
        iterator can't be dereferenced, but decrementing it results in an iterator
        pointing to the last element in the list (except for empty lists, where decrementing
        past-the-end iterator results in undefined behavior). Past-the-end iterator
        is commonly used as a termination value for iteration loops (see sample below).
        If you want to get an iterator that points to an existing handle, you can
        construct the iterator with the handle as a single constructor argument,
        like so: <code class="computeroutput"><span class="identifier">xml_node_iterator</span><span class="special">(</span><span class="identifier">node</span><span class="special">)</span></code>.
        For <code class="computeroutput"><span class="identifier">xml_attribute_iterator</span></code>,
        you'll have to provide both an attribute and its parent node.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">begin</span></code> and <code class="computeroutput"><span class="identifier">end</span></code>
        return equal iterators if called on null node; such iterators can't be dereferenced.
        <code class="computeroutput"><span class="identifier">attributes_begin</span></code> and <code class="computeroutput"><span class="identifier">attributes_end</span></code> behave the same way. For
        correct iterator usage this means that child node/attribute collections of
        null nodes appear to be empty.
      </p>
<p>
        Both types of iterators have bidirectional iterator semantics (i.e. they
        can be incremented and decremented, but efficient random access is not supported)
        and support all usual iterator operations - comparison, dereference, etc.
        The iterators are invalidated if the node/attribute objects they're pointing
        to are removed from the tree; adding nodes/attributes does not invalidate
        any iterators.
      </p>
<p>
        Here is an example of using iterators for document traversal (<a href="../samples/traverse_iter.cpp" target="_top">samples/traverse_iter.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node_iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">it</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tool:"</span><span class="special">;</span>

    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_attribute_iterator</span> <span class="identifier">ait</span> <span class="special">=</span> <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">attributes_begin</span><span class="special">();</span> <span class="identifier">ait</span> <span class="special">!=</span> <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">attributes_end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">ait</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ait</span><span class="special">-&gt;</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"="</span> <span class="special">&lt;&lt;</span> <span class="identifier">ait</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          Node and attribute iterators are somewhere in the middle between const
          and non-const iterators. While dereference operation yields a non-constant
          reference to the object, so that you can use it for tree modification operations,
          modifying this reference by assignment - i.e. passing iterators to a function
          like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">sort</span></code> - will not give expected results,
          as assignment modifies local handle that's stored in the iterator.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.access.walker"></a><a class="link" href="access.html#manual.access.walker" title="Recursive traversal with xml_tree_walker">Recursive traversal with xml_tree_walker</a>
</h3></div></div></div>
<p>
        <a name="xml_tree_walker"></a>The methods described above allow traversal
        of immediate children of some node; if you want to do a deep tree traversal,
        you'll have to do it via a recursive function or some equivalent method.
        However, pugixml provides a helper for depth-first traversal of a subtree.
        In order to use it, you have to implement <code class="computeroutput"><span class="identifier">xml_tree_walker</span></code>
        interface and to call <code class="computeroutput"><span class="identifier">traverse</span></code>
        function:
      </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">xml_tree_walker</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="identifier">begin</span><span class="special">(</span><span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span>
    <span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="identifier">for_each</span><span class="special">(</span><span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">)</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
    <span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="identifier">end</span><span class="special">(</span><span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">);</span>

    <span class="keyword">int</span> <span class="identifier">depth</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">bool</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">traverse</span><span class="special">(</span><span class="identifier">xml_tree_walker</span><span class="special">&amp;</span> <span class="identifier">walker</span><span class="special">);</span>
</pre>
<p>
        <a name="xml_tree_walker::begin"></a><a name="xml_tree_walker::for_each"></a><a name="xml_tree_walker::end"></a><a name="xml_node::traverse"></a>The traversal
        is launched by calling <code class="computeroutput"><span class="identifier">traverse</span></code>
        function on traversal root and proceeds as follows:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            First, <code class="computeroutput"><span class="identifier">begin</span></code> function
            is called with traversal root as its argument.
          </li>
<li class="listitem">
            Then, <code class="computeroutput"><span class="identifier">for_each</span></code> function
            is called for all nodes in the traversal subtree in depth first order,
            excluding the traversal root. Node is passed as an argument.
          </li>
<li class="listitem">
            Finally, <code class="computeroutput"><span class="identifier">end</span></code> function
            is called with traversal root as its argument.
          </li>
</ul></div>
<p>
        If <code class="computeroutput"><span class="identifier">begin</span></code>, <code class="computeroutput"><span class="identifier">end</span></code>
        or any of the <code class="computeroutput"><span class="identifier">for_each</span></code> calls
        return <code class="computeroutput"><span class="keyword">false</span></code>, the traversal
        is terminated and <code class="computeroutput"><span class="keyword">false</span></code> is returned
        as the traversal result; otherwise, the traversal results in <code class="computeroutput"><span class="keyword">true</span></code>. Note that you don't have to override
        <code class="computeroutput"><span class="identifier">begin</span></code> or <code class="computeroutput"><span class="identifier">end</span></code>
        functions; their default implementations return <code class="computeroutput"><span class="keyword">true</span></code>.
      </p>
<p>
        <a name="xml_tree_walker::depth"></a>You can get the node's depth relative
        to the traversal root at any point by calling <code class="computeroutput"><span class="identifier">depth</span></code>
        function. It returns <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>
        if called from <code class="computeroutput"><span class="identifier">begin</span></code>/<code class="computeroutput"><span class="identifier">end</span></code>, and returns 0-based depth if called
        from <code class="computeroutput"><span class="identifier">for_each</span></code> - depth is
        0 for all children of the traversal root, 1 for all grandchildren and so
        on.
      </p>
<p>
        This is an example of traversing tree hierarchy with xml_tree_walker (<a href="../samples/traverse_walker.cpp" target="_top">samples/traverse_walker.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">simple_walker</span><span class="special">:</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_tree_walker</span>
<span class="special">{</span>
    <span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="identifier">for_each</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span><span class="special">&amp;</span> <span class="identifier">node</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">depth</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"  "</span><span class="special">;</span> <span class="comment">// indentation</span>

        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">node_types</span><span class="special">[</span><span class="identifier">node</span><span class="special">.</span><span class="identifier">type</span><span class="special">()]</span> <span class="special">&lt;&lt;</span> <span class="string">": name='"</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"', value='"</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"'\n"</span><span class="special">;</span>

        <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span> <span class="comment">// continue traversal</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">simple_walker</span> <span class="identifier">walker</span><span class="special">;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">traverse</span><span class="special">(</span><span class="identifier">walker</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.access.predicate"></a><a class="link" href="access.html#manual.access.predicate" title="Searching for nodes/attributes with predicates">Searching for nodes/attributes
      with predicates</a>
</h3></div></div></div>
<p>
        <a name="xml_node::find_attribute"></a><a name="xml_node::find_child"></a><a name="xml_node::find_node"></a>While there are existing functions for getting
        a node/attribute with known contents, they are often not sufficient for simple
        queries. As an alternative for manual iteration through nodes/attributes
        until the needed one is found, you can make a predicate and call one of
        <code class="computeroutput"><span class="identifier">find_</span></code> functions:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="identifier">xml_attribute</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">find_attribute</span><span class="special">(</span><span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">find_child</span><span class="special">(</span><span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">find_node</span><span class="special">(</span><span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        The predicate should be either a plain function or a function object which
        accepts one argument of type <code class="computeroutput"><span class="identifier">xml_attribute</span></code>
        (for <code class="computeroutput"><span class="identifier">find_attribute</span></code>) or
        <code class="computeroutput"><span class="identifier">xml_node</span></code> (for <code class="computeroutput"><span class="identifier">find_child</span></code> and <code class="computeroutput"><span class="identifier">find_node</span></code>),
        and returns <code class="computeroutput"><span class="keyword">bool</span></code>. The predicate
        is never called with null handle as an argument.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">find_attribute</span></code> function iterates
        through all attributes of the specified node, and returns the first attribute
        for which the predicate returned <code class="computeroutput"><span class="keyword">true</span></code>.
        If the predicate returned <code class="computeroutput"><span class="keyword">false</span></code>
        for all attributes or if there were no attributes (including the case where
        the node is null), null attribute is returned.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">find_child</span></code> function iterates
        through all child nodes of the specified node, and returns the first node
        for which the predicate returned <code class="computeroutput"><span class="keyword">true</span></code>.
        If the predicate returned <code class="computeroutput"><span class="keyword">false</span></code>
        for all nodes or if there were no child nodes (including the case where the
        node is null), null node is returned.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">find_node</span></code> function performs
        a depth-first traversal through the subtree of the specified node (excluding
        the node itself), and returns the first node for which the predicate returned
        <code class="computeroutput"><span class="keyword">true</span></code>. If the predicate returned
        <code class="computeroutput"><span class="keyword">false</span></code> for all nodes or if subtree
        was empty, null node is returned.
      </p>
<p>
        This is an example of using predicate-based functions (<a href="../samples/traverse_predicate.cpp" target="_top">samples/traverse_predicate.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">small_timeout</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Timeout"</span><span class="special">).</span><span class="identifier">as_int</span><span class="special">()</span> <span class="special">&lt;</span> <span class="number">20</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">struct</span> <span class="identifier">allow_remote_predicate</span>
<span class="special">{</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_attribute</span> <span class="identifier">attr</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">attr</span><span class="special">.</span><span class="identifier">name</span><span class="special">(),</span> <span class="string">"AllowRemote"</span><span class="special">)</span> <span class="special">==</span> <span class="number">0</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"AllowRemote"</span><span class="special">).</span><span class="identifier">as_bool</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Find child via predicate (looks for direct children only)</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">find_child</span><span class="special">(</span><span class="identifier">allow_remote_predicate</span><span class="special">()).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// Find node via predicate (looks for all descendants in depth-first order)</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">find_node</span><span class="special">(</span><span class="identifier">allow_remote_predicate</span><span class="special">()).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// Find attribute via predicate</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">last_child</span><span class="special">().</span><span class="identifier">find_attribute</span><span class="special">(</span><span class="identifier">allow_remote_predicate</span><span class="special">()).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// We can use simple functions instead of function objects</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">find_child</span><span class="special">(</span><span class="identifier">small_timeout</span><span class="special">).</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.access.text"></a><a class="link" href="access.html#manual.access.text" title="Working with text contents">Working with text contents</a>
</h3></div></div></div>
<p>
        <a name="xml_text"></a>It is common to store data as text contents of some
        node - i.e. <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;&lt;</span><span class="identifier">description</span><span class="special">&gt;</span><span class="identifier">This</span> <span class="identifier">is</span> <span class="identifier">a</span> <span class="identifier">node</span><span class="special">&lt;/</span><span class="identifier">description</span><span class="special">&gt;&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span></code>.
        In this case, <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">description</span><span class="special">&gt;</span></code> node does not have a value, but instead
        has a child of type <a class="link" href="dom.html#node_pcdata">node_pcdata</a> with value
        <code class="computeroutput"><span class="string">"This is a node"</span></code>. pugixml
        provides a special class, <code class="computeroutput"><span class="identifier">xml_text</span></code>,
        to work with such data. Working with text objects to modify data is described
        in <a class="link" href="modify.html#manual.modify.text" title="Working with text contents">the documentation for modifying document
        data</a>; this section describes the access interface of <code class="computeroutput"><span class="identifier">xml_text</span></code>.
      </p>
<p>
        <a name="xml_node::text"></a>You can get the text object from a node by using
        <code class="computeroutput"><span class="identifier">text</span><span class="special">()</span></code>
        method:
      </p>
<pre class="programlisting"><span class="identifier">xml_text</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">text</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        If the node has a type <code class="computeroutput"><span class="identifier">node_pcdata</span></code>
        or <code class="computeroutput"><span class="identifier">node_cdata</span></code>, then the node
        itself is used to return data; otherwise, a first child node of type <code class="computeroutput"><span class="identifier">node_pcdata</span></code> or <code class="computeroutput"><span class="identifier">node_cdata</span></code>
        is used.
      </p>
<p>
        <a name="xml_text::empty"></a><a name="xml_text::unspecified_bool_type"></a>You
        can check if the text object is bound to a valid PCDATA/CDATA node by using
        it as a boolean value, i.e. <code class="computeroutput"><span class="keyword">if</span> <span class="special">(</span><span class="identifier">text</span><span class="special">)</span>
        <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code> or <code class="computeroutput"><span class="keyword">if</span>
        <span class="special">(!</span><span class="identifier">text</span><span class="special">)</span> <span class="special">{</span> <span class="special">...</span>
        <span class="special">}</span></code>. Alternatively you can check it
        by using the <code class="computeroutput"><span class="identifier">empty</span><span class="special">()</span></code>
        method:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">empty</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <a name="xml_text::get"></a>Given a text object, you can get the contents
        (i.e. the value of PCDATA/CDATA node) by using the following function:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">get</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        In case text object is empty, the function returns an empty string - it never
        returns a null pointer.
      </p>
<p>
        <a name="xml_text::as_string"></a><a name="xml_text::as_int"></a><a name="xml_text::as_uint"></a><a name="xml_text::as_double"></a><a name="xml_text::as_float"></a><a name="xml_text::as_bool"></a><a name="xml_text::as_llong"></a><a name="xml_text::as_ullong"></a>If
        you need a non-empty string if the text object is empty, or if the text contents
        is actually a number or a boolean that is stored as a string, you can use
        the following accessors:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">as_string</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">def</span> <span class="special">=</span> <span class="string">""</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">as_int</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">as_uint</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">double</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">as_double</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">float</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">as_float</span><span class="special">(</span><span class="keyword">float</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">as_bool</span><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">def</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">as_llong</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">as_ullong</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">def</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        All of the above functions have the same semantics as similar <code class="computeroutput"><span class="identifier">xml_attribute</span></code> members: they return the
        default argument if the text object is empty, they convert the text contents
        to a target type using the same rules and restrictions. You can <a class="link" href="access.html#xml_attribute::as_int">refer
        to documentation for the attribute functions</a> for details.
      </p>
<p>
        <a name="xml_text::data"></a><code class="computeroutput"><span class="identifier">xml_text</span></code>
        is essentially a helper class that operates on <code class="computeroutput"><span class="identifier">xml_node</span></code>
        values. It is bound to a node of type <a class="link" href="dom.html#node_pcdata">node_pcdata</a>
        or <a class="link" href="dom.html#node_cdata">node_cdata</a>. You can use the following
        function to retrieve this node:
      </p>
<pre class="programlisting"><span class="identifier">xml_node</span> <span class="identifier">xml_text</span><span class="special">::</span><span class="identifier">data</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        Essentially, assuming <code class="computeroutput"><span class="identifier">text</span></code>
        is an <code class="computeroutput"><span class="identifier">xml_text</span></code> object, calling
        <code class="computeroutput"><span class="identifier">text</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span></code> is
        equivalent to calling <code class="computeroutput"><span class="identifier">text</span><span class="special">.</span><span class="identifier">data</span><span class="special">().</span><span class="identifier">value</span><span class="special">()</span></code>.
      </p>
<p>
        This is an example of using <code class="computeroutput"><span class="identifier">xml_text</span></code>
        object (<a href="../samples/text.cpp" target="_top">samples/text.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Project name: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">project</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"name"</span><span class="special">).</span><span class="identifier">text</span><span class="special">().</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Project version: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">project</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"version"</span><span class="special">).</span><span class="identifier">text</span><span class="special">().</span><span class="identifier">as_double</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Project visibility: "</span> <span class="special">&lt;&lt;</span> <span class="special">(</span><span class="identifier">project</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"public"</span><span class="special">).</span><span class="identifier">text</span><span class="special">().</span><span class="identifier">as_bool</span><span class="special">(/*</span> <span class="identifier">def</span><span class="special">=</span> <span class="special">*/</span> <span class="keyword">true</span><span class="special">)</span> <span class="special">?</span> <span class="string">"public"</span> <span class="special">:</span> <span class="string">"private"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Project description: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">project</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"description"</span><span class="special">).</span><span class="identifier">text</span><span class="special">().</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.access.misc"></a><a class="link" href="access.html#manual.access.misc" title="Miscellaneous functions">Miscellaneous functions</a>
</h3></div></div></div>
<p>
        <a name="xml_node::root"></a>If you need to get the document root of some
        node, you can use the following function:
      </p>
<pre class="programlisting"><span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">root</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        This function returns the node with type <a class="link" href="dom.html#node_document">node_document</a>,
        which is the root node of the document the node belongs to (unless the node
        is null, in which case null node is returned).
      </p>
<p>
        <a name="xml_node::path"></a><a name="xml_node::first_element_by_path"></a>While
        pugixml supports complex XPath expressions, sometimes a simple path handling
        facility is needed. There are two functions, for getting node path and for
        converting path to a node:
      </p>
<pre class="programlisting"><span class="identifier">string_t</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">path</span><span class="special">(</span><span class="identifier">char_t</span> <span class="identifier">delimiter</span> <span class="special">=</span> <span class="char">'/'</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">first_element_by_path</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">path</span><span class="special">,</span> <span class="identifier">char_t</span> <span class="identifier">delimiter</span> <span class="special">=</span> <span class="char">'/'</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        Node paths consist of node names, separated with a delimiter (which is <code class="computeroutput"><span class="special">/</span></code> by default); also paths can contain self
        (<code class="computeroutput"><span class="special">.</span></code>) and parent (<code class="computeroutput"><span class="special">..</span></code>) pseudo-names, so that this is a valid
        path: <code class="computeroutput"><span class="string">"../../foo/./bar"</span></code>.
        <code class="computeroutput"><span class="identifier">path</span></code> returns the path to
        the node from the document root, <code class="computeroutput"><span class="identifier">first_element_by_path</span></code>
        looks for a node represented by a given path; a path can be an absolute one
        (absolute paths start with the delimiter), in which case the rest of the
        path is treated as document root relative, and relative to the given node.
        For example, in the following document: <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;&lt;</span><span class="identifier">b</span><span class="special">&gt;&lt;</span><span class="identifier">c</span><span class="special">/&gt;&lt;/</span><span class="identifier">b</span><span class="special">&gt;&lt;/</span><span class="identifier">a</span><span class="special">&gt;</span></code>,
        node <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">c</span><span class="special">/&gt;</span></code> has path <code class="computeroutput"><span class="string">"a/b/c"</span></code>;
        calling <code class="computeroutput"><span class="identifier">first_element_by_path</span></code>
        for document with path <code class="computeroutput"><span class="string">"a/b"</span></code>
        results in node <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">b</span><span class="special">/&gt;</span></code>; calling <code class="computeroutput"><span class="identifier">first_element_by_path</span></code>
        for node <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">a</span><span class="special">/&gt;</span></code> with path <code class="computeroutput"><span class="string">"../a/./b/../."</span></code>
        results in node <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">a</span><span class="special">/&gt;</span></code>; calling <code class="computeroutput"><span class="identifier">first_element_by_path</span></code>
        with path <code class="computeroutput"><span class="string">"/a"</span></code> results
        in node <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">a</span><span class="special">/&gt;</span></code> for any node.
      </p>
<p>
        In case path component is ambiguous (if there are two nodes with given name),
        the first one is selected; paths are not guaranteed to uniquely identify
        nodes in a document. If any component of a path is not found, the result
        of <code class="computeroutput"><span class="identifier">first_element_by_path</span></code>
        is null node; also <code class="computeroutput"><span class="identifier">first_element_by_path</span></code>
        returns null node for null nodes, in which case the path does not matter.
        <code class="computeroutput"><span class="identifier">path</span></code> returns an empty string
        for null nodes.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><span class="identifier">path</span></code> function returns the
          result as STL string, and thus is not available if <a class="link" href="install.html#PUGIXML_NO_STL">PUGIXML_NO_STL</a>
          is defined.
        </p></td></tr>
</table></div>
<p>
        <a name="xml_node::offset_debug"></a>pugixml does not record row/column information
        for nodes upon parsing for efficiency reasons. However, if the node has not
        changed in a significant way since parsing (the name/value are not changed,
        and the node itself is the original one, i.e. it was not deleted from the
        tree and re-added later), it is possible to get the offset from the beginning
        of XML buffer:
      </p>
<pre class="programlisting"><span class="identifier">ptrdiff_t</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">offset_debug</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        If the offset is not available (this happens if the node is null, was not
        originally parsed from a stream, or has changed in a significant way), the
        function returns -1. Otherwise it returns the offset to node's data from
        the beginning of XML buffer in <a class="link" href="dom.html#char_t">pugi::char_t</a>
        units. For more information on parsing offsets, see <a class="link" href="loading.html#xml_parse_result::offset">parsing
        error handling documentation</a>.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Arseny Kapoulkine<p>
        Distributed under the MIT License
      </p>
</div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <b>Accessing</b> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="loading.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="modify.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual/dom.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Document object model</title>
<link rel="stylesheet" href="../pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../manual.html" title="pugixml 1.4">
<link rel="up" href="../manual.html" title="pugixml 1.4">
<link rel="prev" href="install.html" title="Installation">
<link rel="next" href="loading.html" title="Loading document">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<b>Object model</b> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="install.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="loading.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
<hr>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.dom"></a><a class="link" href="dom.html" title="Document object model">Document object model</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="dom.html#manual.dom.tree">Tree structure</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.cpp">C++ interface</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.unicode">Unicode interface</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.thread">Thread-safety guarantees</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.exception">Exception guarantees</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.memory">Memory management</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="dom.html#manual.dom.memory.custom">Custom memory allocation/deallocation
        functions</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.memory.tuning">Memory consumption tuning</a></span></dt>
<dt><span class="section"><a href="dom.html#manual.dom.memory.internals">Document memory management
        internals</a></span></dt>
</dl></dd>
</dl></div>
<p>
      pugixml stores XML data in DOM-like way: the entire XML document (both document
      structure and element data) is stored in memory as a tree. The tree can be
      loaded from a character stream (file, string, C++ I/O stream), then traversed
      with the special API or XPath expressions. The whole tree is mutable: both
      node structure and node/attribute data can be changed at any time. Finally,
      the result of document transformations can be saved to a character stream (file,
      C++ I/O stream or custom transport).
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.dom.tree"></a><a class="link" href="dom.html#manual.dom.tree" title="Tree structure">Tree structure</a>
</h3></div></div></div>
<p>
        The XML document is represented with a tree data structure. The root of the
        tree is the document itself, which corresponds to C++ type <a class="link" href="dom.html#xml_document">xml_document</a>.
        Document has one or more child nodes, which correspond to C++ type <a class="link" href="dom.html#xml_node">xml_node</a>. Nodes have different types; depending
        on a type, a node can have a collection of child nodes, a collection of attributes,
        which correspond to C++ type <a class="link" href="dom.html#xml_attribute">xml_attribute</a>,
        and some additional data (i.e. name).
      </p>
<p>
        <a name="xml_node_type"></a>The tree nodes can be of one of the following
        types (which together form the enumeration <code class="computeroutput"><span class="identifier">xml_node_type</span></code>):
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Document node (<a name="node_document"></a><code class="literal">node_document</code>) - this
            is the root of the tree, which consists of several child nodes. This
            node corresponds to <a class="link" href="dom.html#xml_document">xml_document</a>
            class; note that <a class="link" href="dom.html#xml_document">xml_document</a> is
            a sub-class of <a class="link" href="dom.html#xml_node">xml_node</a>, so the entire
            node interface is also available. However, document node is special in
            several ways, which are covered below. There can be only one document
            node in the tree; document node does not have any XML representation.
            <br><br>
          </li>
<li class="listitem">
            Element/tag node (<a name="node_element"></a><code class="literal">node_element</code>) - this
            is the most common type of node, which represents XML elements. Element
            nodes have a name, a collection of attributes and a collection of child
            nodes (both of which may be empty). The attribute is a simple name/value
            pair. The example XML representation of element nodes is as follows:
          </li>
</ul></div>
<pre class="programlisting"><span class="special">&lt;</span><span class="identifier">node</span> <span class="identifier">attr</span><span class="special">=</span><span class="string">"value"</span><span class="special">&gt;&lt;</span><span class="identifier">child</span><span class="special">/&gt;&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span>
</pre>
<div class="blockquote"><blockquote class="blockquote"><p>
          There are two element nodes here: one has name <code class="computeroutput"><span class="string">"node"</span></code>,
          single attribute <code class="computeroutput"><span class="string">"attr"</span></code>
          and single child <code class="computeroutput"><span class="string">"child"</span></code>,
          another has name <code class="computeroutput"><span class="string">"child"</span></code>
          and does not have any attributes or child nodes.
        </p></blockquote></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Plain character data nodes (<a name="node_pcdata"></a><code class="literal">node_pcdata</code>)
            represent plain text in XML. PCDATA nodes have a value, but do not have
            a name or children/attributes. Note that <span class="bold"><strong>plain
            character data is not a part of the element node but instead has its
            own node</strong></span>; an element node can have several child PCDATA nodes.
            The example XML representation of text nodes is as follows:
          </li></ul></div>
<pre class="programlisting"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;</span> <span class="identifier">text1</span> <span class="special">&lt;</span><span class="identifier">child</span><span class="special">/&gt;</span> <span class="identifier">text2</span> <span class="special">&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span>
</pre>
<div class="blockquote"><blockquote class="blockquote"><p>
          Here <code class="computeroutput"><span class="string">"node"</span></code> element
          has three children, two of which are PCDATA nodes with values <code class="computeroutput"><span class="string">" text1 "</span></code> and <code class="computeroutput"><span class="string">"
          text2 "</span></code>.
        </p></blockquote></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Character data nodes (<a name="node_cdata"></a><code class="literal">node_cdata</code>) represent
            text in XML that is quoted in a special way. CDATA nodes do not differ
            from PCDATA nodes except in XML representation - the above text example
            looks like this with CDATA:
          </li></ul></div>
<pre class="programlisting"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;</span> <span class="special">&lt;![</span><span class="identifier">CDATA</span><span class="special">[[</span><span class="identifier">text1</span><span class="special">]]&gt;</span> <span class="special">&lt;</span><span class="identifier">child</span><span class="special">/&gt;</span> <span class="special">&lt;![</span><span class="identifier">CDATA</span><span class="special">[[</span><span class="identifier">text2</span><span class="special">]]&gt;</span> <span class="special">&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span>
</pre>
<div class="blockquote"><blockquote class="blockquote"><p>
          CDATA nodes make it easy to include non-escaped &lt;, &amp; and &gt; characters
          in plain text. CDATA value can not contain the character sequence ]]&gt;,
          since it is used to determine the end of node contents.
        </p></blockquote></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Comment nodes (<a name="node_comment"></a><code class="literal">node_comment</code>) represent
            comments in XML. Comment nodes have a value, but do not have a name or
            children/attributes. The example XML representation of a comment node
            is as follows:
          </li></ul></div>
<pre class="programlisting"><span class="special">&lt;!--</span> <span class="identifier">comment</span> <span class="identifier">text</span> <span class="special">--&gt;</span>
</pre>
<div class="blockquote"><blockquote class="blockquote"><p>
          Here the comment node has value <code class="computeroutput"><span class="string">"comment
          text"</span></code>. By default comment nodes are treated as non-essential
          part of XML markup and are not loaded during XML parsing. You can override
          this behavior with <a class="link" href="loading.html#parse_comments">parse_comments</a>
          flag.
        </p></blockquote></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Processing instruction node (<a name="node_pi"></a><code class="literal">node_pi</code>) represent
            processing instructions (PI) in XML. PI nodes have a name and an optional
            value, but do not have children/attributes. The example XML representation
            of a PI node is as follows:
          </li></ul></div>
<pre class="programlisting"><span class="special">&lt;?</span><span class="identifier">name</span> <span class="identifier">value</span><span class="special">?&gt;</span>
</pre>
<div class="blockquote"><blockquote class="blockquote"><p>
          Here the name (also called PI target) is <code class="computeroutput"><span class="string">"name"</span></code>,
          and the value is <code class="computeroutput"><span class="string">"value"</span></code>.
          By default PI nodes are treated as non-essential part of XML markup and
          are not loaded during XML parsing. You can override this behavior with
          <a class="link" href="loading.html#parse_pi">parse_pi</a> flag.
        </p></blockquote></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Declaration node (<a name="node_declaration"></a><code class="literal">node_declaration</code>)
            represents document declarations in XML. Declaration nodes have a name
            (<code class="computeroutput"><span class="string">"xml"</span></code>) and an
            optional collection of attributes, but do not have value or children.
            There can be only one declaration node in a document; moreover, it should
            be the topmost node (its parent should be the document). The example
            XML representation of a declaration node is as follows:
          </li></ul></div>
<pre class="programlisting"><span class="special">&lt;?</span><span class="identifier">xml</span> <span class="identifier">version</span><span class="special">=</span><span class="string">"1.0"</span><span class="special">?&gt;</span>
</pre>
<div class="blockquote"><blockquote class="blockquote"><p>
          Here the node has name <code class="computeroutput"><span class="string">"xml"</span></code>
          and a single attribute with name <code class="computeroutput"><span class="string">"version"</span></code>
          and value <code class="computeroutput"><span class="string">"1.0"</span></code>.
          By default declaration nodes are treated as non-essential part of XML markup
          and are not loaded during XML parsing. You can override this behavior with
          <a class="link" href="loading.html#parse_declaration">parse_declaration</a> flag. Also,
          by default a dummy declaration is output when XML document is saved unless
          there is already a declaration in the document; you can disable this with
          <a class="link" href="saving.html#format_no_declaration">format_no_declaration</a> flag.
        </p></blockquote></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Document type declaration node (<a name="node_doctype"></a><code class="literal">node_doctype</code>)
            represents document type declarations in XML. Document type declaration
            nodes have a value, which corresponds to the entire document type contents;
            no additional nodes are created for inner elements like <code class="computeroutput"><span class="special">&lt;!</span><span class="identifier">ENTITY</span><span class="special">&gt;</span></code>. There can be only one document type
            declaration node in a document; moreover, it should be the topmost node
            (its parent should be the document). The example XML representation of
            a document type declaration node is as follows:
          </li></ul></div>
<pre class="programlisting"><span class="special">&lt;!</span><span class="identifier">DOCTYPE</span> <span class="identifier">greeting</span> <span class="special">[</span> <span class="special">&lt;!</span><span class="identifier">ELEMENT</span> <span class="identifier">greeting</span> <span class="special">(#</span><span class="identifier">PCDATA</span><span class="special">)&gt;</span> <span class="special">]&gt;</span>
</pre>
<div class="blockquote"><blockquote class="blockquote"><p>
          Here the node has value <code class="computeroutput"><span class="string">"greeting [ &lt;!ELEMENT
          greeting (#PCDATA)&gt; ]"</span></code>. By default document type
          declaration nodes are treated as non-essential part of XML markup and are
          not loaded during XML parsing. You can override this behavior with <a class="link" href="loading.html#parse_doctype">parse_doctype</a> flag.
        </p></blockquote></div>
<p>
        Finally, here is a complete example of XML document and the corresponding
        tree representation (<a href="../samples/tree.xml" target="_top">samples/tree.xml</a>):
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td>
                <p>
</p>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="special">&lt;?</span><span class="identifier">xml</span> <span class="identifier">version</span><span class="special">=</span><span class="string">"1.0"</span><span class="special">?&gt;</span>
<span class="special">&lt;</span><span class="identifier">mesh</span> <span class="identifier">name</span><span class="special">=</span><span class="string">"mesh_root"</span><span class="special">&gt;</span>
    <span class="special">&lt;!--</span> <span class="identifier">here</span> <span class="identifier">is</span> <span class="identifier">a</span> <span class="identifier">mesh</span> <span class="identifier">node</span> <span class="special">--&gt;</span>
    <span class="identifier">some</span> <span class="identifier">text</span>
    <span class="special">&lt;![</span><span class="identifier">CDATA</span><span class="special">[</span><span class="identifier">someothertext</span><span class="special">]]&gt;</span>
    <span class="identifier">some</span> <span class="identifier">more</span> <span class="identifier">text</span>
    <span class="special">&lt;</span><span class="identifier">node</span> <span class="identifier">attr1</span><span class="special">=</span><span class="string">"value1"</span> <span class="identifier">attr2</span><span class="special">=</span><span class="string">"value2"</span> <span class="special">/&gt;</span>
    <span class="special">&lt;</span><span class="identifier">node</span> <span class="identifier">attr1</span><span class="special">=</span><span class="string">"value2"</span><span class="special">&gt;</span>
        <span class="special">&lt;</span><span class="identifier">innernode</span><span class="special">/&gt;</span>
    <span class="special">&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span>
<span class="special">&lt;/</span><span class="identifier">mesh</span><span class="special">&gt;</span>
<span class="special">&lt;?</span><span class="identifier">include</span> <span class="identifier">somedata</span><span class="special">?&gt;</span>
</pre>
<p>
                </p>
              </td>
<td>
                <p>
                  <a href="../images/dom_tree.png" target="_top"><span class="inlinemediaobject"><img src="../images/dom_tree_thumb.png" alt="dom_tree_thumb"></span></a>
                </p>
              </td>
</tr></tbody>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.dom.cpp"></a><a class="link" href="dom.html#manual.dom.cpp" title="C++ interface">C++ interface</a>
</h3></div></div></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          All pugixml classes and functions are located in the <code class="computeroutput"><span class="identifier">pugi</span></code>
          namespace; you have to either use explicit name qualification (i.e. <code class="computeroutput"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span></code>), or to gain access to relevant
          symbols via <code class="computeroutput"><span class="keyword">using</span></code> directive
          (i.e. <code class="computeroutput"><span class="keyword">using</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span><span class="special">;</span></code> or <code class="computeroutput"><span class="keyword">using</span>
          <span class="keyword">namespace</span> <span class="identifier">pugi</span><span class="special">;</span></code>). The namespace will be omitted from all
          declarations in this documentation hereafter; all code examples will use
          fully qualified names.
        </p></td></tr>
</table></div>
<p>
        Despite the fact that there are several node types, there are only three
        C++ classes representing the tree (<code class="computeroutput"><span class="identifier">xml_document</span></code>,
        <code class="computeroutput"><span class="identifier">xml_node</span></code>, <code class="computeroutput"><span class="identifier">xml_attribute</span></code>);
        some operations on <code class="computeroutput"><span class="identifier">xml_node</span></code>
        are only valid for certain node types. The classes are described below.
      </p>
<p>
        <a name="xml_document"></a><a name="xml_document::document_element"></a><code class="computeroutput"><span class="identifier">xml_document</span></code> is the owner of the entire
        document structure; it is a non-copyable class. The interface of <code class="computeroutput"><span class="identifier">xml_document</span></code> consists of loading functions
        (see <a class="xref" href="loading.html" title="Loading document">Loading document</a>), saving functions (see <a class="xref" href="saving.html" title="Saving document">Saving document</a>) and the entire
        interface of <code class="computeroutput"><span class="identifier">xml_node</span></code>, which
        allows for document inspection and/or modification. Note that while <code class="computeroutput"><span class="identifier">xml_document</span></code> is a sub-class of <code class="computeroutput"><span class="identifier">xml_node</span></code>, <code class="computeroutput"><span class="identifier">xml_node</span></code>
        is not a polymorphic type; the inheritance is present only to simplify usage.
        Alternatively you can use the <code class="computeroutput"><span class="identifier">document_element</span></code>
        function to get the element node that's the immediate child of the document.
      </p>
<p>
        <a name="xml_document::ctor"></a><a name="xml_document::dtor"></a><a name="xml_document::reset"></a>Default constructor of <code class="computeroutput"><span class="identifier">xml_document</span></code>
        initializes the document to the tree with only a root node (document node).
        You can then populate it with data using either tree modification functions
        or loading functions; all loading functions destroy the previous tree with
        all occupied memory, which puts existing node/attribute handles for this
        document to invalid state. If you want to destroy the previous tree, you
        can use the <code class="computeroutput"><span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">reset</span></code>
        function; it destroys the tree and replaces it with either an empty one or
        a copy of the specified document. Destructor of <code class="computeroutput"><span class="identifier">xml_document</span></code>
        also destroys the tree, thus the lifetime of the document object should exceed
        the lifetimes of any node/attribute handles that point to the tree.
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          While technically node/attribute handles can be alive when the tree they're
          referring to is destroyed, calling any member function for these handles
          results in undefined behavior. Thus it is recommended to make sure that
          the document is destroyed only after all references to its nodes/attributes
          are destroyed.
        </p></td></tr>
</table></div>
<p>
        <a name="xml_node"></a><a name="xml_node::type"></a><code class="computeroutput"><span class="identifier">xml_node</span></code>
        is the handle to document node; it can point to any node in the document,
        including the document node itself. There is a common interface for nodes
        of all types; the actual <a class="link" href="dom.html#xml_node_type">node type</a> can
        be queried via the <code class="computeroutput"><span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">type</span><span class="special">()</span></code> method. Note that <code class="computeroutput"><span class="identifier">xml_node</span></code>
        is only a handle to the actual node, not the node itself - you can have several
        <code class="computeroutput"><span class="identifier">xml_node</span></code> handles pointing
        to the same underlying object. Destroying <code class="computeroutput"><span class="identifier">xml_node</span></code>
        handle does not destroy the node and does not remove it from the tree. The
        size of <code class="computeroutput"><span class="identifier">xml_node</span></code> is equal
        to that of a pointer, so it is nothing more than a lightweight wrapper around
        a pointer; you can safely pass or return <code class="computeroutput"><span class="identifier">xml_node</span></code>
        objects by value without additional overhead.
      </p>
<p>
        <a name="node_null"></a>There is a special value of <code class="computeroutput"><span class="identifier">xml_node</span></code>
        type, known as null node or empty node (such nodes have type <code class="computeroutput"><span class="identifier">node_null</span></code>). It does not correspond to any
        node in any document, and thus resembles null pointer. However, all operations
        are defined on empty nodes; generally the operations don't do anything and
        return empty nodes/attributes or empty strings as their result (see documentation
        for specific functions for more detailed information). This is useful for
        chaining calls; i.e. you can get the grandparent of a node like so: <code class="computeroutput"><span class="identifier">node</span><span class="special">.</span><span class="identifier">parent</span><span class="special">().</span><span class="identifier">parent</span><span class="special">()</span></code>; if a node is a null node or it does not
        have a parent, the first <code class="computeroutput"><span class="identifier">parent</span><span class="special">()</span></code> call returns null node; the second <code class="computeroutput"><span class="identifier">parent</span><span class="special">()</span></code>
        call then also returns null node, which makes error handling easier.
      </p>
<p>
        <a name="xml_attribute"></a><code class="computeroutput"><span class="identifier">xml_attribute</span></code>
        is the handle to an XML attribute; it has the same semantics as <code class="computeroutput"><span class="identifier">xml_node</span></code>, i.e. there can be several <code class="computeroutput"><span class="identifier">xml_attribute</span></code> handles pointing to the same
        underlying object and there is a special null attribute value, which propagates
        to function results.
      </p>
<p>
        <a name="xml_attribute::ctor"></a><a name="xml_node::ctor"></a>Both <code class="computeroutput"><span class="identifier">xml_node</span></code> and <code class="computeroutput"><span class="identifier">xml_attribute</span></code>
        have the default constructor which initializes them to null objects.
      </p>
<p>
        <a name="xml_attribute::comparison"></a><a name="xml_node::comparison"></a><code class="computeroutput"><span class="identifier">xml_node</span></code> and <code class="computeroutput"><span class="identifier">xml_attribute</span></code>
        try to behave like pointers, that is, they can be compared with other objects
        of the same type, making it possible to use them as keys in associative containers.
        All handles to the same underlying object are equal, and any two handles
        to different underlying objects are not equal. Null handles only compare
        as equal to themselves. The result of relational comparison can not be reliably
        determined from the order of nodes in file or in any other way. Do not use
        relational comparison operators except for search optimization (i.e. associative
        container keys).
      </p>
<p>
        <a name="xml_attribute::hash_value"></a><a name="xml_node::hash_value"></a>If
        you want to use <code class="computeroutput"><span class="identifier">xml_node</span></code>
        or <code class="computeroutput"><span class="identifier">xml_attribute</span></code> objects
        as keys in hash-based associative containers, you can use the <code class="computeroutput"><span class="identifier">hash_value</span></code> member functions. They return
        the hash values that are guaranteed to be the same for all handles to the
        same underlying object. The hash value for null handles is 0.
      </p>
<p>
        <a name="xml_attribute::unspecified_bool_type"></a><a name="xml_node::unspecified_bool_type"></a><a name="xml_attribute::empty"></a><a name="xml_node::empty"></a>Finally handles
        can be implicitly cast to boolean-like objects, so that you can test if the
        node/attribute is empty with the following code: <code class="computeroutput"><span class="keyword">if</span>
        <span class="special">(</span><span class="identifier">node</span><span class="special">)</span> <span class="special">{</span> <span class="special">...</span>
        <span class="special">}</span></code> or <code class="computeroutput"><span class="keyword">if</span>
        <span class="special">(!</span><span class="identifier">node</span><span class="special">)</span> <span class="special">{</span> <span class="special">...</span>
        <span class="special">}</span> <span class="keyword">else</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>.
        Alternatively you can check if a given <code class="computeroutput"><span class="identifier">xml_node</span></code>/<code class="computeroutput"><span class="identifier">xml_attribute</span></code> handle is null by calling
        the following methods:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xml_attribute</span><span class="special">::</span><span class="identifier">empty</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">empty</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        Nodes and attributes do not exist without a document tree, so you can't create
        them without adding them to some document. Once underlying node/attribute
        objects are destroyed, the handles to those objects become invalid. While
        this means that destruction of the entire tree invalidates all node/attribute
        handles, it also means that destroying a subtree (by calling <a class="link" href="modify.html#xml_node::remove_child">xml_node::remove_child</a>)
        or removing an attribute invalidates the corresponding handles. There is
        no way to check handle validity; you have to ensure correctness through external
        mechanisms.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.dom.unicode"></a><a class="link" href="dom.html#manual.dom.unicode" title="Unicode interface">Unicode interface</a>
</h3></div></div></div>
<p>
        There are two choices of interface and internal representation when configuring
        pugixml: you can either choose the UTF-8 (also called char) interface or
        UTF-16/32 (also called wchar_t) one. The choice is controlled via <a class="link" href="install.html#PUGIXML_WCHAR_MODE">PUGIXML_WCHAR_MODE</a>
        define; you can set it via <code class="filename">pugiconfig.hpp</code> or via preprocessor options, as
        discussed in <a class="xref" href="install.html#manual.install.building.config" title="Additional configuration options">Additional configuration
        options</a>. If this define is set, the wchar_t
        interface is used; otherwise (by default) the char interface is used. The
        exact wide character encoding is assumed to be either UTF-16 or UTF-32 and
        is determined based on the size of <code class="computeroutput"><span class="keyword">wchar_t</span></code>
        type.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          If the size of <code class="computeroutput"><span class="keyword">wchar_t</span></code> is
          2, pugixml assumes UTF-16 encoding instead of UCS-2, which means that some
          characters are represented as two code points.
        </p></td></tr>
</table></div>
<p>
        All tree functions that work with strings work with either C-style null terminated
        strings or STL strings of the selected character type. For example, node
        name accessors look like this in char mode:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">name</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">set_name</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">value</span><span class="special">);</span>
</pre>
<p>
        and like this in wchar_t mode:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">name</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">set_name</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*</span> <span class="identifier">value</span><span class="special">);</span>
</pre>
<p>
        <a name="char_t"></a><a name="string_t"></a>There is a special type, <code class="computeroutput"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">char_t</span></code>, that is defined as the character
        type and depends on the library configuration; it will be also used in the
        documentation hereafter. There is also a type <code class="computeroutput"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">string_t</span></code>,
        which is defined as the STL string of the character type; it corresponds
        to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> in char mode and to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span></code>
        in wchar_t mode.
      </p>
<p>
        In addition to the interface, the internal implementation changes to store
        XML data as <code class="computeroutput"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">char_t</span></code>; this means that these two modes
        have different memory usage characteristics. The conversion to <code class="computeroutput"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">char_t</span></code> upon document loading and from
        <code class="computeroutput"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">char_t</span></code> upon document saving happen automatically,
        which also carries minor performance penalty. The general advice however
        is to select the character mode based on usage scenario, i.e. if UTF-8 is
        inconvenient to process and most of your XML data is non-ASCII, wchar_t mode
        is probably a better choice.
      </p>
<p>
        <a name="as_utf8"></a><a name="as_wide"></a>There are cases when you'll have
        to convert string data between UTF-8 and wchar_t encodings; the following
        helper functions are provided for such purposes:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">as_utf8</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*</span> <span class="identifier">str</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span> <span class="identifier">as_wide</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">str</span><span class="special">);</span>
</pre>
<p>
        Both functions accept a null-terminated string as an argument <code class="computeroutput"><span class="identifier">str</span></code>, and return the converted string.
        <code class="computeroutput"><span class="identifier">as_utf8</span></code> performs conversion
        from UTF-16/32 to UTF-8; <code class="computeroutput"><span class="identifier">as_wide</span></code>
        performs conversion from UTF-8 to UTF-16/32. Invalid UTF sequences are silently
        discarded upon conversion. <code class="computeroutput"><span class="identifier">str</span></code>
        has to be a valid string; passing null pointer results in undefined behavior.
        There are also two overloads with the same semantics which accept a string
        as an argument:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">as_utf8</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span><span class="special">&amp;</span> <span class="identifier">str</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span> <span class="identifier">as_wide</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">str</span><span class="special">);</span>
</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          Most examples in this documentation assume char interface and therefore
          will not compile with <a class="link" href="install.html#PUGIXML_WCHAR_MODE">PUGIXML_WCHAR_MODE</a>.
          This is done to simplify the documentation; usually the only changes you'll
          have to make is to pass <code class="computeroutput"><span class="keyword">wchar_t</span></code>
          string literals, i.e. instead of
        </p>
<p>
          <code class="computeroutput"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span>
          <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"bookstore"</span><span class="special">).</span><span class="identifier">find_child_by_attribute</span><span class="special">(</span><span class="string">"book"</span><span class="special">,</span> <span class="string">"id"</span><span class="special">,</span> <span class="string">"12345"</span><span class="special">);</span></code>
        </p>
<p>
          you'll have to do
        </p>
<p>
          <code class="computeroutput"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">node</span>
          <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="identifier">L</span><span class="string">"bookstore"</span><span class="special">).</span><span class="identifier">find_child_by_attribute</span><span class="special">(</span><span class="identifier">L</span><span class="string">"book"</span><span class="special">,</span> <span class="identifier">L</span><span class="string">"id"</span><span class="special">,</span> <span class="identifier">L</span><span class="string">"12345"</span><span class="special">);</span></code>
        </p>
</td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.dom.thread"></a><a class="link" href="dom.html#manual.dom.thread" title="Thread-safety guarantees">Thread-safety guarantees</a>
</h3></div></div></div>
<p>
        Almost all functions in pugixml have the following thread-safety guarantees:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            it is safe to call free (non-member) functions from multiple threads
          </li>
<li class="listitem">
            it is safe to perform concurrent read-only accesses to the same tree
            (all constant member functions do not modify the tree)
          </li>
<li class="listitem">
            it is safe to perform concurrent read/write accesses, if there is only
            one read or write access to the single tree at a time
          </li>
</ul></div>
<p>
        Concurrent modification and traversing of a single tree requires synchronization,
        for example via reader-writer lock. Modification includes altering document
        structure and altering individual node/attribute data, i.e. changing names/values.
      </p>
<p>
        The only exception is <a class="link" href="dom.html#set_memory_management_functions">set_memory_management_functions</a>;
        it modifies global variables and as such is not thread-safe. Its usage policy
        has more restrictions, see <a class="xref" href="dom.html#manual.dom.memory.custom" title="Custom memory allocation/deallocation functions">Custom memory allocation/deallocation
        functions</a>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.dom.exception"></a><a class="link" href="dom.html#manual.dom.exception" title="Exception guarantees">Exception guarantees</a>
</h3></div></div></div>
<p>
        With the exception of XPath, pugixml itself does not throw any exceptions.
        Additionally, most pugixml functions have a no-throw exception guarantee.
      </p>
<p>
        This is not applicable to functions that operate on STL strings or IOstreams;
        such functions have either strong guarantee (functions that operate on strings)
        or basic guarantee (functions that operate on streams). Also functions that
        call user-defined callbacks (i.e. <a class="link" href="access.html#xml_node::traverse">xml_node::traverse</a>
        or <a class="link" href="access.html#xml_node::find_node">xml_node::find_node</a>) do not
        provide any exception guarantees beyond the ones provided by the callback.
      </p>
<p>
        If exception handling is not disabled with <a class="link" href="install.html#PUGIXML_NO_EXCEPTIONS">PUGIXML_NO_EXCEPTIONS</a>
        define, XPath functions may throw <a class="link" href="xpath.html#xpath_exception">xpath_exception</a>
        on parsing errors; also, XPath functions may throw <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code>
        in low memory conditions. Still, XPath functions provide strong exception
        guarantee.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.dom.memory"></a><a class="link" href="dom.html#manual.dom.memory" title="Memory management">Memory management</a>
</h3></div></div></div>
<p>
        pugixml requests the memory needed for document storage in big chunks, and
        allocates document data inside those chunks. This section discusses replacing
        functions used for chunk allocation and internal memory management implementation.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.dom.memory.custom"></a><a class="link" href="dom.html#manual.dom.memory.custom" title="Custom memory allocation/deallocation functions">Custom memory allocation/deallocation
        functions</a>
</h4></div></div></div>
<p>
          <a name="allocation_function"></a><a name="deallocation_function"></a>All
          memory for tree structure, tree data and XPath objects is allocated via
          globally specified functions, which default to malloc/free. You can set
          your own allocation functions with set_memory_management function. The
          function interfaces are the same as that of malloc/free:
        </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="keyword">void</span><span class="special">*</span> <span class="special">(*</span><span class="identifier">allocation_function</span><span class="special">)(</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">);</span>
<span class="keyword">typedef</span> <span class="keyword">void</span> <span class="special">(*</span><span class="identifier">deallocation_function</span><span class="special">)(</span><span class="keyword">void</span><span class="special">*</span> <span class="identifier">ptr</span><span class="special">);</span>
</pre>
<p>
          <a name="set_memory_management_functions"></a><a name="get_memory_allocation_function"></a><a name="get_memory_deallocation_function"></a>You can use the following accessor
          functions to change or get current memory management functions:
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">set_memory_management_functions</span><span class="special">(</span><span class="identifier">allocation_function</span> <span class="identifier">allocate</span><span class="special">,</span> <span class="identifier">deallocation_function</span> <span class="identifier">deallocate</span><span class="special">);</span>
<span class="identifier">allocation_function</span> <span class="identifier">get_memory_allocation_function</span><span class="special">();</span>
<span class="identifier">deallocation_function</span> <span class="identifier">get_memory_deallocation_function</span><span class="special">();</span>
</pre>
<p>
          Allocation function is called with the size (in bytes) as an argument and
          should return a pointer to a memory block with alignment that is suitable
          for storage of primitive types (usually a maximum of <code class="computeroutput"><span class="keyword">void</span><span class="special">*</span></code> and <code class="computeroutput"><span class="keyword">double</span></code>
          types alignment is sufficient) and size that is greater than or equal to
          the requested one. If the allocation fails, the function has to return
          null pointer (throwing an exception from allocation function results in
          undefined behavior).
        </p>
<p>
          Deallocation function is called with the pointer that was returned by some
          call to allocation function; it is never called with a null pointer. If
          memory management functions are not thread-safe, library thread safety
          is not guaranteed.
        </p>
<p>
          This is a simple example of custom memory management (<a href="../samples/custom_memory_management.cpp" target="_top">samples/custom_memory_management.cpp</a>):
        </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">void</span><span class="special">*</span> <span class="identifier">custom_allocate</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">nothrow</span><span class="special">)</span> <span class="keyword">char</span><span class="special">[</span><span class="identifier">size</span><span class="special">];</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">custom_deallocate</span><span class="special">(</span><span class="keyword">void</span><span class="special">*</span> <span class="identifier">ptr</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">delete</span><span class="special">[]</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">*&gt;(</span><span class="identifier">ptr</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">set_memory_management_functions</span><span class="special">(</span><span class="identifier">custom_allocate</span><span class="special">,</span> <span class="identifier">custom_deallocate</span><span class="special">);</span>
</pre>
<p>
        </p>
<p>
          When setting new memory management functions, care must be taken to make
          sure that there are no live pugixml objects. Otherwise when the objects
          are destroyed, the new deallocation function will be called with the memory
          obtained by the old allocation function, resulting in undefined behavior.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.dom.memory.tuning"></a><a class="link" href="dom.html#manual.dom.memory.tuning" title="Memory consumption tuning">Memory consumption tuning</a>
</h4></div></div></div>
<p>
          There are several important buffering optimizations in pugixml that rely
          on predefined constants. These constants have default values that were
          tuned for common usage patterns; for some applications, changing these
          constants might improve memory consumption or increase performance. Changing
          these constants is not recommended unless their default values result in
          visible problems.
        </p>
<p>
          These constants can be tuned via configuration defines, as discussed in
          <a class="xref" href="install.html#manual.install.building.config" title="Additional configuration options">Additional configuration
        options</a>; it is recommended to set them in <code class="filename">pugiconfig.hpp</code>.
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">PUGIXML_MEMORY_PAGE_SIZE</span></code>
              controls the page size for document memory allocation. Memory for node/attribute
              objects is allocated in pages of the specified size. The default size
              is 32 Kb; for some applications the size is too large (i.e. embedded
              systems with little heap space or applications that keep lots of XML
              documents in memory). A minimum size of 1 Kb is recommended. <br><br>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">PUGIXML_MEMORY_OUTPUT_STACK</span></code>
              controls the cumulative stack space required to output the node. Any
              output operation (i.e. saving a subtree to file) uses an internal buffering
              scheme for performance reasons. The default size is 10 Kb; if you're
              using node output from threads with little stack space, decreasing
              this value can prevent stack overflows. A minimum size of 1 Kb is recommended.
              <br><br>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">PUGIXML_MEMORY_XPATH_PAGE_SIZE</span></code>
              controls the page size for XPath memory allocation. Memory for XPath
              query objects as well as internal memory for XPath evaluation is allocated
              in pages of the specified size. The default size is 4 Kb; if you have
              a lot of resident XPath query objects, you might need to decrease the
              size to improve memory consumption. A minimum size of 256 bytes is
              recommended.
            </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="manual.dom.memory.internals"></a><a class="link" href="dom.html#manual.dom.memory.internals" title="Document memory management internals">Document memory management
        internals</a>
</h4></div></div></div>
<p>
          Constructing a document object using the default constructor does not result
          in any allocations; document node is stored inside the <a class="link" href="dom.html#xml_document">xml_document</a>
          object.
        </p>
<p>
          When the document is loaded from file/buffer, unless an inplace loading
          function is used (see <a class="xref" href="loading.html#manual.loading.memory" title="Loading document from memory">Loading document from memory</a>), a complete copy of character
          stream is made; all names/values of nodes and attributes are allocated
          in this buffer. This buffer is allocated via a single large allocation
          and is only freed when document memory is reclaimed (i.e. if the <a class="link" href="dom.html#xml_document">xml_document</a> object is destroyed or if another
          document is loaded in the same object). Also when loading from file or
          stream, an additional large allocation may be performed if encoding conversion
          is required; a temporary buffer is allocated, and it is freed before load
          function returns.
        </p>
<p>
          All additional memory, such as memory for document structure (node/attribute
          objects) and memory for node/attribute names/values is allocated in pages
          on the order of 32 kilobytes; actual objects are allocated inside the pages
          using a memory management scheme optimized for fast allocation/deallocation
          of many small objects. Because of the scheme specifics, the pages are only
          destroyed if all objects inside them are destroyed; also, generally destroying
          an object does not mean that subsequent object creation will reuse the
          same memory. This means that it is possible to devise a usage scheme which
          will lead to higher memory usage than expected; one example is adding a
          lot of nodes, and them removing all even numbered ones; not a single page
          is reclaimed in the process. However this is an example specifically crafted
          to produce unsatisfying behavior; in all practical usage scenarios the
          memory consumption is less than that of a general-purpose allocator because
          allocation meta-data is very small in size.
        </p>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Arseny Kapoulkine<p>
        Distributed under the MIT License
      </p>
</div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<b>Object model</b> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="install.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="loading.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual/saving.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Saving document</title>
<link rel="stylesheet" href="../pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../manual.html" title="pugixml 1.4">
<link rel="up" href="../manual.html" title="pugixml 1.4">
<link rel="prev" href="modify.html" title="Modifying document data">
<link rel="next" href="xpath.html" title="XPath">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <b>Saving</b> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="modify.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="xpath.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
<hr>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.saving"></a><a class="link" href="saving.html" title="Saving document">Saving document</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="saving.html#manual.saving.file">Saving document to a file</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.stream">Saving document to C++ IOstreams</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.writer">Saving document via writer interface</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.subtree">Saving a single subtree</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.options">Output options</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.encoding">Encodings</a></span></dt>
<dt><span class="section"><a href="saving.html#manual.saving.declaration">Customizing document declaration</a></span></dt>
</dl></div>
<p>
      Often after creating a new document or loading the existing one and processing
      it, it is necessary to save the result back to file. Also it is occasionally
      useful to output the whole document or a subtree to some stream; use cases
      include debug printing, serialization via network or other text-oriented medium,
      etc. pugixml provides several functions to output any subtree of the document
      to a file, stream or another generic transport interface; these functions allow
      to customize the output format (see <a class="xref" href="saving.html#manual.saving.options" title="Output options">Output options</a>), and also perform
      necessary encoding conversions (see <a class="xref" href="saving.html#manual.saving.encoding" title="Encodings">Encodings</a>). This section documents
      the relevant functionality.
    </p>
<p>
      Before writing to the destination the node/attribute data is properly formatted
      according to the node type; all special XML symbols, such as &lt; and &amp;,
      are properly escaped (unless <a class="link" href="saving.html#format_no_escapes">format_no_escapes</a>
      flag is set). In order to guard against forgotten node/attribute names, empty
      node/attribute names are printed as <code class="computeroutput"><span class="string">":anonymous"</span></code>.
      For well-formed output, make sure all node and attribute names are set to meaningful
      values.
    </p>
<p>
      CDATA sections with values that contain <code class="computeroutput"><span class="string">"]]&gt;"</span></code>
      are split into several sections as follows: section with value <code class="computeroutput"><span class="string">"pre]]&gt;post"</span></code> is written as <code class="computeroutput"><span class="special">&lt;![</span><span class="identifier">CDATA</span><span class="special">[</span><span class="identifier">pre</span><span class="special">]]]]&gt;&lt;![</span><span class="identifier">CDATA</span><span class="special">[&gt;</span><span class="identifier">post</span><span class="special">]]&gt;</span></code>.
      While this alters the structure of the document (if you load the document after
      saving it, there will be two CDATA sections instead of one), this is the only
      way to escape CDATA contents.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.saving.file"></a><a class="link" href="saving.html#manual.saving.file" title="Saving document to a file">Saving document to a file</a>
</h3></div></div></div>
<p>
        <a name="xml_document::save_file"></a><a name="xml_document::save_file_wide"></a>If
        you want to save the whole document to a file, you can use one of the following
        functions:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">save_file</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">path</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">indent</span> <span class="special">=</span> <span class="string">"\t"</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">save_file</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*</span> <span class="identifier">path</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">indent</span> <span class="special">=</span> <span class="string">"\t"</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        These functions accept file path as its first argument, and also three optional
        arguments, which specify indentation and other output options (see <a class="xref" href="saving.html#manual.saving.options" title="Output options">Output options</a>)
        and output data encoding (see <a class="xref" href="saving.html#manual.saving.encoding" title="Encodings">Encodings</a>). The path has the target
        operating system format, so it can be a relative or absolute one, it should
        have the delimiters of the target system, it should have the exact case if
        the target file system is case-sensitive, etc.
      </p>
<p>
        File path is passed to the system file opening function as is in case of
        the first function (which accepts <code class="computeroutput"><span class="keyword">const</span>
        <span class="keyword">char</span><span class="special">*</span> <span class="identifier">path</span></code>); the second function either uses
        a special file opening function if it is provided by the runtime library
        or converts the path to UTF-8 and uses the system file opening function.
      </p>
<p>
        <a name="xml_writer_file"></a><code class="computeroutput"><span class="identifier">save_file</span></code>
        opens the target file for writing, outputs the requested header (by default
        a document declaration is output, unless the document already has one), and
        then saves the document contents. If the file could not be opened, the function
        returns <code class="computeroutput"><span class="keyword">false</span></code>. Calling <code class="computeroutput"><span class="identifier">save_file</span></code> is equivalent to creating an
        <code class="computeroutput"><span class="identifier">xml_writer_file</span></code> object with
        <code class="computeroutput"><span class="identifier">FILE</span><span class="special">*</span></code>
        handle as the only constructor argument and then calling <code class="computeroutput"><span class="identifier">save</span></code>;
        see <a class="xref" href="saving.html#manual.saving.writer" title="Saving document via writer interface">Saving document via writer interface</a> for writer interface details.
      </p>
<p>
        This is a simple example of saving XML document to file (<a href="../samples/save_file.cpp" target="_top">samples/save_file.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// save document to file</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Saving result: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">save_file</span><span class="special">(</span><span class="string">"save_file_output.xml"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.saving.stream"></a><a class="link" href="saving.html#manual.saving.stream" title="Saving document to C++ IOstreams">Saving document to C++ IOstreams</a>
</h3></div></div></div>
<p>
        <a name="xml_document::save_stream"></a>To enhance interoperability pugixml
        provides functions for saving document to any object which implements C++
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span></code> interface. This allows you to save
        documents to any standard C++ stream (i.e. file stream) or any third-party
        compliant implementation (i.e. Boost Iostreams). Most notably, this allows
        for easy debug output, since you can use <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span></code>
        stream as saving target. There are two functions, one works with narrow character
        streams, another handles wide character ones:
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">indent</span> <span class="special">=</span> <span class="string">"\t"</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">void</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">wostream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">indent</span> <span class="special">=</span> <span class="string">"\t"</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">save</span></code> with <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span></code>
        argument saves the document to the stream in the same way as <code class="computeroutput"><span class="identifier">save_file</span></code> (i.e. with requested header and
        with encoding conversions). On the other hand, <code class="computeroutput"><span class="identifier">save</span></code>
        with <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">wstream</span></code> argument saves the document to
        the wide stream with <a class="link" href="loading.html#encoding_wchar">encoding_wchar</a>
        encoding. Because of this, using <code class="computeroutput"><span class="identifier">save</span></code>
        with wide character streams requires careful (usually platform-specific)
        stream setup (i.e. using the <code class="computeroutput"><span class="identifier">imbue</span></code>
        function). Generally use of wide streams is discouraged, however it provides
        you with the ability to save documents to non-Unicode encodings, i.e. you
        can save Shift-JIS encoded data if you set the correct locale.
      </p>
<p>
        <a name="xml_writer_stream"></a>Calling <code class="computeroutput"><span class="identifier">save</span></code>
        with stream target is equivalent to creating an <code class="computeroutput"><span class="identifier">xml_writer_stream</span></code>
        object with stream as the only constructor argument and then calling <code class="computeroutput"><span class="identifier">save</span></code>; see <a class="xref" href="saving.html#manual.saving.writer" title="Saving document via writer interface">Saving document via writer interface</a> for writer
        interface details.
      </p>
<p>
        This is a simple example of saving XML document to standard output (<a href="../samples/save_stream.cpp" target="_top">samples/save_stream.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// save document to standard output</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Document:\n"</span><span class="special">;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.saving.writer"></a><a class="link" href="saving.html#manual.saving.writer" title="Saving document via writer interface">Saving document via writer interface</a>
</h3></div></div></div>
<p>
        <a name="xml_document::save"></a><a name="xml_writer"></a><a name="xml_writer::write"></a>All
        of the above saving functions are implemented in terms of writer interface.
        This is a simple interface with a single function, which is called several
        times during output process with chunks of document data as input:
      </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">xml_writer</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">write</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">void</span><span class="special">*</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">)</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">void</span> <span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">xml_writer</span><span class="special">&amp;</span> <span class="identifier">writer</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">indent</span> <span class="special">=</span> <span class="string">"\t"</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        In order to output the document via some custom transport, for example sockets,
        you should create an object which implements <code class="computeroutput"><span class="identifier">xml_writer</span></code>
        interface and pass it to <code class="computeroutput"><span class="identifier">save</span></code>
        function. <code class="computeroutput"><span class="identifier">xml_writer</span><span class="special">::</span><span class="identifier">write</span></code> function is called with a buffer
        as an input, where <code class="computeroutput"><span class="identifier">data</span></code> points
        to buffer start, and <code class="computeroutput"><span class="identifier">size</span></code>
        is equal to the buffer size in bytes. <code class="computeroutput"><span class="identifier">write</span></code>
        implementation must write the buffer to the transport; it can not save the
        passed buffer pointer, as the buffer contents will change after <code class="computeroutput"><span class="identifier">write</span></code> returns. The buffer contains the
        chunk of document data in the desired encoding.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">write</span></code> function is called
        with relatively large blocks (size is usually several kilobytes, except for
        the last block that may be small), so there is often no need for additional
        buffering in the implementation.
      </p>
<p>
        This is a simple example of custom writer for saving document data to STL
        string (<a href="../samples/save_custom_writer.cpp" target="_top">samples/save_custom_writer.cpp</a>);
        read the sample code for more complex examples:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">xml_string_writer</span><span class="special">:</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_writer</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">result</span><span class="special">;</span>

    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">write</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">void</span><span class="special">*</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">result</span> <span class="special">+=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*&gt;(</span><span class="identifier">data</span><span class="special">),</span> <span class="identifier">size</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.saving.subtree"></a><a class="link" href="saving.html#manual.saving.subtree" title="Saving a single subtree">Saving a single subtree</a>
</h3></div></div></div>
<p>
        <a name="xml_node::print"></a><a name="xml_node::print_stream"></a>While
        the previously described functions save the whole document to the destination,
        it is easy to save a single subtree. The following functions are provided:
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">print</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">os</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">indent</span> <span class="special">=</span> <span class="string">"\t"</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">depth</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">void</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">print</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">wostream</span><span class="special">&amp;</span> <span class="identifier">os</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">indent</span> <span class="special">=</span> <span class="string">"\t"</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">depth</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">void</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">print</span><span class="special">(</span><span class="identifier">xml_writer</span><span class="special">&amp;</span> <span class="identifier">writer</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">indent</span> <span class="special">=</span> <span class="string">"\t"</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">,</span> <span class="identifier">xml_encoding</span> <span class="identifier">encoding</span> <span class="special">=</span> <span class="identifier">encoding_auto</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">depth</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        These functions have the same arguments with the same meaning as the corresponding
        <code class="computeroutput"><span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">save</span></code> functions, and allow you to save the
        subtree to either a C++ IOstream or to any object that implements <code class="computeroutput"><span class="identifier">xml_writer</span></code> interface.
      </p>
<p>
        Saving a subtree differs from saving the whole document: the process behaves
        as if <a class="link" href="saving.html#format_write_bom">format_write_bom</a> is off, and
        <a class="link" href="saving.html#format_no_declaration">format_no_declaration</a> is on,
        even if actual values of the flags are different. This means that BOM is
        not written to the destination, and document declaration is only written
        if it is the node itself or is one of node's children. Note that this also
        holds if you're saving a document; this example (<a href="../samples/save_subtree.cpp" target="_top">samples/save_subtree.cpp</a>)
        illustrates the difference:
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// get a test document</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span> <span class="identifier">doc</span><span class="special">;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="string">"&lt;foo bar='baz'&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;"</span><span class="special">);</span>

<span class="comment">// print document to standard output (prints &lt;?xml version="1.0"?&gt;&lt;foo bar="baz"&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;)</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">""</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">format_raw</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// print document to standard output as a regular node (prints &lt;foo bar="baz"&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;)</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">print</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">""</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">format_raw</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// print a subtree to standard output (prints &lt;call&gt;hey&lt;/call&gt;)</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">child</span><span class="special">(</span><span class="string">"foo"</span><span class="special">).</span><span class="identifier">child</span><span class="special">(</span><span class="string">"call"</span><span class="special">).</span><span class="identifier">print</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">""</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">format_raw</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.saving.options"></a><a class="link" href="saving.html#manual.saving.options" title="Output options">Output options</a>
</h3></div></div></div>
<p>
        All saving functions accept the optional parameter <code class="computeroutput"><span class="identifier">flags</span></code>.
        This is a bitmask that customizes the output format; you can select the way
        the document nodes are printed and select the needed additional information
        that is output before the document contents.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          You should use the usual bitwise arithmetics to manipulate the bitmask:
          to enable a flag, use <code class="computeroutput"><span class="identifier">mask</span> <span class="special">|</span> <span class="identifier">flag</span></code>;
          to disable a flag, use <code class="computeroutput"><span class="identifier">mask</span> <span class="special">&amp;</span> <span class="special">~</span><span class="identifier">flag</span></code>.
        </p></td></tr>
</table></div>
<p>
        These flags control the resulting tree contents:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a name="format_indent"></a><code class="literal">format_indent</code> determines if all nodes
            should be indented with the indentation string (this is an additional
            parameter for all saving functions, and is <code class="computeroutput"><span class="string">"\t"</span></code>
            by default). If this flag is on, before every node the indentation string
            is output several times, where the amount of indentation depends on the
            node's depth relative to the output subtree. This flag has no effect
            if <a class="link" href="saving.html#format_raw">format_raw</a> is enabled. This flag
            is <span class="bold"><strong>on</strong></span> by default. <br><br>
          </li>
<li class="listitem">
            <a name="format_raw"></a><code class="literal">format_raw</code> switches between formatted and
            raw output. If this flag is on, the nodes are not indented in any way,
            and also no newlines that are not part of document text are printed.
            Raw mode can be used for serialization where the result is not intended
            to be read by humans; also it can be useful if the document was parsed
            with <a class="link" href="loading.html#parse_ws_pcdata">parse_ws_pcdata</a> flag, to
            preserve the original document formatting as much as possible. This flag
            is <span class="bold"><strong>off</strong></span> by default. <br><br>
          </li>
<li class="listitem">
            <a name="format_no_escapes"></a><code class="literal">format_no_escapes</code> disables output
            escaping for attribute values and PCDATA contents. If this flag is off,
            special symbols (', &amp;, &lt;, &gt;) and all non-printable characters
            (those with codepoint values less than 32) are converted to XML escape
            sequences (i.e. &amp;amp;) during output. If this flag is on, no text
            processing is performed; therefore, output XML can be malformed if output
            contents contains invalid symbols (i.e. having a stray &lt; in the PCDATA
            will make the output malformed). This flag is <span class="bold"><strong>off</strong></span>
            by default.
          </li>
</ul></div>
<p>
        These flags control the additional output information:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a name="format_no_declaration"></a><code class="literal">format_no_declaration</code> disables
            default node declaration output. By default, if the document is saved
            via <code class="computeroutput"><span class="identifier">save</span></code> or <code class="computeroutput"><span class="identifier">save_file</span></code> function, and it does not
            have any document declaration, a default declaration is output before
            the document contents. Enabling this flag disables this declaration.
            This flag has no effect in <code class="computeroutput"><span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">print</span></code>
            functions: they never output the default declaration. This flag is <span class="bold"><strong>off</strong></span> by default. <br><br>
          </li>
<li class="listitem">
            <a name="format_write_bom"></a><code class="literal">format_write_bom</code> enables Byte Order
            Mark (BOM) output. By default, no BOM is output, so in case of non UTF-8
            encodings the resulting document's encoding may not be recognized by
            some parsers and text editors, if they do not implement sophisticated
            encoding detection. Enabling this flag adds an encoding-specific BOM
            to the output. This flag has no effect in <code class="computeroutput"><span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">print</span></code>
            functions: they never output the BOM. This flag is <span class="bold"><strong>off</strong></span>
            by default.
          </li>
<li class="listitem">
            <a name="format_save_file_text"></a><code class="literal">format_save_file_text</code> changes
            the file mode when using <code class="computeroutput"><span class="identifier">save_file</span></code>
            function. By default, file is opened in binary mode, which means that
            the output file will contain platform-independent newline \n (ASCII 10).
            If this flag is on, file is opened in text mode, which on some systems
            changes the newline format (i.e. on Windows you can use this flag to
            output XML documents with \r\n (ASCII 13 10) newlines. This flag is
            <span class="bold"><strong>off</strong></span> by default.
          </li>
</ul></div>
<p>
        Additionally, there is one predefined option mask:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <a name="format_default"></a><code class="literal">format_default</code> is the default set of
            flags, i.e. it has all options set to their default values. It sets formatted
            output with indentation, without BOM and with default node declaration,
            if necessary.
          </li></ul></div>
<p>
        This is an example that shows the outputs of different output options (<a href="../samples/save_options.cpp" target="_top">samples/save_options.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// get a test document</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span> <span class="identifier">doc</span><span class="special">;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="string">"&lt;foo bar='baz'&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;"</span><span class="special">);</span>

<span class="comment">// default options; prints</span>
<span class="comment">// &lt;?xml version="1.0"?&gt;</span>
<span class="comment">// &lt;foo bar="baz"&gt;</span>
<span class="comment">//         &lt;call&gt;hey&lt;/call&gt;</span>
<span class="comment">// &lt;/foo&gt;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// default options with custom indentation string; prints</span>
<span class="comment">// &lt;?xml version="1.0"?&gt;</span>
<span class="comment">// &lt;foo bar="baz"&gt;</span>
<span class="comment">// --&lt;call&gt;hey&lt;/call&gt;</span>
<span class="comment">// &lt;/foo&gt;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"--"</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// default options without indentation; prints</span>
<span class="comment">// &lt;?xml version="1.0"?&gt;</span>
<span class="comment">// &lt;foo bar="baz"&gt;</span>
<span class="comment">// &lt;call&gt;hey&lt;/call&gt;</span>
<span class="comment">// &lt;/foo&gt;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\t"</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">format_default</span> <span class="special">&amp;</span> <span class="special">~</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">format_indent</span><span class="special">);</span> <span class="comment">// can also pass "" instead of indentation string for the same effect</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// raw output; prints</span>
<span class="comment">// &lt;?xml version="1.0"?&gt;&lt;foo bar="baz"&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\t"</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">format_raw</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// raw output without declaration; prints</span>
<span class="comment">// &lt;foo bar="baz"&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\t"</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">format_raw</span> <span class="special">|</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">format_no_declaration</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.saving.encoding"></a><a class="link" href="saving.html#manual.saving.encoding" title="Encodings">Encodings</a>
</h3></div></div></div>
<p>
        pugixml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little
        endian), UTF-32 (big and little endian); UCS-2 is naturally supported since
        it's a strict subset of UTF-16) and handles all encoding conversions during
        output. The output encoding is set via the <code class="computeroutput"><span class="identifier">encoding</span></code>
        parameter of saving functions, which is of type <code class="computeroutput"><span class="identifier">xml_encoding</span></code>.
        The possible values for the encoding are documented in <a class="xref" href="loading.html#manual.loading.encoding" title="Encodings">Encodings</a>;
        the only flag that has a different meaning is <code class="computeroutput"><span class="identifier">encoding_auto</span></code>.
      </p>
<p>
        While all other flags set the exact encoding, <code class="computeroutput"><span class="identifier">encoding_auto</span></code>
        is meant for automatic encoding detection. The automatic detection does not
        make sense for output encoding, since there is usually nothing to infer the
        actual encoding from, so here <code class="computeroutput"><span class="identifier">encoding_auto</span></code>
        means UTF-8 encoding, which is the most popular encoding for XML data storage.
        This is also the default value of output encoding; specify another value
        if you do not want UTF-8 encoded output.
      </p>
<p>
        Also note that wide stream saving functions do not have <code class="computeroutput"><span class="identifier">encoding</span></code>
        argument and always assume <a class="link" href="loading.html#encoding_wchar">encoding_wchar</a>
        encoding.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          The current behavior for Unicode conversion is to skip all invalid UTF
          sequences during conversion. This behavior should not be relied upon; if
          your node/attribute names do not contain any valid UTF sequences, they
          may be output as if they are empty, which will result in malformed XML
          document.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.saving.declaration"></a><a class="link" href="saving.html#manual.saving.declaration" title="Customizing document declaration">Customizing document declaration</a>
</h3></div></div></div>
<p>
        When you are saving the document using <code class="computeroutput"><span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">save</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">xml_document</span><span class="special">::</span><span class="identifier">save_file</span><span class="special">()</span></code>, a default XML document declaration is
        output, if <code class="computeroutput"><span class="identifier">format_no_declaration</span></code>
        is not specified and if the document does not have a declaration node. However,
        the default declaration is not customizable. If you want to customize the
        declaration output, you need to create the declaration node yourself.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          By default the declaration node is not added to the document during parsing.
          If you just need to preserve the original declaration node, you have to
          add the flag <a class="link" href="loading.html#parse_declaration">parse_declaration</a>
          to the parsing flags; the resulting document will contain the original
          declaration node, which will be output during saving.
        </p></td></tr>
</table></div>
<p>
        Declaration node is a node with type <a class="link" href="dom.html#node_declaration">node_declaration</a>;
        it behaves like an element node in that it has attributes with values (but
        it does not have child nodes). Therefore setting custom version, encoding
        or standalone declaration involves adding attributes and setting attribute
        values.
      </p>
<p>
        This is an example that shows how to create a custom declaration node (<a href="../samples/save_declaration.cpp" target="_top">samples/save_declaration.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// get a test document</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_document</span> <span class="identifier">doc</span><span class="special">;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">load</span><span class="special">(</span><span class="string">"&lt;foo bar='baz'&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;"</span><span class="special">);</span>

<span class="comment">// add a custom declaration node</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">decl</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">prepend_child</span><span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">node_declaration</span><span class="special">);</span>
<span class="identifier">decl</span><span class="special">.</span><span class="identifier">append_attribute</span><span class="special">(</span><span class="string">"version"</span><span class="special">)</span> <span class="special">=</span> <span class="string">"1.0"</span><span class="special">;</span>
<span class="identifier">decl</span><span class="special">.</span><span class="identifier">append_attribute</span><span class="special">(</span><span class="string">"encoding"</span><span class="special">)</span> <span class="special">=</span> <span class="string">"UTF-8"</span><span class="special">;</span>
<span class="identifier">decl</span><span class="special">.</span><span class="identifier">append_attribute</span><span class="special">(</span><span class="string">"standalone"</span><span class="special">)</span> <span class="special">=</span> <span class="string">"no"</span><span class="special">;</span>

<span class="comment">// &lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt; </span>
<span class="comment">// &lt;foo bar="baz"&gt;</span>
<span class="comment">//         &lt;call&gt;hey&lt;/call&gt;</span>
<span class="comment">// &lt;/foo&gt;</span>
<span class="identifier">doc</span><span class="special">.</span><span class="identifier">save</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Arseny Kapoulkine<p>
        Distributed under the MIT License
      </p>
</div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <b>Saving</b> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="modify.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="xpath.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual/xpath.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>XPath</title>
<link rel="stylesheet" href="../pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../manual.html" title="pugixml 1.4">
<link rel="up" href="../manual.html" title="pugixml 1.4">
<link rel="prev" href="saving.html" title="Saving document">
<link rel="next" href="changes.html" title="Changelog">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<b>XPath</b> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="saving.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="changes.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
<hr>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.xpath"></a><a class="link" href="xpath.html" title="XPath">XPath</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="xpath.html#manual.xpath.types">XPath types</a></span></dt>
<dt><span class="section"><a href="xpath.html#manual.xpath.select">Selecting nodes via XPath expression</a></span></dt>
<dt><span class="section"><a href="xpath.html#manual.xpath.query">Using query objects</a></span></dt>
<dt><span class="section"><a href="xpath.html#manual.xpath.variables">Using variables</a></span></dt>
<dt><span class="section"><a href="xpath.html#manual.xpath.errors">Error handling</a></span></dt>
<dt><span class="section"><a href="xpath.html#manual.xpath.w3c">Conformance to W3C specification</a></span></dt>
</dl></div>
<p>
      If the task at hand is to select a subset of document nodes that match some
      criteria, it is possible to code a function using the existing traversal functionality
      for any practical criteria. However, often either a data-driven approach is
      desirable, in case the criteria are not predefined and come from a file, or
      it is inconvenient to use traversal interfaces and a higher-level DSL is required.
      There is a standard language for XML processing, XPath, that can be useful
      for these cases. pugixml implements an almost complete subset of XPath 1.0.
      Because of differences in document object model and some performance implications,
      there are minor violations of the official specifications, which can be found
      in <a class="xref" href="xpath.html#manual.xpath.w3c" title="Conformance to W3C specification">Conformance to W3C specification</a>. The rest of this section describes the interface for XPath
      functionality. Please note that if you wish to learn to use XPath language,
      you have to look for other tutorials or manuals; for example, you can read
      <a href="http://www.w3schools.com/xpath/" target="_top">W3Schools XPath tutorial</a>,
      <a href="http://www.tizag.com/xmlTutorial/xpathtutorial.php" target="_top">XPath tutorial
      at tizag.com</a>, and <a href="http://www.w3.org/TR/xpath/" target="_top">the XPath
      1.0 specification</a>.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.xpath.types"></a><a class="link" href="xpath.html#manual.xpath.types" title="XPath types">XPath types</a>
</h3></div></div></div>
<p>
        <a name="xpath_value_type"></a><a name="xpath_type_number"></a><a name="xpath_type_string"></a><a name="xpath_type_boolean"></a><a name="xpath_type_node_set"></a><a name="xpath_type_none"></a>Each
        XPath expression can have one of the following types: boolean, number, string
        or node set. Boolean type corresponds to <code class="computeroutput"><span class="keyword">bool</span></code>
        type, number type corresponds to <code class="computeroutput"><span class="keyword">double</span></code>
        type, string type corresponds to either <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
        or <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span></code>, depending on whether <a class="link" href="dom.html#manual.dom.unicode" title="Unicode interface">wide
        character interface is enabled</a>, and node set corresponds to <a class="link" href="xpath.html#xpath_node_set">xpath_node_set</a> type. There is an enumeration,
        <code class="computeroutput"><span class="identifier">xpath_value_type</span></code>, which can
        take the values <code class="computeroutput"><span class="identifier">xpath_type_boolean</span></code>,
        <code class="computeroutput"><span class="identifier">xpath_type_number</span></code>, <code class="computeroutput"><span class="identifier">xpath_type_string</span></code> or <code class="computeroutput"><span class="identifier">xpath_type_node_set</span></code>,
        accordingly.
      </p>
<p>
        <a name="xpath_node"></a><a name="xpath_node::node"></a><a name="xpath_node::attribute"></a><a name="xpath_node::parent"></a>Because an XPath node can be either a node or an
        attribute, there is a special type, <code class="computeroutput"><span class="identifier">xpath_node</span></code>,
        which is a discriminated union of these types. A value of this type contains
        two node handles, one of <code class="computeroutput"><span class="identifier">xml_node</span></code>
        type, and another one of <code class="computeroutput"><span class="identifier">xml_attribute</span></code>
        type; at most one of them can be non-null. The accessors to get these handles
        are available:
      </p>
<pre class="programlisting"><span class="identifier">xml_node</span> <span class="identifier">xpath_node</span><span class="special">::</span><span class="identifier">node</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xml_attribute</span> <span class="identifier">xpath_node</span><span class="special">::</span><span class="identifier">attribute</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        XPath nodes can be null, in which case both accessors return null handles.
      </p>
<p>
        Note that as per XPath specification, each XPath node has a parent, which
        can be retrieved via this function:
      </p>
<pre class="programlisting"><span class="identifier">xml_node</span> <span class="identifier">xpath_node</span><span class="special">::</span><span class="identifier">parent</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">parent</span></code> function returns the
        node's parent if the XPath node corresponds to <code class="computeroutput"><span class="identifier">xml_node</span></code>
        handle (equivalent to <code class="computeroutput"><span class="identifier">node</span><span class="special">().</span><span class="identifier">parent</span><span class="special">()</span></code>), or the node to which the attribute belongs
        to, if the XPath node corresponds to <code class="computeroutput"><span class="identifier">xml_attribute</span></code>
        handle. For null nodes, <code class="computeroutput"><span class="identifier">parent</span></code>
        returns null handle.
      </p>
<p>
        <a name="xpath_node::unspecified_bool_type"></a><a name="xpath_node::comparison"></a>Like
        node and attribute handles, XPath node handles can be implicitly cast to
        boolean-like object to check if it is a null node, and also can be compared
        for equality with each other.
      </p>
<p>
        <a name="xpath_node::ctor"></a>You can also create XPath nodes with one of
        the three constructors: the default constructor, the constructor that takes
        node argument, and the constructor that takes attribute and node arguments
        (in which case the attribute must belong to the attribute list of the node).
        The constructor from <code class="computeroutput"><span class="identifier">xml_node</span></code>
        is implicit, so you can usually pass <code class="computeroutput"><span class="identifier">xml_node</span></code>
        to functions that expect <code class="computeroutput"><span class="identifier">xpath_node</span></code>.
        Apart from that you usually don't need to create your own XPath node objects,
        since they are returned to you via selection functions.
      </p>
<p>
        <a name="xpath_node_set"></a>XPath expressions operate not on single nodes,
        but instead on node sets. A node set is a collection of nodes, which can
        be optionally ordered in either a forward document order or a reverse one.
        Document order is defined in XPath specification; an XPath node is before
        another node in document order if it appears before it in XML representation
        of the corresponding document.
      </p>
<p>
        <a name="xpath_node_set::const_iterator"></a><a name="xpath_node_set::begin"></a><a name="xpath_node_set::end"></a>Node sets are represented by <code class="computeroutput"><span class="identifier">xpath_node_set</span></code>
        object, which has an interface that resembles one of sequential random-access
        containers. It has an iterator type along with usual begin/past-the-end iterator
        accessors:
      </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">*</span> <span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">const_iterator</span><span class="special">;</span>
<span class="identifier">const_iterator</span> <span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">begin</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">const_iterator</span> <span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">end</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <a name="xpath_node_set::index"></a><a name="xpath_node_set::size"></a><a name="xpath_node_set::empty"></a>And it also can be iterated via indices, just
        like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span> <span class="identifier">xpath_node_set</span><span class="special">::</span><span class="keyword">operator</span><span class="special">[](</span><span class="identifier">size_t</span> <span class="identifier">index</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">size_t</span> <span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">size</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">empty</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        All of the above operations have the same semantics as that of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>:
        the iterators are random-access, all of the above operations are constant
        time, and accessing the element at index that is greater or equal than the
        set size results in undefined behavior. You can use both iterator-based and
        index-based access for iteration, however the iterator-based one can be faster.
      </p>
<p>
        <a name="xpath_node_set::type"></a><a name="xpath_node_set::type_unsorted"></a><a name="xpath_node_set::type_sorted"></a><a name="xpath_node_set::type_sorted_reverse"></a><a name="xpath_node_set::sort"></a>The order of iteration depends on the order of
        nodes inside the set; the order can be queried via the following function:
      </p>
<pre class="programlisting"><span class="keyword">enum</span> <span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">type_t</span> <span class="special">{</span><span class="identifier">type_unsorted</span><span class="special">,</span> <span class="identifier">type_sorted</span><span class="special">,</span> <span class="identifier">type_sorted_reverse</span><span class="special">};</span>
<span class="identifier">type_t</span> <span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">type</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">type</span></code> function returns the
        current order of nodes; <code class="computeroutput"><span class="identifier">type_sorted</span></code>
        means that the nodes are in forward document order, <code class="computeroutput"><span class="identifier">type_sorted_reverse</span></code>
        means that the nodes are in reverse document order, and <code class="computeroutput"><span class="identifier">type_unsorted</span></code>
        means that neither order is guaranteed (nodes can accidentally be in a sorted
        order even if <code class="computeroutput"><span class="identifier">type</span><span class="special">()</span></code>
        returns <code class="computeroutput"><span class="identifier">type_unsorted</span></code>). If
        you require a specific order of iteration, you can change it via <code class="computeroutput"><span class="identifier">sort</span></code> function:
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">sort</span><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">reverse</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">);</span>
</pre>
<p>
        Calling <code class="computeroutput"><span class="identifier">sort</span></code> sorts the nodes
        in either forward or reverse document order, depending on the argument; after
        this call <code class="computeroutput"><span class="identifier">type</span><span class="special">()</span></code>
        will return <code class="computeroutput"><span class="identifier">type_sorted</span></code> or
        <code class="computeroutput"><span class="identifier">type_sorted_reverse</span></code>.
      </p>
<p>
        <a name="xpath_node_set::first"></a>Often the actual iteration is not needed;
        instead, only the first element in document order is required. For this,
        a special accessor is provided:
      </p>
<pre class="programlisting"><span class="identifier">xpath_node</span> <span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">first</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        This function returns the first node in forward document order from the set,
        or null node if the set is empty. Note that while the result of the node
        does not depend on the order of nodes in the set (i.e. on the result of
        <code class="computeroutput"><span class="identifier">type</span><span class="special">()</span></code>),
        the complexity does - if the set is sorted, the complexity is constant, otherwise
        it is linear in the number of elements or worse.
      </p>
<p>
        <a name="xpath_node_set::ctor"></a>While in the majority of cases the node
        set is returned by XPath functions, sometimes there is a need to manually
        construct a node set. For such cases, a constructor is provided which takes
        an iterator range (<code class="computeroutput"><span class="identifier">const_iterator</span></code>
        is a typedef for <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">*</span></code>), and an optional type:
      </p>
<pre class="programlisting"><span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">xpath_node_set</span><span class="special">(</span><span class="identifier">const_iterator</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">const_iterator</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">type_t</span> <span class="identifier">type</span> <span class="special">=</span> <span class="identifier">type_unsorted</span><span class="special">);</span>
</pre>
<p>
        The constructor copies the specified range and sets the specified type. The
        objects in the range are not checked in any way; you'll have to ensure that
        the range contains no duplicates, and that the objects are sorted according
        to the <code class="computeroutput"><span class="identifier">type</span></code> parameter. Otherwise
        XPath operations with this set may produce unexpected results.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.xpath.select"></a><a class="link" href="xpath.html#manual.xpath.select" title="Selecting nodes via XPath expression">Selecting nodes via XPath expression</a>
</h3></div></div></div>
<p>
        <a name="xml_node::select_single_node"></a><a name="xml_node::select_nodes"></a>If
        you want to select nodes that match some XPath expression, you can do it
        with the following functions:
      </p>
<pre class="programlisting"><span class="identifier">xpath_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">select_single_node</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">query</span><span class="special">,</span> <span class="identifier">xpath_variable_set</span><span class="special">*</span> <span class="identifier">variables</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xpath_node_set</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">select_nodes</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">query</span><span class="special">,</span> <span class="identifier">xpath_variable_set</span><span class="special">*</span> <span class="identifier">variables</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">select_nodes</span></code> function compiles
        the expression and then executes it with the node as a context node, and
        returns the resulting node set. <code class="computeroutput"><span class="identifier">select_single_node</span></code>
        returns only the first node in document order from the result, and is equivalent
        to calling <code class="computeroutput"><span class="identifier">select_nodes</span><span class="special">(</span><span class="identifier">query</span><span class="special">).</span><span class="identifier">first</span><span class="special">()</span></code>.
        If the XPath expression does not match anything, or the node handle is null,
        <code class="computeroutput"><span class="identifier">select_nodes</span></code> returns an empty
        set, and <code class="computeroutput"><span class="identifier">select_single_node</span></code>
        returns null XPath node.
      </p>
<p>
        If exception handling is not disabled, both functions throw <a class="link" href="xpath.html#xpath_exception">xpath_exception</a>
        if the query can not be compiled or if it returns a value with type other
        than node set; see <a class="xref" href="xpath.html#manual.xpath.errors" title="Error handling">Error handling</a> for details.
      </p>
<p>
        <a name="xml_node::select_single_node_precomp"></a><a name="xml_node::select_nodes_precomp"></a>While
        compiling expressions is fast, the compilation time can introduce a significant
        overhead if the same expression is used many times on small subtrees. If
        you're doing many similar queries, consider compiling them into query objects
        (see <a class="xref" href="xpath.html#manual.xpath.query" title="Using query objects">Using query objects</a> for further reference). Once you get a compiled query
        object, you can pass it to select functions instead of an expression string:
      </p>
<pre class="programlisting"><span class="identifier">xpath_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">select_single_node</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_query</span><span class="special">&amp;</span> <span class="identifier">query</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xpath_node_set</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">select_nodes</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_query</span><span class="special">&amp;</span> <span class="identifier">query</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        If exception handling is not disabled, both functions throw <a class="link" href="xpath.html#xpath_exception">xpath_exception</a>
        if the query returns a value with type other than node set.
      </p>
<p>
        This is an example of selecting nodes using XPath expressions (<a href="../samples/xpath_select.cpp" target="_top">samples/xpath_select.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node_set</span> <span class="identifier">tools</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">select_nodes</span><span class="special">(</span><span class="string">"/Profile/Tools/Tool[@AllowRemote='true' and @DeriveCaptionFrom='lastparam']"</span><span class="special">);</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Tools:\n"</span><span class="special">;</span>

<span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node_set</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">tools</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">it</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node</span> <span class="identifier">node</span> <span class="special">=</span> <span class="special">*</span><span class="identifier">it</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">node</span><span class="special">.</span><span class="identifier">node</span><span class="special">().</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node</span> <span class="identifier">build_tool</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">select_single_node</span><span class="special">(</span><span class="string">"//Tool[contains(Description, 'build system')]"</span><span class="special">);</span>

<span class="keyword">if</span> <span class="special">(</span><span class="identifier">build_tool</span><span class="special">)</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Build tool: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">build_tool</span><span class="special">.</span><span class="identifier">node</span><span class="special">().</span><span class="identifier">attribute</span><span class="special">(</span><span class="string">"Filename"</span><span class="special">).</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.xpath.query"></a><a class="link" href="xpath.html#manual.xpath.query" title="Using query objects">Using query objects</a>
</h3></div></div></div>
<p>
        <a name="xpath_query"></a>When you call <code class="computeroutput"><span class="identifier">select_nodes</span></code>
        with an expression string as an argument, a query object is created behind
        the scenes. A query object represents a compiled XPath expression. Query
        objects can be needed in the following circumstances:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            You can precompile expressions to query objects to save compilation time
            if it becomes an issue;
          </li>
<li class="listitem">
            You can use query objects to evaluate XPath expressions which result
            in booleans, numbers or strings;
          </li>
<li class="listitem">
            You can get the type of expression value via query object.
          </li>
</ul></div>
<p>
        Query objects correspond to <code class="computeroutput"><span class="identifier">xpath_query</span></code>
        type. They are immutable and non-copyable: they are bound to the expression
        at creation time and can not be cloned. If you want to put query objects
        in a container, allocate them on heap via <code class="computeroutput"><span class="keyword">new</span></code>
        operator and store pointers to <code class="computeroutput"><span class="identifier">xpath_query</span></code>
        in the container.
      </p>
<p>
        <a name="xpath_query::ctor"></a>You can create a query object with the constructor
        that takes XPath expression as an argument:
      </p>
<pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">xpath_query</span><span class="special">::</span><span class="identifier">xpath_query</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">query</span><span class="special">,</span> <span class="identifier">xpath_variable_set</span><span class="special">*</span> <span class="identifier">variables</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>
</pre>
<p>
        <a name="xpath_query::return_type"></a>The expression is compiled and the
        compiled representation is stored in the new query object. If compilation
        fails, <a class="link" href="xpath.html#xpath_exception">xpath_exception</a> is thrown if
        exception handling is not disabled (see <a class="xref" href="xpath.html#manual.xpath.errors" title="Error handling">Error handling</a> for details).
        After the query is created, you can query the type of the evaluation result
        using the following function:
      </p>
<pre class="programlisting"><span class="identifier">xpath_value_type</span> <span class="identifier">xpath_query</span><span class="special">::</span><span class="identifier">return_type</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <a name="xpath_query::evaluate_boolean"></a><a name="xpath_query::evaluate_number"></a><a name="xpath_query::evaluate_string"></a><a name="xpath_query::evaluate_node_set"></a>You
        can evaluate the query using one of the following functions:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xpath_query</span><span class="special">::</span><span class="identifier">evaluate_boolean</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">double</span> <span class="identifier">xpath_query</span><span class="special">::</span><span class="identifier">evaluate_number</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">string_t</span> <span class="identifier">xpath_query</span><span class="special">::</span><span class="identifier">evaluate_string</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xpath_node_set</span> <span class="identifier">xpath_query</span><span class="special">::</span><span class="identifier">evaluate_node_set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        All functions take the context node as an argument, compute the expression
        and return the result, converted to the requested type. According to XPath
        specification, value of any type can be converted to boolean, number or string
        value, but no type other than node set can be converted to node set. Because
        of this, <code class="computeroutput"><span class="identifier">evaluate_boolean</span></code>,
        <code class="computeroutput"><span class="identifier">evaluate_number</span></code> and <code class="computeroutput"><span class="identifier">evaluate_string</span></code> always return a result,
        but <code class="computeroutput"><span class="identifier">evaluate_node_set</span></code> results
        in an error if the return type is not node set (see <a class="xref" href="xpath.html#manual.xpath.errors" title="Error handling">Error handling</a>).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Calling <code class="computeroutput"><span class="identifier">node</span><span class="special">.</span><span class="identifier">select_nodes</span><span class="special">(</span><span class="string">"query"</span><span class="special">)</span></code>
          is equivalent to calling <code class="computeroutput"><span class="identifier">xpath_query</span><span class="special">(</span><span class="string">"query"</span><span class="special">).</span><span class="identifier">evaluate_node_set</span><span class="special">(</span><span class="identifier">node</span><span class="special">)</span></code>.
        </p></td></tr>
</table></div>
<p>
        <a name="xpath_query::evaluate_string_buffer"></a>Note that <code class="computeroutput"><span class="identifier">evaluate_string</span></code> function returns the STL
        string; as such, it's not available in <a class="link" href="install.html#PUGIXML_NO_STL">PUGIXML_NO_STL</a>
        mode and also usually allocates memory. There is another string evaluation
        function:
      </p>
<pre class="programlisting"><span class="identifier">size_t</span> <span class="identifier">xpath_query</span><span class="special">::</span><span class="identifier">evaluate_string</span><span class="special">(</span><span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">capacity</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xpath_node</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        This function evaluates the string, and then writes the result to <code class="computeroutput"><span class="identifier">buffer</span></code> (but at most <code class="computeroutput"><span class="identifier">capacity</span></code>
        characters); then it returns the full size of the result in characters, including
        the terminating zero. If <code class="computeroutput"><span class="identifier">capacity</span></code>
        is not 0, the resulting buffer is always zero-terminated. You can use this
        function as follows:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            First call the function with <code class="computeroutput"><span class="identifier">buffer</span>
            <span class="special">=</span> <span class="number">0</span></code>
            and <code class="computeroutput"><span class="identifier">capacity</span> <span class="special">=</span>
            <span class="number">0</span></code>; then allocate the returned amount
            of characters, and call the function again, passing the allocated storage
            and the amount of characters;
          </li>
<li class="listitem">
            First call the function with small buffer and buffer capacity; then,
            if the result is larger than the capacity, the output has been trimmed,
            so allocate a larger buffer and call the function again.
          </li>
</ul></div>
<p>
        This is an example of using query objects (<a href="../samples/xpath_query.cpp" target="_top">samples/xpath_query.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Select nodes via compiled query</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_query</span> <span class="identifier">query_remote_tools</span><span class="special">(</span><span class="string">"/Profile/Tools/Tool[@AllowRemote='true']"</span><span class="special">);</span>

<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node_set</span> <span class="identifier">tools</span> <span class="special">=</span> <span class="identifier">query_remote_tools</span><span class="special">.</span><span class="identifier">evaluate_node_set</span><span class="special">(</span><span class="identifier">doc</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Remote tool: "</span><span class="special">;</span>
<span class="identifier">tools</span><span class="special">[</span><span class="number">2</span><span class="special">].</span><span class="identifier">node</span><span class="special">().</span><span class="identifier">print</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">);</span>

<span class="comment">// Evaluate numbers via compiled query</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_query</span> <span class="identifier">query_timeouts</span><span class="special">(</span><span class="string">"sum(//Tool/@Timeout)"</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">query_timeouts</span><span class="special">.</span><span class="identifier">evaluate_number</span><span class="special">(</span><span class="identifier">doc</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="comment">// Evaluate strings via compiled query for different context nodes</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_query</span> <span class="identifier">query_name_valid</span><span class="special">(</span><span class="string">"string-length(substring-before(@Filename, '_')) &gt; 0 and @OutputFileMasks"</span><span class="special">);</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_query</span> <span class="identifier">query_name</span><span class="special">(</span><span class="string">"concat(substring-before(@Filename, '_'), ' produces ', @OutputFileMasks)"</span><span class="special">);</span>

<span class="keyword">for</span> <span class="special">(</span><span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xml_node</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">first_element_by_path</span><span class="special">(</span><span class="string">"Profile/Tools/Tool"</span><span class="special">);</span> <span class="identifier">tool</span><span class="special">;</span> <span class="identifier">tool</span> <span class="special">=</span> <span class="identifier">tool</span><span class="special">.</span><span class="identifier">next_sibling</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">s</span> <span class="special">=</span> <span class="identifier">query_name</span><span class="special">.</span><span class="identifier">evaluate_string</span><span class="special">(</span><span class="identifier">tool</span><span class="special">);</span>

    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">query_name_valid</span><span class="special">.</span><span class="identifier">evaluate_boolean</span><span class="special">(</span><span class="identifier">tool</span><span class="special">))</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">s</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.xpath.variables"></a><a class="link" href="xpath.html#manual.xpath.variables" title="Using variables">Using variables</a>
</h3></div></div></div>
<p>
        XPath queries may contain references to variables; this is useful if you
        want to use queries that depend on some dynamic parameter without manually
        preparing the complete query string, or if you want to reuse the same query
        object for similar queries.
      </p>
<p>
        Variable references have the form <code class="computeroutput"><span class="identifier">$name</span></code>; in order to use them, you have to provide
        a variable set, which includes all variables present in the query with correct
        types. This set is passed to <code class="computeroutput"><span class="identifier">xpath_query</span></code>
        constructor or to <code class="computeroutput"><span class="identifier">select_nodes</span></code>/<code class="computeroutput"><span class="identifier">select_single_node</span></code> functions:
      </p>
<pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">xpath_query</span><span class="special">::</span><span class="identifier">xpath_query</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">query</span><span class="special">,</span> <span class="identifier">xpath_variable_set</span><span class="special">*</span> <span class="identifier">variables</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>
<span class="identifier">xpath_node</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">select_single_node</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">query</span><span class="special">,</span> <span class="identifier">xpath_variable_set</span><span class="special">*</span> <span class="identifier">variables</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xpath_node_set</span> <span class="identifier">xml_node</span><span class="special">::</span><span class="identifier">select_nodes</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">query</span><span class="special">,</span> <span class="identifier">xpath_variable_set</span><span class="special">*</span> <span class="identifier">variables</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        If you're using query objects, you can change the variable values before
        <code class="computeroutput"><span class="identifier">evaluate</span></code>/<code class="computeroutput"><span class="identifier">select</span></code>
        calls to change the query behavior.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          The variable set pointer is stored in the query object; you have to ensure
          that the lifetime of the set exceeds that of query object.
        </p></td></tr>
</table></div>
<p>
        <a name="xpath_variable_set"></a>Variable sets correspond to <code class="computeroutput"><span class="identifier">xpath_variable_set</span></code> type, which is essentially
        a variable container.
      </p>
<p>
        <a name="xpath_variable_set::add"></a>You can add new variables with the
        following function:
      </p>
<pre class="programlisting"><span class="identifier">xpath_variable</span><span class="special">*</span> <span class="identifier">xpath_variable_set</span><span class="special">::</span><span class="identifier">add</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="identifier">xpath_value_type</span> <span class="identifier">type</span><span class="special">);</span>
</pre>
<p>
        The function tries to add a new variable with the specified name and type;
        if the variable with such name does not exist in the set, the function adds
        a new variable and returns the variable handle; if there is already a variable
        with the specified name, the function returns the variable handle if variable
        has the specified type. Otherwise the function returns null pointer; it also
        returns null pointer on allocation failure.
      </p>
<p>
        New variables are assigned the default value which depends on the type:
        <code class="computeroutput"><span class="number">0</span></code> for numbers, <code class="computeroutput"><span class="keyword">false</span></code> for booleans, empty string for strings
        and empty set for node sets.
      </p>
<p>
        <a name="xpath_variable_set::get"></a>You can get the existing variables
        with the following functions:
      </p>
<pre class="programlisting"><span class="identifier">xpath_variable</span><span class="special">*</span> <span class="identifier">xpath_variable_set</span><span class="special">::</span><span class="identifier">get</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">);</span>
<span class="keyword">const</span> <span class="identifier">xpath_variable</span><span class="special">*</span> <span class="identifier">xpath_variable_set</span><span class="special">::</span><span class="identifier">get</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        The functions return the variable handle, or null pointer if the variable
        with the specified name is not found.
      </p>
<p>
        <a name="xpath_variable_set::set"></a>Additionally, there are the helper
        functions for setting the variable value by name; they try to add the variable
        with the corresponding type, if it does not exist, and to set the value.
        If the variable with the same name but with different type is already present,
        they return <code class="computeroutput"><span class="keyword">false</span></code>; they also
        return <code class="computeroutput"><span class="keyword">false</span></code> on allocation failure.
        Note that these functions do not perform any type conversions.
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xpath_variable_set</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">bool</span> <span class="identifier">value</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xpath_variable_set</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">value</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xpath_variable_set</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">value</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xpath_variable_set</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">xpath_node_set</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">);</span>
</pre>
<p>
        The variable values are copied to the internal variable storage, so you can
        modify or destroy them after the functions return.
      </p>
<p>
        <a name="xpath_variable"></a>If setting variables by name is not efficient
        enough, or if you have to inspect variable information or get variable values,
        you can use variable handles. A variable corresponds to the <code class="computeroutput"><span class="identifier">xpath_variable</span></code> type, and a variable handle
        is simply a pointer to <code class="computeroutput"><span class="identifier">xpath_variable</span></code>.
      </p>
<p>
        <a name="xpath_variable::type"></a><a name="xpath_variable::name"></a>In
        order to get variable information, you can use one of the following functions:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xpath_variable</span><span class="special">::</span><span class="identifier">name</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="identifier">xpath_value_type</span> <span class="identifier">xpath_variable</span><span class="special">::</span><span class="identifier">type</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        Note that each variable has a distinct type which is specified upon variable
        creation and can not be changed later.
      </p>
<p>
        <a name="xpath_variable::get_boolean"></a><a name="xpath_variable::get_number"></a><a name="xpath_variable::get_string"></a><a name="xpath_variable::get_node_set"></a>In
        order to get variable value, you should use one of the following functions,
        depending on the variable type:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xpath_variable</span><span class="special">::</span><span class="identifier">get_boolean</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">double</span> <span class="identifier">xpath_variable</span><span class="special">::</span><span class="identifier">get_number</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">xpath_variable</span><span class="special">::</span><span class="identifier">get_string</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">const</span> <span class="identifier">xpath_node_set</span><span class="special">&amp;</span> <span class="identifier">xpath_variable</span><span class="special">::</span><span class="identifier">get_node_set</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        These functions return the value of the variable. Note that no type conversions
        are performed; if the type mismatch occurs, a dummy value is returned (<code class="computeroutput"><span class="keyword">false</span></code> for booleans, <code class="computeroutput"><span class="identifier">NaN</span></code>
        for numbers, empty string for strings and empty set for node sets).
      </p>
<p>
        <a name="xpath_variable::set"></a>In order to set variable value, you should
        use one of the following functions, depending on the variable type:
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">xpath_variable</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">bool</span> <span class="identifier">value</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xpath_variable</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">value</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xpath_variable</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_t</span><span class="special">*</span> <span class="identifier">value</span><span class="special">);</span>
<span class="keyword">bool</span> <span class="identifier">xpath_variable</span><span class="special">::</span><span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">xpath_node_set</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">);</span>
</pre>
<p>
        These functions modify the variable value. Note that no type conversions
        are performed; if the type mismatch occurs, the functions return <code class="computeroutput"><span class="keyword">false</span></code>; they also return <code class="computeroutput"><span class="keyword">false</span></code>
        on allocation failure. The variable values are copied to the internal variable
        storage, so you can modify or destroy them after the functions return.
      </p>
<p>
        This is an example of using variables in XPath queries (<a href="../samples/xpath_variables.cpp" target="_top">samples/xpath_variables.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Select nodes via compiled query</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_variable_set</span> <span class="identifier">vars</span><span class="special">;</span>
<span class="identifier">vars</span><span class="special">.</span><span class="identifier">add</span><span class="special">(</span><span class="string">"remote"</span><span class="special">,</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_type_boolean</span><span class="special">);</span>

<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_query</span> <span class="identifier">query_remote_tools</span><span class="special">(</span><span class="string">"/Profile/Tools/Tool[@AllowRemote = string($remote)]"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">vars</span><span class="special">);</span>

<span class="identifier">vars</span><span class="special">.</span><span class="identifier">set</span><span class="special">(</span><span class="string">"remote"</span><span class="special">,</span> <span class="keyword">true</span><span class="special">);</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node_set</span> <span class="identifier">tools_remote</span> <span class="special">=</span> <span class="identifier">query_remote_tools</span><span class="special">.</span><span class="identifier">evaluate_node_set</span><span class="special">(</span><span class="identifier">doc</span><span class="special">);</span>

<span class="identifier">vars</span><span class="special">.</span><span class="identifier">set</span><span class="special">(</span><span class="string">"remote"</span><span class="special">,</span> <span class="keyword">false</span><span class="special">);</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node_set</span> <span class="identifier">tools_local</span> <span class="special">=</span> <span class="identifier">query_remote_tools</span><span class="special">.</span><span class="identifier">evaluate_node_set</span><span class="special">(</span><span class="identifier">doc</span><span class="special">);</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Remote tool: "</span><span class="special">;</span>
<span class="identifier">tools_remote</span><span class="special">[</span><span class="number">2</span><span class="special">].</span><span class="identifier">node</span><span class="special">().</span><span class="identifier">print</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">);</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Local tool: "</span><span class="special">;</span>
<span class="identifier">tools_local</span><span class="special">[</span><span class="number">0</span><span class="special">].</span><span class="identifier">node</span><span class="special">().</span><span class="identifier">print</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">);</span>

<span class="comment">// You can pass the context directly to select_nodes/select_single_node</span>
<span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_node_set</span> <span class="identifier">tools_local_imm</span> <span class="special">=</span> <span class="identifier">doc</span><span class="special">.</span><span class="identifier">select_nodes</span><span class="special">(</span><span class="string">"/Profile/Tools/Tool[@AllowRemote = string($remote)]"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">vars</span><span class="special">);</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Local tool imm: "</span><span class="special">;</span>
<span class="identifier">tools_local_imm</span><span class="special">[</span><span class="number">0</span><span class="special">].</span><span class="identifier">node</span><span class="special">().</span><span class="identifier">print</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.xpath.errors"></a><a class="link" href="xpath.html#manual.xpath.errors" title="Error handling">Error handling</a>
</h3></div></div></div>
<p>
        There are two different mechanisms for error handling in XPath implementation;
        the mechanism used depends on whether exception support is disabled (this
        is controlled with <a class="link" href="install.html#PUGIXML_NO_EXCEPTIONS">PUGIXML_NO_EXCEPTIONS</a>
        define).
      </p>
<p>
        <a name="xpath_exception"></a><a name="xpath_exception::result"></a><a name="xpath_exception::what"></a>By default, XPath functions throw <code class="computeroutput"><span class="identifier">xpath_exception</span></code> object in case of errors;
        additionally, in the event any memory allocation fails, an <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code>
        exception is thrown. Also <code class="computeroutput"><span class="identifier">xpath_exception</span></code>
        is thrown if the query is evaluated to a node set, but the return type is
        not node set. If the query constructor succeeds (i.e. no exception is thrown),
        the query object is valid. Otherwise you can get the error details via one
        of the following functions:
      </p>
<pre class="programlisting"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">xpath_exception</span><span class="special">::</span><span class="identifier">what</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">throw</span><span class="special">();</span>
<span class="keyword">const</span> <span class="identifier">xpath_parse_result</span><span class="special">&amp;</span> <span class="identifier">xpath_exception</span><span class="special">::</span><span class="identifier">result</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <a name="xpath_query::unspecified_bool_type"></a><a name="xpath_query::result"></a>If
        exceptions are disabled, then in the event of parsing failure the query is
        initialized to invalid state; you can test if the query object is valid by
        using it in a boolean expression: <code class="computeroutput"><span class="keyword">if</span>
        <span class="special">(</span><span class="identifier">query</span><span class="special">)</span> <span class="special">{</span> <span class="special">...</span>
        <span class="special">}</span></code>. Additionally, you can get parsing
        result via the result() accessor:
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">xpath_parse_result</span><span class="special">&amp;</span> <span class="identifier">xpath_query</span><span class="special">::</span><span class="identifier">result</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        Without exceptions, evaluating invalid query results in <code class="computeroutput"><span class="keyword">false</span></code>,
        empty string, NaN or an empty node set, depending on the type; evaluating
        a query as a node set results in an empty node set if the return type is
        not node set.
      </p>
<p>
        <a name="xpath_parse_result"></a>The information about parsing result is
        returned via <code class="computeroutput"><span class="identifier">xpath_parse_result</span></code>
        object. It contains parsing status and the offset of last successfully parsed
        character from the beginning of the source stream:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">xpath_parse_result</span>
<span class="special">{</span>
    <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">error</span><span class="special">;</span>
    <span class="identifier">ptrdiff_t</span> <span class="identifier">offset</span><span class="special">;</span>

    <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">description</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
        <a name="xpath_parse_result::error"></a>Parsing result is represented as
        the error message; it is either a null pointer, in case there is no error,
        or the error message in the form of ASCII zero-terminated string.
      </p>
<p>
        <a name="xpath_parse_result::description"></a><code class="computeroutput"><span class="identifier">description</span><span class="special">()</span></code> member function can be used to get the
        error message; it never returns the null pointer, so you can safely use
        <code class="computeroutput"><span class="identifier">description</span><span class="special">()</span></code>
        even if query parsing succeeded. Note that <code class="computeroutput"><span class="identifier">description</span><span class="special">()</span></code> returns a <code class="computeroutput"><span class="keyword">char</span></code>
        string even in <code class="computeroutput"><span class="identifier">PUGIXML_WCHAR_MODE</span></code>;
        you'll have to call <a class="link" href="dom.html#as_wide">as_wide</a> to get the <code class="computeroutput"><span class="keyword">wchar_t</span></code> string.
      </p>
<p>
        <a name="xpath_parse_result::offset"></a>In addition to the error message,
        parsing result has an <code class="computeroutput"><span class="identifier">offset</span></code>
        member, which contains the offset of last successfully parsed character.
        This offset is in units of <a class="link" href="dom.html#char_t">pugi::char_t</a> (bytes
        for character mode, wide characters for wide character mode).
      </p>
<p>
        <a name="xpath_parse_result::bool"></a>Parsing result object can be implicitly
        converted to <code class="computeroutput"><span class="keyword">bool</span></code> like this:
        <code class="computeroutput"><span class="keyword">if</span> <span class="special">(</span><span class="identifier">result</span><span class="special">)</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span>
        <span class="keyword">else</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>.
      </p>
<p>
        This is an example of XPath error handling (<a href="../samples/xpath_error.cpp" target="_top">samples/xpath_error.cpp</a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Exception is thrown for incorrect query syntax</span>
<span class="keyword">try</span>
<span class="special">{</span>
    <span class="identifier">doc</span><span class="special">.</span><span class="identifier">select_nodes</span><span class="special">(</span><span class="string">"//nodes[#true()]"</span><span class="special">);</span>
<span class="special">}</span>
<span class="keyword">catch</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_exception</span><span class="special">&amp;</span> <span class="identifier">e</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Select failed: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">what</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

<span class="comment">// Exception is thrown for incorrect query semantics</span>
<span class="keyword">try</span>
<span class="special">{</span>
    <span class="identifier">doc</span><span class="special">.</span><span class="identifier">select_nodes</span><span class="special">(</span><span class="string">"(123)/next"</span><span class="special">);</span>
<span class="special">}</span>
<span class="keyword">catch</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_exception</span><span class="special">&amp;</span> <span class="identifier">e</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Select failed: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">what</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

<span class="comment">// Exception is thrown for query with incorrect return type</span>
<span class="keyword">try</span>
<span class="special">{</span>
    <span class="identifier">doc</span><span class="special">.</span><span class="identifier">select_nodes</span><span class="special">(</span><span class="string">"123"</span><span class="special">);</span>
<span class="special">}</span>
<span class="keyword">catch</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">pugi</span><span class="special">::</span><span class="identifier">xpath_exception</span><span class="special">&amp;</span> <span class="identifier">e</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Select failed: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">what</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="manual.xpath.w3c"></a><a class="link" href="xpath.html#manual.xpath.w3c" title="Conformance to W3C specification">Conformance to W3C specification</a>
</h3></div></div></div>
<p>
        Because of the differences in document object models, performance considerations
        and implementation complexity, pugixml does not provide a fully conformant
        XPath 1.0 implementation. This is the current list of incompatibilities:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Consecutive text nodes sharing the same parent are not merged, i.e. in
            <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt;</span><span class="identifier">text1</span>
            <span class="special">&lt;![</span><span class="identifier">CDATA</span><span class="special">[</span><span class="identifier">data</span><span class="special">]]&gt;</span> <span class="identifier">text2</span><span class="special">&lt;/</span><span class="identifier">node</span><span class="special">&gt;</span></code> node should have one text node child,
            but instead has three.
          </li>
<li class="listitem">
            Since the document type declaration is not used for parsing, <code class="computeroutput"><span class="identifier">id</span><span class="special">()</span></code>
            function always returns an empty node set.
          </li>
<li class="listitem">
            Namespace nodes are not supported (affects namespace:: axis).
          </li>
<li class="listitem">
            Name tests are performed on QNames in XML document instead of expanded
            names; for <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">foo</span>
            <span class="identifier">xmlns</span><span class="special">:</span><span class="identifier">ns1</span><span class="special">=</span><span class="char">'uri'</span> <span class="identifier">xmlns</span><span class="special">:</span><span class="identifier">ns2</span><span class="special">=</span><span class="char">'uri'</span><span class="special">&gt;&lt;</span><span class="identifier">ns1</span><span class="special">:</span><span class="identifier">child</span><span class="special">/&gt;&lt;</span><span class="identifier">ns2</span><span class="special">:</span><span class="identifier">child</span><span class="special">/&gt;&lt;/</span><span class="identifier">foo</span><span class="special">&gt;</span></code>,
            query <code class="computeroutput"><span class="identifier">foo</span><span class="special">/</span><span class="identifier">ns1</span><span class="special">:*</span></code>
            will return only the first child, not both of them. Compliant XPath implementations
            can return both nodes if the user provides appropriate namespace declarations.
          </li>
<li class="listitem">
            String functions consider a character to be either a single <code class="computeroutput"><span class="keyword">char</span></code> value or a single <code class="computeroutput"><span class="keyword">wchar_t</span></code>
            value, depending on the library configuration; this means that some string
            functions are not fully Unicode-aware. This affects <code class="computeroutput"><span class="identifier">substring</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">string</span><span class="special">-</span><span class="identifier">length</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">translate</span><span class="special">()</span></code> functions.
          </li>
</ul></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Arseny Kapoulkine<p>
        Distributed under the MIT License
      </p>
</div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<b>XPath</b> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="saving.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="changes.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/manual/changes.html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Changelog</title>
<link rel="stylesheet" href="../pugixml.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../manual.html" title="pugixml 1.4">
<link rel="up" href="../manual.html" title="pugixml 1.4">
<link rel="prev" href="xpath.html" title="XPath">
<link rel="next" href="apiref.html" title="API Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="xpath.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="apiref.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
<hr>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="manual.changes"></a><a class="link" href="changes.html" title="Changelog">Changelog</a>
</h2></div></div></div>
<h6>
<a name="manual.changes.h0"></a>
      <span class="phrase"><a name="manual.changes.27_02_2014___version_1_4"></a></span><a class="link" href="changes.html#manual.changes.27_02_2014___version_1_4">27.02.2014
      - version 1.4</a>
    </h6>
<p>
      Major release, featuring various new features, bug fixes and compatibility
      improvements.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Specification changes:
          <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                Documents without element nodes are now rejected with status_no_document_element
                error, unless parse_fragment option is used
              </li></ol></div>
        </li>
<li class="listitem">
          New features:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Added XML fragment parsing (parse_fragment flag)
              </li>
<li class="listitem">
                Added PCDATA whitespace trimming (parse_trim_pcdata flag)
              </li>
<li class="listitem">
                Added long long support for xml_attribute and xml_text (as_llong,
                as_ullong and set_value/set overloads)
              </li>
<li class="listitem">
                Added hexadecimal integer parsing support for as_int/as_uint/as_llong/as_ullong
              </li>
<li class="listitem">
                Added xml_node::append_buffer to improve performance of assembling
                documents from fragments
              </li>
<li class="listitem">
                xml_named_node_iterator is now bidirectional
              </li>
<li class="listitem">
                Reduced XPath stack consumption during compilation and evaluation
                (useful for embedded systems)
              </li>
</ol></div>
        </li>
<li class="listitem">
          Compatibility improvements:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Improved support for platforms without wchar_t support
              </li>
<li class="listitem">
                Fixed several false positives in clang static analysis
              </li>
<li class="listitem">
                Fixed several compilation warnings for various GCC versions
              </li>
</ol></div>
        </li>
<li class="listitem">
          Bug fixes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Fixed undefined pointer arithmetic in XPath implementation
              </li>
<li class="listitem">
                Fixed non-seekable iostream support for certain stream types, i.e.
                boost file_source with pipe input
              </li>
<li class="listitem">
                Fixed xpath_query::return_type() for some expressions
              </li>
<li class="listitem">
                Fixed dllexport issues with xml_named_node_iterator
              </li>
<li class="listitem">
                Fixed find_child_by_attribute assertion for attributes with null
                name/value
              </li>
</ol></div>
        </li>
</ul></div>
<h6>
<a name="manual.changes.h1"></a>
      <span class="phrase"><a name="manual.changes.1_05_2012___version_1_2"></a></span><a class="link" href="changes.html#manual.changes.1_05_2012___version_1_2">1.05.2012
      - version 1.2</a>
    </h6>
<p>
      Major release, featuring header-only mode, various interface enhancements (i.e.
      PCDATA manipulation and C++11 iteration), many other features and compatibility
      improvements.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          New features:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Added xml_text helper class for working with PCDATA/CDATA contents
                of an element node
              </li>
<li class="listitem">
                Added optional header-only mode (controlled by PUGIXML_HEADER_ONLY
                define)
              </li>
<li class="listitem">
                Added xml_node::children() and xml_node::attributes() for C++11 ranged
                for loop or BOOST_FOREACH
              </li>
<li class="listitem">
                Added support for Latin-1 (ISO-8859-1) encoding conversion during
                loading and saving
              </li>
<li class="listitem">
                Added custom default values for xml_attribute::as_* (they are returned if the attribute
                does not exist)
              </li>
<li class="listitem">
                Added parse_ws_pcdata_single flag for preserving whitespace-only
                PCDATA in case it's the only child
              </li>
<li class="listitem">
                Added format_save_file_text for xml_document::save_file to open files
                as text instead of binary (changes newlines on Windows)
              </li>
<li class="listitem">
                Added format_no_escapes flag to disable special symbol escaping (complements
                ~parse_escapes)
              </li>
<li class="listitem">
                Added support for loading document from streams that do not support
                seeking
              </li>
<li class="listitem">
                Added PUGIXML_MEMORY_* constants for tweaking allocation behavior (useful for embedded
                systems)
              </li>
<li class="listitem">
                Added PUGIXML_VERSION preprocessor define
              </li>
</ol></div>
        </li>
<li class="listitem">
          Compatibility improvements:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Parser does not require setjmp support (improves compatibility with
                some embedded platforms, enables clr:pure compilation)
              </li>
<li class="listitem">
                STL forward declarations are no longer used (fixes SunCC/RWSTL compilation,
                fixes clang compilation in C++11 mode)
              </li>
<li class="listitem">
                Fixed AirPlay SDK, Android, Windows Mobile (WinCE) and C++/CLI compilation
              </li>
<li class="listitem">
                Fixed several compilation warnings for various GCC versions, Intel
                C++ compiler and Clang
              </li>
</ol></div>
        </li>
<li class="listitem">
          Bug fixes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Fixed unsafe bool conversion to avoid problems on C++/CLI
              </li>
<li class="listitem">
                Iterator dereference operator is const now (fixes Boost filter_iterator
                support)
              </li>
<li class="listitem">
                xml_document::save_file now checks for file I/O errors during saving
              </li>
</ol></div>
        </li>
</ul></div>
<h6>
<a name="manual.changes.h2"></a>
      <span class="phrase"><a name="manual.changes.1_11_2010___version_1_0"></a></span><a class="link" href="changes.html#manual.changes.1_11_2010___version_1_0">1.11.2010
      - version 1.0</a>
    </h6>
<p>
      Major release, featuring many XPath enhancements, wide character filename support,
      miscellaneous performance improvements, bug fixes and more.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          XPath:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                XPath implementation is moved to pugixml.cpp (which is the only source
                file now); use PUGIXML_NO_XPATH if you want to disable XPath to reduce
                code size
              </li>
<li class="listitem">
                XPath is now supported without exceptions (PUGIXML_NO_EXCEPTIONS);
                the error handling mechanism depends on the presence of exception
                support
              </li>
<li class="listitem">
                XPath is now supported without STL (PUGIXML_NO_STL)
              </li>
<li class="listitem">
                Introduced variable support
              </li>
<li class="listitem">
                Introduced new xpath_query::evaluate_string, which works without
                STL
              </li>
<li class="listitem">
                Introduced new xpath_node_set constructor (from an iterator range)
              </li>
<li class="listitem">
                Evaluation function now accept attribute context nodes
              </li>
<li class="listitem">
                All internal allocations use custom allocation functions
              </li>
<li class="listitem">
                Improved error reporting; now a last parsed offset is returned together
                with the parsing error
              </li>
</ol></div>
        </li>
<li class="listitem">
          Bug fixes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Fixed memory leak for loading from streams with stream exceptions
                turned on
              </li>
<li class="listitem">
                Fixed custom deallocation function calling with null pointer in one
                case
              </li>
<li class="listitem">
                Fixed missing attributes for iterator category functions; all functions/classes
                can now be DLL-exported
              </li>
<li class="listitem">
                Worked around Digital Mars compiler bug, which lead to minor read
                overfetches in several functions
              </li>
<li class="listitem">
                load_file now works with 2+ Gb files in MSVC/MinGW
              </li>
<li class="listitem">
                XPath: fixed memory leaks for incorrect queries
              </li>
<li class="listitem">
                XPath: fixed xpath_node() attribute constructor with empty attribute
                argument
              </li>
<li class="listitem">
                XPath: fixed lang() function for non-ASCII arguments
              </li>
</ol></div>
        </li>
<li class="listitem">
          Specification changes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                CDATA nodes containing ]]&gt; are printed as several nodes; while
                this changes the internal structure, this is the only way to escape
                CDATA contents
              </li>
<li class="listitem">
                Memory allocation errors during parsing now preserve last parsed
                offset (to give an idea about parsing progress)
              </li>
<li class="listitem">
                If an element node has the only child, and it is of CDATA type, then
                the extra indentation is omitted (previously this behavior only held
                for PCDATA children)
              </li>
</ol></div>
        </li>
<li class="listitem">
          Additional functionality:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Added xml_parse_result default constructor
              </li>
<li class="listitem">
                Added xml_document::load_file and xml_document::save_file with wide
                character paths
              </li>
<li class="listitem">
                Added as_utf8 and as_wide overloads for std::wstring/std::string
                arguments
              </li>
<li class="listitem">
                Added DOCTYPE node type (node_doctype) and a special parse flag,
                parse_doctype, to add such nodes to the document during parsing
              </li>
<li class="listitem">
                Added parse_full parse flag mask, which extends parse_default with
                all node type parsing flags except parse_ws_pcdata
              </li>
<li class="listitem">
                Added xml_node::hash_value() and xml_attribute::hash_value() functions
                for use in hash-based containers
              </li>
<li class="listitem">
                Added internal_object() and additional constructor for both xml_node
                and xml_attribute for easier marshalling (useful for language bindings)
              </li>
<li class="listitem">
                Added xml_document::document_element() function
              </li>
<li class="listitem">
                Added xml_node::prepend_attribute, xml_node::prepend_child and xml_node::prepend_copy
                functions
              </li>
<li class="listitem">
                Added xml_node::append_child, xml_node::prepend_child, xml_node::insert_child_before
                and xml_node::insert_child_after overloads for element nodes (with
                name instead of type)
              </li>
<li class="listitem">
                Added xml_document::reset() function
              </li>
</ol></div>
        </li>
<li class="listitem">
          Performance improvements:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                xml_node::root() and xml_node::offset_debug() are now O(1) instead
                of O(logN)
              </li>
<li class="listitem">
                Minor parsing optimizations
              </li>
<li class="listitem">
                Minor memory optimization for strings in DOM tree (set_name/set_value)
              </li>
<li class="listitem">
                Memory optimization for string memory reclaiming in DOM tree (set_name/set_value
                now reallocate the buffer if memory waste is too big)
              </li>
<li class="listitem">
                XPath: optimized document order sorting
              </li>
<li class="listitem">
                XPath: optimized child/attribute axis step
              </li>
<li class="listitem">
                XPath: optimized number-to-string conversions in MSVC
              </li>
<li class="listitem">
                XPath: optimized concat for many arguments
              </li>
<li class="listitem">
                XPath: optimized evaluation allocation mechanism: constant and document
                strings are not heap-allocated
              </li>
<li class="listitem">
                XPath: optimized evaluation allocation mechanism: all temporaries'
                allocations use fast stack-like allocator
              </li>
</ol></div>
        </li>
<li class="listitem">
          Compatibility:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Removed wildcard functions (xml_node::child_w, xml_node::attribute_w,
                etc.)
              </li>
<li class="listitem">
                Removed xml_node::all_elements_by_name
              </li>
<li class="listitem">
                Removed xpath_type_t enumeration; use xpath_value_type instead
              </li>
<li class="listitem">
                Removed format_write_bom_utf8 enumeration; use format_write_bom instead
              </li>
<li class="listitem">
                Removed xml_document::precompute_document_order, xml_attribute::document_order
                and xml_node::document_order functions; document order sort optimization
                is now automatic
              </li>
<li class="listitem">
                Removed xml_document::parse functions and transfer_ownership struct;
                use xml_document::load_buffer_inplace and xml_document::load_buffer_inplace_own
                instead
              </li>
<li class="listitem">
                Removed as_utf16 function; use as_wide instead
              </li>
</ol></div>
        </li>
</ul></div>
<h6>
<a name="manual.changes.h3"></a>
      <span class="phrase"><a name="manual.changes.1_07_2010___version_0_9"></a></span><a class="link" href="changes.html#manual.changes.1_07_2010___version_0_9">1.07.2010
      - version 0.9</a>
    </h6>
<p>
      Major release, featuring extended and improved Unicode support, miscellaneous
      performance improvements, bug fixes and more.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Major Unicode improvements:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Introduced encoding support (automatic/manual encoding detection
                on load, manual encoding selection on save, conversion from/to UTF8,
                UTF16 LE/BE, UTF32 LE/BE)
              </li>
<li class="listitem">
                Introduced wchar_t mode (you can set PUGIXML_WCHAR_MODE define to
                switch pugixml internal encoding from UTF8 to wchar_t; all functions
                are switched to their Unicode variants)
              </li>
<li class="listitem">
                Load/save functions now support wide streams
              </li>
</ol></div>
        </li>
<li class="listitem">
          Bug fixes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Fixed document corruption on failed parsing bug
              </li>
<li class="listitem">
                XPath string &lt;-&gt; number conversion improvements (increased
                precision, fixed crash for huge numbers)
              </li>
<li class="listitem">
                Improved DOCTYPE parsing: now parser recognizes all well-formed DOCTYPE
                declarations
              </li>
<li class="listitem">
                Fixed xml_attribute::as_uint() for large numbers (i.e. 2^32-1)
              </li>
<li class="listitem">
                Fixed xml_node::first_element_by_path for path components that are
                prefixes of node names, but are not exactly equal to them.
              </li>
</ol></div>
        </li>
<li class="listitem">
          Specification changes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                parse() API changed to load_buffer/load_buffer_inplace/load_buffer_inplace_own;
                load_buffer APIs do not require zero-terminated strings.
              </li>
<li class="listitem">
                Renamed as_utf16 to as_wide
              </li>
<li class="listitem">
                Changed xml_node::offset_debug return type and xml_parse_result::offset
                type to ptrdiff_t
              </li>
<li class="listitem">
                Nodes/attributes with empty names are now printed as :anonymous
              </li>
</ol></div>
        </li>
<li class="listitem">
          Performance improvements:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Optimized document parsing and saving
              </li>
<li class="listitem">
                Changed internal memory management: internal allocator is used for
                both metadata and name/value data; allocated pages are deleted if
                all allocations from them are deleted
              </li>
<li class="listitem">
                Optimized memory consumption: sizeof(xml_node_struct) reduced from
                40 bytes to 32 bytes on x86
              </li>
<li class="listitem">
                Optimized debug mode parsing/saving by order of magnitude
              </li>
</ol></div>
        </li>
<li class="listitem">
          Miscellaneous:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                All STL includes except &lt;exception&gt; in pugixml.hpp are replaced
                with forward declarations
              </li>
<li class="listitem">
                xml_node::remove_child and xml_node::remove_attribute now return
                the operation result
              </li>
</ol></div>
        </li>
<li class="listitem">
          Compatibility:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                parse() and as_utf16 are left for compatibility (these functions
                are deprecated and will be removed in version 1.0)
              </li>
<li class="listitem">
                Wildcard functions, document_order/precompute_document_order functions,
                all_elements_by_name function and format_write_bom_utf8 flag are
                deprecated and will be removed in version 1.0
              </li>
<li class="listitem">
                xpath_type_t enumeration was renamed to xpath_value_type; xpath_type_t
                is deprecated and will be removed in version 1.0
              </li>
</ol></div>
        </li>
</ul></div>
<h6>
<a name="manual.changes.h4"></a>
      <span class="phrase"><a name="manual.changes.8_11_2009___version_0_5"></a></span><a class="link" href="changes.html#manual.changes.8_11_2009___version_0_5">8.11.2009
      - version 0.5</a>
    </h6>
<p>
      Major bugfix release. Changes:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          XPath bugfixes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Fixed translate(), lang() and concat() functions (infinite loops/crashes)
              </li>
<li class="listitem">
                Fixed compilation of queries with empty literal strings ("")
              </li>
<li class="listitem">
                Fixed axis tests: they never add empty nodes/attributes to the resulting
                node set now
              </li>
<li class="listitem">
                Fixed string-value evaluation for node-set (the result excluded some
                text descendants)
              </li>
<li class="listitem">
                Fixed self:: axis (it behaved like ancestor-or-self::)
              </li>
<li class="listitem">
                Fixed following:: and preceding:: axes (they included descendent
                and ancestor nodes, respectively)
              </li>
<li class="listitem">
                Minor fix for namespace-uri() function (namespace declaration scope
                includes the parent element of namespace declaration attribute)
              </li>
<li class="listitem">
                Some incorrect queries are no longer parsed now (i.e. foo: *)
              </li>
<li class="listitem">
                Fixed text()/etc. node test parsing bug (i.e. foo[text()] failed
                to compile)
              </li>
<li class="listitem">
                Fixed root step (/) - it now selects empty node set if query is evaluated
                on empty node
              </li>
<li class="listitem">
                Fixed string to number conversion ("123 " converted to
                NaN, "123 .456" converted to 123.456 - now the results
                are 123 and NaN, respectively)
              </li>
<li class="listitem">
                Node set copying now preserves sorted type; leads to better performance
                on some queries
              </li>
</ol></div>
        </li>
<li class="listitem">
          Miscellaneous bugfixes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Fixed xml_node::offset_debug for PI nodes
              </li>
<li class="listitem">
                Added empty attribute checks to xml_node::remove_attribute
              </li>
<li class="listitem">
                Fixed node_pi and node_declaration copying
              </li>
<li class="listitem">
                Const-correctness fixes
              </li>
</ol></div>
        </li>
<li class="listitem">
          Specification changes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                xpath_node::select_nodes() and related functions now throw exception
                if expression return type is not node set (instead of assertion)
              </li>
<li class="listitem">
                xml_node::traverse() now sets depth to -1 for both begin() and end()
                callbacks (was 0 at begin() and -1 at end())
              </li>
<li class="listitem">
                In case of non-raw node printing a newline is output after PCDATA
                inside nodes if the PCDATA has siblings
              </li>
<li class="listitem">
                UTF8 -&gt; wchar_t conversion now considers 5-byte UTF8-like sequences
                as invalid
              </li>
</ol></div>
        </li>
<li class="listitem">
          New features:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Added xpath_node_set::operator[] for index-based iteration
              </li>
<li class="listitem">
                Added xpath_query::return_type()
              </li>
<li class="listitem">
                Added getter accessors for memory-management functions
              </li>
</ol></div>
        </li>
</ul></div>
<h6>
<a name="manual.changes.h5"></a>
      <span class="phrase"><a name="manual.changes.17_09_2009___version_0_42"></a></span><a class="link" href="changes.html#manual.changes.17_09_2009___version_0_42">17.09.2009
      - version 0.42</a>
    </h6>
<p>
      Maintenance release. Changes:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Bug fixes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Fixed deallocation in case of custom allocation functions or if delete[]
                / free are incompatible
              </li>
<li class="listitem">
                XPath parser fixed for incorrect queries (i.e. incorrect XPath queries
                should now always fail to compile)
              </li>
<li class="listitem">
                Const-correctness fixes for find_child_by_attribute
              </li>
<li class="listitem">
                Improved compatibility (miscellaneous warning fixes, fixed cstring
                include dependency for GCC)
              </li>
<li class="listitem">
                Fixed iterator begin/end and print function to work correctly for
                empty nodes
              </li>
</ol></div>
        </li>
<li class="listitem">
          New features:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Added PUGIXML_API/PUGIXML_CLASS/PUGIXML_FUNCTION configuration macros
                to control class/function attributes
              </li>
<li class="listitem">
                Added xml_attribute::set_value overloads for different types
              </li>
</ol></div>
        </li>
</ul></div>
<h6>
<a name="manual.changes.h6"></a>
      <span class="phrase"><a name="manual.changes.8_02_2009___version_0_41"></a></span><a class="link" href="changes.html#manual.changes.8_02_2009___version_0_41">8.02.2009
      - version 0.41</a>
    </h6>
<p>
      Maintenance release. Changes:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
          Bug fixes:
          <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                Fixed bug with node printing (occasionally some content was not written
                to output stream)
              </li></ol></div>
        </li></ul></div>
<h6>
<a name="manual.changes.h7"></a>
      <span class="phrase"><a name="manual.changes.18_01_2009___version_0_4"></a></span><a class="link" href="changes.html#manual.changes.18_01_2009___version_0_4">18.01.2009
      - version 0.4</a>
    </h6>
<p>
      Changes:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Bug fixes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Documentation fix in samples for parse() with manual lifetime control
              </li>
<li class="listitem">
                Fixed document order sorting in XPath (it caused wrong order of nodes
                after xpath_node_set::sort and wrong results of some XPath queries)
              </li>
</ol></div>
        </li>
<li class="listitem">
          Node printing changes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Single quotes are no longer escaped when printing nodes
              </li>
<li class="listitem">
                Symbols in second half of ASCII table are no longer escaped when
                printing nodes; because of this, format_utf8 flag is deleted as it's
                no longer needed and format_write_bom is renamed to format_write_bom_utf8.
              </li>
<li class="listitem">
                Reworked node printing - now it works via xml_writer interface; implementations
                for FILE* and std::ostream are available. As a side-effect, xml_document::save_file
                now works without STL.
              </li>
</ol></div>
        </li>
<li class="listitem">
          New features:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Added unsigned integer support for attributes (xml_attribute::as_uint,
                xml_attribute::operator=)
              </li>
<li class="listitem">
                Now document declaration (&lt;?xml ...?&gt;) is parsed as node with
                type node_declaration when parse_declaration flag is specified (access
                to encoding/version is performed as if they were attributes, i.e.
                doc.child("xml").attribute("version").as_float());
                corresponding flags for node printing were also added
              </li>
<li class="listitem">
                Added support for custom memory management (see set_memory_management_functions
                for details)
              </li>
<li class="listitem">
                Implemented node/attribute copying (see xml_node::insert_copy_* and
                xml_node::append_copy for details)
              </li>
<li class="listitem">
                Added find_child_by_attribute and find_child_by_attribute_w to simplify
                parsing code in some cases (i.e. COLLADA files)
              </li>
<li class="listitem">
                Added file offset information querying for debugging purposes (now
                you're able to determine exact location of any xml_node in parsed
                file, see xml_node::offset_debug for details)
              </li>
<li class="listitem">
                Improved error handling for parsing - now load(), load_file() and
                parse() return xml_parse_result, which contains error code and last
                parsed offset; this does not break old interface as xml_parse_result
                can be implicitly casted to bool.
              </li>
</ol></div>
        </li>
</ul></div>
<h6>
<a name="manual.changes.h8"></a>
      <span class="phrase"><a name="manual.changes.31_10_2007___version_0_34"></a></span><a class="link" href="changes.html#manual.changes.31_10_2007___version_0_34">31.10.2007
      - version 0.34</a>
    </h6>
<p>
      Maintenance release. Changes:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Bug fixes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Fixed bug with loading from text-mode iostreams
              </li>
<li class="listitem">
                Fixed leak when transfer_ownership is true and parsing is failing
              </li>
<li class="listitem">
                Fixed bug in saving (\r and \n are now escaped in attribute values)
              </li>
<li class="listitem">
                Renamed free() to destroy() - some macro conflicts were reported
              </li>
</ol></div>
        </li>
<li class="listitem">
          New features:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Improved compatibility (supported Digital Mars C++, MSVC 6, CodeWarrior
                8, PGI C++, Comeau, supported PS3 and XBox360)
              </li>
<li class="listitem">
                PUGIXML_NO_EXCEPTION flag for platforms without exception handling
              </li>
</ol></div>
        </li>
</ul></div>
<h6>
<a name="manual.changes.h9"></a>
      <span class="phrase"><a name="manual.changes.21_02_2007___version_0_3"></a></span><a class="link" href="changes.html#manual.changes.21_02_2007___version_0_3">21.02.2007
      - version 0.3</a>
    </h6>
<p>
      Refactored, reworked and improved version. Changes:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Interface:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Added XPath
              </li>
<li class="listitem">
                Added tree modification functions
              </li>
<li class="listitem">
                Added no STL compilation mode
              </li>
<li class="listitem">
                Added saving document to file
              </li>
<li class="listitem">
                Refactored parsing flags
              </li>
<li class="listitem">
                Removed xml_parser class in favor of xml_document
              </li>
<li class="listitem">
                Added transfer ownership parsing mode
              </li>
<li class="listitem">
                Modified the way xml_tree_walker works
              </li>
<li class="listitem">
                Iterators are now non-constant
              </li>
</ol></div>
        </li>
<li class="listitem">
          Implementation:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Support of several compilers and platforms
              </li>
<li class="listitem">
                Refactored and sped up parsing core
              </li>
<li class="listitem">
                Improved standard compliancy
              </li>
<li class="listitem">
                Added XPath implementation
              </li>
<li class="listitem">
                Fixed several bugs
              </li>
</ol></div>
        </li>
</ul></div>
<h6>
<a name="manual.changes.h10"></a>
      <span class="phrase"><a name="manual.changes.6_11_2006___version_0_2"></a></span><a class="link" href="changes.html#manual.changes.6_11_2006___version_0_2">6.11.2006
      - version 0.2</a>
    </h6>
<p>
      First public release. Changes:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Bug fixes:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Fixed child_value() (for empty nodes)
              </li>
<li class="listitem">
                Fixed xml_parser_impl warning at W4
              </li>
</ol></div>
        </li>
<li class="listitem">
          New features:
          <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Introduced child_value(name) and child_value_w(name)
              </li>
<li class="listitem">
                parse_eol_pcdata and parse_eol_attribute flags + parse_minimal optimizations
              </li>
<li class="listitem">
                Optimizations of strconv_t
              </li>
</ol></div>
        </li>
</ul></div>
<h6>
<a name="manual.changes.h11"></a>
      <span class="phrase"><a name="manual.changes.15_07_2006___version_0_1"></a></span><a class="link" href="changes.html#manual.changes.15_07_2006___version_0_1">15.07.2006
      - version 0.1</a>
    </h6>
<p>
      First private release for testing purposes
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Arseny Kapoulkine<p>
        Distributed under the MIT License
      </p>
</div></td>
</tr></table>
<hr>
<table width="100%"><tr>
<td>
<a href="http://pugixml.org/">pugixml 1.4</a> manual |
		<a href="../manual.html">Overview</a> |
		<a href="install.html">Installation</a> |
		Document:
		<a href="dom.html">Object model</a> &middot; <a href="loading.html">Loading</a> &middot; <a href="access.html">Accessing</a> &middot; <a href="modify.html">Modifying</a> &middot; <a href="saving.html">Saving</a> |
		<a href="xpath.html">XPath</a> |
		<a href="apiref.html">API Reference</a> |
		<a href="toc.html">Table of Contents</a>
</td>
<td width="*" align="right"><div class="spirit-nav">
<a accesskey="p" href="xpath.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../manual.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="apiref.html"><img src="../images/next.png" alt="Next"></a>
</div></td>
</tr></table>
</body>
</html>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/pugixml.css
/*=============================================================================
    Copyright (c) 2004 Joel de Guzman
    http://spirit.sourceforge.net/

    Distributed under the Boost Software License, Version 1.0. (See accompany-
    ing file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================*/

/*=============================================================================
    Body defaults
=============================================================================*/

    body
    {
        margin: 1em;
        font-family: sans-serif;
    }

/*=============================================================================
    Paragraphs
=============================================================================*/

    p
    {
        text-align: left;
        font-size: 10pt;
        line-height: 1.15;
    }

/*=============================================================================
    Program listings
=============================================================================*/

    /* Code on paragraphs */
    p tt.computeroutput
    {
        font-size: 9pt;
    }

    pre.synopsis
    {
        font-size: 90%;
        margin: 1pc 4% 0pc 4%;
        padding: 0.5pc 0.5pc 0.5pc 0.5pc;
    }

    .programlisting,
    .screen
    {
        font-size: 9pt;
        display: block;
        margin: 1pc 4% 0pc 4%;
        padding: 0.5pc 0.5pc 0.5pc 0.5pc;
    }

    /* Program listings in tables don't get borders */
    td .programlisting,
    td .screen
    {
        margin: 0pc 0pc 0pc 0pc;
        padding:  0pc 0pc 0pc 0pc;
    }

/*=============================================================================
    Headings
=============================================================================*/

    h1, h2, h3, h4, h5, h6
    {
        text-align: left;
        margin: 1em 0em 0.5em 0em;
        font-weight: bold;
    }

    h1 { font: 140% }
    h2 { font: bold 140% }
    h3 { font: bold 130% }
    h4 { font: bold 120% }
    h5 { font: italic 110% }
    h6 { font: italic 100% }

    /* Top page titles */
    title,
    h1.title,
    h2.title
    h3.title,
    h4.title,
    h5.title,
    h6.title,
    .refentrytitle
    {
        font-weight: bold;
        margin-bottom: 1pc;
    }

    h1.title { font-size: 140% }
    h2.title { font-size: 140% }
    h3.title { font-size: 130% }
    h4.title { font-size: 120% }
    h5.title { font-size: 110% }
    h6.title { font-size: 100% }

    .section h1
    {
        margin: 0em 0em 0.5em 0em;
        font-size: 140%;
    }

    .section h2 { font-size: 140% }
    .section h3 { font-size: 130% }
    .section h4 { font-size: 120% }
    .section h5 { font-size: 110% }
    .section h6 { font-size: 100% }

    /* Code on titles */
    h1 tt.computeroutput { font-size: 140% }
    h2 tt.computeroutput { font-size: 140% }
    h3 tt.computeroutput { font-size: 130% }
    h4 tt.computeroutput { font-size: 130% }	
    h5 tt.computeroutput { font-size: 130% }
    h6 tt.computeroutput { font-size: 130% }


/*=============================================================================
    Author
=============================================================================*/

    h3.author
    {
        font-size: 100%
    }

/*=============================================================================
    Lists
=============================================================================*/

    li
    {
        font-size: 10pt;
        line-height: 1.3;
    }

    /* Unordered lists */
    ul
    {
        text-align: left;
    }

    /* Ordered lists */
    ol
    {
        text-align: left;
    }

/*=============================================================================
    Links
=============================================================================*/

    a
    {
        text-decoration: none; /* no underline */
    }

    a:hover
    {
        text-decoration: underline;
    }

/*=============================================================================
    Spirit style navigation
=============================================================================*/

    .spirit-nav
    {
        text-align: right;
    }

    .spirit-nav a
    {
        color: white;
        padding-left: 0.5em;
    }

    .spirit-nav img
    {
        border-width: 0px;
    }

/*=============================================================================
    Copyright footer
=============================================================================*/
    .copyright-footer
    {
        text-align: right;
        font-size: 70%;
    }

    .copyright-footer p
    {
        text-align: right;
        font-size: 80%;
    }

/*=============================================================================
    Table of contents
=============================================================================*/

    .toc
    {
       margin: 1pc 4% 0pc 4%;
       padding: 0.1pc 1pc 0.1pc 1pc;
       font-size: 80%;
       line-height: 1.15;
    }

    .boost-toc
    {
       float: right;
       padding: 0.5pc;
    }
	
    /* Code on toc */
    .toc .computeroutput { font-size: 120% }
	
/*=============================================================================
    Tables
=============================================================================*/

    .table-title,
    div.table p.title
    {
        margin-left: 4%;
        padding-right: 0.5em;
        padding-left: 0.5em;
    }

    .informaltable table,
    .table table
    {
        width: 92%;
        margin-left: 4%;
        margin-right: 4%;
    }

    div.informaltable table,
    div.table table
    {
        padding: 4px;
    }

    /* Table Cells */
    div.informaltable table tr td,
    div.table table tr td
    {
        padding: 0.5em;
        text-align: left;
        font-size: 9pt;
    }

    div.informaltable table tr th,
    div.table table tr th
    {
        padding: 0.5em 0.5em 0.5em 0.5em;
        border: 1pt solid white;
        font-size: 80%;
    }

    table.simplelist
    {
        width: auto !important;
        margin: 0em !important;
        padding: 0em !important;
        border: none !important;
    }
    table.simplelist td
    {
        margin: 0em !important;
        padding: 0em !important;
        text-align: left !important;
        font-size: 9pt !important;
        border: none !important;
    }

/*=============================================================================
    Blurbs
=============================================================================*/

    div.note,
    div.tip,
    div.important,
    div.caution,
    div.warning,
    p.blurb
    {
        font-size: 9pt; /* A little bit smaller than the main text */
        line-height: 1.2;
        display: block;
        margin: 1pc 4% 0pc 4%;
        padding: 0.5pc 0.5pc 0.5pc 0.5pc;
    }

    p.blurb img
    {
        padding: 1pt;
    }

/*=============================================================================
    Variable Lists
=============================================================================*/

    div.variablelist
    {
        margin: 1em 0;
    }

    /* Make the terms in definition lists bold */
    div.variablelist dl dt,
    span.term
    {
        font-weight: bold;
        font-size: 10pt;
    }

    div.variablelist table tbody tr td
    {
        text-align: left;
        vertical-align: top;
        padding: 0em 2em 0em 0em;
        font-size: 10pt;
        margin: 0em 0em 0.5em 0em;
        line-height: 1;
    }

    div.variablelist dl dt
    {
        margin-bottom: 0.2em;
    }

    div.variablelist dl dd
    {
        margin: 0em 0em 0.5em 2em;
        font-size: 10pt;
    }

    div.variablelist table tbody tr td p,
    div.variablelist dl dd p
    {
        margin: 0em 0em 0.5em 0em;
        line-height: 1;
    }

/*=============================================================================
    Misc
=============================================================================*/

    /* Title of books and articles in bibliographies */
    span.title
    {
        font-style: italic;
    }

    span.underline
    {
        text-decoration: underline;
    }

    span.strikethrough
    {
        text-decoration: line-through;
    }

    /* Copyright, Legal Notice */
    div div.legalnotice p
    {
        text-align: left
    }

/*=============================================================================
    Colors
=============================================================================*/

    @media screen
    {
        body {
            background-color: #FFFFFF;
            color: #000000;
        }
        
    /* Links */
        a
        {
            color: #005a9c;
        }

        a:visited
        {
            color: #9c5a9c;
        }

        h1 a, h2 a, h3 a, h4 a, h5 a, h6 a,
        h1 a:hover, h2 a:hover, h3 a:hover, h4 a:hover, h5 a:hover, h6 a:hover,
        h1 a:visited, h2 a:visited, h3 a:visited, h4 a:visited, h5 a:visited, h6 a:visited
        {
            text-decoration: none; /* no underline */
            color: #000000;
        }

    /* Syntax Highlighting */
        .keyword        { color: #0000AA; }
        .identifier     { color: #000000; }
        .special        { color: #707070; }
        .preprocessor   { color: #402080; }
        .char           { color: teal; }
        .comment        { color: #800000; }
        .string         { color: teal; }
        .number         { color: teal; }
        .white_bkd      { background-color: #FFFFFF; }
        .dk_grey_bkd    { background-color: #999999; }

    /* Copyright, Legal Notice */
        .copyright
        {
            color: #666666;
            font-size: small;
        }

        div div.legalnotice p
        {
            color: #666666;
        }

    /* Program listing */
        pre.synopsis
        {
            border: 1px solid #DCDCDC;
        }

        .programlisting,
        .screen
        {
            border: 1px solid #DCDCDC;
        }

        td .programlisting,
        td .screen
        {
            border: 0px solid #DCDCDC;
        }

    /* Blurbs */
        div.note,
        div.tip,
        div.important,
        div.caution,
        div.warning,
        p.blurb
        {
            border: 1px solid #DCDCDC;
        }

    /* Table of contents */
        .toc
        {
            border: 1px solid #DCDCDC;
        }

    /* Tables */
        div.informaltable table tr td,
        div.table table tr td
        {
            border: 1px solid #DCDCDC;
        }

        div.informaltable table tr th,
        div.table table tr th
        {
            background-color: #F0F0F0;
            border: 1px solid #DCDCDC;
        }

        .copyright-footer
        {
            color: #8F8F8F;
        }

    /* Misc */
        span.highlight
        {
            color: #00A000;
        }
    }

    @media print
    {
    /* Links */
        a
        {
            color: black;
        }

        a:visited
        {
            color: black;
        }

        .spirit-nav
        {
            display: none;
        }

    /* Program listing */
        pre.synopsis
        {
            border: 1px solid gray;
        }

        .programlisting,
        .screen
        {
            border: 1px solid gray;
        }

        td .programlisting,
        td .screen
        {
            border: 0px solid #DCDCDC;
        }

    /* Table of contents */
        .toc
        {
            border: 1px solid gray;
        }

        .informaltable table,
        .table table
        {
            border: 1px solid gray;
            border-collapse: collapse;
        }

    /* Tables */
        div.informaltable table tr td,
        div.table table tr td
        {
            border: 1px solid gray;
        }

        div.informaltable table tr th,
        div.table table tr th
        {
            border: 1px solid gray;
        }

        table.simplelist tr td
        {
            border: none !important;
        }

    /* Misc */
        span.highlight
        {
            font-weight: bold;
        }
    }

/*=============================================================================
    Images
=============================================================================*/

    span.inlinemediaobject img
    {
        vertical-align: middle;
    }

/*==============================================================================
    Super and Subscript: style so that line spacing isn't effected, see
    http://www.adobe.com/cfusion/communityengine/index.cfm?event=showdetails&productId=1&postId=5341
==============================================================================*/

sup,
sub {
	height: 0;
	line-height: 1;
	vertical-align: baseline;
	_vertical-align: bottom;
	position: relative;
	
}

sup {
	bottom: 1ex;
}

sub {
	top: .5ex;
}

**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/traverse_base.cpp
#include "pugixml.hpp"

#include <string.h>
#include <iostream>

int main()
{
    pugi::xml_document doc;
    if (!doc.load_file("xgconsole.xml")) return -1;

    pugi::xml_node tools = doc.child("Profile").child("Tools");

    //[code_traverse_base_basic
    for (pugi::xml_node tool = tools.first_child(); tool; tool = tool.next_sibling())
    {
        std::cout << "Tool:";

        for (pugi::xml_attribute attr = tool.first_attribute(); attr; attr = attr.next_attribute())
        {
            std::cout << " " << attr.name() << "=" << attr.value();
        }

        std::cout << std::endl;
    }
    //]

    std::cout << std::endl;

    //[code_traverse_base_data
    for (pugi::xml_node tool = tools.child("Tool"); tool; tool = tool.next_sibling("Tool"))
    {
        std::cout << "Tool " << tool.attribute("Filename").value();
        std::cout << ": AllowRemote " << tool.attribute("AllowRemote").as_bool();
        std::cout << ", Timeout " << tool.attribute("Timeout").as_int();
        std::cout << ", Description '" << tool.child_value("Description") << "'\n";
    }
    //]

    std::cout << std::endl;

    //[code_traverse_base_contents
    std::cout << "Tool for *.dae generation: " << tools.find_child_by_attribute("Tool", "OutputFileMasks", "*.dae").attribute("Filename").value() << "\n";

    for (pugi::xml_node tool = tools.child("Tool"); tool; tool = tool.next_sibling("Tool"))
    {
        std::cout << "Tool " << tool.attribute("Filename").value() << "\n";
    }
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/save_options.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    //[code_save_options
    // get a test document
    pugi::xml_document doc;
    doc.load("<foo bar='baz'><call>hey</call></foo>");

    // default options; prints
    // <?xml version="1.0"?>
    // <foo bar="baz">
    //         <call>hey</call>
    // </foo>
    doc.save(std::cout);
    std::cout << std::endl;

    // default options with custom indentation string; prints
    // <?xml version="1.0"?>
    // <foo bar="baz">
    // --<call>hey</call>
    // </foo>
    doc.save(std::cout, "--");
    std::cout << std::endl;

    // default options without indentation; prints
    // <?xml version="1.0"?>
    // <foo bar="baz">
    // <call>hey</call>
    // </foo>
    doc.save(std::cout, "\t", pugi::format_default & ~pugi::format_indent); // can also pass "" instead of indentation string for the same effect
    std::cout << std::endl;

    // raw output; prints
    // <?xml version="1.0"?><foo bar="baz"><call>hey</call></foo>
    doc.save(std::cout, "\t", pugi::format_raw);
    std::cout << std::endl << std::endl;

    // raw output without declaration; prints
    // <foo bar="baz"><call>hey</call></foo>
    doc.save(std::cout, "\t", pugi::format_raw | pugi::format_no_declaration);
    std::cout << std::endl;
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/save_file.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    // get a test document
    pugi::xml_document doc;
    doc.load("<foo bar='baz'>hey</foo>");

    //[code_save_file
    // save document to file
    std::cout << "Saving result: " << doc.save_file("save_file_output.xml") << std::endl;
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/modify_remove.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    pugi::xml_document doc;
    if (!doc.load("<node><description>Simple node</description><param name='id' value='123'/></node>")) return -1;

    //[code_modify_remove
    // remove description node with the whole subtree
    pugi::xml_node node = doc.child("node");
    node.remove_child("description");

    // remove id attribute
    pugi::xml_node param = node.child("param");
    param.remove_attribute("value");

    // we can also remove nodes/attributes by handles
    pugi::xml_attribute id = param.attribute("name");
    param.remove_attribute(id);
    //]

    doc.print(std::cout);
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/xpath_query.cpp
#include "pugixml.hpp"

#include <iostream>
#include <string>

int main()
{
    pugi::xml_document doc;
    if (!doc.load_file("xgconsole.xml")) return -1;

//[code_xpath_query
    // Select nodes via compiled query
    pugi::xpath_query query_remote_tools("/Profile/Tools/Tool[@AllowRemote='true']");

    pugi::xpath_node_set tools = query_remote_tools.evaluate_node_set(doc);
    std::cout << "Remote tool: ";
    tools[2].node().print(std::cout);

    // Evaluate numbers via compiled query
    pugi::xpath_query query_timeouts("sum(//Tool/@Timeout)");
    std::cout << query_timeouts.evaluate_number(doc) << std::endl;

    // Evaluate strings via compiled query for different context nodes
    pugi::xpath_query query_name_valid("string-length(substring-before(@Filename, '_')) > 0 and @OutputFileMasks");
    pugi::xpath_query query_name("concat(substring-before(@Filename, '_'), ' produces ', @OutputFileMasks)");

    for (pugi::xml_node tool = doc.first_element_by_path("Profile/Tools/Tool"); tool; tool = tool.next_sibling())
    {
        std::string s = query_name.evaluate_string(tool);

        if (query_name_valid.evaluate_boolean(tool)) std::cout << s << std::endl;
    }
//]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/load_memory.cpp
#include "pugixml.hpp"

#include <iostream>
#include <cstring>

int main()
{
//[code_load_memory_decl
    const char source[] = "<mesh name='sphere'><bounds>0 0 1 1</bounds></mesh>";
    size_t size = sizeof(source);
//]

    pugi::xml_document doc;

    {
    //[code_load_memory_buffer
        // You can use load_buffer to load document from immutable memory block:
        pugi::xml_parse_result result = doc.load_buffer(source, size);
    //]

        std::cout << "Load result: " << result.description() << ", mesh name: " << doc.child("mesh").attribute("name").value() << std::endl;
    }

    {
    //[code_load_memory_buffer_inplace
        // You can use load_buffer_inplace to load document from mutable memory block; the block's lifetime must exceed that of document
        char* buffer = new char[size];
        memcpy(buffer, source, size);

        // The block can be allocated by any method; the block is modified during parsing
        pugi::xml_parse_result result = doc.load_buffer_inplace(buffer, size);

    //<-
        std::cout << "Load result: " << result.description() << ", mesh name: " << doc.child("mesh").attribute("name").value() << std::endl;
    //->
        // You have to destroy the block yourself after the document is no longer used
        delete[] buffer;
    //]
    }

    {
    //[code_load_memory_buffer_inplace_own
        // You can use load_buffer_inplace_own to load document from mutable memory block and to pass the ownership of this block
        // The block has to be allocated via pugixml allocation function - using i.e. operator new here is incorrect
        char* buffer = static_cast<char*>(pugi::get_memory_allocation_function()(size));
        memcpy(buffer, source, size);

        // The block will be deleted by the document
        pugi::xml_parse_result result = doc.load_buffer_inplace_own(buffer, size);
    //]

        std::cout << "Load result: " << result.description() << ", mesh name: " << doc.child("mesh").attribute("name").value() << std::endl;
    }

    {
    //[code_load_memory_string
        // You can use load to load document from null-terminated strings, for example literals:
        pugi::xml_parse_result result = doc.load("<mesh name='sphere'><bounds>0 0 1 1</bounds></mesh>");
    //]

        std::cout << "Load result: " << result.description() << ", mesh name: " << doc.child("mesh").attribute("name").value() << std::endl;
    }
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/character.xml
<?xml version="1.0"?>
<network>
	<animation clip="idle" flags="loop" />
	<animation clip="run" flags="loop" />
	<animation clip="attack" />

	<?include transitions.xml?>
</network>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/xpath_variables.cpp
#include "pugixml.hpp"

#include <iostream>
#include <string>

int main()
{
    pugi::xml_document doc;
    if (!doc.load_file("xgconsole.xml")) return -1;

//[code_xpath_variables
    // Select nodes via compiled query
    pugi::xpath_variable_set vars;
    vars.add("remote", pugi::xpath_type_boolean);

    pugi::xpath_query query_remote_tools("/Profile/Tools/Tool[@AllowRemote = string($remote)]", &vars);

    vars.set("remote", true);
    pugi::xpath_node_set tools_remote = query_remote_tools.evaluate_node_set(doc);

    vars.set("remote", false);
    pugi::xpath_node_set tools_local = query_remote_tools.evaluate_node_set(doc);

    std::cout << "Remote tool: ";
    tools_remote[2].node().print(std::cout);

    std::cout << "Local tool: ";
    tools_local[0].node().print(std::cout);

    // You can pass the context directly to select_nodes/select_single_node
    pugi::xpath_node_set tools_local_imm = doc.select_nodes("/Profile/Tools/Tool[@AllowRemote = string($remote)]", &vars);

    std::cout << "Local tool imm: ";
    tools_local_imm[0].node().print(std::cout);
//]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/tree.xml
<?xml version="1.0"?>
<mesh name="mesh_root">
	<!-- here is a mesh node -->
	some text
	<![CDATA[someothertext]]>
	some more text
	<node attr1="value1" attr2="value2" />
	<node attr1="value2">
		<innernode/>
	</node>
</mesh>
<?include somedata?>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/modify_add.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    pugi::xml_document doc;

    //[code_modify_add
    // add node with some name
    pugi::xml_node node = doc.append_child("node");

    // add description node with text child
    pugi::xml_node descr = node.append_child("description");
    descr.append_child(pugi::node_pcdata).set_value("Simple node");

    // add param node before the description
    pugi::xml_node param = node.insert_child_before("param", descr);

    // add attributes to param node
    param.append_attribute("name") = "version";
    param.append_attribute("value") = 1.1;
    param.insert_attribute_after("type", param.attribute("name")) = "float";
    //]

    doc.print(std::cout);
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/save_subtree.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    //[code_save_subtree
    // get a test document
    pugi::xml_document doc;
    doc.load("<foo bar='baz'><call>hey</call></foo>");

    // print document to standard output (prints <?xml version="1.0"?><foo bar="baz"><call>hey</call></foo>)
    doc.save(std::cout, "", pugi::format_raw);
    std::cout << std::endl;

    // print document to standard output as a regular node (prints <foo bar="baz"><call>hey</call></foo>)
    doc.print(std::cout, "", pugi::format_raw);
    std::cout << std::endl;

    // print a subtree to standard output (prints <call>hey</call>)
    doc.child("foo").child("call").print(std::cout, "", pugi::format_raw);
    std::cout << std::endl;
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/save_custom_writer.cpp
#include "pugixml.hpp"

#include <string>
#include <iostream>
#include <cstring>

//[code_save_custom_writer
struct xml_string_writer: pugi::xml_writer
{
    std::string result;

    virtual void write(const void* data, size_t size)
    {
        result += std::string(static_cast<const char*>(data), size);
    }
};
//]

struct xml_memory_writer: pugi::xml_writer
{
    char* buffer;
    size_t capacity;

    size_t result;

    xml_memory_writer(): buffer(0), capacity(0), result(0)
    {
    }

    xml_memory_writer(char* buffer, size_t capacity): buffer(buffer), capacity(capacity), result(0)
    {
    }

    size_t written_size() const
    {
        return result < capacity ? result : capacity;
    }

    virtual void write(const void* data, size_t size)
    {
        if (result < capacity)
        {
            size_t chunk = (capacity - result < size) ? capacity - result : size;

            memcpy(buffer + result, data, chunk);
        }

        result += size;
    }
};

std::string node_to_string(pugi::xml_node node)
{
    xml_string_writer writer;
    node.print(writer);

    return writer.result;
}

char* node_to_buffer(pugi::xml_node node, char* buffer, size_t size)
{
    if (size == 0) return buffer;

    // leave one character for null terminator
    xml_memory_writer writer(buffer, size - 1);
    node.print(writer);

    // null terminate
    buffer[writer.written_size()] = 0;

    return buffer;
}

char* node_to_buffer_heap(pugi::xml_node node)
{
    // first pass: get required memory size
    xml_memory_writer counter;
    node.print(counter);

    // allocate necessary size (+1 for null termination)
    char* buffer = new char[counter.result + 1];

    // second pass: actual printing
    xml_memory_writer writer(buffer, counter.result);
    node.print(writer);

    // null terminate
    buffer[writer.written_size()] = 0;

    return buffer;
}

int main()
{
    // get a test document
    pugi::xml_document doc;
    doc.load("<foo bar='baz'>hey</foo>");

    // get contents as std::string (single pass)
    std::cout << "contents: [" << node_to_string(doc) << "]\n";

    // get contents into fixed-size buffer (single pass)
    char large_buf[128];
    std::cout << "contents: [" << node_to_buffer(doc, large_buf, sizeof(large_buf)) << "]\n";

    // get contents into fixed-size buffer (single pass, shows truncating behavior)
    char small_buf[22];
    std::cout << "contents: [" << node_to_buffer(doc, small_buf, sizeof(small_buf)) << "]\n";

    // get contents into heap-allocated buffer (two passes)
    char* heap_buf = node_to_buffer_heap(doc);
    std::cout << "contents: [" << heap_buf << "]\n";
    delete[] heap_buf;
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/load_file.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
//[code_load_file
    pugi::xml_document doc;

    pugi::xml_parse_result result = doc.load_file("tree.xml");

    std::cout << "Load result: " << result.description() << ", mesh name: " << doc.child("mesh").attribute("name").value() << std::endl;
//]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/save_declaration.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    //[code_save_declaration
    // get a test document
    pugi::xml_document doc;
    doc.load("<foo bar='baz'><call>hey</call></foo>");

    // add a custom declaration node
    pugi::xml_node decl = doc.prepend_child(pugi::node_declaration);
    decl.append_attribute("version") = "1.0";
    decl.append_attribute("encoding") = "UTF-8";
    decl.append_attribute("standalone") = "no";

    // <?xml version="1.0" encoding="UTF-8" standalone="no"?> 
    // <foo bar="baz">
    //         <call>hey</call>
    // </foo>
    doc.save(std::cout);
    std::cout << std::endl;
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/weekly-utf-8.xml
<?xml version="1.0"?>
<!DOCTYPE 週報 SYSTEM "weekly-utf-8.dtd">
<!-- 週報サンプル -->
<週報>
  <年月週>
    <年度>1997</年度>
    <月度>1</月度>
    <週>1</週>
  </年月週>

  <氏名>
    <氏>山田</氏>
    <名>太郎</名>
  </氏名>

  <業務報告リスト>
    <業務報告>
      <業務名>XMLエディターの作成</業務名>
      <業務コード>X3355-23</業務コード>
      <工数管理>
        <見積もり工数>1600</見積もり工数>
        <実績工数>320</実績工数>
        <当月見積もり工数>160</当月見積もり工数>
        <当月実績工数>24</当月実績工数>
      </工数管理>
      <予定項目リスト>
        <予定項目>
          <P>XMLエディターの基本仕様の作成</P>
        </予定項目>
      </予定項目リスト>
      <実施事項リスト>
        <実施事項>
          <P>XMLエディターの基本仕様の作成</P>
        </実施事項>
        <実施事項>
          <P>競合他社製品の機能調査</P>
        </実施事項>
      </実施事項リスト>
      <上長への要請事項リスト>
        <上長への要請事項>
          <P>特になし</P>
        </上長への要請事項>
      </上長への要請事項リスト>
      <問題点対策>
        <P>XMLとは何かわからない。</P>
      </問題点対策>
    </業務報告>

    <業務報告>
      <業務名>検索エンジンの開発</業務名>
      <業務コード>S8821-76</業務コード>
      <工数管理>
        <見積もり工数>120</見積もり工数>
        <実績工数>6</実績工数>
        <当月見積もり工数>32</当月見積もり工数>
        <当月実績工数>2</当月実績工数>
      </工数管理>
      <予定項目リスト>
        <予定項目>
          <P><A href="http://www.goo.ne.jp">goo</A>の機能を調べてみる</P>
        </予定項目>
      </予定項目リスト>
      <実施事項リスト>
        <実施事項>
          <P>更に、どういう検索エンジンがあるか調査する</P>
        </実施事項>
      </実施事項リスト>
      <上長への要請事項リスト>
        <上長への要請事項>
          <P>開発をするのはめんどうなので、Yahoo!を買収して下さい。</P>
        </上長への要請事項>
      </上長への要請事項リスト>
      <問題点対策>
        <P>検索エンジンで車を走らせることができない。（要調査）</P>
      </問題点対策>
    </業務報告>
  </業務報告リスト>
</週報>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/save_stream.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    // get a test document
    pugi::xml_document doc;
    doc.load("<foo bar='baz'><call>hey</call></foo>");

    //[code_save_stream
    // save document to standard output
    std::cout << "Document:\n";
    doc.save(std::cout);
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/load_stream.cpp
#include "pugixml.hpp"

#include <fstream>
#include <iomanip>
#include <iostream>

void print_doc(const char* message, const pugi::xml_document& doc, const pugi::xml_parse_result& result)
{
    std::cout
        << message
        << "\t: load result '" << result.description() << "'"
        << ", first character of root name: U+" << std::hex << std::uppercase << std::setw(4) << std::setfill('0') << pugi::as_wide(doc.first_child().name())[0]
        << ", year: " << doc.first_child().first_child().first_child().child_value()
        << std::endl;
}

bool try_imbue(std::wistream& stream, const char* name)
{
    try
    {
        stream.imbue(std::locale(name));

        return true;
    }
    catch (const std::exception&)
    {
        return false;
    }
}

int main()
{
    pugi::xml_document doc;

    {
    //[code_load_stream
        std::ifstream stream("weekly-utf-8.xml");
        pugi::xml_parse_result result = doc.load(stream);
    //]

        // first character of root name: U+9031, year: 1997
        print_doc("UTF8 file from narrow stream", doc, result);
    }

    {
        std::ifstream stream("weekly-utf-16.xml");
        pugi::xml_parse_result result = doc.load(stream);

        // first character of root name: U+9031, year: 1997
        print_doc("UTF16 file from narrow stream", doc, result);
    }

    {
        // Since wide streams are treated as UTF-16/32 ones, you can't load the UTF-8 file from a wide stream
        // directly if you have localized characters; you'll have to provide a UTF8 locale (there is no
        // standard one; you can use utf8_codecvt_facet from Boost or codecvt_utf8 from C++0x)
        std::wifstream stream("weekly-utf-8.xml");

        if (try_imbue(stream, "en_US.UTF-8")) // try Linux encoding
        {
            pugi::xml_parse_result result = doc.load(stream);

            // first character of root name: U+00E9, year: 1997
            print_doc("UTF8 file from wide stream", doc, result);
        }
        else
        {
            std::cout << "UTF-8 locale is not available\n";
        }
    }

    {
        // Since wide streams are treated as UTF-16/32 ones, you can't load the UTF-16 file from a wide stream without
        // using custom codecvt; you can use codecvt_utf16 from C++0x
    }

    {
        // Since encoding names are non-standard, you can't load the Shift-JIS (or any other non-ASCII) file
        // from a wide stream portably
        std::wifstream stream("weekly-shift_jis.xml");

        if (try_imbue(stream, ".932") || // try Microsoft encoding
            try_imbue(stream, "ja_JP.SJIS")) // try Linux encoding; run "localedef -i ja_JP -c -f SHIFT_JIS /usr/lib/locale/ja_JP.SJIS" to get it
        {
            pugi::xml_parse_result result = doc.load(stream);

            // first character of root name: U+9031, year: 1997
            print_doc("Shift-JIS file from wide stream", doc, result);
        }
        else
        {
            std::cout << "Shift-JIS locale is not available\n";
        }
    }
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/include.cpp
#include "pugixml.hpp"

#include <string.h>
#include <iostream>

//[code_include
bool load_preprocess(pugi::xml_document& doc, const char* path);

bool preprocess(pugi::xml_node node)
{
    for (pugi::xml_node child = node.first_child(); child; )
    {
        if (child.type() == pugi::node_pi && strcmp(child.name(), "include") == 0)
        {
            pugi::xml_node include = child;

            // load new preprocessed document (note: ideally this should handle relative paths)
            const char* path = include.value();

            pugi::xml_document doc;
            if (!load_preprocess(doc, path)) return false;

            // insert the comment marker above include directive
            node.insert_child_before(pugi::node_comment, include).set_value(path);

            // copy the document above the include directive (this retains the original order!)
            for (pugi::xml_node ic = doc.first_child(); ic; ic = ic.next_sibling())
            {
                node.insert_copy_before(ic, include);
            }

            // remove the include node and move to the next child
            child = child.next_sibling();

            node.remove_child(include);
        }
        else
        {
            if (!preprocess(child)) return false;

            child = child.next_sibling();
        }
    }

    return true;
}

bool load_preprocess(pugi::xml_document& doc, const char* path)
{
    pugi::xml_parse_result result = doc.load_file(path, pugi::parse_default | pugi::parse_pi); // for <?include?>
    
    return result ? preprocess(doc) : false;
}
//]

int main()
{
    pugi::xml_document doc;
    if (!load_preprocess(doc, "character.xml")) return -1;

    doc.print(std::cout);
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/traverse_iter.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    pugi::xml_document doc;
    if (!doc.load_file("xgconsole.xml")) return -1;

    pugi::xml_node tools = doc.child("Profile").child("Tools");

    //[code_traverse_iter
    for (pugi::xml_node_iterator it = tools.begin(); it != tools.end(); ++it)
    {
        std::cout << "Tool:";

        for (pugi::xml_attribute_iterator ait = it->attributes_begin(); ait != it->attributes_end(); ++ait)
        {
            std::cout << " " << ait->name() << "=" << ait->value();
        }

        std::cout << std::endl;
    }
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/traverse_walker.cpp
#include "pugixml.hpp"

#include <iostream>

const char* node_types[] =
{
    "null", "document", "element", "pcdata", "cdata", "comment", "pi", "declaration"
};

//[code_traverse_walker_impl
struct simple_walker: pugi::xml_tree_walker
{
    virtual bool for_each(pugi::xml_node& node)
    {
        for (int i = 0; i < depth(); ++i) std::cout << "  "; // indentation

        std::cout << node_types[node.type()] << ": name='" << node.name() << "', value='" << node.value() << "'\n";

        return true; // continue traversal
    }
};
//]

int main()
{
    pugi::xml_document doc;
    if (!doc.load_file("tree.xml")) return -1;

    //[code_traverse_walker_traverse
    simple_walker walker;
    doc.traverse(walker);
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/traverse_predicate.cpp
#include "pugixml.hpp"

#include <string.h>
#include <iostream>

//[code_traverse_predicate_decl
bool small_timeout(pugi::xml_node node)
{
    return node.attribute("Timeout").as_int() < 20;
}

struct allow_remote_predicate
{
    bool operator()(pugi::xml_attribute attr) const
    {
        return strcmp(attr.name(), "AllowRemote") == 0;
    }

    bool operator()(pugi::xml_node node) const
    {
        return node.attribute("AllowRemote").as_bool();
    }
};
//]

int main()
{
    pugi::xml_document doc;
    if (!doc.load_file("xgconsole.xml")) return -1;

    pugi::xml_node tools = doc.child("Profile").child("Tools");

    //[code_traverse_predicate_find
    // Find child via predicate (looks for direct children only)
    std::cout << tools.find_child(allow_remote_predicate()).attribute("Filename").value() << std::endl;

    // Find node via predicate (looks for all descendants in depth-first order)
    std::cout << doc.find_node(allow_remote_predicate()).attribute("Filename").value() << std::endl;

    // Find attribute via predicate
    std::cout << tools.last_child().find_attribute(allow_remote_predicate()).value() << std::endl;

    // We can use simple functions instead of function objects
    std::cout << tools.find_child(small_timeout).attribute("Filename").value() << std::endl;
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/weekly-utf-16.xml
 < ? x m l   v e r s i o n = " 1 . 0 " ? >  
 < ! D O C T Y P E  1X1   S Y S T E M   " w e e k l y - u t f - 1 6 . d t d " >  
 < ! - -  1X10000   - - >  
 <1X1 >  
     <^tg1 >  
         <^t^ > 1 9 9 7 < /^t^ >  
         <g^ > 1 < /g^ >  
         <1 > 1 < /1 >  
     < /^tg1 >  
  
     <lT >  
         <l >\qu0 < /l >  
         <T >Y* < /T >  
     < /lT >  
  
     <imRX1TJ000 >  
         <imRX1TJ >  
             <imRT > X M L000000nO\b < /imRT >  
             <imR000 > X 3 3 5 5 - 2 3 < /imR000 >  
             <]ep{t >  
                 <zM00]ep > 1 6 0 0 < /zM00]ep >  
                 <[~>]ep > 3 2 0 < /[~>]ep >  
                 <_SgzM00]ep > 1 6 0 < /_SgzM00]ep >  
                 <_Sg[~>]ep > 2 4 < /_Sg[~>]ep >  
             < /]ep{t >  
             <N[v000 >  
                 <N[v >  
                     < P > X M L000000nWg,Ni0nO\b < / P >  
                 < /N[v >  
             < /N[v000 >  
             <[eN000 >  
                 <[eN >  
                     < P > X M L000000nWg,Ni0nO\b < / P >  
                 < /[eN >  
                 <[eN >  
                     < P >zTNy>T0nj_g < / P >  
                 < /[eN >  
             < /[eN000 >  
             <N
w0x0nN000 >  
                 <N
w0x0nN >  
                     < P >ry0k0j0W < / P >  
                 < /N
w0x0nN >  
             < /N
w0x0nN000 >  
             <UOLp[{V >  
                 < P > X M L0h0oOU0K00K00j0D0 < / P >  
             < /UOLp[{V >  
         < /imRX1TJ >  
  
         <imRX1TJ >  
             <imRT >i}"00000nvz < /imRT >  
             <imR000 > S 8 8 2 1 - 7 6 < /imR000 >  
             <]ep{t >  
                 <zM00]ep > 1 2 0 < /zM00]ep >  
                 <[~>]ep > 6 < /[~>]ep >  
                 <_SgzM00]ep > 3 2 < /_SgzM00]ep >  
                 <_Sg[~>]ep > 2 < /_Sg[~>]ep >  
             < /]ep{t >  
             <N[v000 >  
                 <N[v >  
                     < P > < A   h r e f = " h t t p : / / w w w . g o o . n e . j p " > g o o < / A >0nj_00y0f00 < / P >  
                 < /N[v >  
             < /N[v000 >  
             <[eN000 >  
                 <[eN >  
                     < P >f0k00i0F0D0Fi}"00000L0B00Kg0Y0 < / P >  
                 < /[eN >  
             < /[eN000 >  
             <N
w0x0nN000 >  
                 <N
w0x0nN >  
                     < P >vz00Y00n0o000i0F0j0n0g0 Y a h o o !0S0W0fN0U0D0 < / P >  
                 < /N
w0x0nN >  
             < /N
w0x0nN000 >  
             <UOLp[{V >  
                 < P >i}"00000g0p00[00S0h0L0g0M0j0D0g	 < / P >  
             < /UOLp[{V >  
         < /imRX1TJ >  
     < /imRX1TJ000 >  
 < /1X1 >  
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/text.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    pugi::xml_document doc;

    // get a test document
    doc.load("<project><name>test</name><version>1.1</version><public>yes</public></project>");

    pugi::xml_node project = doc.child("project");

    //[code_text_access
    std::cout << "Project name: " << project.child("name").text().get() << std::endl;
    std::cout << "Project version: " << project.child("version").text().as_double() << std::endl;
    std::cout << "Project visibility: " << (project.child("public").text().as_bool(/* def= */ true) ? "public" : "private") << std::endl;
    std::cout << "Project description: " << project.child("description").text().get() << std::endl;
    //]

    std::cout << std::endl;

    //[code_text_modify
    // change project version
    project.child("version").text() = 1.2;

    // add description element and set the contents
    // note that we do not have to explicitly add the node_pcdata child
    project.append_child("description").text().set("a test project");
    //]

    doc.save(std::cout);
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/xpath_error.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    pugi::xml_document doc;
    if (!doc.load_file("xgconsole.xml")) return -1;

//[code_xpath_error
    // Exception is thrown for incorrect query syntax
    try
    {
        doc.select_nodes("//nodes[#true()]");
    }
    catch (const pugi::xpath_exception& e)
    {
        std::cout << "Select failed: " << e.what() << std::endl;
    }

    // Exception is thrown for incorrect query semantics
    try
    {
        doc.select_nodes("(123)/next");
    }
    catch (const pugi::xpath_exception& e)
    {
        std::cout << "Select failed: " << e.what() << std::endl;
    }

    // Exception is thrown for query with incorrect return type
    try
    {
        doc.select_nodes("123");
    }
    catch (const pugi::xpath_exception& e)
    {
        std::cout << "Select failed: " << e.what() << std::endl;
    }
//]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/traverse_rangefor.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    pugi::xml_document doc;
    if (!doc.load_file("xgconsole.xml")) return -1;

    pugi::xml_node tools = doc.child("Profile").child("Tools");

    //[code_traverse_rangefor
    for (pugi::xml_node tool: tools.children("Tool"))
    {
        std::cout << "Tool:";

        for (pugi::xml_attribute attr: tool.attributes())
        {
            std::cout << " " << attr.name() << "=" << attr.value();
        }

        for (pugi::xml_node child: tool.children())
        {
            std::cout << ", child " << child.name();
        }

        std::cout << std::endl;
    }
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/xpath_select.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    pugi::xml_document doc;
    if (!doc.load_file("xgconsole.xml")) return -1;

//[code_xpath_select
    pugi::xpath_node_set tools = doc.select_nodes("/Profile/Tools/Tool[@AllowRemote='true' and @DeriveCaptionFrom='lastparam']");

    std::cout << "Tools:\n";

    for (pugi::xpath_node_set::const_iterator it = tools.begin(); it != tools.end(); ++it)
    {
        pugi::xpath_node node = *it;
        std::cout << node.node().attribute("Filename").value() << "\n";
    }

    pugi::xpath_node build_tool = doc.select_single_node("//Tool[contains(Description, 'build system')]");

    if (build_tool)
        std::cout << "Build tool: " << build_tool.node().attribute("Filename").value() << "\n";
//]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/transitions.xml
<transition source="idle" target="run">
	<event name="key_up|key_shift" />
</transition>
<transition source="run" target="attack">
	<event name="key_ctrl" />
	<condition expr="weapon != null" />
</transition>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/load_error_handling.cpp
#include "pugixml.hpp"

#include <iostream>

void check_xml(const char* source)
{
//[code_load_error_handling
    pugi::xml_document doc;
    pugi::xml_parse_result result = doc.load(source);

    if (result)
        std::cout << "XML [" << source << "] parsed without errors, attr value: [" << doc.child("node").attribute("attr").value() << "]\n\n";
    else
    {
        std::cout << "XML [" << source << "] parsed with errors, attr value: [" << doc.child("node").attribute("attr").value() << "]\n";
        std::cout << "Error description: " << result.description() << "\n";
        std::cout << "Error offset: " << result.offset << " (error at [..." << (source + result.offset) << "]\n\n";
    }
//]
}

int main()
{
    check_xml("<node attr='value'><child>text</child></node>");
    check_xml("<node attr='value'><child>text</chil></node>");
    check_xml("<node attr='value'><child>text</child>");
    check_xml("<node attr='value\"><child>text</child></node>");
    check_xml("<node attr='value'><#tag /></node>");
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/weekly-shift_jis.xml
<?xml version="1.0" encoding="Shift_JIS"?>
<!DOCTYPE T SYSTEM "weekly-shift_jis.dtd">
<!-- TTv -->
<T>
  <NT>
    <Nx>1997</Nx>
    <x>1</x>
    <T>1</T>
  </NT>

  <>
    <>Rc</>
    <>Y</>
  </>

  <Ɩ񍐃Xg>
    <Ɩ>
      <Ɩ>XMLGfB^[̍쐬</Ɩ>
      <ƖR[h>X3355-23</ƖR[h>
      <HǗ>
        <ςH>1600</ςH>
        <эH>320</эH>
        <ςH>160</ςH>
        <эH>24</эH>
      </HǗ>
      <\荀ڃXg>
        <\荀>
          <P>XMLGfB^[̊{dl̍쐬</P>
        </\荀>
      </\荀ڃXg>
      <{Xg>
        <{>
          <P>XMLGfB^[̊{dl̍쐬</P>
        </{>
        <{>
          <P>Аi̋@\</P>
        </{>
      </{Xg>
      <㒷ւ̗vXg>
        <㒷ւ̗v>
          <P>ɂȂ</P>
        </㒷ւ̗v>
      </㒷ւ̗vXg>
      <_΍>
        <P>XMLƂ͉킩ȂB</P>
      </_΍>
    </Ɩ>

    <Ɩ>
      <Ɩ>GW̊J</Ɩ>
      <ƖR[h>S8821-76</ƖR[h>
      <HǗ>
        <ςH>120</ςH>
        <эH>6</эH>
        <ςH>32</ςH>
        <эH>2</эH>
      </HǗ>
      <\荀ڃXg>
        <\荀>
          <P><A href="http://www.goo.ne.jp">goo</A>̋@\𒲂ׂĂ݂</P>
        </\荀>
      </\荀ڃXg>
      <{Xg>
        <{>
          <P>XɁAǂGW邩</P>
        </{>
      </{Xg>
      <㒷ւ̗vXg>
        <㒷ւ̗v>
          <P>Ĵ͂߂ǂȂ̂ŁAYahoo!𔃎ĉB</P>
        </㒷ւ̗v>
      </㒷ւ̗vXg>
      <_΍>
        <P>GWŎԂ𑖂点邱ƂłȂBivj</P>
      </_΍>
    </Ɩ>
  </Ɩ񍐃Xg>
</T>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/load_options.cpp
#include "pugixml.hpp"

#include <iostream>

int main()
{
    pugi::xml_document doc;

//[code_load_options
    const char* source = "<!--comment--><node>&lt;</node>";

    // Parsing with default options; note that comment node is not added to the tree, and entity reference &lt; is expanded
    doc.load(source);
    std::cout << "First node value: [" << doc.first_child().value() << "], node child value: [" << doc.child_value("node") << "]\n";

    // Parsing with additional parse_comments option; comment node is now added to the tree
    doc.load(source, pugi::parse_default | pugi::parse_comments);
    std::cout << "First node value: [" << doc.first_child().value() << "], node child value: [" << doc.child_value("node") << "]\n";

    // Parsing with additional parse_comments option and without the (default) parse_escapes option; &lt; is not expanded
    doc.load(source, (pugi::parse_default | pugi::parse_comments) & ~pugi::parse_escapes);
    std::cout << "First node value: [" << doc.first_child().value() << "], node child value: [" << doc.child_value("node") << "]\n";

    // Parsing with minimal option mask; comment node is not added to the tree, and &lt; is not expanded
    doc.load(source, pugi::parse_minimal);
    std::cout << "First node value: [" << doc.first_child().value() << "], node child value: [" << doc.child_value("node") << "]\n";
//]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/custom_memory_management.cpp
#include "pugixml.hpp"

#include <new>

//[code_custom_memory_management_decl
void* custom_allocate(size_t size)
{
    return new (std::nothrow) char[size];
}

void custom_deallocate(void* ptr)
{
    delete[] static_cast<char*>(ptr);
}
//]

int main()
{
//[code_custom_memory_management_call
    pugi::set_memory_management_functions(custom_allocate, custom_deallocate);
//]

    pugi::xml_document doc;
    doc.load("<node/>");
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/xgconsole.xml
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<Profile FormatVersion="1">
    <Tools>
        <Tool Filename="jam" AllowIntercept="true">
        	<Description>Jamplus build system</Description>
        </Tool>
        <Tool Filename="mayabatch.exe" AllowRemote="true" OutputFileMasks="*.dae" DeriveCaptionFrom="lastparam" Timeout="40" />
        <Tool Filename="meshbuilder_*.exe" AllowRemote="false" OutputFileMasks="*.mesh" DeriveCaptionFrom="lastparam" Timeout="10" />
        <Tool Filename="texbuilder_*.exe" AllowRemote="true" OutputFileMasks="*.tex" DeriveCaptionFrom="lastparam" />
        <Tool Filename="shaderbuilder_*.exe" AllowRemote="true" DeriveCaptionFrom="lastparam" />
    </Tools>
</Profile>
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/samples/modify_base.cpp
#include "pugixml.hpp"

#include <string.h>
#include <iostream>

int main()
{
    pugi::xml_document doc;
    if (!doc.load("<node id='123'>text</node><!-- comment -->", pugi::parse_default | pugi::parse_comments)) return -1;

    //[code_modify_base_node
    pugi::xml_node node = doc.child("node");

    // change node name
    std::cout << node.set_name("notnode");
    std::cout << ", new node name: " << node.name() << std::endl;

    // change comment text
    std::cout << doc.last_child().set_value("useless comment");
    std::cout << ", new comment text: " << doc.last_child().value() << std::endl;

    // we can't change value of the element or name of the comment
    std::cout << node.set_value("1") << ", " << doc.last_child().set_name("2") << std::endl;
    //]

    //[code_modify_base_attr
    pugi::xml_attribute attr = node.attribute("id");

    // change attribute name/value
    std::cout << attr.set_name("key") << ", " << attr.set_value("345");
    std::cout << ", new attribute: " << attr.name() << "=" << attr.value() << std::endl;

    // we can use numbers or booleans
    attr.set_value(1.234);
    std::cout << "new attribute value: " << attr.value() << std::endl;

    // we can also use assignment operators for more concise code
    attr = true;
    std::cout << "final attribute value: " << attr.value() << std::endl;
    //]
}

// vim:et
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images
**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/dom_tree_thumb.png
PNG

   IHDR        f   PLTEd_cz~U  IDATx^O8 p	<\a/u#:D0+NBTSIu EAg?c+/(SൟbH	Y4e÷)~`W6*ȭe4(ʢ BQ',.@_C8Yϝ(W*"yJ@`Xĉ$
˸*-d<uҳ*Űa0}987<1hPft|3#Mz22l_]X^!z23UX \a,htk3V>]h2Ɗ.(_8.W̩`t]x͝eCnR\,TxcPa[K`X2PHB((8E	q8uO+K8!
xS(ۂO0.J^(Y%pf2e1TwDh)ük Dq/W΄rFS.c@2,w6+E01g/2d<P;Y^ubI<(8i(T	fuC^O%l\c$orFuQG(Le1,!hd;DS4l~16ZOg,hOUgL"1:&bfبFi3R?
GbLP)I5I/ 27KFߌfU_c.f}G0UP$ :n{X1!6q7	i<?Q,I%tgqGwu)n:!Q]1\4YݹN|s(r!^&*Mx
g._3L6akQUOc\~cJx(akePwQԡՙOUHnkMvb;ud;Xð	
HXI(!a{2	05|t$,>5}7(Un:SfPUUzN괇M6ѡ6!(ݎt__FeYvd*qe/]$}2>B20.Ex
F%Umj y
ƥ*]X.C<Wy-!HOw1\4.>l#R1n-7:&ԲG3zU4fwyv)#ԻȌ]e3-
Eo'0n1BIQ\L1ZM}KV3fKCAjBN2lD& Pzr94#|EsdiLI_[W2M'l+.n035tG0~dP }=e>?"þRXb;sF~ @٧ _|Ę1`uk-bzo3c(0GpŪKF+l%yR4R=0]2~Fa`c0öMzp*4eQrgJx^}k]h8VHe]ĠK!=H7XZd6qaLAKp1KF2aS³\D{a:FjYW+AЫ9D[ꁉVQè[Fӌzi)ͨ*[/.:b j !Edhh).X[eG7!HF&/leL誶3":W>!=Xs[ϐ47e.oʭe6{tYƯ(µ8͔x!9/%Z3ShJYZFb$ iΔQ6M-fW-#MtYg9%eU\)CQHUyŠ4ظ0Oև}/ZtkU׌l֯6ve$4fNP׃Y18[BmM`|{~L׍B0y(MQ_$3wưu"7	JB$ Ƙ0Äy<8a=PHp7vԍ^ ׏Y>/'uP괶1L~0d~!'}n̹mu100ޟ)SÐ6EݼC!d9dFv@uݠ\GnB&es|MWw?0}O]Tub>ڸl|[u	DE+Dwcq2S2>TFmHFEᢙ5gq1fi#{*#F,,h)ʢh%C>8o80W3h?*Om--2Lv*'dJ}b	J(=wFl	&MءɈ(867Dt:zƸL3zuIP︡@>׻xzt*&#q1wGX>y!H$ƌ`UfW0l	%lc'5IL+ӌFu#R70:IW1DaïS̎YU3	R/tvXL'l+Fi>bxX	uª>v+/hlt̔%5//hs3z1тfYΘc[O>(8HQ472?T1ƌʉP[U3dxYJ}*hTyO	!U'Ę1^9-RcF${sknK<q|5xrF9bЍr6StG0nM۩3)S"ECC(EWL-aJq1?7|Yv%J#lUsQhE2B佮ƘsG(s]|(/ﻯWAGrQO ,]GsQ`d^(	uv%XGt8t4 LaEu4sd.Dcnm_4[N}_1A<(w    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/note.png
PNG

   IHDR         ש   <PLTEJJJ{{{ssskkkRRRcccZZZN   IDATx^]ir Qg$1޾ᙟabL>344eAPV!Y*h'mfqg cãLmN\s^f6R- "oefM͘º=z!7F\slH~+<61?h0?*0L'@]qThW< sKN<fn.7 L󈺖U*sbz    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2010_link1_thumb.png
PNG

   IHDR         4   0PLTEK00a)?_0DdYJhjvvko  pIDATx^ϊA W=$G)z*.zO[Ͳx?gG=Ϣ'O ("kUQ'TjfGwv?HڝəVN)dΙ(Q
nZgIu$,+wW``:$cG0i#'#K1hk%&&5fɆþN֚
(d2ŎLza}Wn
5Mh؇fEOK4CZnK癢0ME XxR@ɵ.X6 Ptc	 9a8NJ.R\<uNd!_Kq),yJV`hi g1<
NZ|j6טj{<)K*WP4!Oo#8L!T{_Oj}N"*DfdYQlF9J  P߻g
>W{!6<6"*FxH~2{} "mf~Xg+?-md  {}8,{ajNK(qǀ5K@B Nv! aإ״$!lIHhA {4?eV7uAUh%|i+ހjhBh\x;CngЄ|%|yO$=Ep%LKŚ̙`(F%́/Yk?G$ˈJr<SJ,S{   E> nݴFq DjQĞ<YRV*H/bV@MwShԫ-cG6tLh+=G<oQ$1&|~Z=PFQU&,.ׇG5]{¸Nn.F $?4^߭vFUBvv_{]'չ7~]yCD	306ÙjƜ4QB]T_'(Z	&TZXR)tB):,H' Γ
imS
M.PBij͍^Ҫ2 N26(2L ;	FBzdWb:ONB^r1!S1
.${	KPy@H]?HS@wB*164g0qک4}쥳:gNk&c\2Z{k缶yu8}) F` 0YD02	K1Ф\N/rV
>$3^+ڥ|KeyPNhK*	ƗicFa0EXY$v&_oN)TçPGй[8 ӂ
t<ȸeud2jR!Zh.ڂwD*P)Q/E p!c݅;GR>'X0X%z>?L5?ȿ~WO(0 EArܭ"ࡷ02&FtNC>o	4dٽJREp		RA6Z 7CEE^S .%# NF_C C3    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/up.png
PNG

   IHDR         ~+   *PLTEfffC@>QOM&# `^\'   tRNS @f   dIDATx^̡0\1CaNǐT1!8$ۅԟOiGw!VH@Hv;3pRXFjMqJlr^9TG;Fz    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/home.png
PNG

   IHDR         ~+   $PLTEC@>`^\&# ҶQOMfff0   tRNS @f   cIDATx^}ȡ@@Ff EWM>/;Ig>|PXPXQXP9Rk0˥ť,${ֽ-IB1SS    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_pch2.png
PNG

   IHDR       Li#   PLTE   /  9"  $ =9  ' E1 2c& ]< ;2 YU:ce  V 2J
	8
a 6M$g :x b bOHH!7 WQ%%J(X()7&'Z :; 8d 6R)#42///c5[G2  ?55`Bd96;;j Q_?@[+ c6a.%r<BELh<<8 b7CCsYY V892!6'8f gWPRo dI RS~SVd.cYZzI=^Zu]Zbc9Y ^`ppBcse M8*r|t`wͩZSfjoCg<0gS2;k^{pi1ݗS|aF7ˇ5UƆd׈t<܏8ǛM]ycgڛWٗ`@Ѡj੩wy3^spǸܘؽ{ͅϩb̾pÝө̣ٕܗφ۸ٿ؛ؽ܍֫붧߹-npmOQNz{y  D  XŮ  Q Lѓ_`njrs{ѭzdbnn  c E X _ q}}JLw  ?  6IDATx^Er1й$32|ư,r<N,8.M m-v.Bp<#D2OV}_U|DYX :'%ip9ZZNp!%f*ւxCORP5	 :~=(e^T6ƛN):VA0$%/:fءť4` XjiC(B`iJz?`Fuei(![~6BHxOdJP]r@d(V"	'x--Ƣ4vIO01y)J	Kk-h۴Nr쟷i !e^2=T
<Y2zyȐDiM-
LŔ~dypq5[$<'uɰ_B`>{]TQ	WGW̱n(AN{uy0<	
G6$9
bQE^No4 X+XNd`H\p6Px%/tTDY"' <	zg@A~[<+-P񧯭jo&֕vMsE #/6b(<a0=[?&-H;ϔ 2 ө	h?&vLEaȁ6D=lQn:y
ao!k`=غ1\HR~N9&pR𗘾u:h~R~*LvI`):>1SFNSvE	h u@:!K@HoY2)@UVyPa	<	|[@ѻWJ b:1&R#d3WAk>qTa 1),AZ1
P"P"CeK)bC4e<(؋-bw&qkwLft#b~|ff)9uݝno	|o;G!AdƼF0!Āt3Ӈ"DD!j=IpT%(RUdpotZfW]<,ޞ {qUέ]V@69R&'I@ tXYg	 fxldPXV_hP,[S!}ȁW $hB((p $P
`;
\{+
$BFh$
e@d7U<bO"\N)p%s	@ ֋h( 'vu_w
AJЗi-i$гN=*O

W4@XT u  %GH`]9SKkixC*`Nb@P7,+,AQ	Lcy$(rNRFFϾm1`Z Lg (&;O@" '6w[,-LOOfI|r
lxi׈R]h	6M3/U4 ?RT`rD9[N98pG̺!DT~-3ڭRTC`\"R 
KPQ)0`9 =Tݾ(#2 *@4 D>][l-2 ; G5@bY$IBY.I7nHGv  >qP
t8P ((DU Tp0I ?3
x9q}8W}oq*j8#߯C	mC_c-xq3 
C
H55mHi@]-Gu $PB2 k@g2@Xӹ
+=Dű{2aq?( hI/
l*M\&˫d#JWJ/k܁sAا5*\D
~oj =iPP]\rYH0!* ֖<

$(:7$@K3ZOQerĵjܬ! ZO^ZmnnJVХ/m澀Z R@CӦn nZNQ𬑅UbFlgi'ݐe/m鲀@) A2ہo.#Q '@39R.=NDf
X0
C)`f +m\b$"櫮0W@.gc5ڍH @F]"} l1` -GsRV@)@ʸ`IpTP9걋gOF sfa
JY
x.Te_8R]:%&`@
a/" _DBO( @hL#+oi<
E^%q҉G#
?oXڝ-@L0X|>=\ 8e0Iıt做|Zjh~(-lAd=DSXq`d6 z8Dڠ,p9$H\	=H02V#D6Ƕ.f+9
p4	j>	A>fwPw` of2TwǑ3#' E9}%Hd2Ds&+QvxAPхĭKѕ:\FCqhQ'pnoWNW*77ʈ>:$!6uU1p!0hV ^%	!Cq8(x@@ʀb=.ƣ "#G"gdaR
}H`G^|Q@K 
Ư 2Bd;Kf?y%lmEMeQ
\(8[i9 +rH(S}aiP^C BEv_XGE Fd72^@NQ"܇lCWR0w@X̢r@,_R1AI
kuر RKJhWwR8	ď1w+?r8,C `s鋞WA9x$)P' -,Z@ ;	 pXٵca },,ɹۍYv;tkFE\L8#6͜¹U9@1E `<8`: # jOVA .
4gލ  [b6Qdw:ܥkkl^}0- 
( 
7
 ( 
 (O& @@u
..)6O@KK!3i.vxB*<'У f5|g1
07z WPB=`˃.D)ե;8"/G|(a3ä!}JJH-E@cuI{  Cw/	Ȏ  1&`FBO:gm8w
Prt;ZA
5rKnQ\#hAp:(GᨐR7vA<I:8up5ip?x{JroFχlJkIlj0+;؆1SI2}Pƹ[Q% OsYkY鐌Y6
K%5Z6%9JBcR3},-
qy	rA}]U?ĠyP0_3B	 Ƣ%XD%{Jw ݾfnjrw5h$gTEU$(Tկwxvښ$$PLA.2gT	{0SM)RǍ*3&SX×33?$5n3v !L>ޮc#qAc|cB介^D0p	PcGR:Mudhx "2`/!<Ơ<m(Ei	@BC8T}'B	\%z{>pqlg))ß3O.X*piMT%V1/]		lLR[G[hMO9-L_gʜ?wipg#])QWc})z&:/ǧym2]F <DhBB@oF7$hCeK@ܚԘ=QwUygNFlŀ"X⦲q	xX!d6W,[X(rMxG!V~\Lca܅;C^fgKvBVZp<L9ЦRje+PBW{Uv%rC{Z7BImDoatj.ũi8QQ~wɫwۻP\k4J#D"wuQ
\Ezɷ| =u93onފ
`_,-7+S ^@h<ȯN6?  e`m-hO#`j*@Avi.A &_6]$4"53QdY'{DQbn E<6n@A OfL@ Ę<Svs+-ٙstwqִ~IjoG
P8(DV)˖iǌ#V0/F_삎7at]j)w/ _jnCbpKVAVW8.,gs9߁0{nR2	==pCf*PJSDAꑼW^]<p Gdx 	?PJ)Oz1p`'F$	9~jL3!M!@ĐxYFg*P}
*	
nNDBt:"]UN-Zp/mqp)m,IɅBu Ș;{ !sӡH_fA@#5~4q4D@Q-tl Z%ED>_1UCG`^0HT7'6L@E+KnZB>j7vk P-V`3ɓMp@҄R
am÷Ó/U2,0]VQJ #qDtSRA#T;GG?;W`s` >Zڗ4
YHB2U8Aqctq}0,2l]	 	 h/E J`{˄*.	J@@{]&&c  ҝ^+oۭ&N՗NƉ oYZ_VTһKoɝ9.\&{'EOm%
 <w⃾rM@ 83\U^7-%R5  9*gwěr@aCG
BF eU 0gg܄٥ؕ+p.np5H	/`,Ngg5iHEx׭u>L#}ms~+pw.N<a-	{ZXxp6-,N?`qJY,$	^Ax3?|r31dcdǽ}vgyb'aKt:H2 *ZAf<66Fh_0Y"PZ[uP瀉U{VV9+@V,4`b#h	a  ly ˎ(;8b2;v "^aRSc	Í@6X梁OzA`0Q94 Ohy3&LCvՁA!bbIvv{:vcRqi=lv++XedwxS~D{KH6pA{@?8Er+W7/Y?+
re|G
k p[{jh;պY60}~#P>_Tu쐽o-Pb0)dRUMhF0sίA`[G۶l]"fL`F{JB#G2gּEJS; O۽~L->BDw@b5J f.t'ҽ<,ֆ	wF(iBNdjo@o8;t~<" |A:8ߡk5QjE;7tKNG9
Ux)s2BvL  wƞꃞM >@w\g 0 z!^ -2  '= 7mH!pp0
_윽jA;E@ETpg0TIF)ِjչ0-Ur&t%`DS;	[{ڳ]0pWOg.Pݫs8~KP\((rqY0.H7Kw)?4E ?6* FaU|bOLRͭ(b m^?FuɊ#{_E^P8#P[E@]rdRdqx61h~Н!<=R`#0
!!Hd!xEÜAj2f؆ 	@j"<)[Avոc;q&a_peP(6`Ή{L^"IU/\BaX08fOx4:yBbg/[ ZYj" Լzc; 0[^l@]`Љ#6@̛"T7^" Qi __y@@]>KN&˜`pFLA:H~x49Njl D $'TuuW>.R Ⱥ'4xt3 !IKAP&IVK/".(GblB0?PDAEEA*X(⡭%e{ ^*<HbE
wUR-ٙ1ˎKMogBkLV"U@#C`?GHh,E֘qRK@=*P^ZEʍ]5d4EtR")*PuWSF@#Px3,膀gL@a!5IkqœX@Lp5@#0i7]f f[l߰^z<7ʀ(FOWNxXBXm#pp<;AR\E1NjHǧ6$)z@ yhPȆ w:fF@-qR#pya#`&^{EdSw@F>o$rOKkPb&@ Wg
M &F/iLhBF.uo%=.چ㰼&!hRv:()wBxƯB̌.͕qR#0K'Ug4& 8ymtQR#Y)Vj蜍0eQ!$NY(9AB3T˨5k,UT*%cK! }"F,3Ta~Н'5УTx'''~:q.9'$nRB scۏӕh8z] |DtnADQ>ыSKvEK#+_E#3̫d2耦afy0̇Ă;t	$FĄAj@:.KH,J2!1tb*ikA.5,t _*!LOω'T p
V
y	wb@O?:rљ.3@r+gNxd@, WP4S@8ABZNp(OЊ"C3n dnX	O/Y\ϯ xm4W x)&B h\)A)@cn ID#(0h*`r~[܅8 q1ʦ^pS 3Q0x0ILSϏ1)6}^p
4(`p~EUPXF	ƚ\jNFT&0X
P楍2jCHk (AT r^^/pSfx[e䨅J7U%8	a, yS	!
(?JZNBx[!
ЛJ2NBٟj롃R+)A@u[T\ $ \&0\
 L( 0@=K	 zL PiO"o
fm  {la&{6H
QxtzXv8)taa(01$H
:"
KIAEQ$kSXlIHRv-D6dDt4
fg=rITe};hOq%K`Apv_%o {θz	 vڵHSp $pesCGdGRf+  պRcߓEб5'pLD8JPOq3 j$ H`e{o~/t"	(m ٫  Wu:ҩ'"	2(JC^ 	x/ rZGAEnֱT~(@+8\	 . @nI p$ Ki \ 	 . @~g% {wRH pw'ˋd_YnlEk B贷cwN{osw{qZSŊX \@)zRت=x㤸z䠋6i \8'^wgTuK	 .$`k:1h`=qi`.e :6WXSalKYl3B$.j   &@v  ~lѦKPI p͡<X xRS] pAr;% @haVb\Yj-6{;-?Vw	 .^c<̽eje9K@Z?K5G"ErpaIK Hi_@Sc _ <L![tEN*	D5I^ _Ü"B6pXC1!  @7\    pnZ \@ဎJ p$  @/Rŗ Tdm ySU(M.	 .O*EiH HIJ-JQu \ NiSD*Be "gWoZ. /ђVK lo_NGǐj   p \ . E7"k/ /=w^- W% {Y0Yod%ITs}zLQH*I3ߙ+%*NA+6Ƕy*Kf%M-dQXY%id~. @@iOhdS&r$i-% $0{	hRU*Tf~FV˅ӛ"aZ}|1؃mDP4RI 7Eli4aw/,Hi騑 I$Z.j   p \  XXBc- ƁU2.a$*JLC Ї_Q/I> FИe ://X{|h, osyh!6ӦK H@,7	Cւbj-&	( E(&Y
	 ~:m#@!5K M Hf . @^   .M   p {#ϓ~2kǔvIKH 23l 41ܵJ5]P@IO$-Nzُ}Y1WWSMY^@ǥ}1'"S*,nJS%4~,#ӴX4P% BR;
S@,l6^1V>Sj* 5bA;nō´U~F	X3% /vˠS%CyהK beBTb^8H E_1ف /  p \   	kp3ZeptXdivTKX0`EÍ|k\fyfFb`ن1($JiV$ @נP}=5|zL$ 5KQ)][&lo={(c[{m$grn7,+Éf+   :
   . t p Bo1j+`	 .p9t/( PNJ pmwo/O!UI p% 
|g8l6n5Ƣe IC,ftS,kԘ%R	HN͒ PyzPI&@o*=|M1;NT%^@g6E9Z A:& $E\֊CqHN8F# @*$  	2! H $		@ LH $  	dB  H  	@ H $ Ȅ@ @&$  	2! H $		@ LH $  	dB  H  	@ H $ Ȅ@ @&$  	2!pH $  	C@  h@UfHN 	<19$phjM 7 H(<$04H $  s8_8 `Q`3yӢ΢@P(62_N$&/@Y @- ~كQEq	X $lt%@HiofZ-)nx9W,ӊ?@EP"|ݜvư2swf9Sߛ{wg&ܿk_z0TL0&CaL 0dLxyz윛,r߁|f)sCt^&Rtg,+	`dp	*&C#h,;'@V~:cWp`Sz|~\4HFV- ytƔחb\[Y	0f'S_$	EH>0/\[
HJS+j9 (ʵ} O [p6t %pS8ae 4?MC:O~νb.OmB␞[!``
1a*ɷ\[hi?]Cd&Cd2L&Cd2)!LO#`2)tn0K8첖3[؁3Ftd^A"p賞"P<o
Lî#pb+Y]Agz||^#P_ŋ#pb+>G`sXA}E`i|2pU:?wl%cz&@%Gu8"ɓ񘷤XKk^)#D /t
$B o B;!pTr}ѯL]!XBqO͞=IPpjSCJ$EdI}Rԥ4hi@K.O;f@s%nr:i󀡧|9}2M)͍&%=j=>
F_j* Z0E m@
Ħ6:45h[JS98`!q*+>55ܐI:45,_K5o!@,t)%^`h7@}E	/(Fէ6CpjSCJEdCS%CVm5 @9Lj.3
$Fh;+P.spGLk8DA =
AvnQ\awPk%ԲQ}dLErH`$H]1Uf@2 hhB&V	l/!@)rHhg!@:rH@H w;H $  	Ą@ @LH $  	|	اc"(¼m`&hoB-6P(hDmpf3.& zsb }zA (
 x	VI2)Bn׽&` X ,  t^5k0m,v똥a BG83t*d5Q"SNG({!7$tAJP:9tгA];=~pF慿VbY2/A`_y/Wf)^VsDin^uHw, F p  Y]<)͞++CK	5|w+q=I @{[mO%4}% nƇ%@@8>&pʺ#0a	 Џ_7m^&	&rYoy?}bߌYۆ8@~d`P\hEhn*GCVLt(=j[`ǕDM@t?s0-LQ^k8`
tzO\~mtV)+_4li( pfh!jp<qpPo[~M򶰦4&!VbM7'V8oO,}:,D.D/
@+ `FsF!* [nxwZu3) u% UgQ@7ڜ2@)ʯ 
 &!D
x/n6ļSuB?
@CixmJZLE T2?k
|+
_ʐ$^@P^<L*02W}nus5&vk'^^gv  ¨GӀ4	(6`:l@?sN7+ $RȃD$	@  H $ /to ahxK,@UX(= Y18}	 (OA%1M-i~PQ6$4}͚~lpdZLL,MhdnC_N1KH-XeL3S/
OD9u~x/I`pL 2)cE8&@X		 0 7AV?Fe'˅w2aзJ=#PoM ({7pM`6`! D࿀.ԷIe{Lݹ)=o5./(/ mi6    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_pch1.png
PNG

   IHDR       Li#   sRGB    PLTE    5!@!  U%  f: 3?> 5E6 bd   b 8+ a d#!8'&=)*(V)*2,*@2h 4M*30E]+ /3;757A98L CE>>@@@S62I:>w:DBP'la=:8 3IcFHGe98:#P}LMKTP>]cRQbDTqVQ[A/4=A)@e@d^0qRQL[ AAx*Ud}ha`p_+V{5eFljech[ Bo>i8m[aVjjYR'fnopqooqvfglchF~#hJp|l~{}{Ybvh;oAk_sdnfN:zfg˅3eS 8 Bj܏8ߊ|t=|Θc/֢ۈCb^vnݏ˱գuޠԫ_ⵓͩ޾79Ƿeuӳ乷زˣpƲҊي͋^φѽӬܝސo7   	pHYs        tIME	,(KF    IDATx|Tյ?SRznmJy %h:RzonCM^!E45F
IbhJ$&4)cs!L#ͼ}͟d&?{Ag3gάYkږkkF
12&G-K_JH"b@Ҫ}+ͼxiV4V
*YH8KJRwhkI?7]*A]1|Mk%n3ZK= 0rk͛C6F2JI70ʔ e Sg~JO]URʼX͉6oƗ::PƔTHj! ~_~K T80@@yWf+S|n @k֊#/lsفb1h"X HAA_S|-Vd`~Tk @D7A`kq⚄1@37+Tȯ{#Ia@7"#dZ*Wx@`d͍a TTTT+٬t3߫t G+&_%D`ː {JJKJd))S	A Rs"be3#2U嫒|
CẄ́cA˃̝"D*4"#HʒJK$~J}r[]#e		#/@oeR_R84߳Ï&0;?&-Ch䕈J*+.*]GRR\+T	Mh9}U(j#t.T;@	2lFZkCDa"*p#/j`+7Ɩ !ZNk%N -#vk+'Eo*va5Ј~ 7恁{zJs7DeYY,N~o#tqMjn3nQPe&|@ƾ%ө%;%yFGlbAÂeIKv'9yk"&.z?o<> ]C@WJqc1<_pT'`\k뉔̩oRϟO嗰)*wQT8=ƶa5 ϼz?{ 0Dj_5`-S_c+8x/ҥ$.)lǎΰq/,̡<|NP %˲Q*;0l1	[@ - ; ;fVP:R1`	wPxGhdT[.럳"`ɩxwoϏ/! oK^CB6;v'HM?޼yWz@Mm"fe_<!@|M3I%СF;<֭O<̾^O@᜜y4h,ZdXZtge*G+#j.rGbSoZ^Է-9֟}IˈHr%_փX,	?G݇s
dǣp-XBIXnn2.O,f^g^v]πrxp&_7;b@& !N#Yh@&ܬv!Jy/BJ@y#ݙj,O?<b@ߍSh
X h=#JӰvA!@Oނ%DwS`vߗ8
<c`OHH`	XQ^Jo2 %ˮj
,̖{]ys
Q> Vc^Aph `+eqqH][
_x1@xZh*(SUBwF3U (@Ʃo=@xh@B*eel(z?=Ԑ<fF	yǣ#<z/x/QFGmg>6!pZpdmٵ?PCP=Joϼ
>n pæ"	y
:3O<B%[EKd3,rA#wɾ7ZsKV[#cǣ7#	2KE]+!ڵXG`.Èp	X@K9yU	]HW:RþDjGޜ􂶼֫x	9~~ģ#;!Ck;	Y BKZRF _|nm@bPg/``o_/A灘 c]tk>u  !.(2y,` #4:Bp8|gt^ڞ:gz>ϩ	>5=͸뮇v~gx"<FC ṅj;s([>E gT@I /K@Kv'Yr;vk`|;%SGxhb|Lغ,dkCw$
ek	˒C8c0=.^ɷFEB,9ĬqK5۪^0@20{>SPg^ό|>5~ZY	w? Bx%}.APCCeiMd$O|([[ )dBW	i=eMߦz2aoUe}8,߆`sEuu}5'TH4J̀%,@{U_Q<GOG뭬`?	iQ!`OGlИ|oz;;\T:l@j*gF)ȣɂ` 4(~EB^@*nzgV{-`0 @  CO6=o-y*ۆ'1{h^H,VfsKhOFD`G!m!mF@Ǩ6Ѝ߱1Lm| 	P/15)4a554``ߠPQB G`khA9QF.e>e>(ʘ`_j?ĭ|HcQeF)ˀVdhT(I=z>@!0%ʯMb8ZV~My70${B+POZm0F@
iual}}u0RPK{f(W1KdRRVfo]Χ(Zo U[nrUy|l)*odQ
_ToŒlJz«׃־ɨ˜ZBNntDtǵ\FLޱU  gvZB`&,3J@@  z5g,˺^;;5c'5ȻAE#VG`	Jg 'BǾfXu650u³cj";ۆ_H ;C 0X?5y}gWA[0eG+Pt6h-2#<+PAa`*?TPp	=ǧ]ckw׬#B ^DˈMm?ZoaժU׌"v @[M#>"e8+cvtzl gCyvKI]tO.-OǮ
5>ޡٱuQ9q9xrmd<?0#@lY3@ڷ$H-:u]
{0y;Bg@1_O隱
3P#{oI0El҄OYb${7b쑃V`ƍIxm[]a|w@<x7?:jlO]=i"zF~k3qW)4P4OMYd|D	lE7@ŷ'w#@d"X#NO"l@ 0CX]^Q=Y}On㴏L\}d;{@); zGp_2)wd6Kf"pOLulHznPںGh>>!jHM
! wf@c@F|!;Bt֙pZʃ@ raG4pE5ﳘQ?ߖ5^*080NN1}@	Q7y@wdHeW2nG#woa7C5Ԗ2!J0
"\MT l4'&6T#>7[E79M.|@ {n@@ B ?@@ \BSf !q#$7L#J3M\ȰI(Պ?lh*"IM}v
)1ۇC+ ^6dgg^Z 	Wέp<rCU @|lWU^yQeյUvZv5tݮ?$ʟ'=BbaC{p	8'v c^/}vܹYBrQq#ϙ!VmG߯_\KdەmmݟVՏtdTk>r t˥*Hae
xn͈.-/Э)<zP9eWZ)P9\sjQIR5\Qޥ+Ό%:zZmy<0B{[ywJ3jxasU ex\ո	t8|!қgV?D@Bʒ.h!C`4J:l%|KbDչ(ݥҰ ?l߮R/rwO3H{B۠Sp,(gxl64BtyJij;R\\!<X@<1~ PnCVtaT3@/*M@WARG	|v;ler0 PezYY)<E4B/wmPc7tfn+w a 2n+V6M	0wëZ{x:DT>I6[mGQkϪv
(9zқV<pLFxiavRA~R(O,̙j2"<[e:	? I[1svh PCD Fڀ h\Oy_Dxo :BQt4vt;Lpht8>nU#c<Lfmևi?({(`U" @X}鋘brH@ h:yXxJ.ʎ"sGtSh)j<~񦓗;<-Z!v W:6As@	p;Ruy]-*j̞4i`68);ȇBg2QZrV-/pvz].k+[n) u\Vf%M;C/-H!'!"ǲQ ! bQtYrA_v箪39w2涇Xt#/Nio1oW5._#~Ϡ p|*55\	x L3@tQvqvv{*rn//<6\kakj6wz}^_N2N4Zdm!wTZA
UF+a@;?OZ5ѓk   jEeR<#EM{O2q>>ܲj< h1_g?IV]\xlz<G
[nT<H@y/|ŤQέer-zj7(wx}@ey68 ܺp טIy%Nׂ'@s~e=rkov\И4*ݴr垖{=}FH,mp#@n
5uJSxqNv)x;8rm1AQ^kv>/fEۨנVUs	hZ:T&%tHcM_m&\Ä@ԗ/=7?74*kgee@+Pvb^TkP# JNZas{r_oHEA캺ōu{g>gwmT Ԃ "
n3(Chd#y\vS T{DGh>i|_'px8/j:<230 IY_ܡP}"UA`;=sp{v1FB1&haG RJR" ڿaqMY^8`_j}ycy/jm97r,AZ+^: "KL Rӗ"H>^hG-ւVBںݻ8'<O.X0G vyl*e玡(͆ųS#0$ԖEp6^>@}߫uOAC@ "`%J%B&F9BOh@('hJRTlٲ;H7n̘1\SVDD.pu,MkFyhqr'Gl6ŷҐ|_?!.sf&3*Kc( ,A7lCF8xbт@M@#dnj#NGq
T1=r8o~[[d+¶L7uBĪp!J)DHlJ@{dݨ10.G\;X{w/D69M." Eh'@.5lr@!qRF@^	@B E<ˌ,tIGGx\ pJ5=3G-FVv'u@`HMΩ|s:|h.2~%r$w}2e绐%#g(3(2ݕRĠ?GRtM nJP6m]NO6_\oFW[NB^t*Δ;,RPPUȒjѰt|GV8?{)\c>t]P\g[b*7pd?Cjoi9}(Gz:@
5,T2ݡ*Ci`H@x(3GeE]v:(8m СAvsGmy
8HP+Lf%s-=}`竐~VY(e+ZJU$}$R#pQF@&G AݕtDp9G@o#@ӾujP(뺴A8BO}6
>Xv%y<D}\A8>LwR|$#-;%+Rgsb̓qqxm85Vv3vUP(7*>_ -OkpH! QF YD(Wjz_Z# e誝6M 0(Br?7?KAV'-bnC6G(JyCJ]JFeϹc    IDATɞ >nѨ->>Kl4 6cn@{DWUr-x${ LᓏիKJs9xhOAAM@5 $PځZTI5t  P<G%.Bp x<MGLhU,])S[;ر:o* ~4p:ݮj&2Pɑln|Q啲iE6[^-rdA>'  '*`۰[=l$)[RuX:uFzʕ$c64aTMv	=;v4+gQ\|#RR	n[c;Or9mU<-T&@F-O>HSe)ꤜG jJa/mζN>\-e<H / xVW]ՁᛒF}eM)RqԿ1/6"[8[ Gx4ul-8Ojk \QGse^W;`#m2!Ւ8uJ^G]ceӧ> AM$tMubdgmTp :]RW )>TW1I*zW0M2_̫k[!ilg/Zp*w*.@ `,PRgM} V }r6,Vd)yj7ي*Eo{;e݀ 8uC MNJprɠX6]*8?JJf(-?|b	lmS{jcC$/Z̊FI|9.@`إ&Q	{1]WI9U~G.@ Lt*$K=R	@03(HayH@ =E"1@ $plrC G
lrlhr|%k(!iq:u@@qXhၘ<5<=qSO\O	F{#Lh\"ӤFpzstRbY*WC3|E੧#0m"zpd
 
ܷAVO]YMN#yqo&Hʌ ضmw@` J" @#eQźwZ/[7}F XhI(Fda$ ۶LC FmV![ BgD+.]!/X;ST,RzhㄗF렐uǵ/k_$g Wђ@>J!~AK 3`SX  0Cuu.@  Y\v݌zо/e<qꡍD1 aH(L3D )4"owвOD`  WZ.ŢIxosTTTTc ޝ`N=rzg[wtzo}z[x YOp>kЙIKkfka
$1p<5cEN	N3-:P߬E`J-^~6ixR|)~!F 8l¥-	atD(A6-d0xcyUgk2/w"<(hll>T^_?هXzl}Ge>1RkP#tmv6qV#gd-QBU$
uptQkd	>	X]3^;hlxjfǶE~:	Wvn[Åz/P
$XѲnuMT4SƠ,	T{',XMVΔI\Bj38#3	G7qZ/B֡D]'\GQa[ާ$uG+h\/o;pȷGHHy7{#,@!.>G` xoPɟ9ck1Ӗ	RooYjA=,qk'/gnLx˞V@ۀ
Xx6	N5Qo)Te:<4׶aNPyň_']B
"J1q	DY>`i@`EXA@Zj+,W$k@}];Hn, lţ߆?&vˣ1>ˣh#IR෱tob@?	r1? YĬ`a+GX<6Dura]Ha0x5EmyVF@CfFZ?(~1mb0!`kYy*:y Bp[
2}4D 0<k\w҃V9zpWؙ0S`+ʊ@`X{(nKZdlF<!& xp\õ nnFF@u}Uu"cZU"# /pCYcF(OL̀9]FC!?fVmg%PABN\謮3H>fIw.v_ȕ-!8K1h	#+sQw8sj5dl˯  \w"N!**Rך{$!Њ0(\BNuV SQϭZ  $x66^\J,`ϓ
!stVݿkwL7B3@TY7ୀBoѣhx!h(Oh@5#pϥ]?|EA`N
V׻
j+ 3N^o]4=2EAMD *F?)X˅V@FȼyD2Tz'-=u)B8<]}ylnv3X!5!˗=-ZM~;YtiSәq-)#_t )wʔ(z{;ϜD#4s"\7[Alt]f✜@ܑ)=xb@IMM]AHcN)S<
+\g8b@@ךGy9hnoPWoJt!P`zH'ER)+ȊFΝowv@(X $Uꚡ\lo`TKp2<WܣiH(KF`"3z-.mx\j-M.џ|"4Td~]fV+p }%ioMEMo;AV/Xon%W\c^3~
4>JF`)l(B nKvͯi@K/l58wԻ `޹;`
G@}kA:8u'kt@Õ1зGV7xWAؗfcV>J"?<ZqKuo@a xA? N|7{
}cud/V`#r<ǠWJ +>w{׭m<c7RU⪯﷧hbPjx),	'wM[ԗxح	~R;dZsǊԎ=ޏ޹srcL΂2~JwЫЗduo:> R0%:$XePo+A^qDdǎ2XG oLW&oWɏB`>pԵ$Fѻ|L__ErK*u	Ʈ|]Xh}_
s_KEQUgX@3b 5t
kL-E8fooi8RA@Ps@	ep-EA^qS\8\7)! U$.NR0MvhtaQ);:^gq\E	 1% .AU`r,#\*?u!\8A@wlo!i#hF#Q60D"D,%K
o!em'pk-B&! _ C bU+KԷ$z.@qH!?vkZ5<iiW3Ʌh ELV|qEc@g糩s_pX=F`Н^fNUx#LKׄïiZT[\\ab*sKObFE}[ӵ;VDd݆l1dg,C`
m Ok^UXS}s4P^`y+n@@ {"0OBKz>ǌ/x<6~]Q>d&]m@Ӵwug  @K [C!" 
C7o/SW?|<}_Cf 42{/YR]i3~gإOr,3oNS;W+~on'	9d&P C&S=9YY+r&YJ3k"`UX)6{tK;>;WARxbא<|ZEHCFΨp]SGxоgU:6}hB{
BU|	?V{%  -\74n]DiC(Pznt+$&Y#
}	?<[ofwE!za;b)WY\'fɢX@UKksЀb,1Fib)z{WZ|uK^E=FIP}8ȃls< ]RTKk>l+|Y!9h@3]nߵNBz&-=]_	@ KRH!`0dF0:z7˗Up<3UA}MH^P s^ǡ\sW.a!ox
R|"y̙gsĂzC*M	AuV@$45?3wG龯\vz
F{YuV'No#77ukܬn׏{OrVSJꦏࡤv{Ǩ?q+wW*<G|
ɽ졜x/tX7cK_|\כ>p F k2op+{&>zrүzJ}|J*/ϑKwEU|qxhRޚ_yCyC0r}v@O^ls=>rV&F_=Eސ:I]NQ~ZVOor-k/ϑ¨Vt;/k8YP{f(k~itaS{'D&}J#@#L }C<
YH>xqP}NC*fz>jvBt=>Ѭy6+@|` Ĉ0kBU 
<$T5<N`J=#-y;;/Չpwym.w?ir}-^/i=_}ҊAhj?
L	jb3#r8gXW53$B;-t)6k#d	JxɎC_Ǉ|v5C,|e{OV2C5!/דiC?} +Bt{p
8>f dE<ĐrKD?|mG\#(O<QqϞh)bzNiW/&8F7TSP#pڀF@HLJHȿB%_#v l q(M֔xg%a>IfD!C	g:C	Rᬦ	
,֮	fUbbz+P`Vm5FV/ڰ.ەYvPxBMG*ZX,@P8 ->BI
UCrw{1ųpa#C GLX@nS8 _YS*+@mJ D㿕p@ :Bvň6m&2DIN3t^N-b/5<gkAwa`	5XhTLHG@_G଀1)N6Ё 0!3B"9%eeF-B F'Q0E(>B6hD@@" @# zd|  @<Xg
X#pF#?V奡ͻQa#~V?@Hn>@CfD*%)0GԇE
%*4۲ҙ%O>l-BBb+W@_lmmm.Ft͹3g,y%# t\ͮ!>ox@s!É =.WCuUX!, &'ЩVHb\E.L  d \aC`\=yKS+U0pMA*jʐ
89/!$451d;H4sE F,1K  $t1|.d @2@@!'5HSu͒P	 &+p `tx^Pf!2-F;l1%e# O:V%24V@5ݞgF gj~Ȃc0fzH*2@n S	M,,.qcDno"V=EM,`0dzj+q2]X!qb+ T&c9
/;hL  >zC>m	@T[tS:fL.o8ǌ	Z+Z ! xk*@X=u7ûW6@@01@3TjjfDIGҘ0:,c!B }:|eRPe$v賾]3t(Yǌ	;H3'wX\ޔh'c`Ve+pF$9fL  A"X=8濫T/"uXP|w6	e=F0!`@8B{+yI9f,HvR~jHו_^ħwM|8n~G'N|][gT8B502$$C~$)k
1ViI `ü3HN=4M|RWz8B 'eȰq5d,(~z=-~XF7;C	6o[T^fĉ߼mO$7w+'8ֿq*$T"W~zw?)?۱*8A'#t_*GwV #{X]b>zJaV $vj`~b$tb:n|i}
#4QuGGR xɛF(PBu5@:(	6;X>t])w~tOo1k?z2o}ԀcD.vl!'ߘHp
d~d	ſ!Ƞ    IDAT@Tlb+'a#D̷DK``ĉx"0e]H8)`lC`)w8ɪeSGaD?1}GV:XliK)%V 
X hXC^m儁B#=0H_榤[~+kB")0[jEǝ0G@X!D`n70[IO+037X`(@"0 lNypsX@V4iK@[߼S?;w~?dox
 zŏB@J|ڼ<ʜEYVo@瓺]
qmozKڲ۲Fr7! dlRa(W[œz;8Y,}u<m&BϢјȄ`5[ Ё-wc9kBP@gt@ jȳ.G@ț\r
lU!!l22nr
=--8.?܍{;HKKqW  $df(@b5&bsMB
4hN%pظX@%'gS"yPhFanR1BaB@m^^^9% 2hh3/`W@ݝw4#r(j3
htK"²@T#@iAP!`r%c!q2aG ^xBb"5,8bL85#K  dX許 (aדB|!s6,TB>fX䥤!@k֑c_JD$GpvC	"\許lLDm٤	Nt:d<8M  DF #+50=Y#'|B
B8B!B`Gc
EB  $XGz;|V@?jLd{W`V>{8^Ǒb"٤,$$e	gЏzYl.UWh" 4 @Q%zBxКbܼQc8Si$HTzkm)>ƛ#,3L~du:.53qh)V Qc(kz<ƣс@@,Tb@XBEEEUkX~e r%eV96[d#k}Yfى8q DN=]剳$ͿA6#GZg"\@7j@df" ef9//oݞ.}-_ mF:@=EtX3jLn jYfdJ2.6V#tȊRf
hF$Z*y2~#-
8B[A c,g,bUx9 ]Ff8˕I/N|a:*Ľ$ii2ƹl65]_`fHK!B 4!C Gc?30}
$@T!SH{lo@x:H,5;V@H7sԘ@@H4,5&X 4'C4jD#	05&@0|'QYdg݇ZO:DB`8F?ITZql֡4raدpXS!@ %$*8~Ob@
<K1?4-H8AYov}3(0jhv, De>l"V *<@ z=̤Qcl @qV-Y
HDq8!59Bl YYӞw\2@@ `( <fVXGAlwdAI5#B@/H%Qc JeDE6@lc56ÑABHA p+ب1al$
*!mc&'$@YPe
TT|_X Cd*.S  $bs?;!`h47{Օ:GbۡWxRTUТ$|IоA =D }:+*+p+D++d]	4LI'@D\b@T+R V#0Lq 0p0pTNH8}6o׬74lVdiKfͲJ
,(hFN(WӉ~NT{h<,|i@ #$)	YR@Hûvgǒi*c
HSm!A [a%0l	Z@{ӆ /WcNR):x+PrxKd+4o;:)[]ZgV-eį'#7f2]"=QfMdS}GiKVwGND7$d"d1ƍX<Jj74D0GHnrpV@A "ba
]^vA:
LCz6Le
@軾(	;#XyJпJ;'K=/Yg+Ά@a}j4sщHBa.v^9	JTp_	}0ÅV\^#i0vjx^Re+Dطh`j[
>nyXʊx#0&V nA[06XtF'wUC`QV'&K+Ḡ?) G@ٟS[x4I~q8D@>o$A:/^@л ")%0@`5@jJ4D@Lɡx'BYp۰@@>s+u
{~8sBD%D[ngo0NBɨ_OX+1Ñ06Fb\@''b;$2~G=)j;uTiJAݴIĬ4$v?O&VacBMn=h@59h-0b>'ÊETh͒
֨>/fEÌ@&/F=+=M8L΢Di-';1,$ztx@\#-湌nh>/vAIV I@~i *Y\dG"zD@pE%$0@<N ʽy{׭,!0-<-BÄ i(@zl#`j:`\tH-eCE8Be:BIY1@#S,p		GHҭz@XYZ@@  $̋@@H!5=E  N
C	4̈́!)*)6wommv5/TU(UV:jL$W
V m1@  -9(n\@H"S\|콺!B 9Xe$Q13Gguv*DKgϞmD;*@1M.Ť\ IT(J@ -I$QE8R";y,ٱ0XpvK.	
U@G{GiǳA8HbxM`bR0A	H
ݶ=$*%`!0눲f 夀DO Wd HBrh{ ITF(&rЂ#"tol^&8A`hk@ ITp6~!Cѭ|9Zv+PC%z ]BcL`vIi{K{$Q$v	tW%YCт`̮f}I49]6%bۄdhXB՝YepΤ&y?7AҲ=7@ g=Gٸ/OHZfgQ6:I̛h4	HЁYeXtyYdn[uG "@G~ڪ9j/TriRMMl4z$?ls=|Be$ive5PG&GWcᖂeCkeYe*}!PIm@ L$*wQ?pYL!p\p"534+&쨷l1Yڛd`n%!IV :aYfgf"Bg\O1;!aTczm@;KdE&DaC@7;@Y!!F`{$@D\ba@@@ )6dB
k2!1CZCħwM}wݭ^ߔi^ y=-+
?+f}*+[ħ+'͸uF.
PEhlq5B2@G_ -l
!8!-NTo7]}DBrl8qߦ˻y#\ڋ/x4fgmZu5>Oeϡ@`NyhioڈCZXNo:Dt4Z/ʻq3u[wGe@ htZ6lڴi{uuK1#OoxvcGH/ܔhio~+PE bby8Ä|+6K	80Bܣ}sp@iڥ1ټƩu=wtYIv+ٯ-<[aD/#$M	0G]AǱ C8>}ߦiMsPDM;s*Es{;u9B Ev.qHg+Xdh
E@:#])X'ĆܶQwMv"88A`˩#Č@]4tfp]G(۳rQcGH<[h4)kۡ1jXlAGh
"dXg+
Gcj#t
Hpd"?G<[@ *a+4
C@?cQ	

8)*3t@8,:KJV!3@@ d
J."TZB"tJ+`		d4@ ~@@  @@  @ 9-vj>xL^K  x]} 4nkm_DPl ೊ@ H"fdup	lC\-gѦ˻ .GiA`\z#NL*%AɢE%ϻ8Bv)|daa*+HA Y$+p f;Y>@ ^XSHY!@A,K*V;Ba`IYMR#l;* "SX%č0˝tEt]-5v39r"wKs	aD,")go8iሒG{wO~M;m?rOb*Hb@'=_QNÿx߹;Dw&@#p21!\\_ʟؤ^" DXȶAwD<d
	}>ha1LD#  qޡa/_o-3XF cV /)fP# D D*-!qE%+ !!0 %@  $pw4WۻKBh]i20fwW@@ u-B@6jCN&(\A@Zmka'`+@ z]H!7}jϸi:U2h"lm tQvqvv!V@  $&8xlkX@  $dFEًlh<بEu,g	 uuu{g>dW.IpXH,"phv)7Bgm9W  $>84e)*$5bȌ@@@@  D  "B
\@H|#pJ"iQ\ud8BrX뷕g8IT̈B=}쯶c u~
Ay1,,z=ITBbnE&2>O;ώ})ђE88ޑ@@ >?񸋽EEٓ&M5Md<9٤	`qٹ."IrrKީfV,yXvK!D =4E+n:=R,!E[dX@ȠHRPrulS͒Ght٤,B	hu(HIT`ٴcT*Zk!9"@@HL!0IHE!1@=E)]38@ XBBeƉyqlF 
bq WG_79Y9i
ZUX/!@\%TWB D%{&, l(M<y0.V  d t r;̎vw䵍:&Yhh#ijR3yzZFG:hi:Ӓ'|(jRɰ#DD+g6 pFRطX,Y,Ml+w^)Ek'@,`e$da
*4
VeIaUsH 9.b^6c+@=b"V(gS[l;hpXu<y$v>$lZ\!;;{հZi)x7:a 윓ܹsF \kmbl*rʹ0"GFη^ +.mަ"jxrpÇ	CSe`MjS?|&;ݍMaLB%U<9mtkح!oZ/$PpIQ h3OPN/{^xJG[ƧNC:W*]3,ъ5VuH'9_r0"0Nnޝ[
_iI]O"N}T#@@M͓DU`^J֎$֖F!D !h^݇}厖r@5u?Ɏ0Dւv d= (8Jݬ\c"PX04ZՙYBWt
|#*ynN@`ǈ*vr,_ΉeUծR]0dϗ2-n86턀f
ԹWk%UC"UF&2!DPS~+G݇ :PqFwͰ{+8m'ZO߽n<Ϯ5|~>Ͽ
EQ7d&}}IiU~_TUXUX сRp8+-;a\^i6>vw9Q//ǢhEjH_慠|FC"lٲ;Ȼ{ȑa@t]ݱzOM]	 е&5˩Qa "?^G>?x:mS),,ܓ5с@Z排
!)FgáF`I'ZqΤB8BB@a8!F7gƦG9
IE"2ɦVDȔ0  ,$:;2L2x A:\㧄DAH!v[y_DKDJ@Y!u  IDAT#
	"fD@$$Q@IoLx$**p&Jq;C.XzAu+a%J C)X}K>DIK_XC`(iJ׬#ڌ*ak@ V.#0e*
fPuDQeH!C@DkemG4U<@ Xe ˣEMN a:9@ >2}z
HO݅/p}WߗZ,;UY@`4C༃<YIcwwv/GZXݑ=^|-@#lɦM玷S,(>8K&o)@ b8w8uϟK%P dQsEp7!t꤀nQ2oQ@16s}.Oi6}Ř/}$+fY?XSLTi~?;+Ess@ Xhyל>/..A՗̠xWO͑r~+5!l!c;5Mf(?.(F ~fzÆhXa@`{$E@#`^hx9Αq^@G_@D Pپ{%P?S +L dә7><haLI
+(}hX
Z>DG#4g:~-@L!P&#u=zȂ0"'⊝@czW$)L,H@7:#@ LiR6Ahߺ-?9̀J1@؅ @ZC$u	\ Fl &ҹFaE|m:	GQGZD  p%N/h#Lt`p	:|>s}XUja@\jD6=$^Z	
 Gxb@Rhe] k#^t:G ;K_baF GlRօIGZI\+KZc16v> DmyD2@8<D͏Yd?.%ג|+@!,@/{Z)ƎoRpߎЍS}!l)Sע qF}P!@v`&ƆOQPt]ʧj9;5yq:KkNtI
ESr4>l@2C0(*7zR@#P>F tFL@]{x{ɀ@ FH7G@ÂGd(?> #=qh&|rrs3=-C/!k#=qf(g$9ŋ!W4G
Ʉ-t.'}BHퟄOOWtvlI@l=GhKEE:C d27RΟNy*%sU>It.xrmGB0ɍA[@q:Ca"@ p?G,M|Szp	bBGHF`U}0&4W~j  -@8B횑p$'\][ՙ,ifpfj@xALnrUC.߼zGUՎ*~%G(SKW-]Ř#!MD`WuKWo~sʞdBDfΜq*zLHK"U+#tobP*<cId^4Kh|08BF$= 3efR+p՘oL2 Qp
81c)&ꑛ@8Kcnqk\z?`:&Pg(X_̙ Ƭw	(DJo^ǀ fZ*%\5RHɘ8`9*@ *!%  HC WxSU#uUㄌK<sΜH#     IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/next.png
PNG

   IHDR         ~+   $PLTE333QOM&# `^\C@>i yJ   tRNS @f   VIDATx^e C@Y2B`
`4T4^.U^ϥqT7@uq:B(koM0$6z|eD    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_link1_thumb.png
PNG

   IHDR         4   0PLTE0.*UDeqrqpҘѯ͐ٸm$R  	nIDATx^1j0qAN H"b<}ht	簋pGy.#Aw$CC&M)`\0~EV"F1Q^?geev(7<\p-}60şȈQǔr%K*|rCm+AzXæ@DQز>2?h~M{g`O A;L)b*
P
 :擛"Y<DuU>V\qHqZ䆯(6fDp*"\5.o}cǼm$WSs)%]5:U\(IaC r9.L-R9+hXSFЛ)_f8ƞ42+#Dt` wԂ?<7$3F#ܠ	A"%GmE ӆR!XLݒA$:P֪U"CiȕRI @/G!db〒RYK"' Z)Md5'2jÜGЇw/}MKz |'8ycYt&d 
ORJGi_cIྻw[٭5W	iHZENyez%nؕ'sj]d֚j,N:$viH_EMN'"/WOװ\QQQL7HgB_l4@zUds8MZ;&LRҒtxE3`$AFȂLVN:ć. D	㉤#F)$E
 pb!Ey`´Ja{ۤj\P8qzQᰑ0=XV&"=IG\i%z45uiĥ+թ+O~<yK9@F>X ֚;?YX.M|W8]E_~{J3ՙ+Aؾϒ"˧Ze<@+A*:ッ D~.l1GVNψ ㅙX(GaXiȆ?CʃJ NB\+=8D^AqYDI*.oB
gB5d+EעBv/AXz
# VZX=5 \+NwRP\%z	"*<]VH6>>]\X}Y37~t ixНGT!"qG7ioLA&t@G90{g}p DVE`s<9xwON=xd:<{`"آ༰&zx%<WB(B\pD9Jv\PZKL*RxSJV ߇8&L_
(*G[(<4٘ P(!k2ZHWo>~$]yaYk1w2-{)!G֡$NBvz+igM?`eKxjkm4<ua_-/ .ap~ڈ7-_֑ h玵|zfOYr a]Bq/xN]h]ئfdQGpBsd]5 2UClw7f5].?/6u\_oDj}Y/d5t`` 8SϴyvNǵp=><QPڪikG;܎K'7':Vfu7Ӎ?BT ;;%p%g&&Dش^gHڬ@yO]5JK$!0R,U,t27J'{N_H>LbCD&JAZzC3z-V@`RmzUhBjpńuݿ-eokHp=	/%TYjq4nQΚ^	X_8^` HcH@إlYR_mf
	m:q_P{7-3;t5]?9UèK-vZH^BBw0UNNW''&1ե|<пkF($yɧvѴ:z=d@KM! @4'!+$W(j^J}aEFQDΐsqBqR{/ptq,@CJ(mPN	Kw,s9.!Cx8Wٸ2PB3>=ՐӀP8-|+G*}Zp?LiAQsl rdfBA-)1VC۱	)7*Q9a c<,Pڍ;?և<R    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/dom_tree.png
PNG

   IHDR    n   7  PLTE   Z   ffۏ3f0009  99 f 9ffZf́3ޜ3f~3fXXX9ۏ99  f@@@PPP  9f 9   9 f   (((~f3888f  xxxZZHHHχhhhf~ff 9f fޜ399f ```9f9 fZ9f~fZ۶́ޜpppZffff99 99۶ffۏf~ttt{{{ff&&&MMMۏUUU///ff]]]f9ۏ́͜99 ۏfffeee~f:::~۶993AAA*N  IDATx^흅# 23,33!33Ï233Ox{UݜfX\α;SϩeMMMFRT)jjJRTnJ)JRT(JRT(JERT(ӤCȝw{tRq)G
bƭWZ]hJ.ZІ74AxV&?B_O/lLZ[JEޘ7[ooAc饒]Z^؁з/ϯ@pΗ`_z|
HBbB>=" Uh%J{tR*>Bh|><,r=>'vtY P/=oT(0I|m犓'h؁:}NkM`scbq:{*tA
Bh̷
BoRT(JRT(JޘRT(JR1eM;j=85}ܪ)7^{'N?OR|̓oiǍӟ>SJEv.<1>HأwoyR=z6wo޽T4(<NOމl&ǩץ"mj*\;2Pd1Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0Pd0PN$Rn
JE'+& T$Rn"JEISW*&-z
#SN(hbE>u]SAMYVT(JRT(JtV,8TPwǨTP>LoxPJXAݥ>Rwe=D_*'y*AWZ]hJ.ZZpWlZo4~2oIZBW/~}py>}1c4>^*٥u^^_Z>T,M IQZ{~NT܅wC%o]Bd+u*qx- ד%x3{:j/n`
@r*0:|u
C.@zHp1CEp9t@CdR*$Ů@v)@Ea4tk]{CǷ' :;<0V`
w}Į.ؽT0"DTy -iؤu8Q+tL'`v]7~=8~oɨuxͯ]Bn QP*0ҹŀ&*zwBcjJR[kxTPԨhcë680=3Ww7_DzH~*6UNg=>CeGj!U
t:;`̙/\z9
QsPfّcXyX fD6cf<^V&*rk&<DZ׽u+wgW#GpZ\/zP!0Vjm F\sp4%\cx
^.9uStM6TJ<\ft*͹w*T5*6Gë=Tp6_!TvR1g)T=r/.AܮV"PyHw*JVUO>;T7~fA|`/6a:T~2\c|ym=BeScrVWps-TuL1JT(JRT(JRT((|mџHhAS*
TX%Znf-
tSM]`ҵ+C Cw"g"JfAHM+Yx+/@G%4?2[J?`4
h
*P1g\QG 5
Jzb 82?RD2}A gA7J:R|QQ^;i+T(.	j]|֜3TIlާ~h9+*TQDP*
BP*>e_ߤYTaz(ߒT_rakS~1ʷ*aw"t#G|KR7Ep8şCݬDig F6SDyIwQ#ݞU J_-Jr*h90Ҏw
(m]
U;+QrpK>A:*py+PNadYj(AjCny(ڒTPI6Q6|k  nIS1eΦ
/*(6Q޻(T{

T*CTc69(jsg/ 36Q=wQ:7RrAg}[R`(JRT(JRT(5S~\7]DT*Ėf;VljRH[^ImvTIf&&M.v:
9fƞ5v9KC* `SǦ"%ʹ]Βrr*[^Iw?&wjܕk+kr엓SJ:fXYIRrvry
9;SQE"fZ.g~9JH:[^I'TｩP4l{G2^!BΔtu|I {-C@: T(JRQ/;^U*4V(JRT(JRT(JR1eҲd=مGG<uۧ͘?<8zU39pptѓ]}'}詛S}Aȓ`ק-''~3ac^5?`oDadB1P\Coa֞<Ϡ}Пw0@ڿ_uÆɋ(>|3r0u0Y@ 䣾#r&/hׯ}Uͫxa`NQvq0@ڳX{$`4P؋Ov
+Y	4P .d%+ϰa`
de6L,@N/,^?6L,@݇kd6Ar@{Yw;tLÆycݎf\ͷCY4l 5$P(vݡ2( +Y}6
(Pb1+YiB(PVoÆRAb$2Е<ÆԩE1*ӕ,Æw_0d%+FȔ#*E0FWrr*nzڅVdR8mxC-?vcVioLu*dE10L"F+ah7淠R.-A9s\mX9B(PIX
zYaCN %x'֭. W-B(Pt#+Yل9!ҡbˢ!(LCD<P(-$a1+Yy9ϧ[+O:I
BAؐQ[~Zi'<|Ӎu~<jbGF((F$f%+ٰ:<P(FQf%+TbjK?lIEc8
>P׭Bt%+
*Yq%+tT#IXWi0}G(BI=\T>u`f9՞q_R*_+^߆cz3k"bB@O*9F(\R*ǿnwj1ah?Aimϊ1h [_DŨZ%H0aeש(ݩ^^]ã0V`ұ9Xh@؊;_R
F#IXW8	%*ap6wN{}c 0,eΊΟ#$,JVTA
r+=RQZAi7sY8Ķ7(Fdq4
߸7WJ?Qm*i>P9+j\`D1J&&$)`W7~(jzZlWPq,ҝMvg|l?9P
N#IXidY\7w&(FY2$-؝4PIJe%Ȓinե3
VG2+YFin8\KjT@bTWTI
>P<E.U*5
^IXdIp)MŘ$,f%+Xh`%Ko|E1&	YɊMMGJg<tr>TŘ$,f%+64&m9!4Phe
OMGTrET@b*v,͗2gss(|*$>qJQ
^x,+節\O7xMtL/$VLȗW'	_$IWʀ
A@Q$J1
Ĥ+A(xQ&a[$>$>1JyP
^IXid47~fA\H|bҕ(FW+YzE1>	KT(hXIX,"@brQibrd)
^G74@㓰,"ٚN;IXD>Q*|?D1&	+JRQ&aWҧB ._J
b(ST`Ld)XȉS_R*d7o2;hVZ+YJ;xDL(a%K`9lڍO&kLsTMJz~Tp,LCg'Ko0nMJI_	`|sOkpT}DB9!-H48*xQ&a=T}tllI;RQA9uؘg~ۏ+\hCD{_\!oI+uvF+ԘMׁc~ś\cŨ>ŭB
zJ&tYQ*	Q=~^9o+M,? #niaGf-XeFYďTe@T"<~Cnmbl#봰#ܒU C2*'I>:ЖT0MJz
,mx@Wwv[RHߥ?桎BۉQ8kC&ّj{mI*yRAE1duK*봰#-!Pd+(FQWC8<>S5~- Xj`!4H{mI*/FenJ`8܁Èb̳%Ru]8m}-Ř,d+tY??ÈbLQW*vzġ;n_2kv.uhVTC<}/~큑jnM@R#1Xx~!Rn7!TG(TñNHE*C#JX}?y]	R#1Xx~!RmhT+(F*asVxw
Ceek_^œ+v<>*XQ.d$[D]?(G^ TIXQ+_|O>;=B3<DmqQAE1`u^g{kVU3'TIX	Q+_|O>W*ۧhVbEJ:gWԱTTPO+.˕/>ݩc>ԉ`{l#TIX	Q+^ͩU|91<ҖǠy`TL:b4	+BuAhV"JE:T(WɌ
b4	+'*
wQT&aDRbJb#fOP*R1Eҧb$aS*:u&a%KE&S*ו
=PP*NHgVr7hVT(.w

LHR!4w0IX1P*&	+JSߝ7$aŠBVbf,"J_iΛaR+T𕦸&	+zu"&	+vT(4	+Zu"r)$a(T6$a,
&a.
&a-TȊ|wލ YuRTD+N;IXJL=[%~njJ5IXJL׬Nտ]һ!	K]TkbP靡IS.P!/}
lS*3T0IXe4*Eݱ/P;TJLVrD=ͅ
yQwg: buwhһRA*Ts3LVrٱP*hVrٱP*hVrٱP*hVrٱP*hVr
>h)
"IXJR1:T(4	KP*$,B8}BP*hRTIXJRqb<*뽧OEb7s꽧OE|WM_R9JRT(JRT`Yw~LB^I
yYoZ]`ScQxD@E*ABƥcP!*߂ҜF*ϭBz
q|*|ZzCw#P!*;
+-!ww%}@;bIJMr*{盯°F;RQ|G7Wa9!;w	xT#[F*Rd7	]]*;"byhJ |&pծ7 
+t4TIUX@S*$іAPcI
BP*
ywQDdr*Yް[e*;o|wHMɩL_	Q;o|wLMꢜ
fTx*{ÏۦכplnҪtSQ羠\p`\4{D~W$JwtK UMZ6A'Pq<[s7 0Jcg.D^	SBo"8W}7iLDEzs0(Ex^	S=PG*:c|wX͚
:׃n]D*pL@EzR㎊_ݤTou21["pP޻-v05=W}&zD'EylνwJ񉪃 JRT(JRT(JRG0W(jjPS*Ԕ
5BMPS*UQ    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_pch3_thumb.png
PNG

   IHDR         4   0PLTEddgWErw|HŉƕerE  #IDATx^AJ0x.t=zaH`
. .\<sRQ%0dZ7"m^6,Y,_S\ٺHWC 
<^3!c4$' b G )IVNw%.w{[
%E ̹ip|	Yve͂=KyUpo8mewUa:RT!D00'mQĽ%C{۶=М&eHIF%Pt$*kmK8wPJ-e)6ȴ	71{bt,CտZGl :k9imY]B<~yqF3gɝ ւnԜ\2'wꇹ8"3 <iSKMFѐJv=<USllH{3eOp\ooqaWd9PJL=}6<Z.;zZs[g$rNltjs3z65f"bA/aؐ-(j=XIͳmi~Q8ɉo9e%ܼ=ڜ$I[^laUKʚ-ύM! 4qp^qY/DG^GV8дzf
1zt a·~j;[y^+ <' 3E$e_Zfw,A1;l&WZg6+H6ƒNVNu12ລAuL$^HQ8n+*{"RSBt>|Bv|2?YbDp]G8o3?ithmWTVa9\C(JeZh%z@.3wxUs0c2M~0;C{ H,wg$$nDDd0O8
X>}L,^orB8BF)UVN	_rm`;3&)ww9DelU5ռҼB,(OX{xX 7kVH#N&B*r\B._=/U:V	K67=:Wi	BYajE96RFqA[ᱫ 9=Dy]f9yFt;GPˈJ"SY^zI.(aODA'gkJ3BzR.HEHΜJB>WAS㡏y =>^8Pd>؀0Dal#{8]C=$@OTI˫Z=8odP #bV_n[Vn̈́[49޸Is?nIڠ5LK-X{n=s_ݵݼ7;Vͨ6`m[iK߳;zUPh`=7vF|'@-<b<"Nqɠ듮
?.Ne&-"_aRF7lN(?3rJY=#ߑι:Tw}VߑVJ+^"W8w9V!0/n\&IqD"BЬ<knAݴF"Pl5~Jo%1NBK	yw1qߥ"3|F®Zђa6eC!u
}ԃ%	Vҿ/0sm`jӔ῵A	  $"Y2=.p;gCJ$,%ޤCH"    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_pch3.png
PNG

   IHDR       Li#  PLTE   7  P ^0 j7  ;  F 9 9%V 8aa W 2h  a 2` 7Y Xg :x _ ah f.v 3~5_T&)1A 8X-(12~FEa(^16HA94 U@;e9IHL77;r@? __xG 8fNOL ^ ghNSUH >,ig@)W dc9CcJ3N?_(z|$ze^A7e;fQqx18E1݂aw\|zGȂ${of7ϫȄ4|jSء8܏8wǙIb^^ڛWؗ5+슲yb{؊ئ褘Ӯ{ٵ]6篣ؼ{׸ebҮθѽєυ׾׮ڛؼ܍ݸߵܻnpm_fm}hpwňmt|-./y}?CErvxNT\QSPbda=Lv̟z{yѮ^Xs{[cjFKMklᰵx6ܑ  :IDATx^En1@ZffaRVY	~UOZ9ACmFyCљ9AG;6ut ƖU9c^Զ+9dBLj=4@lޟf,m1wD	;ɚe@a@ ty![֒^RAӼm[*@}|s!V+B!8R b"A?r.iCk,nܟbo1;- p`@XXOͮtUjs5~+ZB['^Ӳ "#)Yҕ`4qsFq 7${	ǩ@ꡇqU9M;P`1b@Ь]e"M>;v'q@ۭնȧ ev*NC{9	
e?b0FD0HoBQ$!
IHƌb*` _iq:X5?ϫ2Rϻ\tow6R榓f3=wg7,}L'.W#cxvm@d8LIuWҍMpSmB* 	 %9GqB;Y k%ɿS ^A(=K[+[44j`8P9LSS1-	(@  @PnzN	@t.2
C j6^xg_a@Y ʲ ić~aO JBFK $0 h!U>2suPu`#( RD*b
Ľ<E	Q0׻;5HBs U`݀!鷁{^M#V(?׳W`e4rQ$B=҄ 7k_59LdUǂEP BSL}P q(bWCu%;P
nk P_w/5\,xwN(\}`k;`xsN	--<uR%B ˎ?KhW̀`1&0!#Xθ*B"
A+dM7HmEݚ6UvflsշRVuUwW-ۋsέKZm^绚P2=9åMHI(dg/*e-6@P@*	~'H	R #ApN@;vI`.Gx_=:+Œ"(P`1`+[ ~(%r`xd
55((`!4P0; 7+E;P~hiNP^i,	K8hzϞxe  uL?)N)8ږ(` y/{PP8\gX fߊ(PhIMBԕ.ě.'zu$șF
`db@+M0BG&vXZ^XLC$8	@ӒF0
0013~\lW
n83a) l@ł9c*bAO;<NSH
إTJw]5Ri_
*دk` B%p#l~OY~!iq@?{v9n+W0剙
ų@5&N,eI:qA8TB@քrQag1i4L	9 m5G}rׁ]V`_\.T5(NP.k }rj7zBڂ 'J`D!XY	6}+ @ h3/ZQ
X5n<~ؽ@բvXHŀ2Hw jDD	|r)YE0E#D@9ݷwn`HDH3˅r; fW"
ة ytZ?
llU`T KVx?cxޣ@Q)>w';缷<Tu^{BY<;y
Ӿ<A.`v^X>|M`" + 
`ojVʁH)NI>kl C, ( }V*
4DjU#  xQ@%?Q0(tccJ
`D;>(ps`<<4kq.ͯG-V C/X\⥜,l6rac#[3
 K4+eN$t7SWrPg} :@$6BeZwT;rP#F蝬]%K $HJpHAu 4΍ Ի:\LP@,YP$_̧4:D65VЛ.x5H*q+xLX
d235(4Be-o2N	*!h[Qml@?%=97*QNP8f>@+ Nz|fr|rs!"i)X:6t3 vhnX =M;nnvQqaƻfWhn+OFD;2{MJ
ҏ$0g*D¢T@M ,	Kn*-LEQG_1nWc 
'^cs|+BX
<a,MTj! X;Ӥ 2%RW8.@,Rs̝0QT@ȇ򁂛,/K#,T\[c跫K_K`KT榧4	K :G\9}j
F h`@?9+u?!8y8`bD,(Jv!^mPޛZR9ܫ0
)
 NpHlLw?	An<)	k׮j
nxη+yFwꢅ?Ɓ'?LɆG7ٕw:̏U ;Ù<I7I [:	=\>)q\
9gx9z*x19n#^r\zVbiIcPӶ-APD⼷fG`am>L	 Oz	toKJ?X\4fQ	CSw=x-6p4]A@/;%>r[΃2.C KjG)r\APld<}4,gpjBWfyeZPP$
PRp ̣5 R}1ݱ7?Nk.
v&s
'Nie&*Hڮ8\'{À`wS@IbCܬti:1v {oؗ/[d#x@d"x&j;; 
PlF[Dx=%HS(b:La~:C\u{  	Ky>,GƔżx1 kwmۃ恨 VI UCeFXz펇3"E:ڙ׀JT.AQKwx 8fx*I!#c&@T ȍqKd	T@WA ޷|nѱ29ff:(h:".>葂ihW(PA7?DjhGwu9?(&6c&IIϳ)7惀8 @@Ynmuj8؄A(h<mlF;+WӇBBH_s/j;xH O 		 	 K P0;@ v0Cq[#;9tqC\ݒ%҂\~cjC&X4L]P|$nrG1uC[4UL]P|b"%(.(wo؏@H!{3"PVA~G8#D8xp$p*d-l+r"]$b,B@D=SA{;ٝMr;3yf8EI&|j6j;$'% O.+o҄&-^fK4ւе=lWHZhODj}ϑ+J=ta	k`n_7iL:+cв.Dtma;/
؀V+XЈOS@)}%MyKP ΣY):3Cx AR-lhXNO/.|aS[/'
W6 䏉qVP{G$X-6lRW)%7#7YzfL?	R8]4Hj=]'ϝns&=EGt_lE	8S ͹HBj(1m-'P`'.?}p7*JqJQ;0m8β`hfkC<J~v1ml8dOWʹ g},uil>9sw8i>\} ٌ;C*0U"5E'tbRxhD-HA=O<0?C0mR1cb(GAl]')"7EcH :uA]\JR:Pq$Z7ߤNrBI{	C~/":Y
`*m"i`HLHYVc@ 
z)J]NrJѱƑw8 ƢM6Dn&^,znōҼ͵\.<Bz$Ŋ6\de@Z?7WP h2@ga 4[ 4<"W!N{p1֨N5jImōbZԈ)Q<j<#ķ}E^@!1i_ksZܙ=KP[+NPA(1v d,[AI"9:ji^miJpJ>Krhڋʩ`hؓJr=j ꌀSmzvi#
vn%- 37fAgOWSGԸRTEs4N@xW9lH(H!rt\^s,d-g]
5T@K(Ha3^C2NR.?^JńmbhY^b7Dz sRIP4B[BjICjHnt/!?TVP9dnh|K5uZY_($ZdB*&5:lg@Ή/>P1%vZoSdZhԛ1
@E%97H*7H;Alv	x -,oū1/J≐ji'/w@z,E-( {1У'.Q[_  °S8aTjFD$Sh:d%t"3wf8IOfT y)pR "`ip+ # 01
  @Q08S-,ʤLZl2)ʻ~z;-`Lvő"
Aذ₈0zax	B HKз>}K$9#z",2A$"x0^ٯ+LѰ^UjxUtCB yVDK^Ѽ,P0Gg6?x2gߜ]cvb6{p g6١k%fL. >O.,֍҆/@EK # {`[VF]Dڵ툊G!'QmuTC*B*>l @B@8؋A@`X['|"-g%<=s@"~n+~ @aƯI `M祍R.]K60&`|`Ln0`&.G7OZ4݀[ m6vtc*oeqi$sxBW
}s>Lmm{	"e"QZ,4k'F[	2&QPe*|H tAHa={|;ۍG@Yj&\b0ec밎"`Y&VhI*+ҾLٶ3i7|K
@Sn8Q۶ݳ@D,ӃL L'AY&1k?U@:C,v"Ez  iCk	ra>bCHN	HaMPU&o1ps1ܢ
t,^NP(D!MLֲ8>",4Xh^{theZΐ  FM'!duD/ҧ􃳀Ԍ Y _S	x$I2	LF`$lv`-E Cn,w(-$GIIOr%,ڧ8b# 
$#`cς:d͝I<仠F n셂4
jpCrB mVAla#$A*JdL Kq	gnYo#9_(N6*.D: m!gjȘ(t^lkv& ngiQӃw>m	ra끙u=cS>pCr@@dAlDQdO _oI1p`.ŭ3 RdXmy2v7BONjH60 nOUXd0$E<tl-!)s:t<cr_T@LL#xn޼];((BD,A+ՔLJ&Vn4[@"G|իD;P9ߙz7\IN\pvf'U{]VE@0kd;
(g!x`7E@4
dWK+# 7zo#e$q#W#M#8.ƸWWd# (t?sm#B&:6x}j.kE #";a8 mb [AL$Ċk,VT %#0
  h-#o#b:!BuI0J@+
WFlLP2 0*P@h0
(Nۈ<B 4D?DЪH?/~9-1i-,
ޗ~J !8VQX 8`#z 	ZuVeDiodm5POPB*D"B`4a"FSDML	CU" .Л+`8@h0
	P1mXC kn!{B9B%Cah0
avR~sx
!ۆu+/ߍFc
cKcP־O4FiO2C("
/o
(@7XU@V] "p#5V3D@P~vHM41Zkhb&!d'F)'&gg[uFoX>׷b11g wz |'F?]p@EIcsVGsKfa6"<m8AB`p9<RC z]L%;\xz*ЋLZ@ӝzDh`M?M8[rɐZ塓a	׊!0cY(#X,Xl{m @>|TΩp׊fNF`b)"p'F)#K	/i'83ap_!bITmغk~,I\N=RxS4J#FzT,E>9Z;Z?oo(rhRNkl7%lh@ `:9$|F h~۵,ZRy;j!x.2_N=R3b8/#W"*9`Kr*fkEK=/ VZt{1vg}_V"Pom|݉I[b7P;ۈt*(^>   -$Ft
JGDJ{pR@6a8$"CQ_PO`')RM  88Pu9'43\ry{\ޤ[s3`m9,̏ XsT`N	2c pd00?W P`̏U %(1?fY@c (??fL@cy 8*ۑU (
<,F Q) (I
 
4+ HR@ )\cR l>q4" VVV>n
~vX_]zx nr=GYRm5^ϫI@oyʷT1 @XBN=If\F}_&Ź^2[Qdk,dA\kSNt( (OѾI2`N]XS HY@$.kn
 )aE$s3=ɀ^L( (o$6KRy~(\k/ ` @
 (  } P  ) @
 s{LPj@
TaWLc=6)P_iQ0?
 )7B~TCcjrN}q`/:MDc=^Lxz.4cV5K\/*௞~k.5Q Hb{LհR<+ |Ћ+G
$ۦpѡ *R H R   } R ) @
 @*twC2pAc R`3p
hZ\d
 )}*[`eF}Ax?дn|_,?fC`k,K=Vto4-V&1;
 )3"(wdǌ( l* 1#Ѓph̴XR|?@
ě~ذU|n-K}o8?y}    ) @
4  H R `_q
 )`H@ SRshMV7{9&tj iKM6Y
 
)`kL
L6- )a{Mf] VojFӣMfY@<jgYV H,[gU HU<3  } ( (}i} r:
\ W6ZJ_v)(\d.A(BDM(!ygFf_lވ
_x  HDD *`6   T0KcIh=;n maƬ)
 PB
c* @g;̘Țز#[9:墡ܺ
Ǆ6&y
 P0wrqx)A%)HJuJ
 Pq3#N;r.>r>&`w0\\g _
=!*OHa*P IRK @&Cf6(O餃;r͙ԭ&QT Y P@2?a L6}XCY%8*jNqVm
 #Ӕ#
ݽ#@ nB 5<{Erdō*㳇B=$9MZP0ˀe.^ZR=R<u</AADDHUX&KN4mY&O6L~w~2|t'@wx0g) 8;H@
Ȁ0<"Wc-|5@
d{3.^j^/*`xXH_L~
 )_n/⓫QbjW*zC+M szQx
 )0?ȕR@&VRRMhXˢ5L ~޸.E=cnb<wM5V?4)P&ō!* |G0nVI^⤨(@~V\hq83mh~[_ P;  ) (1 P` R    HKHYz 7"uvY 
 )/̬I7C T
X=k@
dﰳp5ԌSEC\T{x?םIfێ],f:g*i uiH="11T+ٗ:jhVo䙕"4i R@%I	ƩRwhVTk~GE{Oǚ#ۤ ?S5ļ:>ȋV*`0 R@77N5Q+L~F^#T P;y=uF~.p,j(`޸Yf~b
 
a@;L
 
H R   . P HqyESmR H㛳V HI2IvT `6blW4вH5ɞq(i#cj@
L	|U4@
TpRV_F_[  gͅit#XnXun=:X<G"^:@_   ) @
&@
    )p )@
Ms֊ nj|pABN  ~d/=5cujt)  jy_V{h9Y@
nNb6~TͲ Zc:W@;6P@: Ȣ;BkW 9x.=mȪzǉU_X%0hWa-	ާQsA.J'"88T`A\}ι</n0H $ Ȅ@ @&$  	2! H $		@ H $@O**@	Ъ&)@ @&$  	2! H $		@ LH $  	dB  H  	@ H $	@@7# Hi%H $  	dB dH $  	\9	 y,;$Pe&_	 M&'	WH (@b!p$pbQ ({
0DaunٰaAELx<vSsmp, |;"5	[XXDXP|)~	umm4/D89m,,ędfsnλdfww|2/.vu.&[x]tAj072Ͼ}_  _l{4tX> dhd| CI-|B+slnspk"0wBqC@F\g
CqkLoB_# py</p@ ,EGGMu_CpIzmJ! 11DA18
	x^!I$tJ=D0NzF@r)+jK,J2h fHԛ,8U硙"l|wbBHC|1\'!C3T *SpoJxSV#  !ĚFd]`6#D xEHu'4	R.l&hxȎFP()FEk6yFnH&C@  /P#xZ;"%DB d_ȍJjsqL@LP-sCM|]FdF!`nLL&2Q-p6٥iqPsi:[tu5WBʬ?Fg?k;rNH S6@6W P kq	.^Ğ8M7r(wjۉ_XE ʁ h``sɾDༀ*,z 
ƇUU?Cskss_UN]Wm ?4,~r`o]DT])xa#dP͘B> 
};)kQCN:`J#%9E1ɉē׭/ۅ=0%TcјG	,-im
&;)Mnޝ$tuE
oQ
,+P	,rңLT1$U@0ΕңGW7_ݷۛ)1xͣF	<UWsZq&2?(*Tpr#N!9H]Q0Tj"*Wn#E1C%&o)yR]4[&Cj̢>ywe)]/c{Eu~TTE
\+% qȵ*q~`vQa٭/6񷈾 7s4BAF(RR@m8{]Q+0	b%␫:q*F!@%&A)iU|ӋS1Qʜ*@	V=!Ne绅W6F%;Vc.wEA(>TC`\ՓT1EoZIJPi3="nUL*MQs__a(`.8bJ</pq2OE#IC-2vHo`9c>ۛNNnl)7eBq[]o+]$m}|m 4tWtx:Q۫mL|( $\y/@|>_&G  B"W#G 6ORo 5[^p <b󗀉'.хA`22qu\o
zB A3:^$@H2@>IBĹ@M_S `seZeYM 2@4S"@ A}: (l(0"SEI9{lpc\bm v&a`
404Aj%3{|@H` X ,  nz竚<O6I\!h@W
U3Ssa.
05X蹙Adը)eET,13Q5W3^a0(쥐HӍx?q_ݧ/ʾ60| 	MIPЌ38)`:<r|plF Ӡ(K0|!BS]B@	HB@HB NP 4X'py^Jz$!ЭeO_h*qK'8]Vt;}"p-% =asX g0 PW!ɾDa\fqdtK0x18dH^<XAй	!C&7tR*(]
e	iR(
Ir >8>,fok_av`*@wB_1!bUM)?m[koUsЮ5s^E3,`nkk:8ItqO
܉|a}EZs&Q	y
{aē3BH=W^|<mOKQ A 5
_EmUAZ@Ik@PֽUiPPnT͜
x"*Q<OWԪ/
x0 +V%Hq?*I)W AJQh ]Nմkr T?l(0¸깝C7m8T '3'[5(@*-OZV+:"=*pQS`m:q@P2`/``HtXpv,Y]cG'<{_;;0L`V`<+9s0"iu}o}ĐAbH!˃DH!z2 	@ 	& :  z]P	5Ί+NbX
@!_}H N=JwJ H'u!axO!ACZ,R,@¢xᇙ{'2,	%>ڲ$ Voٷ^c:,@w"kX cIw^CsD   e.G|B*ul Q-$3ݰ!i*X\%VȡoW<k+|0ܥ	TqpduZxPb   vPXJO6 0 ٖ[0]o]Rxȷpk}Fݕ&qHoth  m,Z@P;+-DPRDDV15ub    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_link2_thumb.png
PNG

   IHDR         4   0PLTEXEvurp`b꒗{򷸵Ѻًi  IDATx^AkGa~#$Jshǂ&RPgѰX9K	.Y$T(=ԕӒh:[OPUx=RkwNgvWe؇9. 8u( 0S67;Szvҥr	@asD)JԦ\:fzzUrک/ϖ(>Bs7BRңZXWwj6kSbx	]81sqO^a6?x2pt SC3~/ۓBalq};v'M/~>qEBǁnYJf7.-qoA"BhF`AC2iaZ]hwخBrp%Q7Hi*&~vJ̦LꅔJ(I"QKM6S"gd^v-@x&@H.	5iY߼xsy0BvcetjG۶3X Rn.xHe:R.f^>KvH=F2H4~c&0[. QU-,)lqbAQ(PBE	W3m8ࡡ|he(TVEEUUH|TP6,F~H)cT1X<Kv'Fw#[!0 (d&L4F	sßbaJg`#
XHps}>E3bagʚ#$n6ZLy @X9'̗-P94l]@{*4zV0IkiaaD$/ħTi~Q{YE˞
\>w=ȟ<&|*ljTͻ+:6rP)gr760-ԅ6cʟE#/c Bh
! =_,ן4!=xOV0wa&{>9gK{\5 p^LF,X%	ܟ
#r	a8t(<2s
T#	̙&$Dۗ}vC]
c6g^0߻mA^ԵyzV<1v'BA{:Y;Ao+'_`c'49غ>Z]ۯ(~)O!Eo^a	ezrl)O 4{`Hb7=K&7YV`Vd	V? }/eb/o rYƉ?q۲{).	,j˱N,2e7! Ȯ(
WY_$}ivfǓ2 ^[{ټcazzSl҅Jv
ǩgƥB/[X{UN'M)N߸m[T^/N;Btvj@m:5B,`*432!,~	'*'$jƓe
2q
ؿ'jӸja.iAZЂCr"har(-@@2"+0$#)m@VPbN+T	~
p` qQ}JT4;{P,<;r%2%ѽU1}Ņ4xwkdMy#ް;#B$#q!/!2ɤ-h'2?M    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_pch4.png
PNG

   IHDR       Li#  PLTE    4  : R Y a h  7  ;  !8 8.5 ^W a ;eW 2h  ` 7Y Zg : h f.89 5`,/: 6/0B ;32[01w20}V2099h;7c89225 BEOg9f R; ]^9:IMj af[\2km7_[[uge Q dd:_cfFdcebY4cgj_lmj zlmnpme17`1ݼz/aȇ 7̈6UXV8܏8Uژ^큤5bwݮS]Uټ{bƉшי໔Άϼѭؼݙ܍ܬߵUWTLQSOTVDGIPNRؚVκJKHt--x]_\Y\_ZUTy0RUb߄ٜV /u1 Wrtqzذf1- z0 686۬Ŋ7db6q,.N 1ڲҼvvjknE)  7IDATx^n1efZԙjv͓z(tH:݃8OO397`nͮ / ڍ[2l60}af+{&,t}<y D)%Q>;V7w+:ݷ8Q^1 VP6Rڃ$!fbY)%ѥª/ ")h9)CII;u1F嶄[
"H kBt?9zpK<{RD?B-!4}=Z#pۭҺ94WZqPSU[}qrN7Û@<	b>CxW9@:,RHƨ4|wB<JP&)eyxbYw^:\EY OPWlmekwa&(BYZ'bJtAKLI4="C7`GiqZO#VjvRJ'8Ti%Y˨0lm)!'u !R~om\QVL!a.\vv^b7r{0ddAEF3BX]4.i*	Fj.3w|Gxf1T\;!|sͺ!l
V9/mqӃ)tLgߟ2d2r"ŬF]<!xʹ{=ԃم{4+J^+XXx]l׊6 :Q.Am]Qt kER 5/69-B,6._,¡
n2c(.Y9(7
l@`	W@Q(ue@8j&V#+QH6"!ƌ
Tʿ:csض]*DVJf.j2zVl RnpՁ ˨m;%T ) "H!J@^}IeL(pc  ،B(%6BW54)*`h$ tvtPD"yWȪbZbdEQnX]Ȱ@7E)ꔑDAdI #
L$@%u 4f=×SUvn3eRYQV(RT)wA=­.򎣬5fX# @q$"(  X~S T_Q'DESd4㑥&c! DB!1*@U)C *M_bTAQE\K'_;QD8?? g
l:bV\'fLi
ai/ix-sM5ᮦ VIRspJWpHcxWQFЪnRHX)Mӫ56.Q`$ ap	؁FwMR@8)L* l4HhļgCk:7Ƚ'5@]"apƏ5^HPJ 	 0 L `@4~;79RV7	雐zG Kbxk>=Q`0%ȅ(pntݚDWSddk)nI-;\F\hxs&˂DD@e"U $SjW M"$IRF*0Kl>&Q`שZ$Vkc:oRX23s=iai>{ŁXn$
@J
r "2=+qhYzzM@.l=O!J;b G	H
۾
4 |33Nߤ4dpl|%4)f(Vt*0$
 }9 
P8ѫ Q 
 OxPUT -N@,P&8wѷh
lN:N
`-/ѭVcIi(C}qx!X]z/Et*-w;ȖSRc;iI}A88e%
 R̫UnH:PXٟZY{zdf#P	m%q\IW[Y֦i.L
(p~1@=yA!l~ȸ

IƦ )M 	'Ǆ+K$
L	޽7+`C> +pnѩ Q`C30tnC 
4 7DMp<	2 <]zVٯO0z',@ 'ABг.tptb*25Bp-Xt.@P'| F,C3RWkV70Ǫ:U,:A}{ QT`$Ē 9g EQO+SYzv &Xܔb2pP])GD
=,fwX#UHLgWQ>#
X|O*1}{1Ep } -qM\conn%K,&r~"qHhGiXh=D{cAV%<yGA (£yj'pA+c1 jnoma``c H	+XX  UQ 	?+4
E	ChjC$w׸2w2
E˧8mMDt5JDGo!ȕJ7yUǀxMtr'B61R]'p7p?wc$&zJ	NH8-
߻r. Q©?w%@M)' R ~	nĉ'
dSLEl +m+	Zmq![
bBP{

WN&zs$cw޼yyvk5&gf
Ą&|\Rν:roԋxɢc?AZ!TmJc]Y$m+sQj<>w(@/~hKyE;jJ_) ohb ?Y)YbtMagS85XPM駀RsSj읊?Kǀ.o5>31
i/5
6XcƥxrGtd漩a/I݉g4`#jX>^rm\mlRPk6u
!EN&$нқ7F[$!XP𻉛i"֝:'+}(1wil Ǧ^.̅Rstަ@
<t
lWM8j Rrf3I,˶wa;7ĕɶWlptifeXJ{0(Lq6l0	}RYp=OH{@¦@?tHGRst1k0JD:X04ꪩ0 ~ qP}U;!udxm?7{ 9E9Y(3]},~ 6ګU*I!H<E4w?%ܐ0ٙم73.ʉh=))}hD1<	I<s#)a @{|QRJV%/s$J%J(Yba#mj&G)䔷Z|ˣʿϟνw:,7t k A ea9@+a8)` u0vMLb9+ݖ76ҦFdS&X5B r?/BiRLWT)Nsz?ܝ=K3A% T`e WT
@:?CP|AӋՕQ$	!Ba@,LͲf%x&'arni *g pڳ@Y}i sOb@I@IV`9,V QeAYӝ	W`5LjUh4Y3GzM-pQ\nfm2Qib4.,okH]98ϗrHqzi<.p9e 1\P" 'qCFR@AnM·DIi}Nn-
wdO"E!_h
@*+_@m4Dh֓np/!~QS=7(rCJ1W}}y=lАзkWxǅ"EQ-*
Y?M!EJ Z*vEMn@KY=WXYUX?"o2D4X?`~/B@ODuGM5(ՌS(|PH.P-Ԑ@:8N]Eu!@akmH^`}M.EMD_L`řwF.\@p!|$A s! H $Pn> a ݵ<sb3ZŢXbwG?a/' z;G 7!0A9ċaYgG	ʂB (
E9l>vzē""TdEWAVuUc2d^/ס3] Z{kgsQ:eAN!!`0g-+;8VM5G[A%#QL *
-6 7׊jhȑM7-W)K·*oLF5^%PrTA;,tசa3ͩRv1UۯSja.@vXryYn쮟)U%@1w3uXn;XfN-e1~/yԅe9X8:/iΆBo[V9
B@Nb/lbz>-k0w2o7U8RW

<P?_kdqH5jJeVi:[0#^ev'^U/X{%#^(Y`d>qh%Ä0p.g+		ŗyJBv<6K[p2},m4sqH!Xvi*;|@[>.4BHvݠn6~E%xh]j Xu9c[dMX7\d#& oRýMsB(6dqygJB'W@;{Oxv$}{ÃVC@
F8ysi5`(@"{,<?ڙ,(CD?BaARx&7GA<.pCX!\q\VB0_DEࣙYZ., ;|r| eT+0;UCԯiRxL: #<?ŵ4!@;l0Ww><88`M^b!#+>qhA0B1S=T2'$pF Ā}"D{YO7`P{j\26XC@!).pSSm-A " H/5+"
b<_Hȿǃ+@Yd#wNPڅ@/Sspvo*Cch
O%GU*;j~_u_ko"LLni3vZ;ӦB1 qXvXx#lo^B7+$=c7v۠$?Nm1nfg'FGೠ!egRI-W÷^N_MD `$3\<A36ӐԺٳ1ҟV~/j!~33cX@-vXӏ>gY
mLkP㲖S	#`U8n!Y,@VdFnF@^?Z&eЩq!YO0± }^ME 5ҁ͆  Ϥe#eXSwXFCӃTNE}Ur}Hta,!E)C}Q&{7w5H@{8+gQvd^"K"tA*rpG B _!']BN@u·^FM3+ADH?_RK:"KYhv 
ǎb<gd&)"YN_C
y2sAW)D-V"H#±4T>t@}TOa˓xEEWP>3&ذ<SG}E[Mo"mY`u.F$|,uD8
D"';GBMDJR.  'EUa":2G/iˠM8vznP	0~j_5" BPҐt
tmQ3# 5zη2Z+Y yFhmuE>XY`z[]⊖߄!,R
܃J]߹׶S(MP"!pb0Y<&'֡D2`A ;'GνәL0Y 	wd@-=h_ N";18w[`2B- ڈN
~`x{͕潜\SIτu"&˽˵V.<	" z?fl	"`XXLQcYP@q)א8< qsu!W;/V1cz> bMb{ԁ@q)Wn]:CWo[oE eny k`:CW*g.#P5m M  .0p.$,Q7	7]6m"Gl^9Ӣ,еʋ}ԧth/fsz gl7c8;_9orpÏϴV}Fg6B~IߩĶse=2Y롷]ȇ޿wyǺB'p'	u)^Fo6^b9Ӳ,צNEx4	G@+Xh/F\G!`o6߽ĶsE=2YM}h `@& ! &'.C ɗو#໗vδG# mȰ)rz/ ǏGy6x	C ɗGw/iYG@AE!gO L$;}OuN@y3FײG3Bt)c )"Ȼ$X)c ǈ +'Bǈ@"ǈ@51xb"?~$rdMev_@Hɚ~(#a.`7N@ |/#a.`7NĀ .D1"&pM;@@QrUhbɺ 'E@CCĠM?P& Ф%&ML'.@ `@XD,]45;Se-p'B%2wqORc}" [cg2EDM=1lUv Ѧ`JABkLF
c^*
&a  ]膣Ȱ14;+@`PR^MXYX%  쬺HشJhW [c`"}#$@nȰu{q,"Jqq0|SSb\G`I,`]P ׷:;KuH+a$/"XT0{1R'wf^|.w_W<FΌ>ygR (kC* T  
 U PP|* @ 
 P:PI( (0#D$% >'* Tω3͹\g{Y": ~<^hzh4̆u:;T:X @6cO:MR*6S P>)>'.=(I}(C@жI>=0鸥Z:A 's,j4L;Y$>d ߘJhCr @$S@V@;VsoG$
J(V%M
 
,߼l8f }YaHU P`a:ѳ ӯk*dt: ?
 
Yz(LYFt@6/S PքVȽwt8]'Tϣw4!&Oâe@[Yk,FhrYXk̇)*:]ͶYТXt ߚX6WfL0fa? W P`+X|S
 U`urE\k̞ NkL7B>_bǢ) (pWňge[_?U@KNߝ}S@p;{^H6/ (И3
$[*0VvPBU PZ:U PgQ
 
T ( U *`_Pp3c4َR zy/Yy,v@(46T!M
 
|+TMd;N
HemטN4R 850o}T&
 ;`4 :M-JS P ʗCη+A@4@1 1@ѳ2x* 6
|ch4flhO; X+>B3V@u!j'zԟ9szyQ|Tt[
 yyV(qё.՟ XuQ Xr[]!T?sd]2粓#Y6d/8\T@'^Ͳu7C?pϮ j+{婡pnp锼O~`.e)E#=gУN7\+ᶪ 8
(8>'Ͱȓȕ.=pjNOd
1Ԏbh7{7TtQ@S?t
萮ik#(8)* {! {Fz
)gr: @v'tXLp ,88,WJ쌛!{"0{6 >hlA(aO"Q@F}SZ 'Q@)a8ydAAH4;(Àﴭ U P *PL_ww@G˽*a∟(S@!j[( (._lw?Zr#\j9f3:
 U@ǸZp&m5H,`VPRqU `^bЖc}.U '(* УC7B@0]VM1ZL7B#
cJ* (~.0_8#EL>e+ (H 
 U *@^ + @ 
 ÿߌ^-k ۿ5lb+ (&*a fZ/lZ3d++ (0%DT*G@CŨU/OΛ\iMVRYV1[ʢ]k7&c6ZA9s1]~)z[glp^Xȅ*RQTMZkj"E͛b._ R0
ؐ	G%J||h̦\@k݈eٮe% DKiB,}_{`d
͡mT @*AlV\*L:~c
{]O@@.}Kc0sNkS@%x
 
h4?Xn̽-l%/(T%M
 Ue4 
GRoӉ ݘ~]XK
 
Yz(LI
 
ܚH
 
P>[0.3M./) (plBA&͸UZVB@H
x\I`oMI5^]U@X\6bVy6V%1(lGVM骒 SbԳ@"?'_./MN* (p\X&bfB*NakQT PT<vzg/_R7Bξ)|3/0f3lsrpfl3]U+wg sFBxWM6;(px F 
(* @ 
PL'OݘCX* TQy8
t
 y?~S^% @6|b>EɱQ  0hg\e!E17VqɲT aCfܣ_e۩ ~M.^jL)
Nۦ gf3/PZ+nLe 8+|z޿6]Sdq/d3(_X5(pR H'Bde"i,l1žA	TVJ4I0w1s|?H`~P@-2@*3$pyW;	 f[&	 &~ XI`l H`t@,q	>E4j	ש	 rM 	\/E@?^f	 ~.	 wnvx].4$.%$$)	Jnx
,6%,$=M 	lJJH@8"	@w!V H $
	@ LH $0	%$ 	!IK 	 H` 8h! H $		@ H`8,!	 "H` x+1C  H  	@ H $ Ȅ@ @&$ H@ 0$H 	,$hO*w/$  	~ BAUB $4@#P($%P0|C\%  	 H ǞHqxRIBV"$!y!XCTA=C<!HrAN`@'lHP$$gyә&-c;3}}WVU
; 
@   @ X~s"J	䃹dEiQG (Pjب7UXr 
ͫnlاr8wE hmmIDY,7
4mf
#Iu 	qҺ
hmE	fl~c	@2@7sB /OH	|)tA*rہЋZU*@L<4*SܴHT.R[*j;ՎP6lrwr΃%&rMFJK
HDnJU2VV@koPCZ VP@iB;ĐEil1mx%@W/ eZRUCf P@ <sh$r+eQ2
h;lH8})V3KlR 8:'0G P @   P  (p (    
4smvKs݁wc~嫛2clUY[&ҷ;ڏs %F(eh(F+0<~[0Yzkޙkg<{o{~o	(3vq"
¸X"Xi Xؤ5V[XX[ZوUbae韐J,lyvy\q!py&|ͼNv^'=bO;h캅S@Rx'p936ֲq%:5SvH,~b)$gJO~ңo>-ĔSa-{!C/l$LkUwޡR]upTwIT)EQ@5K2K6S8T1eb f"l87HfƯa.oĘqhoBb{"ޮB7@9	C%ة&r2Ri!О1y+M;YL
]c_J(c;t(<I	>W	T)
rp@g 1צbK '9JaG1.pb,@%/PPa
P}{:
r&>X8DsU'"Rv9D~h$49oڵ/zbJ18j^:Vo5!Ne鉶a\{H@]}1» a*C1WV,U@51򛗀bTlJ)YeI8j*5Mp^l17Al0| hYM ?&?1^6 No{xD|s	d$uWM@n:	@ H*C  H MH $  			@ 4! H $&$)$pgm 0
Ŭj[@0 [TvH͕(Nqұle
7	`O6Q il	h $_Q - LϽ,--  ` X ,\-b-ku?hŴ\>~JLk2~J2z,cq :AA%!XA0k@ fo@LRDqz)D[Y<1^F (C^) c>-RȠ(FNW
m0mf4 	Xi(%Mk<&PRq]	(4>aR|&tP ڙ0 ]e~2P'sUXN dU" pҩc6!B8d3-
E(d_vOIN|P!4$㜶4UXEE>mWB%QYTq6o"Q+U\B$l_Z7&	 7t59!5n}Dss?Kq<wO H[:OKz\	y 3}3-:B`|PD0H*ӌp5+a~VGJ #" ;%\.~M  A2;O[r	Pm[$PJ@<z5bYCHm=J ?XŻ	cfQ0
cj30)Sa+0z5^Dp2`(	 w>VobMSP)bO?$4_WY$sC .  H    `9]
l 6)RE9IHac!G #}	ܖ@^	@D,d_&@;ϡ΍qx	&ԅ!oO f[Ǖ@{
yK Hji=u%cbK 8|fm Ĺ'ul QIBRqKWpAFpIcsNqvx?gRiCJ?p(RRl=}_y     8A>deM  ZMre\"\֠z uV13$_xwMgrO& 0 `if$<c#8v8>ഀ !VF&U    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_pch1_thumb.png
PNG

   IHDR         N.   PLTE%$:RdW]icvzraq߆ᶢa؁ԭкpmmCBOj\efsz|øLLIڴOCڝ$&N͎}FV())Ba  IDATx^[n0aέwUjM`"y~Zv|B?ʝۡ8_s2JOl;;d_."Ka]Xs2ݎffD!@!@2<gXay"
<}9Q3s:7) !h%j$iʑ|WGx&1P9gm%s]gq!2CV%u/PQ:]o X9s&Hw5M?M{bx75۶вDU7F4z2K{Q3zNN= )> H	fz\|l"I8.L!ՠul]xkR6w]1_6K'DmEBv ͬrgJ]s&76ϻYMJwM&lM~ϭpޞGhqcзg:12zݰҵ]>뻍Y;lk673.ϯ']<X_
6١8%Om?I6M84|+!\Ui:]d
&}?@댄h	1\3u0*;0./@m7Hi N\'zzx48PEvfmTrQc0*qCA3M>̗ Fê,N$yFnn^R@&Ox<1(	dQȀD(Ya]dOÇr}6?MD/΀|P"<hCM!Z/ @dV[. b:At~<#jT;\uRr>߁O:D<vXtٗ,Z_PꉶrnQvldKU878RB{ƌo9 0t^uCZr7E,ؙUHJ< {"  B@`BDx4프9V'+G90t:"J
i	]%$4"#m@ؾ/#YLvƴ(rB/:G!A#h\EASM%.*~&F<@aa!OiЦfs~A2!v~$dN57!i$@&A.D.6D}`aKeئtГT3vk U!̲u&%[uQ4|*@Ueg@U
ݬnpV5KL>0<k0{PPl2M66e?gf"oe2Q$o[hnYQl8FSr4E.A^o0'YV{NJG\^R+5ZNqzkpDJe1.}Ĕ?15p~\>h}J:ggب޶Fۚsw20,0rf<gؤIonG% $ $-B#*MJ!r,0i*t^VVRYODE"PBFƦKx2u}U^,HB4=1[ԚH$Kp\y-RyUzakzw |E_iZWWi]Z6}lUUa ,`-	tǪ4\(p,L9u%@`U)O/ZVQY؋J"L+4k0fH+@UDggr1^Y+RY5QU)0>b^07JіwȘb%x}7p+ΣQ Tb5p+J?5u~m+`s)Q!`I  ICz97jI@)%nm	%A"@}J6oۗA~_/$r~MۃD.p^.Z b7{}5"\+Mg-P]{stFtFlA3|dߕo܋|9?B<TBY)Pک@@Ê#Prɜ *2H"@A	&l`eE.w@ҁen,Z'!_bXcXNwĀҡ(G>hڭ?^K뗞t@k1PΦ)p	%T"'I(F&	^L- 94cpnˏL&MӨV`_I?u9)0*Lv+zl f PF)a4}$
__|rug):O> >h((ֵ;:(PzIِHt|{l#˦_qm6pƞ\\aLhĊ{[cV\?	C{Cbm!@fώI!p'Bq(>'\m7cGPVO@$lugyfŰ*"%!	4 Sj6;ٽdAm5&R(v/ 3
0 Lg"0o1%^4]'I=x{BCVm+
zt
GoB|,M<Gs@:3r25S^|Q	v83(AfK&Wq̅ױqwN@%Ⱥz=[!0SJG#q/vMs1d`]yM4@2+t`]c^d&P]#\ `Vّ"ٍYSdۻ}P=T"&6uUl<&ܷ (%{S X*&_}`G:EuSY fL($PXʉ#4׆@FN.즲/|;e$PJb(B7O%PFGW+<2{\9A1YysD'˛lTe~fm|Ҵ !cYPpK˘`WR">zAPA)UTE2u  KI-0k1(dEȵF+r":|g '#`u:,daMGdնevgcF6=l	&MtQV꧛Vv #g 10 ݂өl=3ZI?dܴY0'k,:$Vv'@f611!ԊiƔnIhTonMӱ|O*/)?+5ʺ|rJf	 ܟM&8b/w_,}B'.??GQ j >ۜ|
Au-s>	NU؄IӋ>kE,|Y{?h]/8dE'Bڋ 9Ș5]YUDG'}M_b`qtQ!!`bţkd;JrdBո:L:t# 	 ƪrFηO4)$\2nzţ7CYaPp@om*IDoO]gm4TO
]!*9xL9AAVva"DiUT/{#DUduo+mm\Xyf.)8/,99Ln[j+ETIBsEӂdҤ!\w]5A)rgz-XЯs bΐ(W /VV9蠩.dmrARךֻ.Z~<t|OVrtq͢@G|K\m*hǀW5XI2Zhc5!d;;}	S˵ٱ@:XA 0ja81WSqk"v](^Twg/e~͕w J%= @*oGQ(r]9#-"F˙R tEwxnzszyxDwPg1    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2010_link2_thumb.png
PNG

   IHDR         4   0PLTE7BYOS\[N>sz  IDATx^jH@?	y飡'K?d0Bβi(}3LR0BR(VH5YX!ٸ&3w./+VѨ=Ì
}ڨy|x7R#a$4QR 5`i`5\MJ747ĩakׄ`c;%ڪE(y8!xW}T..Q	ZyÆ,[B2K*%كc۷63Dɢ$FY$=wD1QEuΓAW]u)4$Fv»104jSVRj,Y982L\t=,}"iQ&*ca/TQ[pۡۯj<??a{h}<o[j*P+!c>3?(JϨO`xJE^XҚbjC	hȧgyYM]p,w\˺~Qf/&/`PbThL뇖	6RIuE>F=  Vb5
J߇Rv5lJ-XS d+4]Y4vUvv@[čαo)Nm%t[7ͿN7q"pS~>2o;iD%3n	kq8p<
IѾA%qSL?j0 =JAf}`pJ0[`Kv_enz%C)4!V
B#U,{0	\mcI>s
vdQ`wv()9svJ	6dÝ] #U'\-'ɳBCjX@ȊbJʓLB@oWC.<$aIa|G[O5Y/^p ~[	ZSaŇeߵfsRBu|)%/
p.̎
n~QMcB+`54MͤA>p&TE_>LYAg§s3ߝL ?+TBXJJZxZx_=»]B?CO׏ȏW;KgR0%sk\(_ %*,W-tl0@fZFR8+~	EB]|1&XaEY8Lz+e)Ńueaӹ{QMӲD@{	]/([[(xm^}sⲀ+*]Z!^S:ic
y>@.NuV\wrc>.ve!Jw݅ipӞlLvtV['9uB	ƀQKpi*%&AJ5,-Xq_vN$L:84/fj'Sqe3eHL=w{t.5$߿H#$ƃrYP $Wn9_\y4)iW[kƒd
nu`6;[?+<.Iۧubyɱ)\iD/#z10>'zt4lֽ޽;    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2010_link2.png
PNG

   IHDR       Li#   sRGB    PLTE   7 J  c 2)  7  6 84 aTc  S 1S Sb 8%:	z    | F",7 3u$0E/0/N-186`466 U* %6P0;Q<d562B]7BX5 T>8=EO9E[42X@?CFHg6G?FHEO|>J`ML2&O:c ]OQOGSj@TuOSV_VWURSZcC/B*cb8TN^`][bjWbvW ^3P@S6cgjZujAmfhe*yy xmolcqgrkje;_Btvsl7rsn1h}|}wSpX ayjg}wQj7~`ˆ5W͓p:gqێ8~`cM5ۜU_ӤQ~߫堔Ɵҫw%}׭ڧ]pƸ걣ټ{bцʷ滋ÿgÿ֫ՌǤϒχծֳؙ߳ع܍Xc   bKGD H   	pHYs    od   tIME6~h0    IDATx`hEU)?(ž4@WSc'j6tV"4Pr'vԕp.nÊzkݶk].+VbM癿gwgw~>3g~gyFGGGFa>uނ**;փ:*Xqڵ* 0C!WWupBPY9cƌPlcFR++f% /)Pƭi4qp0ݎDv:݅B	kwn`B" hWۈ]*Ac]b
BqI>۵~7_'ꫯ?}1B/~n^|T@vۻo</J~#:@B6$[1 vC(~+A5Ã<c <m+W.Yf:M  !0k,6EY₸<Krg_EzB}D"d
bX|q۹p07 YoZ˼O!xA~-EfK--~_F Qb }׈!4&!o߁XO}j@ ZRfK& D *%sSg{ɄB"@@d@AVAB ۏgA___,|"x=dbPeC$v.|PTfWO^BL`dFB]7b H |'om2*8rEh| 6/
쟦^? @V{+xf>x\` 2D܀۱k0J	h!@O > ~SEG,@.Hw8Ku J]n]&Dipp(be +dd N91qd	$({>9w:ݧ0~Y$7X
2sG47+!
$#< E^"ǬY84@(x<Eh;qD%:j`Q%p"c`@ x5 p9}+QQ@ y`Hqz|v
%+Un@ WԮ 7.p*w.ӫA>FsD2
ƌ"Ɩyo 17V. D@P"Op s/0"\qel/ܼu^f'FC "e 1媯pjw^#Z
pk @7l{4'Xaq+W^qW%A /vsl;q'Dn5#p.xʷP(D,?bܫ[SpYO"POu
d;DyNx/^+W]36  @B@D J3pԧ	OuwrR+>R`𰼣6$XGyqC&^p{/
R\, p] " HAfPp&vG@}$:D&"@9~[!29GȮ]#BqڿI9֘
=!v<wޑ󎟭#'G#ύ}B\wlڄ<l웃 NG"wr [!
ۈyuo.xkjA ";o_$!ZfdY!Bux+3_Ȫ gZߜ0r8O1"5dh4N]ȍff	x}&5Qh#O7d 50{KL5NC4ՒTIDDVg@ޯ\qc]eB[1<A ?RutHA@v$H'Nq:"CRL<AHaD(@|s*PW* P@uXxzqTGvs?'S$FC	Î]"ozC ]$=gD4$XO;vI:p@Y?i<oB7ֱ%ɟžYIUI 
%B 1L'E7	ʇ:#Y ]wI3Wwn #  7F P9#
E4<|rʎʠ@_P8>b "i@𼀂̀VEs}SPJOT̣I ̥[Q-Y!ZGu3f\Bň<SwJճkka~-~<.P&w8L:#("0B:Gi"(#@EP&P@kk/ -/e:}v@@2И<G(LA2F@&g.r}L@ `vI ʄA.P	{G	n-!3SA l5ďs	5Gfx[`a^#Cf:Ru.W
@IH~|K_A#/6 ?@s"P 6\0"2#jI!͚G3~odqj#VMXct0ιƭ1kdtoߣ?&{V&&ǖq߄uTqHn!p8<|~l4@ϻ=noxQk5nM&~qif&ƭjh[F`4#--1UV]IL3	|?	Rl V-@0xsVfxۙ# U\/|=%uTAG^S! tˌ˂4G% c46[MW>k@zQE0wIH},WmSg~D&`?,!G9bJ
:UIm40(=#jSѰ	(;5rQaG>̒<\24:&THmhxp\"[^Gg))fDZѳwߤg3,s_pDʣ=R<\2. z:t§3IsbP##5&	ު5m"z얛dC{C#P[Za.&P }^_`TVŌu4l"˛ޤvj
 >JazE5?F@&B<tԁN*"7	oiqfbXlTȎYGP|t)|0KpK f˙)Y6x.UuhWƱJoRHdE@F FD`ç@dttt4 Cr[.^cL؇muHǾCX!o
@4^`5sI1@t.AP&"B"D  (D "B!("(Yᯊ"BP(D@RGԘַqrJ7fkVTLb'' rud͝U1هN1
n Z)@}&cNNl`YtlWRoZ];wzȪ*B!i j!3p%"ph@w~b *WRq}QR/E`qs*`6H*Y4҂*?mXEZNdz?j"~"h#+&$9/Ï$;ZnEEJGv|KΊ@D LoɆ菓sC9P(,dX&5J<k':Rp*tS1O5"1I/0l6NcƈFȖ[agD wR9$ND Jx
媄dRZExKo̷tӰnLc?֧!Qy#ݚd`'NErm?}RuX>R&`kB4.# "Z)-xjWy\ixWS6~j`{~BXŮAvjN7E6}	fye=4رrQ\@>ɁП'5*W$3x H!(hDzb!rWao!YE"ZQQ	Kx?4~L"283j{N\b 9t+BY#`pZ6`;&Uz`F\;҄ߏoSܥw!P
iTHW-H.ӋqybXjV@m%)G*Њ|<3݁u`~-FT쪠i#tB #04Gxfd f*Xa1ԕ0(LYWE}yaTLR5KEERu[4 R U:^fr(D @! *W`@ *;Hk0FpCяsDyT)@Ed=]BTA`O!>"*7I \~6LMy!if1m'7tm??|S2 Hh͹  ӝI?;'_?܃*/~FAP h)ݙx%CRA?|St:2j&.Tɉp@(2x#<o@Zi?L~ob:w-!sŽm=;Yb=I<Iz(,v:=z{{zewgoEN'@;#t=uhoE-dH|Fiq\;7UlE]*|}KP%'Ux<0WKJvqW/BI?yc{[ƪݓ^XIn'*OwO?cI\"G>q7LHVBAmm]
h8fSGxXxCd){0N[fTLxnbit70|TXt1[٫,bae555[ ^=@@2gSG8/!n!VMoW67O{<: BZK?l# pdb}oW˒i↦Nd"D@.(Oy`N޲<ǬzWBGqXb@@سp~ڴHdt
m(yA-ef(g6[27#kM[bi?`8UAv;krkΎ.MvAE歭0BNeWmm/FjQZAnuU=
&	np-OgJb;C"
uv",|^ij]:mf0gv9vti $M C@AggBOnyXȄՁ~ ZBԓl^`BNt@ U zi0ubs7$(1qb?I$/#v͘$v LAbWЙ"
k@tB[XۡJLB!]@nCn5ڴ 7 cw	% H}=	5 05Lk׮I,Hȋ/S_F; wC8L'Uv
0@q;x\.g2^2jft8}}r8H1t
DRɬ?ͫd mzܐ§J9p퓲S z>$Jڀ~	xy}422iZTB@%'t6;qʏ}n%05Ɵںc }$>HXpy>y>-uƽ
D-^JkN!B0DB.[  ,gNN8V 0|VkD5$ @Ӵde@* t/uj"G
_5gO@5B	f	!Q<N]@@p	ewU 6ٍa@@^ ;AC 4׫]_
jO9
~[emiiF` 8HVAEsbaV}8x~2;zV2qb8(dj<-@pI¥ֶֶVjiH{ǔ&"=?S7Y4ۣ*%`v_׿*
_sQ_s/]a|׳>c=]v$@aZ<YvqkgKCECA༗D:K1n+ ~@H(=76MQ7㋤_!MY &Y$} @/rk0 !@!RpyC|$:<׉T㢳xt\C^m۱:;7?uD~j/, yԧ a
umv) JbPS7]W!f(	1Һ pA荦k,qrL^5ֵ߸ӟW0ѺoA3{V/qy/-#A29Zq ryIܴvB5fwtt+H[V!jS,#uIEEIi+4	^ =gm Y+	~CqX5~Nn8\K*:\
';EFߖNG#}Ht] h}+W]}UU o+CM{ec5J E2h`5hlJyU(h%@r4uRZfg  mTe+DD7wV
z -фcCkx2Lf+W|/ f 6ew uIcn5^q2)5Io'f@uZ`' Pt?a|';N[wq+Xzhɛ|1q$Ca$yTx66-wg׼+F:.@ @N@,(y=@Z@uE"y֦ ::%C(zpATS.g(o	'k,!P/s^dZ[zUyhh-\8vvn+%c}4 pnryY JW:1qPz(ei}<y]D}kSBٹi)dZW^uc7xB_T]=~ I@M4ZMG1xR3 %&мê`u**	$	؜K#4~2]TuDc}toĿ>a/(w25b;Ϯukulu:ғh<V]tOKqIT1q8e M5h)
^oS\IUl&6)P^J}k9Mh vG}\?m<CSb^KcuRe
@z$T~ S_OOOPHے*$r#!dIKp	
IbC#܋  IDATwZZEYN0dAhHULn?.'66#dt;ii֢V^;_ `^`A -r2Pv;ldJvXC,pvRgsJY>YzWX 	OXųu]f -F!`?u^ŴpW]c,s8Ct2=L.i]pc:  hY6@	8D 
ixtř(ާ%Dw"4Y i\c-hUmA"P 1GI*R J]83k<	yy@6p;A~dA@C&<?]K$-)=oTQ?wuZ2qOKKK4oi
6E "O)/#m"Hip~P$
`PZ}n7x]2U3)'F!K^U!]Qc6,gE! h_]=~5	ܹ%LTj)K"̫We5@GPe!D @D @D @D @D @D @D@0" (D `?k!@ED  (D @! 
(}4}DH5YCDHFD (6B14/AW2r 3D (?b4/K8r 3D (34/tRd Wӌr 3D ([er 4@xgt2$m&#)2Ch\}5 Ǐy!L(GzE@0B
P
2maࣈ  *<G È" @" "  "  "  " fB)N"ND @D8rDGG @BV+D@/d`+d
(kD H\	HWn]@>p@껺? DULj߁D:aDFC=:ҶŽ7iNy`;2)5d0!`ԫ.(	Vޔl6$iFY"PfxR#.;S;wKV	M
0MH\0Jǃ'#ޙr͸CdbK=+CHn#	@xn*-
)t>>#hg*6+ʪJ^3xbx4ˎ3	{wM~wKيF3ˎo2n.ϭyIޛTdpng㙊F8 ecJBݶ\膀'-&rNO\~fX<D!eB[EC<@/,J޻`+N#A@p8[4S@3ӎG RDbJ(8qU9D3q31{L$Ml D1[.;΢%1`$bq)  [B^@H7cHvLX&uމz\'VajL7ԑ/\Pf8g6X"q%u,8g` D -ph\`@ ZF D:v<=]r"P0Nhi1O @+97?;JF>7TJ 	 "H "`b<D D 5#䋊sFUi 0}?!D['D^ @!e@(B/PD!!<qi?aLy20a'fklI6dA@TO/`Xz%gkkt:L[!V H
+L[Q|4: |O~c>H2=*0,<ι(HGvAr<ٙ,)AM\qЩ迠k'tG44>HBXG~ݣB胆<Hx?-~Ɂâ; fJ39XVgpHe MD -~?3O/$:ﾷg>|p>zP>_3:X|L2rq|:?(Pɶo_n, Qo DDbv&36nxA2#j% 	hs7	~KBgaubOH<6*# o>t	ifbD^෴FP!R@ u y0^'ayH>dgtPER~BZA6}xFd23#EyT'dgt)+OV"TzRE l(}O6 8oS ;xk,==!l)Z~BXct{XAR# _TR"Ў  "6D 01aD#yhCD@DhC#І@"P! "  " @R "  "Z[Z2Dc! "  "  "  "  "  "  "  "  "  "  "  "  "  "  "  "  "  
@P "B"D  (D @! 
@P "B"D  (D @! 
@P "B"D  (D @! 
@P "B"D  (D @! 
@P "BT	"%-APE  ʬ, "D eR}ň ʴ8@A("P-DPfEFPC`?Ypg#(!y@spڋ̇  @ࢽׁv@P&D ]W#uLE"2!_Y>^ eb嫿L,(B&D eVnE@@eR<kF"27/irD eBF~17A#(zSCP&D`۷ } ʼ|!zLEQY`Ea1U|f	my@z֠T[O@/]fC T-x>Fy# `JXQxMa" P\d<Ss[9	l?26s ,HSCӗŨ;8hM9G5HD@ڍ0`
d
-096I_A	`0l3%>c*I_6`ۛs n$>2mӐ0rE`n3j8f.`)0lktsE`Pux>C/Ϙ&c]2~1{tr/`F>Î\ 7DJ@w@(OBTj҉ DB
 ʨB
 ʸB
 D  "  "@7C!Iy'YFGPfEB!Ia替fGPC`Ѣڅ3JD e:A1ýFPD4#ݻkJZ@>փT)*fPضmz"25TJ:\tܹk/nXj45ini$De ,4/diuN7XvW@PE`k"("? ˲.*+Vػo׶k+ t^ (
.m[/ PF࿁]뫃{AE |!(#A ʈmD ; xxD Gu:75,YMA7 D,u]n6niGtdA=u>~VaHTg "+>X;D (!aD @D @">xgJg+
y<a)݈ "P NԖ1Oh<Δ'nkL]^@8 À@D (8oWl	L޽j	=8UDh~gݗ#08?9nxGCq@UD@g>|+\L_xo%3qG&V6{hE=TOF#0	.>>Lx-lO og<ԽD@,9˓woJFub9?E%S-D (8c_y前oo2A@^fs>Ao D:$m!|Z
MN^^{+Z$xgܥs@ɩJ@@t~^@@B" ! "PfP(!Bbx@gt"i  _fė.'NH'a	$"n_}"E穌0W{.pb}>wvGf 3Q
}i" @
Ml""  `jkhvw@
  D 0)@@dvߐn @@@qq	" "`b.# 
@P "2&͈ " XË,	LM'SD?]N¢)cc9; v[Gd"|qښ7w-ւ֬]Cul-e47ijZD|j_3!iu!EWis- " "0Bx=-Ӛ{rUOhK[ @XCP6-D2
4OADPXOK)\M5HD@M H@OW[eiP`NAֆK9j,mXvBYkEf.`!N@+(}h67eU.)ѣ،ZDl@˚&AVr=f 
1ڬ-k*-*EZ) I.Q'ĸ>tRS\Dɜ w07*}E! ^EZ.0/^c>577 d 1n@` QNM9+sF"5	=u> kRggW .(y/` \N.TYO ` J " B?PYԃ*+:) y!@Aȉ*+.B|PPU}..^Kh]WI1* 	(iU\9xR'T4y,KNv2O?偀 @%;PhMw	 [e!z0 zP&0
,b:k}5T%A@pBiK]Bg"vOp(#$V(`p1{/"=j#\NϗT^P)o6" 0-F: S"<>*anyvrRIm?fJ>nZ_M׆եYc(CyK/B`g6$B wyؐG'>.g5c/j\ը)CDwH_	T,z©9݇fCoOg<]H$i@\ŲE)׌&
XfUD^ ?Y>S/9Q`}#plSI9a=ç%']#$`WCtB@6EOqS_,u782qC`'v3H?2y
lT4>dM*Z2TXX/-AqbeX.`>C!!QΟ~z|ƕ\Yo]"0<"@oSQMu$FXT]3UA:n"I[7lsHTHerZKGX!WkX'9hB"1>!UZkI\;*脀ک7DCPxYuG63!gt,!@f$G+/d{S?qwUerZKG54FDB<ӊP_F \ZK2?9u v<6v[۠(l@&bG+VK!:ػg<I'WMZH?J"$A]ki(dB{1	$Q!@!rQYZk	
@@>GFT榡˒y	鴅\B}Wy7q7@ ŁD2U=ohpv몙iJVKIi =H+@D1OzSBHVBc ?ȴќW{
L[HH@6:Jȩ;;@i/[$G6 ZdO (ӧ7rSl9n< #@yxڦ.5`|9IF $9xWނ(@kWor%۴pN@8*#C@MqEHkwҗ˗vM	Y7ur&C>4R]/w~+9)D,>*# O],NtKh s8F셄УB5uT|N]l4s"7Mow(Uu0Q} |a~6\sFm] 054~ K}r5@@dv݀i(Y"Kt&E,$3VT+PaU𢯹GQe2G J+BP "B"
@
@*W=u6ePٟ	@?C%,M&Ok@SW_vqOTAt_0w[.y4'  |T_ 
@P "*2;9kwtpbAI;L2*h CL"p["phl@Pي0=4a Xl8UbTtD eP	sߙreF QPqU`'Ӛ#B##ȕoޙ=dzQpP{f!.&ӀЈ Lx p'F flg?>Cc0h6´Ј  Hp){ƽVbhj:3٣svh- ?"4"*&omyb[[?Btٰi=:X !g>Z]z1HW)~DhD ~R"C po"!ZR!C @C^c$1"4"ʷw8CPLaD ?~E'HX"(@! 
@P "B"_ʌ@P E n
e2Z(Dｻv2(v]ebᗁ21VTv@@LZv5
e>	PGk۶()&    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2010_link1.png
PNG

   IHDR       Li#   PLTE   /  : B E L Q4 5 ;6 Sc  L	d $-e 8M f \R0%#$7(6! X']*?	/~))\A)>%1F7*[S)"5`<)t`- 25;:9 \)>V(\33eh(=)9T&<[g)^ >(>]R;<==+@`-Bb<=l.CcG~/DdFA@1Ff3Hhi5XE#5JjEEtEEFKL6-a ]iK2B ]M=9"-UPQPnBOPzNRt-WQVdzMENP. M=|O_Y `^/rXta:SG]bP=@v$IhRehk[d;j0hlnoparm^rppqr<jUyzl~{_tk|Uw衂b`|ι}~V~hlQtOlU0aۓrh훦緥qΡ^ϛn܉ݘĩ$ʩN߫|_鰀Ѓлθ@ľͼȧaȗ~ݨơ먪ߏv p b |p  u} X Zj ac2M;(~A*Z=K/Uo#mE  ITIDATx^I0@;K*Z ?s)ߴmz+<Ux6cT""c0iIڦS"<GVñs	<_  ,Tll,[BbWLU$dm a(
0b$f`d 8TĢ +'xGj=5g ] BVErٚsGO\p̏ !܀$8رc޴($uZ:KЉ5dHE%`D^P2:;C/G^S3;xvNOƅ寜`uS؄Vk(S1ؘcbrFVd5uqj3-UCjZn٧h wRtc.;x}X(愅&qYމwI )	8@Pd#zaUe ?J,O6-@	iuW؀H 1q^2aB5#2$;i!&$$\TJn`\\]vx0r0~+dv-Q#*^7P 'Eid2X7c K$*KpCrW\CXa0"r WTJy8?%}^L
r:b W6	,앤	W=N4z1|59P	s'{5{!F>&Hƨmۊ=hs 2y+*9C@a0
7e"l122=D]8% <G`*NgD&~<c,@ "6y9Ey' v$# X1 n'+=N`ˮqDq|,	ZhIl)mJY(NE1iTu& A9$`dc.9S/=PȽHu8KߛI;ZP~ޛLam0iZYjȆC@0 bNHcT%*#JPBPH*Fd		bi&;JWyGP!r|0piHEČ@D]cJZ܏=yz7L_1e`t?> 
X;1N.@ "FHIn뛒ʞ@)9!uRN\f%1!k&9NL@tr3p]=t#YK5 JDjV8f#c YN" 
 ~yJƤب|  @Qv8X[@@I~΂B)qcBRA  "PXy<4'x(\ '#`q$˶v~yNR;MBT/K?q"=Z%]܆.E!VshSj%N<MZc(c'ȁ*_kn-f#:ؕ*ԫjRA*QECSۆZQVK:NnQ_ _GA-$+Y@_t
w,l'X0yĪ\EjTّ~$4+1)A  [_b,- p!'Fy+C(C8R#Kl\ˈny82R6X<U0fB 98׳U@\4z`  :J9Tj(3_Z߿ޱȤP$ l[5exq&7@4EQ2Л%!?NN]e` k4m4|Y'`hSzC 0=Y¢vԪu,x C$+?jVav ["v 0h!:G :78,BE@8wve՜\#alB;It X\P-?8x#$^pEztCXNj#D
 "Jb@HD*W.MF(B?#vQC`@h	.=02TO,Q@8!|S4+?~)ǚn۵v`U@^yѡ!1wJn"|_ nå mW\ TbV,:fc$c!s4kOG [9,7P_',RryR B0ZڅI7]@ p.0 6~%NE8j2uc}}f	8	\!NHw  Ђ߁La\1t5Sp?fǓ {HB"`39r@9ǽ"x%"LfaVQ+t.D@@O7SɡEv闟(hCkz4ϢsSOÿ^;f hlq<[=}r.O̓ujitῑ `	O㡙 0à>g~~srP wruԐqcZ{\O6{sXs*1
6.[]qOWXSXZz>a%bXhȜ.5l5qlqA>2P[Z"=crcrMy/4<o$vA8A3),ULFOh%@ipj&n@oJ23@S #}I `+P8w8F9SbzEfνV0]-M3b x_b%9GnIh1a地?Hpf>onXϣ\\ iюfY(>2MN8$0+ @z5&
(WC2XVŽDvܼ<Jm^u ^Y_8a0XKauxmlOiWA/6E ٳC  3 !$7AE݃Q@jRڽ)O Rs8 0KpSdN'A; 9	ct7@SMVDü#_ m_,Vݢ~*bbl.f	seѥv~_@N@ hhm01=~5L20*_3@*$ Co!&
K+^U~<l`A#x`cHRH\ BwPa4)TfkBj]-{h1ƜH=&,w屲8$ȈAGET<"9	#ЙjY}O|ҩoS 1%c+{[q, NQ!@"Pgh(8ddicI%U}gy |z\T <Q BZ xNX Lk#Nl-qU<lCxݩXթ+C ꂢH<bB
<Ӆ6k-JﻳJqeiG4#/:~w)g(sf<8u0]{pj<Ò H2da-3 i
!D
ET,NM;RE2"fP|yYa "nvhѸu+p)zMVsH(;%f0B֑TM ِy	HZTscJ-4@!@YuH4*<Si:Vf"X!ґ~j
ZpVuʦt#xLj3C,\K-+X!E*>Sv5Us80˼Ԕ΅04@!"آW'diFK+Ɨ ȧģR0Wκ<PcCEb:V.֎@DItHANGEzV+N%HENI(YE$3Y2b${?x6g&Q謮b:Fy'/||߼	!*u-9v•!9hz*!%qPPBG))Y7lE1r8%¿16-u߉RJ}.2`_н9L="CԨ
z> ½.4؉QoMW` *UGAt`aO#T"9YލIvf|8VX,V[+l?0~
] rj{uyqh|(c0njIHf'vr@<}܌]p
6_9Z\LPȋuIǤ4qZTe蕮A1؞U Kն
UG]78v+8BuKHi%׈o' 
6=CoT.>(Ӈp>6b$\	@sö*% 8~ʃ
(V$0ѻ$`>BΞ  AQTb?f1DTP0g/-!Y 'b 'ͮ"BQunXCrͦl▋!}>B $jK~* smdgvۦXpZ(rbz-H	bHM΂:HΔ``'/{mm{Z,ZLJeVFK,=uާ0yXTSF&d=͌Em20"pC0B6 @0bȁ@y6)#@,"Rm Cf@i0:"«oX@A@5++Z7Berл
.o<x Iӓ' |{	P8 Cy TBk(! 		#_{n-pKQ0DXfdDn+ .8bE y'*(TYQ'v+hGWHÏʗ6K,ΔO\*`n#]+ucBǘMiMɯ)A:	N:%*"%@"

`h@%  ]		,gX4	6 ~꿬5Zm6mpkȭ4e $ar
WDԨ@EBuP
e#RUQdӍ `@EncPiq|Qo>洹sC gϞoV;	 bbK E#I>@ls94.uP F /E.PzL!|FaO ƩF  Vá`,	v>_<dm@	㣉QzKc^VU61FZ fPڄ38!@%16b56JZRM(7 A[n/SJⱙi9xEnp7_ơ689p&B`wFZ7wq6  XV'3. M~&`r7MRa4N!wD@@8`(Q N v#pC`4C_<jK /^PdÐ ι_J|5giWrϴ7r(l3ERBhYPl.2h `fwqy;66V7lXbnޕb!xY'b@O $I9@m.	nΦpZx@|ƱÔ"86m&pXX'?||~i~u=6U !)jzNO$Ưa{DQt6KD(_^05jU\D$j6?HFʐ5bLeI .L2 XL\|o	A	@Y=<HQC](Qe2rXUEd#-ADr" ^*dv߃OLboi\`+8ekۥ۰]w" xq{x fhmثI @ÌST|j|qvA@ba!`PPs$<	(H|C	*#{]LyP - ?>z.Y{\p+<zאP7p,aL_"?o.Pu>{>!V, M Q	ǊԲ8`U	,	P2Gԏ  K/	C,{	M?N Dasw@ȭlمt</`YkK t#P+Y>\NƟ%t: E ,	TTn| 25Ob(w] \?w?f*O6\@ p@0p&B&40kk[\ݾzӊw.vRE^߿I@H,vW*ӵP/ò	HYH:I(MQ 7K`smҢm$p\vڅBA?8m|K`7U`SEhskA ;##or,-b?,	=0NX^;E!W/E+f ifp?2 %o<ϯf	wNعC  1|l!f\wpՉ
8 
ٔZ#AgR	o/ܝ,x+ /ٻ{ ,2W9)r	A,BH-B\p;`a"{X"p#P}ud(: xED >@ 9]ר (gpqj ƨ ';0q%!oB>]2?CK
d02en]LC)J9Do=~qI,Y>=@JG)T$GcK\  %6T7(J &?"5Xc-T$1U[ D$v {J%YõTBFfue\ J<.g(uDl,@y?S{ԧmX'-׹* ٻzՆa |!M0qBǮ;
.tKhPBD<^Τ}2S$lEE(8U ^ih6xpA)TjRN*=Qn&owdBd!t/[y|hɑI#bT"R@6G".$rnU1M,C̰>6zz@bËj[%<ې 2 {!ts^ 1XV#9qIk$`p%;Prn +MKw/C6IrD[5D\h9ӓ$0oHx/JCK	l8ƽH`aM b0쳌;&*q\%bD5q*_{Z4 !ɐ@{ϑF  Dy)N+
<윿kL[(nCեQ 0l]R i!d)n:\)JXzO9yg?| .S uě`,`]`~PE *PRGf,d
}VQ@? L/p.PC @H\hYePf+q|  .`'4{$LqnI. "~⺀94S G3Ξ
)]F4ͶNof{>}M. D졨V-''&5[:\*i&  
St DVn
tϾ>+'B ])@Av]+[[t]  ẀuS<ou{× rS@F٬')sS(t+4~CF. 4} !d4Ǉ;*7\8=vރ@d_{C. Ten
@
ZM7QԀ&] @	4.@SOffH$cF-L`wNx/[ `9QW@/P
cv2w/W `  S`<4N8
 on>)W `@/x(,G#R?|&W )p/kqp
( t/0̨" )P躷  (܋P@Edw oA#=e
! .*:}WUp⢛W[n} g@G[tAP뽧r.r>.8 f@^(Rέ^S X.H2(1̀Pҡu+0bCSsB[^ sGH s$]B]@))wh* GPGɮ-am-_
s1xGE&P(ݕcB80Uon-1~S_~1z*K)	!dh$jZt+cPJ
T(vZZE(Tƅb+k>LP̥s֚vCk$9gƣ3#v/:=E@@NC"PqphȒM><ߍ["M.vM@e C hrXc"D"ih"  1$j#pțxfmq::NdȍM`ڐA7]hԜm{crA[bKMrB4$H$ pm'D{ 7ݨZ<qPqB
P匴4\H']/Xn2g)#`y@ JN,2D0u1[n
!^D^@ v/ܽ	xt!nj@  RF|^2/@"V/ppttk.s Wu0 8@LXQD`8T]h/S\q#$V/@"Cr|l#dG Xg237B&0xPaSq!<H Ȅ)0#V  4> V/Pj2h4Wf^fgrn5\D("iOnBJG Iɼ P zTJlXe'@|J}(3' L| zriBP`vI$El$U^D|zD @|.brrH$@`zDM +y)H@xJ;x^D#TkAx-"[G=$F j\n$@ؚwV=
 4X/W!L/>32cߚV"H-@(l}?! Vw] _M2q?Z(v^DBD "`zm QH֚mpVwE)Q5H;R(^D!L/¶߹gA rͫnwu]}HcFH#v# t_;$RW#`zoڥ׀  Vw1c#  >EzŹ>]_.U?!ZE"}_xFm6څ#/~OHU鴛N\`ݚ{l]6s/׵a =vTNN&Tm6.*l+Q3`3Q8щR1LIރQ'>=Y xx#Rss12rn9,	 @
Ĕ(Fp/RP
HG Chw/9,
A `w/ЧfqDpw !e@|D3tHDD  Np^ nS] $՘ȗ~ 	\
R\_ԌKC  Jʷt$WU ? &fdFm`xi$ 2A*FAdta&|1Laho @)	UcV4HHo /[H
ZeXhEZF@^-!	UcD1t!"VQ7x5RʦUc4Ưƌe Xba>"
8RPD$bnKuRJTk!ѡ.H2ֳҵCZoF뙽>|g{|;| ./悉sR4N*[c\eu'-'U70LM|
4 Gt[cJ[cmxuR  s)wJ[c&A2L9~xP9) ho
T*B?q	! L
[c쁡S >~ M`,KQuZoQVaS&o_&=$)3Xj]@%")3׾8p4<ֲ2S8p
Ԣ F	P@Vtan P7{8&4hpD2!w8X-p kEwH񒣔r9<܇v.EV\_R
QtV#8E`?R2>oLzqҲ ]5E`GJ.}\" Oe[M&Tq/.}:] rܜO*|XZ] KiF_{/#P<0.}:] Kth&.u@DT"߂8+#&. D q ?}\@ ]W_p|@s  \ @ /_u(wQ<P/wt |>k w">B6' ϠMN<&?H>~ڞv,$eYV=H'HBI 'QXP>+Iw8t6Op89P"/3RY p3]vTB?,p8c }Y$Dnf=jQ`$]P]`8.D\\ / ȋcm&"QЗ;Q0$yAMމRzI`F@@H 	\ ! a /FH  } . }p`& \ p04R;L<3.Z\@RIVK#C'@:E*S"؁_X-`/;gC@Ea:Q1	4QN1'U&%TX+y^tn܉_2ݜ+W$LQ 9} >]bAp6#J{yZ\Ӓ#)r8C،(EHΫw ] pPs/2OJPs!z.@bvbf;|7{ L,Zl(nv6k<"")eBYoᱼe^av@@?E#P@=[ 59P ,B!nL^Hk *aT\- dlbT -D;g<F#,XoaIՁ		Ka
Wadc`Д׀HlHZ@J96S}zާs4+Q ld44'dtE?3u%v, Ec֡_M@OFvfY'SZ-]FY <:,Y;)reo+
^P8Ri-kn)$cA`
XJXk{f,e8fAfZ
o{ Y 8+ӏ{|)`cCxL 4a3sQCX,`;[>KkB0YX 9>doqXdFFRY7+z* ü;Lp%KfdTvyS,@S,\S,pQdS?;g"EdN#C?p72
dpq@ݺM~}%z@~	!XG,_B?,  `'b5=V"*B7I,9moKjTB4wT ,<C@X8,}H, Y4vI,"ɊVV	[!u'YܩW vfvG~yPVa.-k5(riCQitEs1zX"F80O<tv핰 C,,ݢ5%|saNp?JW=igC[B2͚pZgztut>ꜵ. ,L{B5']X5uL@aWj$ÖL0QX/Xg,`Xr	,  X ] `w`,  X @ `],  X @ , W[ޫiZb
hs6-u`ѝ4X,7mkd(>)ekI[^g{פ#m-`g'-0x, U:Xr3*̴e,8q緩LQ<KХ^ɒi0x5EheϹs﬉Rf%+tYxd2OY`~p2OBt@'h\Rlxg霆}WMnj2?,2a-`+tPgʜtK$Zwu43VSIuP&CI5t Yѽ-AIܽPɼ_2B>K0!]j_b]h2>B=/y J; `+X @ ,B ,`X7`!X @W9 O!
AW#x6C3l#CW'iVrxGdt~ʜo2F[ fiЌX H&JmwR7.Ti@31'
M>lzٽ(G43$x9`kgUWj?ჸ]5ڝ}Z*Y>HZ&SuX٬juERW)j^5:-,Kzk6ES%,`ҒNmΪhܷEsVşDj6͸`oO>EY,q-`5EC&X.QC+ɶ[WJb-l\ͦЪh]~@.إ62eI**:e>ZS3Fte , ',oa{S-D@7Blwf
 `,  X @ ,`X @ ,@LA#Eg0a`$yq!ghhXɺW	VwחyF؛8+	)w-`G%[]tg%Q a-`~g%qR 19	-Y@ҞD`a	
Eo#$YIyV\t!40^yD-  XĔ `X`,  X @ ,`X  `,  X vÓ?'+^ 4Ea&.^H>D!P]sugPB̹xJz)KLN)=qK=O,`OH^3.O4(tf{2)X5z(=DJa#O$9Oc?wJKx;,hY tg{22l7KIV6J%2)@8v=X /*Y񠴀@0 tUbERo)<XlZ`{2i+=.q>6Q{u*s2nUX ,`O`X*n֬"QHNtxTdzM P`y`c 
, @d ,  `[<KK |_6 P OVplXf  LPW770\Z ч[ >'HB MgQ0<`!l"bM0'@NwAH"֙fY-y`y/<Ϟ@
\uPW+t (r\@: }5.H@BYc}pq^kV@e{$] "`LpH>LduH0] 
/uHY#@Á`N޴ .=`v- ѿ/LJ|Va_`!\p_ ׽	0EaN,,B\e.4n` Qt x̓{ -dbi -`Ke5ZB1h - ^@QubA,\ҥyl7")b"
IuEX}$%``!Fd,zR'D`~Q^=}V(~ qC#k n.g%n5/,]:2B#RS">8|nO?{FV1=6\ Dl w>M 7]\ 0D>Vq❴gtsSlN /}7^왿j0?nMKBC@42<~	w#h6d%k!Cۭ
YgBr?,Ctq-o9~F0߮گՓwp#0Z7-ԱBpk:pz# Ā6P%LRqG`2jq\ 46.B4g|C`VG@kq V.@@_qO# *idZﳊhq .*IpwQ?!@v4`t kH3q .#c@4^y2j>ٳc 
jv"X 	A] ,FntSM/Xz EYa;	зz[y Dj=Pp !bg@b,;a(݊PQgCKWdU,t8pM:*GI!.K-Ҥ%$gzc 86Knj)h'6 #έ#Z
"~b5Z 33LQ4><'Vp sbZZ<_#^Vqx5͏{yI7,ѧpEr5]DTk`\R')K!,ACF[o/0-C&1g-%.جF؄Y%,O9nrvw0UB$c\葂A?[$Ioa|w.qQ7?0]HW.WlRBrBkp ErMkRͦ,9_`0`k.nc{μۏo>c16uX$߮['?9b@  jpF?Xx,J_kU'+@KKUW!%w@Afw"Ǉ-P 2ptS"PYE5U]9C	L|?7+`;0X<٫ l?:-DHE1	`BQ^UѨdQtsQA̷ e0zPHً֭.@4`/.:-dY	YE*4S")#y-pk\ӑ?m6{	>):MȬJ!!&U&̪|	Ԏ 0?i.. 0Q" /@|یql	Q%`5W*rdJ+[	:@ TA% %,1..`G ږOŽ`]] #˲F1wvsTvvF]]>"..7(ډXX8+R:ٹ8` }
!Bw#	o7sB	H?MhACoAN4ţ"C<B[bADҵ =<l6N߰y}f2D s`F&bMHn`w<
 \^>] .j;#!P@ . m0)M+p@R)J=p,.He}ϞT`_`1sEt|ʌΜ!gȬ6 Jfq yL`ʞ4E2Tt  mn07ϝ91]7NG@]2[A{)(U8]/G.sp2úG2=yD׊ߚI!w3ˣ(ZȜΏhp \D+M{8_tE9595:De(o%		@$<%;4`J+7vTq-"]A@ܛ @!B"xObc. ]xkǷkP)!ӵO&^2(_dC] PxO|/ P÷)(a/ťD@+,=/Z.|v'~.D4Mrp^x1k'\ g	j \ ?Bp ]@ˑC p1\ ןg5j(
㩊E&bH(Kw.GBW}0>A%.LνI\E;7:]KWc@Ƙ^@5B0{ @H% AҰFz 0Yw`X:`|aCuķ/ DqӫZ3ܠJstt8$	5Kև]	ĚbrXiUFUlVm:.4KV;E+X XZ}_fu|RY"5t-2 , hxr,c5Ycpv9BA>6%ډrB+r`.+"P	btV>E
 r+Ew`.Fk,ڊҁcɠŬ#Yot]J!4q)X @*tO`|
L6/@ , P0 , а ,0Ԇ`C`,@ Nl, ̳4Mݽ>=[ uaJTrrJ@` 䠳(2jT.C"k#Y1-h , VVĸp/ X P"GM%?' gٵiss    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/prev.png
PNG

   IHDR         ~+   $PLTEfff333QOM&# ҋC@>`^\J   tRNS @f   PIDATx^e	 !Vo~,jbL E"Aa\~%%L`yj6^24C0    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_pch4_thumb.png
PNG

   IHDR         4   PLTE$r(5  IDATx^a \w-~ljM#alW(w}sT`Q$o Xlfj]LZ'jvJ)y/ȏS
*RWX4&|%
1[( H<=U}go:GŽB_SVr<XD3tZB` Z[A_wR2jir(4$۠5mRڶ%/ma]` 'ĨXe3!N
=H@%sĞِSa'=v#îޱiP2j/ނ]d^l"3zx+Η*̾UħğMo6`@{5z螉9׺kisV8/,ٲlhԀ_4tz0I0!*.canj]Wc⼍#'sTC⭞?>8" @ i|l>9deٕpgA8z,Ol'!ۓ	Xs6ͅU+iV/)i[W}fLfݒ+5lBuCVN_/_SM*!E~"XϦyy*3,zc+5-
ӖJ+ET_ȷ>KΛAW:M4 Un$#tiZ	y*t 2DT3ms_Bk`Ϗ, G a`ݛ}I4KgAUFggCղzջBY
}ٚi&~Ȇw^`'>fa_o3@!7\04F(P=Fp.PЦP5U:C#׃fgwaD -i6#r̰ᲦɄZI%خApBQwH)	}NIJ{=~$ՂG%.}DL:0<*y 9\ʎ1Ґ;䧋4cybiG  yBu9[c7#9T"k:YBAw|c|%O.{c O	NۉB@Sr!ϻFz;ԩd8k@tJ#-[ww_ +]p,*4Bp@Q~Ea&Cx!Ӯ6aWrz1#ÌNF {nPzFu BCH?ḂhҕwHUӕk͛
(\1dB	H #`߬}RMT)gwșbH2sKD"#>UCy`X@kxc+فUh4EMy>5<e# qJd	洑!C3ZB":/"JƘJ9Q$hAydNiJaG{Roe@^B˅>0$z;A	&%5q    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_link2.png
PNG

   IHDR       Li#   sRGB    PLTE    8  zf9  O: :9cd  U 0f 9x f d O  $6 4^:#//,z  :V,%;.z#6=8 Lx40GVT8 1Z5LeQeHNGLGPYQPCLPR8?< pQSPXT9qE pZoNkf"ghO XYtE1A(]_\(knb,gcBDcOq _cf]gdYVHb,Zf7lgifOo(v rb]tt nom_B? uwtnb.w1|}|=AtNz{sOo5߃}~bv^$M^{mdꛂU8ky;
xҏoPq:yޑ9ӈi݅ۜȝGؓ>Я؝U좨_ܤ+êmɉըt~W~נԧ礘4갠ؾ}wbC¿׽ͥĠӴƿҾʹۻVɘ΅ѽؙp׳_ގ~w   bKGD H   	pHYs    od   tIMEy=H    IDATx`TՙAزъm6h6j#,HJoF[\ֆU͆j6"6oHCD.A4HB44iRbvy9s33wL;>syα-pm"uǑIv"5ER_T5440{ƍ$4  MT&qX `Uxw+'KW3ĖQYoTy;wǎڧ'006{}t%vC92A`xy}! *lǞ4{@h	j5cs_>(rIy 4JAnnzm~NelC!U_
!z*aE^#[K!m.oKkE/?lƣ|nzznƬ#GӛO_;&(~_5C>r.jz-.]?,ye- dUjVh 7nqh	1&$jڃ8VBN^>=QE
W..|i7ņ 0zRb@ (*]9=Y{.e/fA z~?&f[ZZ]gZ!W%l.Cyp?k<+ Q\G(o
0|ǁ E)SlS>:6i.m_?05>jB>dɚw6Lm|wd*}?Slb6a~~#H^b+\LE ܿǄ@cA_[[K{(zߢxxyA W3e//D'}o!Oڧ^䜭ϝOKe
W{7sm:9=%9u,ϯDۻ9|*XKG@ܿ- 6G"sE"~MoB@	)Ejأ!`x"W3LO(drgKg^忰mU(,Ub#$ޮiJ	Yv{;%V{;+.775_	b@seG"PoF` ]x"(}Z:|fyQ:e%6%"E9gPw	@FQrn|K*tҪ/Fԅ]iB@>O]2xhIb0@ȐoBCNb`h)iw2sYcҾ 8Ω\L>|YjB!-Cɸs^~"F7쿤%7ķDs
@`0b @xی l2+ DMWHE%8fʵ}2 o
(v<5EƮQԘu@\'1hU^Ʈ.ƪk̘Z*'>JarEĀ@c 0vsa_x)QJv@ wَ9VgtF;0.wac;V޽q]w\X Ӏ pϱ{ǍGbIC`G"sظC @m<z4oٲeD.lc@Ҳ@ hJf\fYgFP2ΖMX-lD\`޽{_߻wm3j3~VOi(pR>l@]HU^ <r=	-?Q"%T-cp|t t'(\tY+Ntaywd8k@ d|n@`1B>К /@.l Q߳AvNtDv6n<?S QI=&{1`o3yP\^`m7y*
J]i홾lM>l..p.{/KEq+JJFVx>W?~q2ȣ#~6^#yݐh=/b/jc%ZLmwGS&8+ٯ	@gݏ>ۗap<lXgh D4Rt_}>Y|-_tz*s÷ܩ"v]uϡ< ۷qw^ݝ.WI^w׾_h9aPua" tw6ʷW/G8|T58"h#EyxCI㑊 Et^HtгLz\}-vӋY\~|mM>bij98ugX	y*>%XC?|޴-1rg|>C.4qy<+͹3FggP7J9@`8s1:U~wtoo FF67|{}lR-_Ε#x+W筰MGפj\D9>w+_Cw%t\">)Cώ	/Bwe3J%6JhBְ%OrPV8Ce8ϸȒ%sL#`2DM&/e15~l/#B3"tpG@ʗoPG_:~6ssw?+'Ӷtq=fIl^R#^6%fl*>I'# #Gҟw{+~y՛z*m>o-i>bX=fC}LEEWW}tY!-h+P	D]=@jU!ݞ'4/^EU)V~rԴ|wJ|gkxūE-^R?)dS/q-#]M;ʶr-yE,q(5mC d"a2d!v/@τ,رc=W' ibV:sVb~"OerSY%MbOGdڸQq^;wbFbN	
eϛ%OG?_|*&m$yz::c}tߜE5p _$P!՟82@MKG;JyT&ڄKXRJܧnu7MODot?[y\P>3[BwFEFʹ뿧xlh_ܴS["Ηu3y~O+,)Y[nq%#ފB858ϟ-A&E<k1L.V-5 tǪ2y"&4oծ8e%[2J-<@%G>oMOn+	wEz}NPZ~|]ci̪ -ZkkmQglSR1c$1gEKxnyU	m쩪;f@ŪX<ޘ -Bf\'N<ys˻Mԏni\MIgsyht8CUGݯ@ĉ>mO+\.'PW[EvB\hlFI ZT2;l@`郀Vj[Z6U5ֿEy  G (ju pHUVVՋ,¢9Vrb`l7VGСw>m|ޑPY]GRb4蝌7oB8?WzE
w{焙rAlS[^-Ξ|M--m:L
C^86pej/.wE}NUbξLڶ(7EeJiSM&~Z0#돲xm7)wDHtxf{B6pz~H?	-zU<wyvں%ph ^81׀ƍS:/9@86فMMRhl
ņTE2DY~T,D N@%N)tv"#h$hl(^Xn|(	U7
ذqYw]8@{kmv76ҭ]lwcSckBڿ=yu<K{>`F'J"Ξ1{NQq[:dOkQ/P~ZEXXh"*A~V*cG'`Q~@Xm.նۂ91LFA 3T  !T@>5?¼}qG"AE垥HGJwpF<Ȗx)087"jHUooZVXqt_qa8v2X]F?~#<mÒ   r(b#: 8pkwn7;$>&7/2.*9r{Q(YmBn݀@P@Ԡ
AK{8,{P"ж˱kaamʦϽQrUC3P3sZ5$	a1?
:_gAH>%_׾j~-}Þf/䄸d S@v8aDJˇDe80RQR(*İ_J1[M[H6j=Z'L6=NMCn)1js@y8_:a12`$ i&ChskBc}E Ȝ "]_D pI.0y@RJHhS/" |^l5b,֭BBe 0WrY^^'4r5x޻[ɓ➶ TW6;;; 5_@(04'ZYcvZ
5ߔ"s􏳋Z[cET Brln5#`ȌO1uա!oE eZ\	Ś=%Y SCb]\_qoGvOiŅ">5u!
Z(u:nai.
,iqeҊ<ZC7|MaB5kQds4Ka@C@w}~ =1#ng\ `WORM/w|*@%d |xS/@uh;w~󽽿ggW:V@W{"ҊB0^rB-mÛmL.wtaKz,筮.34JG`k<@@`2B&e6#تhCv PR?5\:F4t(hT.WB58[`|3IWk}<t͟Igbm(o_ݯ![e;{xc?揝H^^8q(w~?T.O[nx.P*y)M	rEN=T9R.\nSYO]n'&Il`z݊;34d@!"-mGC@l!eEXaB XhѥC ',/k|IL׭X@mAHz}-=
eGI~m ӲAgF-Hjr81?ފ}tXD-LLXK'	z=*	H5X8{Wcݲhsjc/@.նa32lg:St.xU"b@хp%-z|!pG]XlkG+r0 eY%~V܀B-ӫ
F/įnsX#2hw~WW>P# >I#'~s_o}?tҿiN\
TWH=o.0E|{s7tvBJ	^/\2.@/)&TE/xXK70( v;y힙#gtg>A#}tk*-	DR"ǘ܀@ꠀ3إ#'uZvNg~ڵ~ZvaޟQ ??rJq&/ZehuAk$3;otD6ܵ*^1$P&;2T^4B.1FxPf_^"dƂ6}P m&o;/#YPtp^@"A&L!PXP`,n؟Л:억8ҷZI3!qO_n<s0aoaʣ{	CeGQ ٢@E2kҒ}I	8Q NB@$]~Ɓ]9 O^0  ȱpС\
Ns` |X08X^Ɗ Vl7|(du\g33!@9-BU\ީ?J(z>tLL{n)񎲟"!s Da:[˼[{:Sװ'&v|&eJJsh\=,z:NpT#KVgf
f
;^=~79^akm9=&by8BF{nD	Lרv jcKӧ1VX_@EkR{&l;.mcەzJAn()^ڌcd.<0!0" `::EۋN8]D{/xU@|Ȣg99_ @[s^]dǔtX<FkLF_5.s1`˪4vlvkL3Iy-;;Qs9gvu^@Vju'RzXhi{B 0-a@(iec?q`jJkW|qkiXc0Y{ ʅh#:,3;.,-p/<qad/0|	j')W==`F !u",qю,$j2hG:W	P{k fqAA^jrt=pZ(0Ozq\CuÃl#>@)x&JBá>J'*z,5=q̀1E vooޭ#0<2O@4@?7chh7%d1Ta/J{wĮ1b{h4G1#!0y7c@t8XX_oqǟڻ-6/0*tQokAcM@d	#30@`q&p(Ӏ8%>  W4Ǌ-bҞn Z@j f-'0TX w)ǔàSPbZ2<nn9B8hm+	h>LA`dvqe]CcHP thCHcE42R2VDqcX u>ldAd NRAb]p:l1XZA4L^M73U{<ywchu2*ibu?P,n\.zL    IDATj0P0i+ݸ2QWs0 )!PSx^QÄ, K"Pܕ
BeF```jxN+^, S!=ef|mI.#修[ VRy;6T/ 
1JL+(@V$sF+Uئ,Xa  ol޵k={vn3#8,1|4VhBxB ! 0
qɱbty]{t-Bkӥ^  ج-N~  e"dCCOwvv(pR 0/ 	m-&yAF`(ƀ &|X=eCEX5@HH6{!F^:V  D~G ɌhT5J HBKyP:y/m;L,-3# @{߹ /jI:ezT|<Cz)b4'Ko]?&ek	E YI-B:=[<izsVx>wҾf?-X@ d"Uc0X\K
y/lf
ljb鎀oi^k"UcQTq@mo@E!0<jtk-q,(8U Pb^ @QXEz1?BɌUb^O< l2+ xdc]f1]Ba/\S3^$EDj,"%Yq!! z !-I3^\Fjl\+طԨ?땋UJ_F2 n8
;jl+(⹺Ĵv}jKw>l9[*MrMChuܒWU qp)D@ZTj֮YFvڜ.ro!0ٵ	wrkހ0L$4.d	\ۿFg2{Ji0UW؛lՌ+i'0=2k"UXEkF.A0 `ڧ!dz ąCG(ud)ֹLB6]]w$kK͇;\ I-BE3pi)Y~@(KW~`"._.K])^Wv7;)_;#5pUNYJ4*[eCNc''3㷩鰭0닆%!W$F@ {WGF XGN:՝`3d(ϺL$/f:Iz 䤈_^?ybq7N QHy1{j&,1Zd.ٽ4[ȚlU o\/L\췭S,^͑L ѹ@|>/v/ +v 0y@z"`ɀ(
';j)&7z@z"Xǌ1R$K+@@Hڹjj H$*CcF`%9d sOݥX#_&HSGmv`DW;vZ@ s`).	H {\@rZj H*UUGFlewu瞬uW a.66k!?=M[y^wo8<Vd+_ <lNQvr!I[>IawD*M%Knj~Zp:>2
!R>\9w5̘m%w DeeV@ T!Y҇ t|P@xR(  "vƇB  e6y'@o?lܖ0/@ ]ƪUzv&l@! V7:Lئ<V 6(D1J1!UOj+6*$Q(@$[b-:Y_|P2pKx$7-BLUޡޣyVƨWdXYj0r 0x
eb@ z/u8	usn|ju Yr9垠ooD|YffjWq"/lS4(⁦Td-fJ  KfU>wֆY;zTd znrF#K?,o㬉И 0̖%Ty	>#1YI&f9!7##h&Bc@{#CCFd!@]|F!

	u6-mh@`hv#d@Y]BjP4:8ϘOՑS'R!+q  ϓFWQ=T
1YILr[h~vbE` *
 b#F @ $K)bكt@c l@ =d@_d& ]	 HKcwbIё^#<e1Wq`}/֫0X 0,/1lyh#n/0~~wX0(x1StA"й@{cWD,@uqel@LiձX|3 P-1"x}I--FNi&6?t;Z]x*XX7v8Z\qx*}I<PG_=̯4As'Γ닀 HQhQBx{Bz^Ҩa(j,W{ھ3U/:5m teaEm"4Ue[z.mAY%#Zui|d6<3E8EPPwugUD@9$p1,
@rEN8^yJ'%3a0|nY+zJd: ^
 5<)j*lD  ie @yМagS?$Xn9gÔF.^zQ8ö6ۅ?d" 0r:2uˑOO.;nq/A ?x<]ӟƔA{ꢼ"h&w)7~躭8%Atfc& j1gC*3tu-kx+8x?l5itEBG0\e+f8
 '[%*r;5IƯ<pWPzz(h7yR
SlGB3aPHݞ/`" BdP^o|7{F`:1Uc޾^`3ar;#̤e. @,czqU%h, M8ڡ4P8+H߶f[Hc#T}ԩDY 0j= {CWZlNG@)Q-SdpLbq#̍;Lp& 0sӦnDL&nctAb` dVlY2 	D7mbM@Ȓp^+UfFR}A%?c3T F}āJr/@瞜K%SRPaM璙*ے>"$ =yG{JMbʪxx<@ Л%3U6#OLUc+^ <dŭ+
co H~!")R^u	ie/DQXLb
3  | ߿sϞ==apK P(IZmh/V)f0@ I^`ozD~R<\9w5\61\`d0#,*n]/E_ 9 B0DȈ@a~q(AhS th%yGyiX/0hmmuFMߠc8]au#uF_`zG8uu>2Ɖ"PK-$l3zjk#]oY@ EgV26*>=@ -M"z#}0;-ƚyDK}6e)P(vCC6h}-BV^`hÆ oU^^^_:l^9\VYex*oO<Rb>e6UR@m#az/;kV>hOϨX־6")cM}]qV<akb #r~FRO~BYC}YCFSNtFd: G:0T  cJJ
fmǍby 9uRkUcڑ?z!@tDhQ=ٸV@/ʋ%^owhh1@-2l3'VJ#˥~4eR/ [5=7V*BltXB`@;wn뙗/aѡBӽ{ߐ@U5LeLqBLrVwg{(+_m0B4D#h-qϞ}qyǆJ( N \q dcְ#f@z  @XttG ѣZ:\Qڬ5XjeXj Tj?' IG??/aC  ^`:ϊgt^(tx;
0L$(ZU
/5[2x`mE@B@U/e7n-(
/ @"s?P5Z/v- HtxL %(-{F K@BXk .3 '-=)6@>?Uc@` `Ow>cX5n@ yq0T HyHUcz[hjf kA@Gо3BVUHV@yɭF Tט_ ld 6  bF"HU5C1纜A,\Lԑ(Ucj.=63kitz8'O5/د 'yyUcjbTM3~PT"d:_ӏbg/@$Kr՘ԲkdLU(Uc!`c.mS k^7( -$j̀^@j,F\TG$ !Z֒1C d( @H)fPT }I(LA?8@  hX˺jrBe:-"j#QbL9ߗ&8*]0~= F`HPEc(P@fvDhk@`a@UcQ!`_61B 1Ph?`!F`(Uc!09F N ZkŃ41ar@ ĢӲj,vΘ(/v.@J@kM0 RZ}N_a8-m0L 
/;4@`@ ^ēFejTWGcEH祛`@ e^@ejlаB`1N:ˀ@pͨ .u]
t5lQ&Km\?-iM]p@ U^aī\	&)bj~.Q-\:)r!E.u y/ *$awlq?V3P@h @ e^`Dve0QT%Pͫiu3	D,@2@P@Ta:g%(WgJaJ}Jb  BL\Y>c^]lH	H! j*5?P? Bʀ x,r  &F 1    @      @      @ ӧOw E`Ɯvh"Pdkt &KhU@ ؁1  DF 0                        @      @      @      @      @      @ }xD;   &d:                                                                    @      @      @      @   rh#	@&r{C===@ ;v@=y@ @ hb#1@@ @@ @@ @@ @@ @m             +(&8D@ `BE`Z]h"#! %6 Z&4Xn@ @ @ @ @ k           h#P                        	@?        2~& @& 4u`hDCQ[@gӇ ¯5   Z&  E J1C J7e^(        @" @6 Q@      @       HX(ZC	Vq %Kg`yǗ`yʖ @OӋ=)@ Z?H˷ A@bx/   
6thi[-Lεri[ HOb/"$6/0BLC<@?++@ wrkOYV%́@ uG?ݿsSy?A>S>Ylg06[9@ c=tn'H'qYԧGn95ӵ~k|H!G[LE[ʴ'ma{4@ sK%dt.k-ǯd$r.k jzd92ukϒ݉@kmYs^mHE!6@ ݑC/#-"8C㝜W̵}2F)nY6:
B!@8`H  @ dÉG`   @ Оp P3g~NM j1`X>Ntݤ;@z>럾<񓨘	 @`     @      @    @  x    tB"`_)^  @ PT"#^6T2 s37H #wWlFy=fUVVeREKk.gpDB`@ PW>'ud^DZWY] /GylΆkZ. I>{YQvyGh5t0K6Q !a|Mpc]A  IDAT 4&*0hyye||yќl(5}t2 GBuKĪ$=#zr//N qA@s@APt7E$qgB(բ/o$ N` G#1PY^V|4N|3k)r-' 	(N Dn	1B@-A@ĦIά2(" L A8@nP`*c>s(ժd  
\:1XZ"0̡c!AmmE|ҧ^ HZ	 6	,@W*	$q Ls[}Pj_] (Ȁ( bQ1/Jk d@:W3  _C)}{.t&`! `G <at	hrGPE/< d0`#xsŤ2.X*arAy $00!F~SYIܙ@d@
_}As ]ʃ/Ir	K$ $qS @E|5Z
AOeKBcT 0A%^86KO⑝~{0~h|hpj6              4C     DB       ЄD[Hв    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_link1.png
PNG

   IHDR       Li#  PLTE   8 iT- &=@ 7M ,7e'f 9^ _* 
((%
,~ 4)0B71%U*!654 =e/B.+>9t MKC5e:q??6K{8:8HOL-SFz\QAjo:>}e@!yPvCD6x*O1=_hb7om_PV_BogCjZhf8d^me W|7R'f ]B,np#wmcioO1B1fGg}<i@tnJvfc8nW^͏9 5Be^̙;s=Ј󩠑/c擆ԝiًaڞwҶƬuƩ¿֞պ8e巤;踰³ųӄֱȏͽȣgՑӾ]ʼݳМvڌu~4Keamzmqs[cj~xhKOQN}_Zo8^fgeLS`^	FHJԍ²r< KPTN{`k#_=  ~oa\ ̤h  eyJ  a IDATx^n0PzJe{M/!FdC"?F|WY=wfpB9 eS/H(@,j:UG8/T,p\ے]aJ2BV.L	L_	L1HAp5wd2)'a\$NhNhxGt*<s2:Vn"0,QkBb+bk3sZwWޏz[6m?l͈uҖt?4O62w:։ |[,zOS2<Q%nAL-q;[Z6rl׭Z *Vt	I>)cK`yd=X/gl\9lSL,
`0O ?0T@h<N̓xfEʹ{jZee3-KR7ʉxi[m(g}0/z˳tm}quRTeh89.p#߬?kqwirl5
ҥwIBT7XԹ&E".7/IaG8Bp<h4%]^x0ђI+>~</	z!$xd{(xy[ڕXꭗ*e2cuy֌%
W`a-t]uhhGU'>9~~jl?8hWj罼<?nVnF 'DoYHS0de,)ˊ]i{^ghrKaȡq_p`!pX[듥NG)30a*5X͒f@* 	PF; oOV@F a @ 	83\\uwh;\=I)>7
 !&jStN	PM1/K&E H^: '@D*Xxh{@H@P)", 0@j]xH딫4Wz׀18jqg@b P"k\4!.)X70&n8uS@GjojG jxoՆ$c
U_}t`O<'pΎ(`a:k$p!o/0&T炃*8tNkӱj+Ps@	p1"(
`L-{ АK~1MY>MT Ir7ta8<- O:>g}C\@sk?^=M"  gS RÁp1p * z,cRshQ|ł a~StGWhMPhs*-b&V
bf8	_/?5[{H`&uv-~~-R
ehsn`a]# 6'@8ϴ{	<օX=  mP@ ߥ(ݑ 0(N(8=̞[HjЗe  $Ib(G\A f #RShflZG@$ klAih c))p6JОm
dl`p^7$`(&p
}
߄|r/fVvkMZJQ5x`ei"%7&L(uZDBJq3!uS
U&/2R?IMXnk%c'c}W^4nHQtιG&}#+ d	  SNr6`!뤻 o;i&@3@9H:ur^'8ܗON6B4Mvˣ|u?ރmgCl#82A@2S38_ԵqV]ڥO=ù_R\t.S:G@fÅWM,Dx,B|c206ȵ%cR0	pTZS wq@ł ѻh s-&O  L)	zq`c +>	fks @ujjË< %;B`"ͅWC~	,p2VID @&`
 1D cP,WE0`6lrнδEo'@9" u8^kjza{?  F6*F@7!&0?}T$sC&&N\"08rq|9AIyM\O'Σx?ޡKK-:ydQQ8NbMV#\Nޥ}@=n0n ɯ15Ҹl@\5v\4bgGq.p6|?^A"Uw<ekv]Re ĀFՏr_kX!04t֭3'eV6u7}d01N-<W&C{}MdA}XCK}R]XjH 
D, $J^N=NfM
ܹM+B,UqnnkKBa!Fz폀]u.fyBE!0LbNuśb&<@G@@04933?E<4\ zLO<&:e_bJ 2jЀ.E;*І-((PPE`K-Qa׉	F Qi@3_}U}榴[`_"! 1w? Ix8,Zk|UQhc!psXhttTF0f tܵ灀oI .^'_#p%?(h݈yr^l2N@]ځHDxLOr# v#;q.rq?p[UlNA=2l)+2\S1؀d|+O@ 
EѨZ}8#a 8CQPvnnՒtM \džR" Gȵx]Os Ds&}6$hFhF:b!?cNvS"0BWn7A+RD~ᴱEE@@ EHAA\CոU(_mҿq
^{tȈ[X@5Z}z/ZQpD
Ǘϝ|x|H΀O~mnVD9c p"QmFt8~N04s jq?gc*
)K	Ƹ=lQd$X? L@	@~43"KBA46"3sP	\5}B-7 
_UbcqehX|A%!YC7od˷
F@1p
|EHp j7焮0ڀjPW̅AD Jf$@UYpe [4A@p,!zВ&`g&$
`@ch<J_ɲW })6$]A@qCsm}՛L|co,Ā 87_BD01|nJFkR3bջp)S F lBt`EܿPzy/|QSޠڲ+`"	$	j TħC w޹08 &2op5pyHy,	a)"E{Mnswdu)%}ޭWB `U%@UO\ҝ"DLQv)@o ^a0l@̝vbof*sp)bc,F,S`?E,Y@	*NAG Z*n l@ vt:RD#^='{nғU"z ))a)=)`?|+<$@
l%(@*#p*l PJ
  3*mv 89	`Ѓy|m@ ށ V@v|(?5'%@*$
l6PCP( q#T){@)\a	.ӻǠ8L'|H	ȁ۽`7a=U;L'5	ʐm^n9I`#l SS@+!Q HM4EfVǁ2\;i[\εgrhzq*@$ &

3Op2iF
&Ty y v"WN0*v2U#5m*d I
1h>  <v`;ne-+(`n ^/4^@R	 ͥ5B#|tvSek`

1!;Z-(.fBSs4MI[^`D}LNHHZa
 +`ɥmf#8`Pl;@@/e#k JI&|$
 5"4:()v;Y <06̟`0[\
iCX'iӯ	4A	IY .*$+(E^x!"[:r.Kz>hgw|_GrN_5w^6nyzvZHc$q8Vر RXZj5 P<N;$D	F--|,0(@]0[C`#Gc6n6FnDq|֘@dKB8U\FҧT" jzsAv$#]4)	2)y?gF.fV4>ibse%/Czn"j" /Z@& Ǐ;  ͸r`҅P)tδ~4=p W2ãFo9fXXIM誹k,71AkZƳ5 sOɯ tO#KU!f(X\gQQ<p&][/efmٵ@7Cn# DP;![Chf2d6Mk}`+v}7#NS*@qeE<=<P9"@}I%)x8ܠ,~39;4x]Р"7C:?R.I}d!;$Ւ&;8: @/JYRGMY#eQrGK8MBu/ "NӴ:QF ( -/r*b~2;ƃ1%}6cRmcW4燃+ Ȍ;_yc)4R.KMq! R-v?*BA/@ut><}|o˕+5. !Y5r!Dܸݗ: 4
]hғcRDd5Ud!T-dͺ Z_;F4SH0AgOΟ oEk[5wD"q0n2WV&$G"%u!o+r2OJӴ*@P!ā)$",.5^k$g7/(an+r~q m9@40MD;f&/U}.R'WǣwqC =!!Od0zaU-IrHXuCHzIK +~ٛˁm)̧-0tP g8MU'=a.x	 a@V>a_tǳmD VSjQۇk\^gr39A@A@A@A@am (^gB7PN	 z9' Tqv/"Sx>o~ Cx\ޠKAKn,-!,E?x g.? b3A!75O]G#N M:+u]#6![M\"IĘh 6FfW$"3'(c	,O)܈ agՒQ2>{([y[kt@HgpQ/&4"x !Ї=IЃAqO4:K6!9T#l-fB0
1aa_U09!u4g	pzaxwmAgvvH֖!;<bmnquNz*1{`)O"O)$cK<JLxQ̜b|R$GA>y*|e=㘧JBT|r6n_.69E	Swa@;o$	 E|(3 WL	y$Xʋbf=<I2L/athg:}EA8z G 梶JRa;"͂+?I+`׹Y׀[ny pVĄH(QH<E(D"(FAUU&* 
>]-F!pJ_7T?P5i N0FϜΡ;*pV!x[>JL, Xֳ5<89>*X\0KD*+'{`$XM-M0# [辺/ӗ8z=*zyb
0֯X	q2v;{lmr]@Ys@YD6L>YwiNg<TL  @HYD *02X%Qugf	/
+2Msm'Gly~\҂`\^P`EC( ٳ@';cS:vE6 1fv%YZ:(7+32p{׹^/!·% JИ ('F0mNt5#Jbĳ+l#Ĝ|_!ǳWH`ٜ. )=އwK z(Zwa	a zmh?S U>j0>@Yf #
NoBO!IC!uYpŗrً	ٗ.Bu';aŖ!ҋ	bF(B˴Z
6!1lfgS9<0\kR߅. R!
47)t}]˶@.g[WY85 .{OjL{?	%2e"8,#\#Xx*Gd@EG oBG`7R2/аd.DAd?:D
`HH.+;i`._K{:,[o)L*7;Og'[XPuZOhugζX\s,aw{e@H"da 0$	={L{xP

@P72) P Qί .RN餯Ah^Xϧ.c/p @:Zntwa@
TP`fL
4(RjyepzāzZ6Հk4VDVQ|  B,`ELsfD  BU~XhR h
7ujS>(%T/I)h 鲴4uF@@J峍UzC h`ըi@\~(8z'gX,Y4ėNe="N$gi0+\p@5s%LCtCbPDFhJܱghXs* (၀
5ETEcYg^R)km`T`6ҀQ;! ?T?h?1recD^ﾡ+ (s$YP'ts?g0 K&O0S/|g-a ǥ%	v!>F{"Bx`N)=e=5r"^/=:f?aaX"$]Xon:v:xwD9j6l% ;3j/SItss*K+(1t֖MAMk B$b}`w	Wg}%!Km|(S ]fopnb?+z%F#p%* BO&=YL 8 p_uo[d'Po4Rl8`,'c91O&6
J@^un4)i` ]@Tj7m7h1
0Q7G:`! (ƀ1C>'R! 	M t rb	oKIYD MSn5O&ws*P#AWd88DlRz|MM5jEYC\(0Ľ tq"
+  sQWݑ`IYCXғjM^kZUV*
YtQ>PvzP-4PR@/Vk(0';gt)SR׹"മWOH+@0իݥ<8\,#.YF֮<W٬nH=o\AB@ !=) vu2N0_Xmޖ9]vA(Y[BF=x8nX`uBL]`]  *1`@	W+?:ܲ;1E	fmbaD{!0!30R!MJ׾ @ H+kIguFS;*t:D<9']l1.4dMMQ>!0mzG8J`WmSW|c:	c45TxZ#V#X]H6BY[pK4dMA d{~}|{,PuV djtݜJ}@PQȦ]  ֊#5	  zqj,Z RiZ˺ (3/ٱJv= hA ٖȕbT \p\iEMU48٧Ht@	PSNMBn^i(DMOc5"Dl.-sJ P@)h8  D6rFGۭuϒ kYD"A6B&i|& A+ (a]u-\BG@ BTA⥞	Xr#(|Ap 'ؿ4GA/zD !Dq4z&Lm;RNj2XߟG=G^jrP ,f%KXz]U4HC`il?@ *k9,!/Pz^pF uU@ق  4g` lA	Ù/̛ܳD`B`3RI4Xhфd}l{ghhߎͻnGGTJe  %xd:snqU @ HK!0;g@a;lSnq 5{
[a oq}FE,@
Y"lY.1)++.P\FAHz6~ zt8ID읛|G-`9Ocz	Ak2G	aKT*&׀>g0E	RE/K3wm)ty:*pˈ۝4Eg
5=S@OUoT@#ؼ5YYH\
	=W@oAp"{&@^?(p/3/h5ֳPZ|g6 @ qH,1s`&4 ?ag:ASQ}
GqS66{gH7n]`ҹR"9B)eBZÂAA^]Ib.E0iߛ˼tbLhw}e$gFjH,,!)B г=~c^93LʟԎ& dx5 /#`vx

D Q}\2j:"H $>>&0B]7Z	 OF %HTJ J64E!"!pX,EV[@`)( 2 a C7pљ~o]cc3Z$L(C*z*)D	z~rkviTv8D _/K#PA2d:f´ jGr!N@XFY	P^eQ_U L2FE3
)#" g]ҿ$S3G<ضX!x@BRoYM%/E&e  @!c֚M9D3\4J*}?I? ]0ra&p!4J#5։"P}w@^!A8H0B~tE[x؃0ɇ)DZQP[jIl;	Ϭ=gSA$4QQ WXwD5G/[@%x;k6tXن1-Z(#$hͷ .,i{QsѸ^avAtToD|J@qE"ɰۮ
CY ]餬dv%x:/89NȻU$VFO8EiL`K;yvH¬q"(?4RCCQ/\/|fw=a2z02@8"*_^zݠ](dNT) 1 zg"$ǶٟBxG X :J· 9s?lT`>0ZKz, eCK>o\ !PFBI$+ 0C %95Jr;./*!o L`xhDE}g|p~O!0P^']OBA hwzA"1D@"gaB`g{:FA8,x ݳutuMd@GmA6oP)J?μ/Fu%@	!L *Q	P"$Q1~oH  J!	c˷bAH1(F&@(u ס
0a@7X|a q,X \r܊c߅p&a ǅɼi#`)*Pw@oVlEfU8;kd	 ]%wsQt,'䨋74^K?P N.ASVJkHC 7`q)7l+`U}#r'RGjJd][ [ L gyi]/  %#PC(N<VVFzgr2%AH#(BC \XC  Q$Qǭ&d8@Ru<<艜1(@߻jn+vՊP}]	,;c'(W8& W9p
JmH#.Œ"slx6&)L%$KNj%9s$LqZ<EP>{3s{\dv^?Eҙ/wD%̰!uz!qr#KP`Ur\	]>@چkvz;\K!;
Q
fs5@~3^A]jENTwZZō,P dIߨEDeC~:<XVYB3"N>ٝfخ'@`R5ܐ `DsCoЖteɒM q\i3"Nܥ<  ,_C!p 0lT7a@ &x $;M^uC,
MGa4x	ZӍ, @VҎ[/}SG`9<	spyؕ_޹)s?p(5{JG# ʱ>ZJ X>J&c l
%̍偗 t_6FW0`OY&h4V}cME~b@3eaW.`|~©0I)s;:C"Tý0E`
(:hCU@@0AXw6_G" .`E$hzXn  YV72Ŀ/p{`7I_2
Uscm"i&pL!-Tv)RiR;k;k66P܏QB4šfow/ȑ?Ȓ±ayw8@hpyN= 9=(|zH= ] ׽A ҉*HXd@ $~HUC*A@qD -oi_Ϊv=JZ	(8PF0~GZ
)mLjDb8` s*S x#va&B~
~> M3٬,{&B#@AFjuCoTuB"\*[Qt_# 91G"KQ)ژzrM|L.+C`ͿMnˤD.ຍ"`^9$dÏKUbm. B[|;:XnuK捛A?`00ˍLzOJ}@4f0aoW7(tf%='pmAP!	8v %{㽟LD(@uLI
 p'|@ ;iY
Y
(4(IS
`Y X($EQ^\ٹc a n856Ρ3BP$l,,*b#B o:4j 	اz/P'z&ps>QW(Fd$0idՓ=C"xiЅ2J0j\At!xe0y5U'\yTW^=UMڡgϟ;)TXK(ؙ nB;׷M+Ez(A"k&/^[<aaa΁nJu
xz"~r<JPV7CP@E

HAD
=Ԉ곜6@-ө)4mJg~P
lR a!B(
=U#"HTD \4Fs(~P`YqlIEbǆmȓԔOeBVN6?{l
`W BT>xN-]=:DP~KR =S`7q6[֒@ov &iu8|51-^ <:rv^{
 ,F78D.ԈT_PRFq@nfR4b}yY3+Q4sI)30o̥౭,J	E.7zX횗D y8:q߈8Lrzh'#_r~y?ָhRP&e@nk'/e")2#QwSSUǅ;Gn aT9LMZC(T8Z-KYȕ%- GYNEgU%~"hsG;y0X&ҝg-lϣp qx0^?wHb@_18jS'LB$|rI

BqFǄ,c{
?E#lNmtNG@	X2f6Hh@NsN4K\C^BiWϭw<(UΏRp>/oQz
ċݥZ zuƤ,?	gi((SP e9$TW@j^(p
P'JͯOqǻseʏÆ9
>ֲ0`JO3J 1_8.P	0-;]`i3Vqg8EMF]〷8tu!_=ʂT=?qgUw/Z/I?<y
C.sc7=q#9˵2sKд ?Bpgc5HcfNzè'~jh%\zt_q<|'uN)O<n6qX=([O='uE(^64PeBJ!ۄĘ6e]w!s0lbȊ{1E_s.4޼^'qp6x[Q@(ʯj0ȗB<ME]2_oUiyņFvL7Hh
f)@'9c+NG( S`C	5 DV@i4()p}y )*f)V\ivl۾w9.no+SfR$IT`@<ru@ϻ[Çe@we Znu6
,+}J
،d |Qtc&VEQDL<@VU:j_Á
$fOyTc|ՑY
=08:ypo99yjUrɥ9Onwj#= HPqfyث$yP@ * @H(0&ؚ_f	KQ) ]?&U`(C S`,:bI={ D}Nb:<=jC	>^b)`{jd~]@m{RE%x/P^E@(D(
\Hu+hXk( ~@7.cy(,6T4)mPH
^gsP
p§T! B*`$ 3`*@\1T ZA:зP
 SP k*`:\ۢ @jS\9(Z\*=P	񹀪 R'G(-e)%Vvne:%o*!֘e-L
%wRG}T@mq`b)Pb
0+@2PmP	
AƲ5) 8ssUWVmY5RI_}/蔕͠
Hy2 (֘w<|P'h(Nسr茇nY*V{gFrqj+vzs)W!9Ù׆6C,:A:pC(Bq'lۊ,R]&Ө.	N֡73ݭyW+ٚا}G Np#/Ai>[e"wrTY&DM!箍G`!"O@Yc?98\{lN-4H@m0M&'grhכ/>Dtb0 PJ@ѫ|2>-4pF#p\`qф "@ѻ.Lfzf`@  .pg=15@Sgfcʓ9n+hQf"8F]) :l: pT:lF CdB@:)ˑH\@!eM?"P/X%CE\ MNeBXooog[ 5H`yRy0xl+ A3 % M[Ķ"A`%sc9N_#r0	. &$.V# jҾs&
Qg/BBRt/P 0`V-S8#I]UrB̪f A0GUN"pAs/$>477YB FҴ@W{zP=@k'ku@OU3tj"-_DKf? E\B߄lӁ(i6-tC	)5$A8+L6HأB%j4U/K 
>O &@ub௑ew= 9tpI	e'V< mؕ޶O$+IJ@,vJ)C&&̱ ii#j< RM7(H(@ Jt@.`HV$'b
ULnn'7W9Ac+u[(榉#h׍	>GmWA tD%@ ngєK}D'|\("`xhc`*ii0`=
i@Ha-4q$M%Zt
.
c@GC``
k]moi* .!UvK# 0:5  zMAA+Ձx_@Qk8q.xF@1q7= " @԰\ @c.D Wu^fVA{x_@)f ".PuyvTA0_e*!.
  V88KMyꥯǉUDZr?8sg,D  . >	 
4x$DX@拓`awLy`flRvT2(t!K:,,(D P7= " *8G] <ubc.p6.ӬؘxO%M^_X 	m|v*3G@ʌU&  (N%"~PAK/خO{̠P"j3u^ +v0 F*3!x#FP{2CsR 'ʯNTIQqH\F*3!zW'tX5@W1Z'D\ 	 \F*3f .-:FpRT"tL vU ƪ2ҋ,IQ2$B:j3:FIіG 6u)@cUxUWM0ZGDŴ^M_iΧyS:FpRTpu<	u:F=ECτV$t>Yh,Bn{F:u@x}rӮ64ƴcR/^E¬1̐1"O#BG $F* }k>_".@㉌,x(d!8zTH0M߽".pqU+ #	W[&Ov4kL!c#l((LN X_GGao#/L/ݴZXZdLpRtaaii6࿕NҜ2"U!'/\ MNxV2kX*ӳ-<;`8ہeZ݊`R32"I tj"-_F*GHTj0 =ZXD<k" _IR meDIіÅAʗ$XQյ0%y0kÇn8K}D'!eǈ@]]\!F D 家Vkڏu.\A5`}O
(ݴD-caF/@h%Xea0[GkNV.
 (>M,n &	!bqJټ ({G;8*%PCm$
Ty	#Z+5"FUh"5S)BXɳ!nhm*`YD#K(a?ޙ|xwx;s?Ǫoιw}L20ZFvWe8C"k^\xIpPCjvqNMb:ǧ0 L|̝T?ux(r8̶Uց Po>1ֈ<y%ACy7uS e;CBƶ@NE=(r^pp8i@'o{<^Vrϡjm_A^D%Uv۷1jK<Sxm6f 4B @R繨ES5 *=B@0-׏éǖ[{E
$z>޲yxBlp슁RZX{̍^"2,B$_!F jLS/B $ S0WaZ8N(^TE2:5G鍙Ysn@sڞ+i I!v -"p*	CHŖzF l~"PH/?f|`ׁFf{Uj% M0N>p*HCw$C%F a B`C(sx2ӷVo;=FgVc>#V@Zp} XTW6>	}I>IǇ]LJkCޯR,do<yK;\6|؟g0{(-a9qJ4A-'TB<9(/?]BVdo^(ԎbDϳ|5V2lA@RTd\Z`p2 ~Ad~yhA $- D$!Qi   PhLAkA@@	D(^@B@|yOA;r	jA@,W-(\PZ,SN=8l{p!p{gk0EF@M2}YnD@:)q`'A)'r"H"˨k镨)$Ci0WU01թ.P=9Q,S. 큀B-G2M׫U}RM.㞌nWO6Q,ATJ @Z JhTMEn%JFiL%l	5"lm|F )@n@PS}@rjA`9?[;aiEA+<!dzB">+e	C)8}8%݄WuB]]BE^X2'ˉ @$O? ߰Ρ)0Z@pL3 <Aѷ-HPAܡ#[/@n41?O#rx`۝*fZ|Q6"jʘ9r:D|(hl6GN!}*NN&;B3W1l4T6j*g8Z^א346VV``1!7,@Z(B0)
{u)ex~=Ng=B6O~>8
\qfۋC{!@)P/
A.Qs"x?bڵ3@@goY!e 1T&q
l14?S@6N_Z`
4ju]6Y2pTԏZW96]<G}2{MvѫP-xi5ǜ(H&pgVYM>'=@`BaA/t"ԝk7$K']šh>-Y]過 0"૱A`rErЃU d~X?tä.H~.3[WXjA|^Qz7[^- 2cڙo2UR1&|\X\Z(}_{/%_=~tYE5U~QX?n&ٮ)͸Kمd`vP	 w}`$ZVN/9UH<6wc/?횒DUviQ-BBU0~_mRmᬾα@;FxV#zǏ)A%0^!rMDϷpK6Fx(Q6VowG 0_ѣ>!4wگ>>|ޮ)@nr3Y,~ d͟P;WqJ	h %JE8rc~Ph"CD@ @ JaS'6&vP{ҵL`vBƥ!2|9|4!TvB#|B 'c/]S:{S9@KZ.~B/hˇpe4	D]ckot{Am1=׷぀H:0 p^:h^@(=@<GC(+B  PH"b5&EJBٳHEa̐ 2ڤ3[DmO*FKAAq*~mf1*I4lvߗs=3y/7!]F F5㢎" ecEЉA F <2S    Is Qߛ	W?ԑ[mV;./ @(ߌ5O9KtO</6|B" pVR?
-"/USqөxp"̂Tum^1Vy#g.=휑dnEt*ΆR㘠Qϟ乲fF	dDHHPP.p<b#)otxA	Er@`֛6B9d$^L+ި
@PNv#$Plw@@J5'swd!-Pe\:-09IݳLi`O&WFH[1]@F@ ?nt8>}1|0$  }7HC# 6  ӎ&g^2GDW'^7M;OfI<Y.e:wP>~pxfU0i&E<@}/pݑ"\uAPAJ9mA8HDl.dۙbgE[ȉHCI.qv2c:Vab8xl|Oq(19R	dPTB)6B 8NJ|ʨI^{䤞E]?()vCk>LWk8htdHГ|r	 pU%" ԦS$ź;gºUw?/rqkHܠ\搃a!}]s[xSBy`Cr!Ң_ L`%48ڪ1һno!3]=S=Tw |ŭjjA~! <m%Cu.ꍊ kTPt|6I҉tC`@[C`^0zt=>_fy:yN`v$i)^?J'=VꝥR%zGcil7Ͼy	BӥN.3Բg%!pd.p{&q@ /<n?C'(?]FCvs Ӕ	d	;ս*XV/2, c=-Pfn{TٟO@_{#8<H

?z͍h9/^ `KW7f+2K@ Zr]c&@5®1vAk]c  a[f @  ? 5V변˸J*]cIҷwbVURCaA[fd@e%wj2jMqU-T+J*]ueTAC	eF	=vUPiYTVR:+@B0`L@Ы$ܥJ*rr=bYh+T?W*+Ȼ/9C	$2?QdrEG_*:@Y@"˕PyyE"'R^ueT-!p@"*Mw  & e  BFן   @ 7.   @  @@`$`3Ւ)mJ? ȇ:Ւ)eaOm&@  u/
fkr$ȿdݴwKb:E@`rR36@?.d;G'sdmhh,@ 
F&CIySHv :@aN0p#LY[sd	T25@d(L1*UMi"@@     @  mA@Y@     @  V$CwF&@ k_7 lה5\ӈ(u*k@H	:}ymC@]&WA]T+-,@ 0+%M~"D ~@@     @  &    @ ,Tn =y:8˝t lR)m^?GϤ7˂t!@x-h#/	ekF6Y $R%+Z-"@  9Y;*we!dBH$,N @d㙓#>+/['@ ~@@     @  @@   0G](J;ufήV^i%_=^2́T^i!2ړh!߹?}f<*JoZx*07\W^VMep]mXx|< 6r!BϬj*b+& /:A[2;6,E0 ^<m.Y^]IgNUSYQaᕬDw@ɣSyyC	4J]#EKj*{J^ d{B㏳<~| @  @@   `  @  lo /-6"!    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/caution.png
PNG

   IHDR         ש   PLTE     c Zs { 9s BB !! 11 Bcc  9c  {{ { 1 ZZ   kk 1ss  5   IDATx^uWr0Pzw%3HCu?ej#Y:(mD\n}z98݋ȏKJQyb`ܔ+*k\L[0Mrܸ'_4`.Q UzPxu_Fpruԍ`rXn h`!rCͱ> Ȇd֫\0    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/docs/images/vs2005_pch2_thumb.png
PNG

   IHDR         4   0PLTE  OC34WVW|b\Ae̡`b  IDATx^O0z!:7r1Hf?qRڷxaf ($</ a򤙨Avy Ir2kXGY(?;R.I\cx*{Dzn(DK=nRR-c pH̳牔3)^M( oPh/YKs/VpԦ"WaM`X6w}xP4p}bY2{vH|@y\zWD0UPEgsrńNNZP9	+d]DWu 20MLI]"<a`~B娮 2\Su.}kY2IQ1B'Dl-oex.*RB'D6*B[	ܻ- ݽ5'%& O<_2} X&Qђ;;,!e$	RLdp @,h.ЩJٴZt:%"#MDUWҘ!}Yd]ťTBH!]0%|Ք3MطyE|D#Bƨ XIB*XfDmM(BV@!Esi5z\fU\ d]WH#$IopAxkwz&P
A
	1p7~/d:B9*K^u}*uKu<` S	BJԌFfP*R<Is!s=A3vvf|yF*S,w]Cg2[yϿ%S=C{!\ak$ dNy8!BEb/E(Yi. kS
/jҮ1LcBظd 51O`x&7mچzu$>oj6F["Kۃk\$0hLȜ33q%68#FzA'z64r[SL[k7&|>6N&"
5MCFo\fՉFz`Jm1 {̠ӌv,mh&
(ƄTO}h!h=9%TwiuV
[a+lRZ7X昑_  >uaPyͻ.k߇}8vyV P[[Kck#1!ǘ`-fb]^}kB#x
0FJB!<UzxiPƄ@1u|[gBo\!4:E\EuS4G\~)Di*LW@d[hd[3!]="%8h,\O{p.IsX,4ovSᕕSC͍K_ᲱL׉F    IENDB`**************FILE************ ./source/0.9.0.0/infra/pugixml/contrib
**************FILE************ ./source/0.9.0.0/infra/pugixml/contrib/foreach.hpp
/*
 * Boost.Foreach support for pugixml classes.
 * This file is provided to the public domain.
 * Written by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 */

#ifndef HEADER_PUGIXML_FOREACH_HPP
#define HEADER_PUGIXML_FOREACH_HPP

#include "pugixml.hpp"

/*
 * These types add support for BOOST_FOREACH macro to xml_node and xml_document classes (child iteration only).
 * Example usage:
 * BOOST_FOREACH(xml_node n, doc) {}
 */

namespace boost
{
	template <typename> struct range_mutable_iterator;
	template <typename> struct range_const_iterator;

	template<> struct range_mutable_iterator<pugi::xml_node>
	{
		typedef pugi::xml_node::iterator type;
	};

	template<> struct range_const_iterator<pugi::xml_node>
	{
		typedef pugi::xml_node::iterator type;
	};

	template<> struct range_mutable_iterator<pugi::xml_document>
	{
		typedef pugi::xml_document::iterator type;
	};

	template<> struct range_const_iterator<pugi::xml_document>
	{
		typedef pugi::xml_document::iterator type;
	};
}

/*
 * These types add support for BOOST_FOREACH macro to xml_node and xml_document classes (child/attribute iteration).
 * Example usage:
 * BOOST_FOREACH(xml_node n, children(doc)) {}
 * BOOST_FOREACH(xml_node n, attributes(doc)) {}
 */

namespace pugi
{
	inline xml_object_range<xml_node_iterator> children(const pugi::xml_node& node)
	{
        return node.children();
	}

	inline xml_object_range<xml_attribute_iterator> attributes(const pugi::xml_node& node)
	{
        return node.attributes();
	}
}

#endif
**************FILE************ ./source/0.9.0.0/infra/pugixml/pugiconfig.h
/**
 * pugixml parser - version 1.4
 * --------------------------------------------------------
 * Copyright (C) 2006-2014, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at http://pugixml.org/
 *
 * This library is distributed under the MIT License. See notice at the end
 * of this file.
 *
 * This work is based on the pugxml parser, which is:
 * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)
 */

#ifndef HEADER_PUGICONFIG_HPP
#define HEADER_PUGICONFIG_HPP

// Uncomment this to enable wchar_t mode
// #define PUGIXML_WCHAR_MODE

// Uncomment this to disable XPath
// #define PUGIXML_NO_XPATH

// Uncomment this to disable STL
// #define PUGIXML_NO_STL

// Uncomment this to disable exceptions
// #define PUGIXML_NO_EXCEPTIONS

// Set this to control attributes for public classes/functions, i.e.:
// #define PUGIXML_API __declspec(dllexport) // to export all public symbols from DLL
// #define PUGIXML_CLASS __declspec(dllimport) // to import all classes from DLL
// #define PUGIXML_FUNCTION __fastcall // to set calling conventions to all public functions to fastcall
// In absence of PUGIXML_CLASS/PUGIXML_FUNCTION definitions PUGIXML_API is used instead

// Tune these constants to adjust memory-related behavior
// #define PUGIXML_MEMORY_PAGE_SIZE 32768
// #define PUGIXML_MEMORY_OUTPUT_STACK 10240
// #define PUGIXML_MEMORY_XPATH_PAGE_SIZE 4096

// Uncomment this to switch to header-only version
// #define PUGIXML_HEADER_ONLY
// #include "pugixml.cpp"

// Uncomment this to enable long long support
// #define PUGIXML_HAS_LONG_LONG

#endif

/**
 * Copyright (c) 2006-2014 Arseny Kapoulkine
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
**************FILE************ ./source/0.9.0.0/infra/pugixml/src
**************FILE************ ./source/0.9.0.0/infra/containers
**************FILE************ ./source/0.9.0.0/infra/containers/spsc
**************FILE************ ./source/0.9.0.0/infra/containers/spsc/BoostSPSCQueue_withoutAtomic.h
#ifndef __SPSCQUEUE_H__
#define __SPSCQUEUE_H__

#include <memory>
#include <atomic>

#include <stdio.h>

#include <stdio.h>
#include <stdlib.h>
#include <execinfo.h>
#include <cxxabi.h>

namespace infra 
{

// stacktrace.h (c) 2008, Timo Bingmann from http://idlebox.net/
// published under the WTFPL v2.0


/** Print a demangled stack backtrace of the caller function to FILE* out. */
static inline void print_stacktrace(FILE *out = stderr, unsigned int max_frames =15)
{
    fprintf(out, "stack trace:\n");

    // storage array for stack trace address data
    void* addrlist[max_frames+1];

    // retrieve current stack addresses
    int addrlen = backtrace(addrlist, sizeof(addrlist) / sizeof(void*));

    if (addrlen == 0) {
	fprintf(out, "  <empty, possibly corrupt>\n");
	return;
    }

    // resolve addresses into strings containing "filename(function+address)",
    // this array must be free()-ed
    char** symbollist = backtrace_symbols(addrlist, addrlen);

    // allocate string which will be filled with the demangled function name
    size_t funcnamesize = 256;
    char* funcname = (char*)malloc(funcnamesize);

    // iterate over the returned symbol lines. skip the first, it is the
    // address of this function.
    for (int i = 1; i < addrlen; i++)
    {
	char *begin_name = 0, *begin_offset = 0, *end_offset = 0;

	// find parentheses and +address offset surrounding the mangled name:
	// ./module(function+0x15c) [0x8048a6d]
	for (char *p = symbollist[i]; *p; ++p)
	{
	    if (*p == '(')
		begin_name = p;
	    else if (*p == '+')
		begin_offset = p;
	    else if (*p == ')' && begin_offset) {
		end_offset = p;
		break;
	    }
	}

	if (begin_name && begin_offset && end_offset
	    && begin_name < begin_offset)
	{
	    *begin_name++ = '\0';
	    *begin_offset++ = '\0';
	    *end_offset = '\0';

	    // mangled name is now in [begin_name, begin_offset) and caller
	    // offset in [begin_offset, end_offset). now apply
	    // __cxa_demangle():

	    int status;
	    char* ret = abi::__cxa_demangle(begin_name,
					    funcname, &funcnamesize, &status);
	    if (status == 0) {
		funcname = ret; // use possibly realloc()-ed string
		fprintf(out, "  %s : %s+%s\n",
			symbollist[i], funcname, begin_offset);
	    }
	    else {
		// demangling failed. Output function name as a C function with
		// no arguments.
		fprintf(out, "  %s : %s()+%s\n",
			symbollist[i], begin_name, begin_offset);
	    }
	}
	else
	{
	    // couldn't parse the line? print the whole line.
	    fprintf(out, "  %s\n", symbollist[i]);
	}
    }

    free(funcname);
    free(symbollist);
}

enum BoostElementState 
{
	EMPTY	= 7,
	READ	= 1,
	WRITTEN = 2
};

class BoostSPSCQueueElement
{
	public:
		BoostSPSCQueueElement()
		: _elementState(EMPTY)
		{
		}

		BoostSPSCQueueElement(const BoostSPSCQueueElement &rhs)
		: _elementState(EMPTY)
		{
		}

		uint8_t _elementState;
		
		void writtenElement()
		{
			//_elementState.store(WRITTEN, std::memory_order_release);
			_elementState = WRITTEN;
		}

		void pushDeleter()
		{
			//_elementState.store(WRITTEN, std::memory_order_release);
			_elementState = WRITTEN;
		}

		void popDeleter()
		{
			//_elementState.store(EMPTY, std::memory_order_release);
			_elementState = EMPTY;
		}

		~BoostSPSCQueueElement()
		{
		 	//_elementState.store(EMPTY, std::memory_order_release);
			_elementState = EMPTY;
		}
};

template<typename T, uint64_t Size=2064>
class BoostSPSCQueue 
{
	public:
		BoostSPSCQueue() : head_(0), tail_(0) {}


		// Below functions should be only called by writer thread
		std::shared_ptr<T> pushPtr()
		{
			if (ring_[head_]._elementState != EMPTY)
				return nullptr;

			uint64_t prev = head_;
			head_ = ((head_ + 1) % Size);
			//@TODO: See  how you could replace lambda with the sophicated function
			//return std::shared_ptr<T>(&ring_[head], std::mem_fun_ref(&T::pushDeleter));
			//return std::shared_ptr<T>(&ring_[prev], [](T *t){t->_elementState.store(WRITTEN, std::memory_order_release); /*fprintf(stderr, "Wrote something\n");*/});
			return std::shared_ptr<T>(&ring_[prev], [](T *t){t->_elementState = WRITTEN; /*fprintf(stderr, "Wrote something\n");*/});
		}

		std::shared_ptr<T> pushPtrSpin()
		{
			///@TODO: this is code duplication: Remove the code and call pushPtr in while loop
			while(ring_[head_]._elementState != EMPTY);

			uint64_t prev = head_;
			head_ = ((head_ + 1) % Size);
			return std::shared_ptr<T>(&ring_[prev], [](T *t){t->_elementState = WRITTEN; /*fprintf(stderr, "Wrote something\n");*/});
		}

		// Below functions should be only called by reader thread
		std::shared_ptr<T> popPtr()
		{
			if (ring_[tail_]._elementState != WRITTEN)
				return nullptr;

			uint64_t prev = tail_;
			tail_ = ((tail_ + 1) % Size);
			//@TODO: See how you could replace lamda with popDeleter
			//return std::shared_ptr<T>(&ring_[tail]);
			return std::shared_ptr<T>(&ring_[prev], [](T *t){/*fprintf(stderr, "1] %ld deleting : %p \n", syscall(SYS_gettid), t); print_stacktrace();*/ t->~T();});
		}
		
		std::shared_ptr<T> popPtrSpin()
		{
			///@TODO: this is code duplication: Remove the code and call popPtr in while loop
			while(ring_[tail_]._elementState != WRITTEN);

			uint64_t prev = tail_;
			tail_ = ((tail_ + 1) % Size);
			return std::shared_ptr<T>(&ring_[prev], [](T *t){/*fprintf(stderr, "2] %ld deleting : %p \n", syscall(SYS_gettid), t); print_stacktrace();*/ t->~T();});
		}

	private:
		uint64_t next(uint64_t current)
		{
			return (current + 1) % Size;
		}

		T ring_[Size];
		uint64_t head_, tail_;
};


}

#endif //__SPSCQUEUE_H__
**************FILE************ ./source/0.9.0.0/infra/containers/spsc/BoostSPSCQueue_with.h
#ifndef __SPSCQUEUE_H__
#define __SPSCQUEUE_H__

#include <memory>
#include <atomic>

#include <stdio.h>

namespace infra 
{

enum BoostElementState 
{
	EMPTY	= 0,
	READ	= 1,
	WRITTEN = 2
};

class BoostSPSCQueueElement
{
	public:
		BoostSPSCQueueElement()
		: _elementState(EMPTY)
		{
		}

		BoostSPSCQueueElement(const BoostSPSCQueueElement &rhs)
		: _elementState(EMPTY)
		{
		}

		std::atomic<uint32_t> _elementState;
		
		void writtenElement()
		{
			_elementState.store(WRITTEN, std::memory_order_release);
		}

		void pushDeleter()
		{
			_elementState.store(WRITTEN, std::memory_order_release);
		}

		void popDeleter()
		{
			_elementState.store(EMPTY, std::memory_order_release);
		}

		~BoostSPSCQueueElement()
		{
		 	_elementState.store(EMPTY, std::memory_order_release);
		}
};

template<typename T, uint64_t Size=2064>
class BoostSPSCQueue 
{
	public:
		BoostSPSCQueue() : head_(0), tail_(0) {}

		bool empty() const
		{
			uint64_t tail = tail_.load(std::memory_order_relaxed);
			if (ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN)
				return true;
			else
				return false;
		}

		bool push(const T & value)
		{
			uint64_t head = head_.load(std::memory_order_relaxed);
			
			if (ring_[head]._elementState.load(std::memory_order_acquire) != EMPTY)
				return false;

			ring_[head] = value;
			ring_[head]._elementState.store(WRITTEN, std::memory_order_release);
			head_.store(next(head), std::memory_order_release);

			return true;
		}

		std::shared_ptr<T> pushPtr()
		{
			uint64_t head = head_.load(std::memory_order_relaxed);
			
			if (ring_[head]._elementState.load(std::memory_order_acquire) != EMPTY)
				return nullptr;

			head_.store(next(head), std::memory_order_release);
			//@TODO: See  how you could replace lambda with the sophicated function
			//return std::shared_ptr<T>(&ring_[head], std::mem_fun_ref(&T::pushDeleter));
			return std::shared_ptr<T>(&ring_[head], [](T *t){t->_elementState.store(WRITTEN, std::memory_order_release); /*fprintf(stderr, "Wrote something\n");*/});
		}

		std::shared_ptr<T> pushPtrSpin()
		{
			///@TODO: this is code duplication: Remove the code and call pushPtr in while loop
			uint64_t head = head_.load(std::memory_order_relaxed);
			
			while(ring_[head]._elementState.load(std::memory_order_acquire) != EMPTY);

			head_.store(next(head), std::memory_order_release);
			return std::shared_ptr<T>(&ring_[head], [](T *t){t->_elementState.store(WRITTEN, std::memory_order_release); /*fprintf(stderr, "Wrote something\n");*/});
		}

		bool pop(T & value)
		{
			uint64_t tail = tail_.load(std::memory_order_relaxed);
			if (ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN)
				return false;

			value = ring_[tail];
			
			ring_[tail]._elementState.store(EMPTY, std::memory_order_release);
			tail_.store(next(tail), std::memory_order_release);
			
			return true;
		}

		const T* front() const
		{
			uint64_t tail = tail_.load(std::memory_order_relaxed);
			if (ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN)
				return nullptr;

			return &ring_[tail];
		}

		std::shared_ptr<T> popPtr()
		{
			uint64_t tail = tail_.load(std::memory_order_relaxed);
			if (ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN)
				return nullptr;

			tail_.store(next(tail), std::memory_order_release);
			//@TODO: See how you could replace lamda with popDeleter
			//return std::shared_ptr<T>(&ring_[tail]);
			return std::shared_ptr<T>(&ring_[tail], [](T *t){/*fprintf(stderr, "%ld deleting : %p \n", syscall(SYS_gettid), t);*/t->~T();});
		}
		
		std::shared_ptr<T> popPtrSpin()
		{
			///@TODO: this is code duplication: Remove the code and call popPtr in while loop
			uint64_t tail = tail_.load(std::memory_order_relaxed);

			while(ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN);

			tail_.store(next(tail), std::memory_order_release);
			return std::shared_ptr<T>(&ring_[tail], [](T *t){/*fprintf(stderr, "%ld deleting : %p \n", syscall(SYS_gettid), t);*/t->~T();});
		}

	private:
		uint64_t next(uint64_t current)
		{
			return (current + 1) % Size;
		}

		T ring_[Size];
		std::atomic<uint64_t> head_, tail_;
};

}

#endif //__SPSCQUEUE_H__
**************FILE************ ./source/0.9.0.0/infra/containers/spsc/SPSCQueue.h
#ifndef __SPSCQUEUE_H__
#define __SPSCQUEUE_H__

#include <memory>
#include <atomic>

namespace infra 
{

	enum ElementState 
	{
		EMPTY	= 0,
		READ	= 1,
		WRITTEN = 2
	};

	class SPSCQueueElement
	{
		public:
			SPSCQueueElement()
			: _elementState(EMPTY)
			{
			}

			ElementState _elementState;
			
			void writtenElement()
			{
				_elementState = WRITTEN;
			}
	};

	template<class T>
	class SPSCQueue
	{
		std::atomic<uint64_t> _front;
		std::atomic<uint64_t> _back;
		std::atomic<uint64_t> _size;
		
		T		 *_element;

		public:
			SPSCQueue(uint64_t size)
			: _front(0)
			, _back(0)
			, _size(size)
			{
				_element = new T[_size];
			}

			std::shared_ptr<T> getReadPtr()
			{
				if(_element[_front]._elementState == WRITTEN)
				{
					_element[_front]._elementState = READ;
					std::shared_ptr<T> result = std::shared_ptr<T>(&_element[_front]);
					_front = (_front + 1 ) % _size;
					return result;
				}
				else
				{
					/// No data available to read
					return nullptr;
				}
			}

			std::shared_ptr<T> getReadPtrBlockable()
			{
				std::shared_ptr<T> readPtr;
				while(! ( readPtr = getReadPtr()));
				return readPtr;
			}
			
			/**
			 *	It is responsibility of thread which calls below function to 
			 *  mark the element as written once its done
			 *
			 *	If data is not written then please make sure that you recycle
			 *	back the writePtr
			 */
			T* getWriterPtr()
			{
				///@TODO : this is asserstion. The last element is not written
				/// and last element is already read and freed so now _front and _back are 
				///	and you are requesting new element to write 
				if((_element[(_back - 1 + _size ) % _size]._elementState != WRITTEN) && (_front != _back))
				{
				}

				if(_element[_back]._elementState == EMPTY)
				{
					T* result = &_element[_back];
					_back = ( _back + 1) % _size;
					return result;
				}
				else
				{
					return nullptr;
				}
			}

			T* getWriterPtrBlockable()
			{
				T* writePtr;
				while(! (writePtr = getReadPtrBlockable()));
				return writePtr;
			}

			void recycleElement(T *element)
			{
				if(element._elementState == WRITTEN)
				{
					///@Raise an exception
					//@TODO: assert this
					return;
				}
				
				if(element._elementState == READ)
				{
					///@Raise an exception
					//@TODO: assert this
					return;
				}

				// element is still empty element._elementState == EMPTY;
				_back = (_back - 1 + _size ) % _size;
			}
	};
}
#endif // __SPSCQUEUE_H__

**************FILE************ ./source/0.9.0.0/infra/containers/spsc/BoostSPSCQueue.h
#ifndef __SPSCQUEUE_H__
#define __SPSCQUEUE_H__

#include <memory>
#include <atomic>

#include <stdio.h>

namespace infra 
{

enum BoostElementState 
{
	EMPTY	= 0,
	READ	= 1,
	WRITTEN = 2
};

class BoostSPSCQueueElement
{
	public:
		BoostSPSCQueueElement()
		: _elementState(EMPTY)
		{
		}

		BoostSPSCQueueElement(const BoostSPSCQueueElement &rhs)
		: _elementState(EMPTY)
		{
		}

		std::atomic<uint32_t> _elementState;
		
		void writtenElement()
		{
			_elementState.store(WRITTEN, std::memory_order_release);
		}

		void pushDeleter()
		{
			_elementState.store(WRITTEN, std::memory_order_release);
		}

		void popDeleter()
		{
			_elementState.store(EMPTY, std::memory_order_release);
		}

		~BoostSPSCQueueElement()
		{
		 	_elementState.store(EMPTY, std::memory_order_release);
		}
};

template<typename T, uint64_t Size=2064>
class BoostSPSCQueue 
{
	public:
		BoostSPSCQueue() : head_(0), tail_(0) {}

		bool empty() const
		{
			uint64_t tail = tail_.load(std::memory_order_relaxed);
			if (ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN)
				return true;
			else
				return false;
		}

		bool push(const T & value)
		{
			uint64_t head = head_.load(std::memory_order_relaxed);
			
			if (ring_[head]._elementState.load(std::memory_order_acquire) != EMPTY)
				return false;

			ring_[head] = value;
			ring_[head]._elementState.store(WRITTEN, std::memory_order_release);
			head_.store(next(head), std::memory_order_release);

			return true;
		}

		T* push()
		{
			uint64_t head = head_.load(std::memory_order_relaxed);
			
			if (ring_[head]._elementState.load(std::memory_order_acquire) != EMPTY)
				return nullptr;

			head_.store(next(head), std::memory_order_release);
			//@TODO: See  how you could replace lambda with the sophicated function
			//return std::shared_ptr<T>(&ring_[head], std::mem_fun_ref(&T::pushDeleter));
			return &ring_[head];
		}

		std::shared_ptr<T> pushPtr()
		{
			uint64_t head = head_.load(std::memory_order_relaxed);
			
			if (ring_[head]._elementState.load(std::memory_order_acquire) != EMPTY)
				return nullptr;

			head_.store(next(head), std::memory_order_release);
			//@TODO: See  how you could replace lambda with the sophicated function
			//return std::shared_ptr<T>(&ring_[head], std::mem_fun_ref(&T::pushDeleter));
			return std::shared_ptr<T>(&ring_[head], [](T *t){t->_elementState.store(WRITTEN, std::memory_order_release); /*fprintf(stderr, "Wrote something\n");*/});
		}

		T* pushSpin()
		{
			///@TODO: this is code duplication: Remove the code and call pushPtr in while loop
			uint64_t head = head_.load(std::memory_order_relaxed);
			
			while(ring_[head]._elementState.load(std::memory_order_acquire) != EMPTY);

			head_.store(next(head), std::memory_order_release);
			return &ring_[head];
		}

		std::shared_ptr<T> pushPtrSpin()
		{
			///@TODO: this is code duplication: Remove the code and call pushPtr in while loop
			uint64_t head = head_.load(std::memory_order_relaxed);
			
			while(ring_[head]._elementState.load(std::memory_order_acquire) != EMPTY);

			head_.store(next(head), std::memory_order_release);
			return std::shared_ptr<T>(&ring_[head], [](T *t){t->_elementState.store(WRITTEN, std::memory_order_release); /*fprintf(stderr, "Wrote something\n");*/});
		}

		bool pop(T & value)
		{
			uint64_t tail = tail_.load(std::memory_order_relaxed);
			if (ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN)
				return false;

			value = ring_[tail];
			
			ring_[tail]._elementState.store(EMPTY, std::memory_order_release);
			tail_.store(next(tail), std::memory_order_release);
			
			return true;
		}

		const T* front() const
		{
			uint64_t tail = tail_.load(std::memory_order_relaxed);
			if (ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN)
				return nullptr;

			return &ring_[tail];
		}

		T* pop()
		{
			uint64_t tail = tail_.load(std::memory_order_relaxed);
			if (ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN)
				return nullptr;

			tail_.store(next(tail), std::memory_order_release);
			//@TODO: See how you could replace lamda with popDeleter
			//return std::shared_ptr<T>(&ring_[tail]);
			return &ring_[tail];
		}

		std::shared_ptr<T> popPtr()
		{
			uint64_t tail = tail_.load(std::memory_order_relaxed);
			if (ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN)
				return nullptr;

			tail_.store(next(tail), std::memory_order_release);
			//@TODO: See how you could replace lamda with popDeleter
			//return std::shared_ptr<T>(&ring_[tail]);
			return std::shared_ptr<T>(&ring_[tail], [](T *t){/*fprintf(stderr, "%ld deleting : %p \n", syscall(SYS_gettid), t);*/t->~T();});
		}
	
		std::shared_ptr<T> popSpin()
		{
			///@TODO: this is code duplication: Remove the code and call popPtr in while loop
			uint64_t tail = tail_.load(std::memory_order_relaxed);

			while(ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN);

			tail_.store(next(tail), std::memory_order_release);
			return &ring_[tail];
		}
		
		std::shared_ptr<T> popPtrSpin()
		{
			///@TODO: this is code duplication: Remove the code and call popPtr in while loop
			uint64_t tail = tail_.load(std::memory_order_relaxed);

			while(ring_[tail]._elementState.load(std::memory_order_acquire) != WRITTEN);

			tail_.store(next(tail), std::memory_order_release);
			return std::shared_ptr<T>(&ring_[tail], [](T *t){/*fprintf(stderr, "%ld deleting : %p \n", syscall(SYS_gettid), t);*/t->~T();});
		}

	private:
		uint64_t next(uint64_t current)
		{
			return (current + 1) % Size;
		}

		T ring_[Size];
		std::atomic<uint64_t> head_, tail_;
};

}

#endif //__SPSCQUEUE_H__
**************FILE************ ./source/0.9.0.0/infra/InfraCommon.h
#ifndef __INFRACOMMON_H__
#define __INFRACOMMON_H__

namespace pugi 
{
	class xml_node;
}

namespace infra 
{
	#define NAME_SIZE 20
	class LogMessage;
	class LoggerClientHandle;
	class Thread;
	enum LogLevel
	{
			TRACE	= 0, ///< Log all the members from the message
			DEBUG	= 1, ///< Something trivial
			SANTY	= 2, ///< Sanitly checks like cross book
			INFO	= 3, ///< Something less trivial
			WARN	= 4, ///< High usage,
			ERROR	= 5, ///< No subscription found. Can not login to recovery
			EXCEPTION	= 6, ///< an exception has occured
			CRITICAL  = 7, ///< System soon gonna fail
			UNKNOWN
	};
}
#endif //__COMMON_H__
**************FILE************ ./source/0.9.0.0/infra/socket
**************FILE************ ./source/0.9.0.0/infra/socket/Socket.h
#ifndef __SOCKET_H__
#define __SOCKET_H__

#include <sys/types.h>
#include <sys/un.h>
#include <stdint.h>

namespace infra
{
	class Socket
	{
		public:
			Socket();
			Socket(const struct sockaddr_in *serverAddress, int32_t type);
			~Socket();
			int32_t readSocket(char *buffer, uint32_t size);

			int32_t socketfd() const
			{
				return _sockfd;
			}

		private:	
			int32_t _sockfd;
			bool	_isActive;
	};
}

#endif // __SOCKET_H__
**************FILE************ ./source/0.9.0.0/infra/socket/Socket.cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>

#include <string>
#include <stdexcept>  // std::invalid_argument 

#include <unistd.h> // close
#include <fcntl.h> // get/set fcntl
#include "infra/socket/Socket.h"

using namespace infra;

Socket::Socket()
	: _sockfd(-1) 
	, _isActive(false)
{	
}

/*
 *	Socket: create socket
 *
 *	@input: 
 *			@sockaddr_in: Address of socket
 *			@type		: SOCk_DGRAM/SOCK_STREAM 
 *
 *
 */
Socket::Socket(const struct sockaddr_in *serverAddress, int32_t type)
{
	in_addr_t interfaceIP = 0;
	int set = 1;
	int unset = 0;
  
  	//create socket to join multicast group on
	_sockfd = socket(AF_INET, type, IPPROTO_UDP);
	if(_sockfd < 0)
	{
		char errorBuff[512];
		snprintf(errorBuff, sizeof(errorBuff), "Client socket could not be created to an address %s:%hu", inet_ntoa(serverAddress->sin_addr), ntohs(serverAddress->sin_port));
		std::string error = errorBuff;
		throw std::invalid_argument(error);
	}

	//set reuse port to on to allow multiple binds per host
	int retval = setsockopt(_sockfd, SOL_SOCKET, SO_REUSEADDR, &set, sizeof(set));
	if(retval < 0)
	{
		std::string error =  "Could not setsockopt to SO_REUSEADDR";
		throw std::invalid_argument(error);
	}

	//set the interface
	{
		struct ifconf conf;
		char data[4096];
		struct ifreq *ifr;
		char addrbuf[1024];

		conf.ifc_len = sizeof(data);
		conf.ifc_buf = (caddr_t) data;
		if (ioctl(_sockfd , SIOCGIFCONF, &conf) < 0) 
		{
			std::string error =  "Could not cal SIOCGIFCONF";
			throw std::invalid_argument(error);
		}

		int i = 0;
		ifr = (struct ifreq*)data;
		while ((char*)ifr < data+conf.ifc_len) 
		{
			switch (ifr->ifr_addr.sa_family) 
			{
				case AF_INET:
					++i;
					//printf("%d. %s : %s\n", i, ifr->ifr_name, inet_ntop(ifr->ifr_addr.sa_family, &((struct sockaddr_in*)&ifr->ifr_addr)->sin_addr, addrbuf, sizeof(addrbuf)));
					if(std::string("lo") == ifr->ifr_name)
					{
						interfaceIP = ((struct sockaddr_in*)&ifr->ifr_addr)->sin_addr.s_addr;
					}
					break;
#if 0
				case AF_INET6:
					++i;
					printf("%d. %s : %s\n", i, ifr->ifr_name, inet_ntop(ifr->ifr_addr.sa_family, &((struct sockaddr_in6*)&ifr->ifr_addr)->sin6_addr, addrbuf, sizeof(addrbuf)));
					break;
#endif
			}
			ifr = (struct ifreq*)((char*)ifr + sizeof(*ifr));
		}
	}

	int flags = fcntl(_sockfd, F_GETFL, 0);
    if (flags < 0)
	{
		std::string error = "Could not get the socket flags";
	}

	flags = flags|O_NONBLOCK;
	if(fcntl(_sockfd, F_SETFL, flags) != 0) 
	{
		std::string error = "Could not set the socket flag O_NONBLOCK";
		throw std::invalid_argument(error);
	}

	char* mc_addr_str;            /* multicast IP address */
	struct sockaddr_in mc_addr;   /* socket address structure */
	unsigned short mc_port;       /* multicast port */

	/* construct a multicast address structure */
	memset(&mc_addr, 0, sizeof(mc_addr));
	mc_addr.sin_family      = AF_INET;
	mc_addr.sin_addr.s_addr = /*htonl(INADDR_ANY);*/serverAddress->sin_addr.s_addr;
	mc_addr.sin_port        = serverAddress->sin_port;

	/* bind to multicast address to socket */
	retval = bind(_sockfd, (struct sockaddr *) &mc_addr, sizeof(mc_addr));
	if(retval < 0) 
	{
		std::string error = "Could not bind the socket to mc addr";
		throw std::invalid_argument(error);
	}

	/* construct an IGMP join request structure */
	struct ip_mreq mc_req;        /* multicast request structure */
	mc_req.imr_multiaddr.s_addr = serverAddress->sin_addr.s_addr;
	//mc_req.imr_interface.s_addr = htonl(INADDR_ANY);
	mc_req.imr_interface.s_addr = interfaceIP;

	/* send an ADD MEMBERSHIP message via setsockopt */
	retval = setsockopt(_sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (void*) &mc_req, sizeof(mc_req));
	if( retval < 0) 
	{
		std::string error = "Could not set the socket option for mc addr membership";
		throw std::invalid_argument(error);
	}

	_isActive = true;
}

int32_t Socket::readSocket(char *buffer, uint32_t size)
{
	return recv(_sockfd, buffer, size, MSG_DONTWAIT);
}

Socket::~Socket()
{
	_isActive = false;
	close(_sockfd);
}

**************FILE************ ./source/0.9.0.0/infra/thread
**************FILE************ ./source/0.9.0.0/infra/thread/Thread.h
#ifndef __THREAD_H__
#define __THREAD_H__

#include <stdio.h>
#include <stdarg.h>
#include <thread>
#include <map>

#include "infra/pugixml/pugixml.h"
#include "infra/InfraCommon.h"
#include "infra/lock/Lock.h"
#include "base/BaseCommon.h"

namespace infra 
{
	enum BindThreads 
	{
		AUTOMATICALLY,
		MANUALLY,
		FALSE
	};

	enum ThreadState
	{
		THREAD_INITIALIZED,	// Thread is initialized 
		THREAD_STARTED,		// Thread is active/running
		THREAD_SINGLED_STOP,// Signled thread to stop
		THREAD_STOPPED		// Thread is stopped
	};

	class Thread;
	typedef void* (*start_routine)(void *);
	typedef std::map<void *, Thread *> ObjToThreadMap;
	
	class Thread
	{
		public:
			Thread(const base::MarketDataApplication *app, const pugi::xml_node configNode, const char *threadName, void *obj, void* (*funPtrStart)(void *)); // Constructor
			~Thread();	 		// Destructor, stops thread first
			void start(); 		// Starts the thread 
			void startWrapper();// Start the thread;			   
			void signalToStop();// Signals the thread to stop
			void stop();		// Stops the thread 
			uint32_t getID() const;		// Get threadID in constant Time
			ThreadState state() const;	// Current thread state 
			const char* stateName() const;	// Current thread state string 
			bool isActive() const;
			bool isSingledToStop() const;
			bool isStopped() const;

			long int getThreadID() const;	// Returns the threadID in constant minimal time
			LoggerClientHandle *loggerClient() const; // returns the logger handle

			static ObjToThreadMap _objToThreadMap;
			const char  _name[NAME_SIZE];	// Name of thread

		private:
			Thread		*_thread;		// self pointer for logginf into file
			LoggerClientHandle *_logger; // logger client queue to which thread will write logs	
			uint32_t 	_threadID;		// Threads Id saved 
			ThreadState _threadState;	// current state of thread
			std::thread *_stdThread;	// std::thread handle
			void 		*_obj;			// obj of class to which thread belongs
			start_routine _startRoutine;	// thread entry of function
			int32_t		_cpu;			// cpu to which to bind thread  
			mutable std::mutex	_mutex;		// mutex for state change and cpu allocation
			const base::MarketDataApplication *_appInstance; // market data application instance to which thread belongs
	};
}
#endif //__THREAD_H__
**************FILE************ ./source/0.9.0.0/infra/thread/Thread.cpp
#include <pthread.h> 
#include <sched.h>
#include <thread>
#include <string.h>

#include "infra/logger/Logger.h"
#include "infra/thread/Thread.h"
#include "base/MarketDataApplication.h"


using namespace infra;

ObjToThreadMap Thread::_objToThreadMap;

/**
 *	Thread : constructor
 *			This class is wrapper on std::thread. 
 *			Creates dormat thread, Thread::start gets it active
 *			via startWrapper by calling _startRoutine.	
 *
 *	@input:	
 *			@app			: Main app instance. Necessory for getting 
 *								loggerInstance related with it
 *			@configNode		: Config node entity the config file to which thread will represent
 *			@_name			: User given thread name as seen by OS 
 *			@_obj			: Buisness object related with the thread,
 *								ie Logger, AppThread, Assigner, Processor/worker thread
 *			@_startRoutine	: Buisness object start/loop function
 *
 *	@Algo:
 *			See if thread related with same buisness object is already created	
 *				if yes, this is an exceptional situation
 *				else insert the thread into map<obj, Thread>
 */
Thread::Thread(const base::MarketDataApplication *app, const pugi::xml_node configNode, const char *threadName, void *obj, void* (*funPtrStart)(void *))
		: _name()
		,  _thread(this)
		, _logger(nullptr)
		, _stdThread(nullptr)
		, _threadID(0)
		, _threadState(ThreadState::THREAD_INITIALIZED)
		, _obj(obj)
		, _cpu(-1)
		, _startRoutine(funPtrStart)
		, _appInstance(app)
{
	// Lock for _objToThreadMap, simulteneous creation of threads
	// Though all the threads are tried to create in initial startup mode.
	// When applicaion is just main single thread
	WLock wlock(_mutex);
	strncpy(const_cast<char *>(_name), threadName, sizeof(_name));

	_cpu = configNode.getAttributeAsInt("cpu", -1);
	int32_t numCPU = sysconf( _SC_NPROCESSORS_ONLN );
	//CPU indexing starts from 0
	if(app->_bindThreads == BindThreads::MANUALLY && _cpu >= numCPU)
	{
		char errorBuff[512];

		// Throw an error exception. Can not allocate cpu specified
		snprintf(errorBuff, sizeof(errorBuff), "<%s name=\"%s\"> Can not bind thread %s to cpu core %d. Server has only %d cpu cores and requested to allocated cpu core %d !!!", configNode.name(), configNode.getAttributeAsCString("name", ""), _name, _cpu, numCPU, _cpu);
	
		std::string error = errorBuff;
		throw std::invalid_argument(error);
	}

	ObjToThreadMap::iterator itr = _objToThreadMap.find(obj);
	if(itr != _objToThreadMap.end())
	{
		char errorBuff[512];

		// Throw an error exception. Thread related to this node(Object) is already created 
		snprintf(errorBuff, sizeof(errorBuff), "Thread related with no <%s name=\"%s\"> is already created. Previous thread [%s : %p]", configNode.name(), configNode.getAttributeAsCString("name", ""), _name, itr->second);
	
		std::string error = errorBuff;
		throw std::invalid_argument(error);
	}

	_objToThreadMap.insert(std::pair<void *, Thread *>(obj, this));
	logConsole(INFO, "Creating new Thread [ %s : 0x%x ]", _name, this);	
}

/**
 * Create the native std::thread instance and start it
 * Calls the registered start function
 * Do not log anything in this function
 */
void Thread::start()
{
	// Lock to check if thread is not started by two parent threads.
	WLock wlock(_mutex);
	//Start the thread only if it is initialized
	if(_threadState == ThreadState::THREAD_INITIALIZED)
	{
		//@TODO: call thread start function
		_logger = const_cast<Logger *>(_appInstance->getLoggerInstance())->getClientHandleForLogger(this);
		_threadState =  ThreadState::THREAD_STARTED;

		//logConsole(INFO, "Starting Thread [ %s : 0x%x ]", _name, this);	

		//_stdThread = new std::thread(_startRoutine, _obj);
		_stdThread = new std::thread(&Thread::startWrapper, this);

		char name[30];
		pthread_setname_np(_stdThread->native_handle(), _name);
		pthread_getname_np(_stdThread->native_handle(), name, 30);
		//logConsole(INFO, "Started Thread [ %s=%s : 0x%x ]", name, _name, this);
	} 
	else
	{
		//@TODO: Log a warning on std::err
	}
}

/**
 * \brief: Calls the main activiy function of worker thread 
 * 			Sets the threadID and log the function 
 */
void Thread::startWrapper()
{
	uint32_t numCPU = sysconf( _SC_NPROCESSORS_ONLN );
	_threadID = syscall(SYS_gettid);
	if(_appInstance->_bindThreads == BindThreads::AUTOMATICALLY)
	{
		_cpu = ++_appInstance->_lastcpu; 
		if(_cpu >= numCPU)
		{
			char errorBuff[512];

			// Throw an error exception. Can not allocate cpu specified
			snprintf(errorBuff, sizeof(errorBuff), "Can not bind thread %s to automatically allocated cpu core %d. Server has only 0-%d cpu cores and requested to allocated cpu core %d !!!", _name, _cpu, numCPU - 1, _cpu);

			std::string error = errorBuff;
			throw std::invalid_argument(error);
		}
	}

	if(_cpu != -1 && (_appInstance->_bindThreads == BindThreads::AUTOMATICALLY || _appInstance->_bindThreads == BindThreads::MANUALLY))
	{
		size_t size = CPU_ALLOC_SIZE(numCPU);
		cpu_set_t *cpumask = CPU_ALLOC(numCPU);
		
		if(cpumask == NULL)
		{
			char errorBuff[512];

			// Throw an error exception. Can not allocate cpu specified
			snprintf(errorBuff, sizeof(errorBuff), "Could not allocate memory for CPU mask of bytes %lu while binding thread %s to cpu core %u", size, _name, _cpu);
		
			std::string error = errorBuff;
			throw std::invalid_argument(error);
		}

		CPU_ZERO_S(size, cpumask);
		CPU_SET_S(_cpu, size, cpumask);
		if( sched_setaffinity(_threadID, size, cpumask) == -1)
		{
			char errorBuff[512];

			// Throw an error exception. Can not allocate cpu specified
			snprintf(errorBuff, sizeof(errorBuff), "Could not bind thread %s to cpu core %u", _name, _cpu);
		
			std::string error = errorBuff;
			throw std::invalid_argument(error);
		}
	
		logMessage(INFO, "Started Thread [ %s[%u] : %p ] binded to cpu core %d", _name, _threadID, this, _cpu);
	}
	else
	{
		logMessage(INFO, "Started Thread [ %s[%u] : %p ] not binded to any core", _name, _threadID, this);
	}

	_startRoutine(_obj);
}

/**
 * Signals the start function of the thread, started above, 
 * to stop and free the resources held
 * Stop the thread only if it has been started
 *
 *	@input:
 *		logger of the parent thread stopping this thread
 *		If parent thread is not of type infra::Thread
 *		i.e thread created in the hierarchy of clarice market 
 *		data application
 */
void Thread::signalToStop()
{
	WLock wlock(_mutex);
	if(_threadState == ThreadState::THREAD_STARTED)
	{
		_threadState = ThreadState::THREAD_SINGLED_STOP;
		//This will get out the module out of loop
		//@TODO: join the thread and change the state to stopped
	}
	else
	{
		logMessage(EXCEPTION, "Thread [ %s : %p ] is currently in state %s and signaled to stop", _name, this, stateName());
		if(_threadState != ThreadState::THREAD_STOPPED)
		{
			_threadState = ThreadState::THREAD_SINGLED_STOP;
		}
	}
}

/*
 * Main loop of the thread is done, Now stop the thread
 */
void Thread::stop()
{
	WLock wlock(_mutex);
	if(_threadState == ThreadState::THREAD_SINGLED_STOP)
	{
		_threadState = ThreadState::THREAD_STOPPED;
		//This will get out the module out of loop
		//@TODO: join the thread and change the state to stopped
	}
	else
	{
		logMessage(EXCEPTION, "Thread [ %s : %p ] is currently in state %s and tried to stop", _name, this, stateName());
		_threadState = ThreadState::THREAD_STOPPED;
	}
}

/**
 *	returns the state.
 *	Taking lock for the synchronization, do not call this function unless needed
 */
ThreadState Thread::state() const
{
	RLock rlock(_mutex);
	return _threadState;
}

/**
 *	returns the state name string.
 *	@pre-cond: 	must be called from Thread member function
 *				which must have taken atleast rlock(_mutex)
 *
 */
const char* Thread::stateName() const
{
	switch(_threadState)
	{
		case ThreadState::THREAD_INITIALIZED :
			return "THREAD_INITIALIZED";

		case ThreadState::THREAD_STARTED:
			return "THREAD_STARTED";

		case ThreadState::THREAD_SINGLED_STOP:
			return "THREAD_SINGLED_STOP";
		
		case ThreadState::THREAD_STOPPED:
			return "THREAD_STOPPED";

		default:
			logMessage(EXCEPTION, "Tried to convert unknown state %d to string", _threadState);
			return "THREAD_STATE_UNKNOWN";
	}
}

/**
 *	returns if thread is active.
 */
bool Thread::isActive() const
{
	return _threadState == ThreadState::THREAD_STARTED;
}

/**
 *	returns if thread is singned to stop.
 */
bool Thread::isSingledToStop() const
{
	return _threadState == ThreadState::THREAD_SINGLED_STOP;
}

/**
 *	returns if thread is active.
 */
bool Thread::isStopped() const
{
	return _threadState == ThreadState::THREAD_STOPPED;
}

/**
 * Returns the os-specefic threadID
 */
long int Thread::getThreadID() const
{
	return _threadID;
}

/**
 * Returns the client handle of the thread
 */
LoggerClientHandle *Thread::loggerClient() const
{
	return _logger;
}

/**
 * Thread destructor:
 *		Stop the thread if it has not been stopped already	
 */
Thread::~Thread()
{
	if(state() != ThreadState::THREAD_STOPPED);
	{
		// @TODO: deleter is stopping thread, log warning
		// @ Should have been stopped by the owner first
		stop();
	}

	_stdThread = nullptr;
	_logger = nullptr;
}

**************FILE************ ./source/0.9.0.0/infra/app
**************FILE************ ./source/0.9.0.0/infra/lock
**************FILE************ ./source/0.9.0.0/infra/lock/Lock.cpp
#include "infra/lock/Lock.h"

using namespace infra;

Lock::Lock(std::mutex &mutex)
:_mutex(mutex)
{
	_mutex.lock();
}

Lock::~Lock()
{
	_mutex.unlock();
}

template<typename T>
AtomicLock<T>::AtomicLock(T &counter)
: _counter(counter)
{
	while(!__sync_lock_test_and_set(&_counter, 1));
}

template<typename T>
AtomicLock<T>::~AtomicLock()
{
	assert(_counter == 1);
	__sync_lock_release(&_counter);
}
**************FILE************ ./source/0.9.0.0/infra/lock/Lock.h
#ifndef __LOCK_H
#define __LOCK_H

#include <mutex>

namespace infra
{
	using namespace std;

	/*
	 * Normal lock with the mutex
	 */
	class Lock
	{
		public:
			Lock(std::mutex &mutex);
			~Lock();

		private:
			std::mutex &_mutex;
	};
	
	typedef Lock RLock;
	typedef Lock WLock;

	/*
	 * Atomic lock
	 */
	template<typename T=uint64_t>
	class AtomicLock
	{
		public:
			AtomicLock(T &counter);
			~AtomicLock();

		private:
			T &_counter;
	};
}
#endif
**************FILE************ ./source/0.9.0.0/infra/judy
**************FILE************ ./source/0.9.0.0/infra/judy/JudySArray.h
#ifndef JUDYSARRAY_H
#define JUDYSARRAY_H

/****************************************************************************//**
* \file judySArray.h C++ wrapper for judy array implementation
*
*  A judyS array maps strings to corresponding memory cells, each containing
*  a JudyValue. Each cell must be set to a non-zero value by the caller.
*
*    Author: Mark Pictor. Public domain.
*
********************************************************************************/

#include "Judy.h"
#include "assert.h"
#include <string.h>

template< typename JudyValue >
struct judysKVpair {
    unsigned char * key;
    JudyValue value;
};
template< typename JudyValue >
class judySArray {
    public:
        typedef judysKVpair< JudyValue > pair;
    protected:
        Judy * _judyarray;
        unsigned int _maxKeyLen;
        JudyValue * _lastSlot;
        unsigned char * _buff;
        bool _success;
        pair _kv;
    public:
        judySArray( unsigned int maxKeyLen ): _maxKeyLen( maxKeyLen ), _success( true ) {
            _judyarray = judy_open( _maxKeyLen, 0 );
            _buff = new unsigned char[_maxKeyLen];
            assert( sizeof( JudyValue ) == sizeof( this ) && "JudyValue *must* be the same size as a pointer!" );
        }

        explicit judySArray( const judySArray< JudyValue > & other ): _maxKeyLen( other._maxKeyLen ), _success( other._success ) {
            _judyarray = judy_clone( other._judyarray );
            _buff = new unsigned char[_maxKeyLen];
            strncpy( _buff, other._buff, _maxKeyLen );
            _buff[ _maxKeyLen ] = '\0'; //ensure that _buff is null-terminated, since strncpy won't necessarily do so
            find( _buff ); //set _lastSlot
        }

        ~judySArray() {
            judy_close( _judyarray );
            delete[] _buff;
        }

        void clear() {
            _buff[0] = '\0';
            while( 0 != ( _lastSlot = ( JudyValue * ) judy_strt( _judyarray, ( const unsigned char * ) _buff, 0 ) ) ) {
                judy_del( _judyarray );
            }
        }

        JudyValue getLastValue() {
            assert( _lastSlot );
            return &_lastSlot;
        }

        void setLastValue( JudyValue value ) {
            assert( _lastSlot );
            &_lastSlot = value;
        }

        bool success() {
            return _success;
        }
        //TODO
        // allocate data memory within judy array for external use.
        // void *judy_data (Judy *judy, unsigned int amt);

        /// insert or overwrite value for key
        bool insert( const char * key, JudyValue value, unsigned int keyLen = 0 ) {
            assert( value != 0 );
            if( keyLen == 0 ) {
                keyLen = strlen( key );
            } else {
                assert( keyLen == strlen( key ) );
            }
            assert( keyLen <= _maxKeyLen );
            _lastSlot = ( JudyValue * ) judy_cell( _judyarray, ( const unsigned char * )key, keyLen );
            if( _lastSlot ) {
                *_lastSlot = value;
                _success = true;
            } else {
                _success = false;
            }
            return _success;
        }

        /// retrieve the cell pointer greater than or equal to given key
        /// NOTE what about an atOrBefore function?
        const pair atOrAfter( const char * key, unsigned int keyLen = 0 ) {
            if( keyLen == 0 ) {
                keyLen = strlen( key );
            } else {
                assert( keyLen == strlen( key ) );
            }
            assert( keyLen <= _maxKeyLen );
            _lastSlot = ( JudyValue * ) judy_strt( _judyarray, ( const unsigned char * )key, keyLen );
            return mostRecentPair();
        }

        /// retrieve the cell pointer, or return NULL for a given key.
        JudyValue find( const char * key, unsigned int keyLen = 0 ) {
            if( keyLen == 0 ) {
                keyLen = strlen( key );
            } else {
                assert( keyLen == strlen( key ) );
            }
            assert( keyLen <= _maxKeyLen );
            _lastSlot = ( JudyValue * ) judy_slot( _judyarray, ( const unsigned char * ) key, keyLen );
            if( _lastSlot ) {
                _success = true;
                return *_lastSlot;
            } else {
                _success = false;
                return 0;
            }
        }

        /// retrieve the key-value pair for the most recent judy query.
        inline const pair & mostRecentPair() {
            judy_key( _judyarray, _buff, _maxKeyLen );
            if( _lastSlot ) {
                _kv.value = *_lastSlot;
                _success = true;
            } else {
                _kv.value = ( JudyValue ) 0;
                _success = false;
            }
            _kv.key = _buff;
            return _kv;
        }

        /// retrieve the first key-value pair in the array
        const pair & begin() {
            _buff[0] = '\0';
            _lastSlot = ( JudyValue * ) judy_strt( _judyarray, ( const unsigned char * ) _buff, 0 );
            return mostRecentPair();
        }

        /// retrieve the last key-value pair in the array
        const pair & end() {
            _lastSlot = ( JudyValue * ) judy_end( _judyarray );
            return mostRecentPair();
        }

        /// retrieve the key-value pair for the next key in the array.
        const pair & next() {
            _lastSlot = ( JudyValue * ) judy_nxt( _judyarray );
            return mostRecentPair();
        }

        /// retrieve the key-value pair for the prev key in the array.
        const pair & previous() {
            _lastSlot = ( JudyValue * ) judy_prv( _judyarray );
            return mostRecentPair();
        }

        /** delete a key-value pair. If the array is not empty,
         * getLastValue() will return the entry before the one that was deleted
         * \sa isEmpty()
         */
        bool removeEntry( const char * key ) {
            if( judy_slot( _judyarray, ( const unsigned char * )key, strlen( key ) ) ) {
                _lastSlot = ( JudyValue * ) judy_del( _judyarray );
                return true;
            } else {
                return false;
            }
        }

        ///return true if the array is empty
        bool isEmpty() {
            _buff[0] = 0;
            return ( ( judy_strt( _judyarray, ( const unsigned char * ) _buff, 0 ) ) ? false : true );
        }
};
#endif //JUDYSARRAY_H
**************FILE************ ./source/0.9.0.0/infra/judy/Judy.h
#ifndef JUDY64_H
#define JUDY64_H
//  Judy arrays 13 DEC 2012 (judy64n.c from http://code.google.com/p/judyarray/ )
//  This code is public domain.

//  Author Karl Malbrain, malbrain AT yahoo.com
//  with assistance from Jan Weiss.
//  modifications (and any bugs) by Mark Pictor, mpictor at gmail

//  Simplified judy arrays for strings and integers
//  Adapted from the ideas of Douglas Baskins of HP.

//  Map a set of keys to corresponding memory cells (uints).
//  Each cell must be set to a non-zero value by the caller.

//  String mappings are denoted by calling judy_open with zero as
//  the second argument.  Integer mappings are denoted by calling
//  judy_open with the Integer depth of the Judy Trie as the second
//  argument.

//  functions:
//  judy_open:  open a new judy array returning a judy object.
//  judy_close: close an open judy array, freeing all memory.
//  judy_clone: clone an open judy array, duplicating the stack.
//  judy_data:  allocate data memory within judy array for external use.
//  judy_cell:  insert a string into the judy array, return cell pointer.
//  judy_strt:  retrieve the cell pointer greater than or equal to given key
//  judy_slot:  retrieve the cell pointer, or return NULL for a given key.
//  judy_key:   retrieve the string value for the most recent judy query.
//  judy_end:   retrieve the cell pointer for the last string in the array.
//  judy_nxt:   retrieve the cell pointer for the next string in the array.
//  judy_prv:   retrieve the cell pointer for the prev string in the array.
//  judy_del:   delete the key and cell for the current stack entry.



#if defined(__LP64__)      || \
    defined(__x86_64__)    || \
    defined(__amd64__)     || \
    defined(_WIN64)        || \
    defined(__sparc64__)   || \
    defined(__arch64__)    || \
    defined(__powerpc64__) || \
    defined (__s390x__)
//    defines for 64 bit
typedef unsigned long long judyvalue;
typedef unsigned long long JudySlot;
#define JUDY_key_mask (0x07)
#define JUDY_key_size 8
#define JUDY_slot_size 8
#define JUDY_span_bytes (3 * JUDY_key_size)
#define JUDY_span_equiv JUDY_2
#define JUDY_radix_equiv JUDY_8

#define PRIjudyvalue    "llu"

#else
//    defines for 32 bit
typedef unsigned int judyvalue;
typedef unsigned int JudySlot;
#define JUDY_key_mask (0x03)
#define JUDY_key_size 4
#define JUDY_slot_size 4
#define JUDY_span_bytes (7 * JUDY_key_size)
#define JUDY_span_equiv JUDY_4
#define JUDY_radix_equiv JUDY_8

#define PRIjudyvalue    "u"

#endif

#define JUDY_mask (~(JudySlot)0x07)

//    define the alignment factor for judy nodes and allocations
//    to enable this feature, set to 64

#define JUDY_cache_line 64     // minimum size is 8 bytes
// can be calculated using http://stackoverflow.com/a/4049562/382458 - but that would limit optimization!
// 10x 1M key hexsort, line size 64: 9.949s; size 8: 10.018s --> 1% improvement for 64; however, this may be dwarfed by the sort code

#define JUDY_seg    65536

enum JUDY_types {
    JUDY_radix        = 0,    // inner and outer radix fan-out
    JUDY_1            = 1,    // linear list nodes of designated count
    JUDY_2            = 2,
    JUDY_4            = 3,
    JUDY_8            = 4,
    JUDY_16           = 5,
    JUDY_32           = 6,
#ifdef ASKITIS
    JUDY_64           = 7
#else
    JUDY_span         = 7     // up to 28 tail bytes of key contiguously stored
#endif
};

typedef struct {
    void * seg;               // next used allocator
    unsigned int next;        // next available offset
} JudySeg;

typedef struct {
    JudySlot next;            // judy object
    unsigned int off;         // offset within key
    int slot;                 // slot within object
} JudyStack;

typedef struct {
    JudySlot root[1];         // root of judy array
    void ** reuse[8];         // reuse judy blocks
    JudySeg * seg;            // current judy allocator
    unsigned int level;       // current height of stack
    unsigned int max;         // max height of stack
    unsigned int depth;       // number of Integers in a key, or zero for string keys
    JudyStack stack[1];       // current cursor
} Judy;

#ifdef ASKITIS
int Words = 0;
int Inserts = 0;
int Found = 0;
#  if JUDY_key_size < 8
#    define JUDY_max    JUDY_16
#  else
#    define JUDY_max    JUDY_64
#  endif
#else
#  define JUDY_max    JUDY_32
#endif

#ifdef __cplusplus
extern "C" {
#endif

    /// open a new judy array returning a judy object.
    Judy * judy_open( unsigned int max, unsigned int depth );

    /// close an open judy array, freeing all memory.
    void judy_close( Judy * judy );

    /// clone an open judy array, duplicating the stack.
    Judy * judy_clone( Judy * judy );

    /// allocate data memory within judy array for external use.
    void * judy_data( Judy * judy, unsigned int amt );

    /// insert a key into the judy array, return cell pointer.
    JudySlot * judy_cell( Judy * judy, const unsigned char * buff, unsigned int max );

    /// retrieve the cell pointer greater than or equal to given key
    JudySlot * judy_strt( Judy * judy, const unsigned char * buff, unsigned int max );

    /// retrieve the cell pointer, or return NULL for a given key.
    JudySlot * judy_slot( Judy * judy, const unsigned char * buff, unsigned int max );

    /// retrieve the string value for the most recent judy query.
    unsigned int judy_key( Judy * judy, unsigned char * buff, unsigned int max );

    /// retrieve the cell pointer for the last string in the array.
    JudySlot * judy_end( Judy * judy );

    /// retrieve the cell pointer for the next string in the array.
    JudySlot * judy_nxt( Judy * judy );

    /// retrieve the cell pointer for the prev string in the array.
    JudySlot * judy_prv( Judy * judy );

    /// delete the key and cell for the current stack entry.
    JudySlot * judy_del( Judy * judy );

#ifdef __cplusplus
}
#endif

#endif //JUDY64_H
**************FILE************ ./source/0.9.0.0/infra/judy/JudyS2Array.h
#ifndef JUDYS2ARRAY_H
#define JUDYS2ARRAY_H

/****************************************************************************//**
* \file judyS2Array.h C++ wrapper for judy array implementation
*
*  A judyS2 array maps strings to multiple JudyValue's, similar to
* std::multimap. Internally, this is a judyL array of std::vector< JudyValue >.
*
*    Author: Mark Pictor. Public domain.
*
********************************************************************************/

#include "Judy.h"
#include "assert.h"
#include <string.h>
#include <iterator>
#include <vector>

template< typename JudyValue >
struct judys2KVpair {
    unsigned char * key;
    JudyValue value;
};

/** A judyS2 array maps a set of strings to multiple JudyValue's, similar to std::multimap.
 * Internally, this is a judyS array of std::vector< JudyValue >.
 *  \param JudyValue the type of the value, i.e. int, pointer-to-object, etc.
 */
template< typename JudyValue >
class judyS2Array {
    public:
        typedef std::vector< JudyValue > vector;
        typedef const vector cvector;
        typedef judys2KVpair< vector * > pair;
        typedef judys2KVpair< cvector * > cpair;
    protected:
        Judy * _judyarray;
        unsigned int _maxKeyLen;
        vector ** _lastSlot;
        unsigned char * _buff;
        bool _success;
        cpair kv;
    public:
        judyS2Array( unsigned int maxKeyLen ): _maxKeyLen( maxKeyLen ), _lastSlot( 0 ), _success( true ) {
            _judyarray = judy_open( _maxKeyLen, 0 );
            _buff = new unsigned char[_maxKeyLen];
            assert( sizeof( JudyValue ) == sizeof( this ) && "JudyValue *must* be the same size as a pointer!" );
        }

        explicit judyS2Array( const judyS2Array< JudyValue > & other ): _maxKeyLen( other._maxKeyLen ), _success( other._success ) {
            _judyarray = judy_clone( other._judyarray );
            _buff = new unsigned char[_maxKeyLen];
            strncpy( _buff, other._buff, _maxKeyLen );
            _buff[ _maxKeyLen ] = '\0'; //ensure that _buff is null-terminated, since strncpy won't necessarily do so
            find( _buff ); //set _lastSlot
        }

        /// calls clear, so should be safe to call at any point
        ~judyS2Array() {
            clear();
            judy_close( _judyarray );
            delete[] _buff;
        }

        /// delete all vectors and empty the array
        void clear() {
            _buff[0] = '\0';
            while( 0 != ( _lastSlot = ( vector ** ) judy_strt( _judyarray, ( const unsigned char * ) _buff, 0 ) ) ) {
                //( * _lastSlot )->~vector(); //TODO: placement new
                delete( * _lastSlot );
                judy_del( _judyarray );
            }
        }

        vector * getLastValue() {
            assert( _lastSlot );
            return &_lastSlot;
        }

        void setLastValue( vector * value ) {
            assert( _lastSlot );
            &_lastSlot = value;
        }

        bool success() {
            return _success;
        }

        /** TODO
         * test for std::vector::shrink_to_fit (C++11), use it once the array is as full as it will be
         * void freeUnused() {...}
         */

        //TODO
        // allocate data memory within judy array for external use.
        // void *judy_data (Judy *judy, unsigned int amt);

        /// insert value into the vector for key.
        bool insert( const char * key, JudyValue value, unsigned int keyLen = 0 ) {
            if( keyLen == 0 ) {
                keyLen = strlen( key );
            } else {
                assert( keyLen == strlen( key ) );
            }
            assert( keyLen <= _maxKeyLen );
            _lastSlot = ( vector ** ) judy_cell( _judyarray, ( const unsigned char * )key, keyLen );
            if( _lastSlot ) {
                if( !( * _lastSlot ) ) {
                    * _lastSlot = new vector;
                    /* TODO store vectors inside judy with placement new
                    * vector * n = judy_data( _judyarray, sizeof( std::vector < JudyValue > ) );
                    * new(n) vector;
                    * *_lastSlot = n;
                    * NOTE - memory alloc'd via judy_data will not be freed until the array is freed (judy_close)
                    * also use placement new in the other insert function, below
                    */
                }
                ( * _lastSlot )->push_back( value );
                _success = true;
            } else {
                _success = false;
            }
            return _success;
        }

        /** for a given key, append to or overwrite the vector
         * this never simply re-uses the pointer to the given vector because
         * that would mean that two keys could have the same value (pointer).
         */
        bool insert( const char * key, const vector & values, unsigned int keyLen = 0, bool overwrite = false ) {
            if( keyLen == 0 ) {
                keyLen = strlen( key );
            } else {
                assert( keyLen == strlen( key ) );
            }
            assert( keyLen <= _maxKeyLen );
            _lastSlot = ( vector ** ) judy_cell( _judyarray, ( const unsigned char * )key, keyLen );
            if( _lastSlot ) {
                if( !( * _lastSlot ) ) {
                    * _lastSlot = new vector;
                    /* TODO store vectors inside judy with placement new
                     * (see other insert(), above)
                     */
                } else if( overwrite ) {
                    ( * _lastSlot )->clear();
                }
                std::copy( values.begin(), values.end(), std::back_inserter< vector >( ( ** _lastSlot ) ) );
                _success = true;
            } else {
                _success = false;
            }
            return _success;
        }

        /// retrieve the cell pointer greater than or equal to given key
        /// NOTE what about an atOrBefore function?
        const cpair atOrAfter( const char * key, unsigned int keyLen = 0 ) {
            if( keyLen == 0 ) {
                keyLen = strlen( key );
            } else {
                assert( keyLen == strlen( key ) );
            }
            assert( keyLen <= _maxKeyLen );
            _lastSlot = ( vector ** ) judy_strt( _judyarray, ( const unsigned char * )key, keyLen );
            return mostRecentPair();
        }

        /// retrieve the cell pointer, or return NULL for a given key.
        cvector * find( const char * key, unsigned int keyLen = 0 ) {
            if( keyLen == 0 ) {
                keyLen = strlen( key );
            } else {
                assert( keyLen == strlen( key ) );
            }
            assert( keyLen <= _maxKeyLen );
            _lastSlot = ( vector ** ) judy_slot( _judyarray, ( const unsigned char * ) key, keyLen );
            if( ( _lastSlot ) && ( * _lastSlot ) ) {
                _success = true;
                return * _lastSlot;
            } else {
                _success = false;
                return 0;
            }
        }

        /// retrieve the key-value pair for the most recent judy query.
        inline const cpair & mostRecentPair() {
            judy_key( _judyarray, _buff, _maxKeyLen );
            if( _lastSlot ) {
                kv.value = *_lastSlot;
                _success = true;
            } else {
                kv.value = ( JudyValue ) 0;
                _success = false;
            }
            kv.key = _buff;
            return kv;
        }

        /// retrieve the first key-value pair in the array
        const cpair & begin() {
            _buff[0] = '\0';
            _lastSlot = ( vector ** ) judy_strt( _judyarray, ( const unsigned char * ) _buff, 0 );
            return mostRecentPair();
        }

        /// retrieve the last key-value pair in the array
        const cpair & end() {
            _lastSlot = ( vector ** ) judy_end( _judyarray );
            return mostRecentPair();
        }

        /// retrieve the key-value pair for the next key in the array.
        const cpair & next() {
            _lastSlot = ( vector ** ) judy_nxt( _judyarray );
            return mostRecentPair();
        }

        /// retrieve the key-value pair for the prev key in the array.
        const cpair & previous() {
            _lastSlot = ( vector ** ) judy_prv( _judyarray );
            return mostRecentPair();
        }

        /** delete a key-value pair. If the array is not empty,
         * getLastValue() will return the entry before the one that was deleted
         * \sa isEmpty()
         */
        bool removeEntry( const char * key ) {
            if( 0 != ( judy_slot( _judyarray, ( const unsigned char * )key, strlen( key ) ) ) ) {
                // _lastSlot->~vector(); //for use with placement new
                delete _lastSlot;
                _lastSlot = ( vector ** ) judy_del( _judyarray );
                return true;
            } else {
                return false;
            }
        }

        ///return true if the array is empty
        bool isEmpty() {
            _buff[0] = 0;
            return ( ( judy_strt( _judyarray, ( const unsigned char * ) _buff, 0 ) ) ? false : true );
        }
};
#endif //JUDYS2ARRAY_H
**************FILE************ ./source/0.9.0.0/infra/judy/JudyLArray.h
#ifndef JUDYLARRAY_H
#define JUDYLARRAY_H

/****************************************************************************//**
* \file judyLArray.h C++ wrapper for judyL array implementation
*
* A judyL array maps JudyKey's to corresponding memory cells, each containing
* a JudyValue. Each cell must be set to a non-zero value by the caller.
*
*    Author: Mark Pictor. Public domain.
*
********************************************************************************/

#include "Judy.h"
#include "assert.h"

#ifdef HAVE_STD_ENABLEIF
#include <type_traits>
#endif

template< typename JudyKey, typename JudyValue >
struct judylKVpair {
    JudyKey key;
    JudyValue value;
};

/** A judyL array maps JudyKey's to corresponding memory cells, each containing
 * a JudyValue. Each cell must be set to a non-zero value by the caller.
 *
 * Both template parameters must be the same size as a void*
 *  \param JudyKey the type of the key, i.e. uint64_t, pointer-to-object, etc
 *  \param JudyValue the type of the value
 */
template< typename JudyKey, typename JudyValue >
class judyLArray {
    public:
        typedef judylKVpair< JudyKey, JudyValue > pair;
    protected:
        Judy * _judyarray;
        unsigned int _maxLevels, _depth;
        JudyValue * _lastSlot;
        JudyKey _buff[1];
        bool _success;
        pair _kv;
    public:
        judyLArray(): _maxLevels( sizeof( JudyKey ) ), _depth( 1 ), _lastSlot( 0 ), _success( true ) {
            assert( sizeof( JudyKey ) == JUDY_key_size && "JudyKey *must* be the same size as a pointer!" );
            assert( sizeof( JudyValue ) == JUDY_key_size && "JudyValue *must* be the same size as a pointer!" );
            _judyarray = judy_open( _maxLevels, _depth );
            _buff[0] = 0;
        }

        explicit judyLArray( const judyLArray< JudyKey, JudyValue > & other ): _maxLevels( other._maxLevels ),
            _depth( other._depth ), _success( other._success ) {
            _judyarray = judy_clone( other._judyarray );
            _buff[0] = other._buff[0];
            find( *_buff ); //set _lastSlot
        }

        ~judyLArray() {
            judy_close( _judyarray );
        }

        ///empty the judy array, delete nothing
        ///overload below can also delete JudyValue's, iff they are a pointer type
        void clear() {
            JudyKey key = 0;
            while( 0 != ( _lastSlot = ( JudyValue * ) judy_strt( _judyarray, ( const unsigned char * ) &key, 0 ) ) ) {
                judy_del( _judyarray );
            }
        }
#ifdef HAVE_STD_ENABLEIF
        template <typename X=JudyValue>
        typename std::enable_if<std::is_pointer<X>::value, void>::type
        clear( bool deleteContents ) {
            JudyKey key = 0;
            while( 0 != ( _lastSlot = ( JudyValue * ) judy_strt( _judyarray, ( const unsigned char * ) &key, 0 ) ) ) {
                if( deleteContents ) {
                    delete *_lastSlot;
                }
                judy_del( _judyarray );
            }
        }
#endif

        JudyValue getLastValue() {
            assert( _lastSlot );
            return &_lastSlot;
        }

        void setLastValue( JudyValue value ) {
            assert( _lastSlot );
            &_lastSlot = value;
        }

        bool success() {
            return _success;
        }
        //TODO
        // allocate data memory within judy array for external use.
        // void *judy_data (Judy *judy, unsigned int amt);

        /// insert or overwrite value for key
        bool insert( JudyKey key, JudyValue value ) {
            assert( value != 0 );
            _lastSlot = ( JudyValue * ) judy_cell( _judyarray, ( const unsigned char * ) &key, _depth * JUDY_key_size );
            if( _lastSlot ) {
                *_lastSlot = value;
                _success = true;
            } else {
                _success = false;
            }
            return _success;
        }

        /// retrieve the cell pointer greater than or equal to given key
        /// NOTE what about an atOrBefore function?
        const pair atOrAfter( JudyKey key ) {
            _lastSlot = ( JudyValue * ) judy_strt( _judyarray, ( const unsigned char * ) &key, _depth * JUDY_key_size );
            return mostRecentPair();
        }

        /// retrieve the cell pointer, or return NULL for a given key.
        JudyValue find( JudyKey key ) {
            _lastSlot = ( JudyValue * ) judy_slot( _judyarray, ( const unsigned char * ) &key, _depth * JUDY_key_size );
            if( _lastSlot ) {
                _success = true;
                return *_lastSlot;
            } else {
                _success = false;
                return 0;
            }
        }

        /// retrieve the key-value pair for the most recent judy query.
        inline const pair & mostRecentPair() {
            judy_key( _judyarray, ( unsigned char * ) _buff, _depth * JUDY_key_size );
            if( _lastSlot ) {
                _kv.value = *_lastSlot;
                _success = true;
            } else {
                _kv.value = ( JudyValue ) 0;
                _success = false;
            }
            _kv.key = _buff[0];
            return _kv;
        }

        /// retrieve the first key-value pair in the array
        const pair & begin() {
            JudyKey key = 0;
            _lastSlot = ( JudyValue * ) judy_strt( _judyarray, ( const unsigned char * ) &key, 0 );
            return mostRecentPair();
        }

        /// retrieve the last key-value pair in the array
        const pair & end() {
            _lastSlot = ( JudyValue * ) judy_end( _judyarray );
            return mostRecentPair();
        }

        /// retrieve the key-value pair for the next key in the array.
        const pair & next() {
            _lastSlot = ( JudyValue * ) judy_nxt( _judyarray );
            return mostRecentPair();
        }

        /// retrieve the key-value pair for the prev key in the array.
        const pair & previous() {
            _lastSlot = ( JudyValue * ) judy_prv( _judyarray );
            return mostRecentPair();
        }

        /** delete a key-value pair. If the array is not empty,
         * getLastValue() will return the entry before the one that was deleted
         * \sa isEmpty()
         */
        bool removeEntry( JudyKey * key ) {
            if( judy_slot( _judyarray, key, _depth * JUDY_key_size ) ) {
                _lastSlot = ( JudyValue * ) judy_del( _judyarray );
                return true;
            } else {
                return false;
            }
        }

        /// true if the array is empty
        bool isEmpty() {
            JudyKey key = 0;
            return ( ( judy_strt( _judyarray, ( const unsigned char * ) &key, _depth * JUDY_key_size ) ) ? false : true );
        }
};
#endif //JUDYLARRAY_H
**************FILE************ ./source/0.9.0.0/infra/judy/JudyL2Array.h
#ifndef JUDYL2ARRAY_H
#define JUDYL2ARRAY_H

/****************************************************************************//**
* \file judyL2Array.h C++ wrapper for judyL2 array implementation
*
* A judyL2 array maps JudyKey's to multiple JudyValue's, similar to
* std::multimap. Internally, this is a judyL array of std::vector< JudyValue >.
*
*    Author: Mark Pictor. Public domain.
*
********************************************************************************/

#include "Judy.h"
#include "assert.h"
#include <iterator>
#include <vector>

template< typename JudyKey, typename vec >
struct judyl2KVpair {
    JudyKey key;
    vec value;
};

//TODO: use vectors only when >( sizeof(vector)/sizeof(value) ) values, and store data/vector within judy.

/** A judyL2 array maps JudyKey's to multiple JudyValue's, similar to std::multimap.
 * Internally, this is a judyL array of std::vector< JudyValue >.
 * The first template parameter must be the same size as a void*
 *  \param JudyKey the type of the key, i.e. uint64_t, etc
 *  \param JudyValue the type of the value, i.e. int, pointer-to-object, etc. With judyL2Array, the size of this value can vary.
 */
template< typename JudyKey, typename JudyValue >
class judyL2Array {
    public:
        typedef std::vector< JudyValue > vector;
        typedef const vector cvector;
        typedef judyl2KVpair< JudyKey, vector * > pair;
        typedef judyl2KVpair< JudyKey, cvector * > cpair;
    protected:
        Judy * _judyarray;
        unsigned int _maxLevels, _depth;
        vector ** _lastSlot;
        JudyKey _buff[1];
        bool _success;
        cpair kv;
    public:
        judyL2Array(): _maxLevels( sizeof( JudyKey ) ), _depth( 1 ), _lastSlot( 0 ), _success( true ) {
            assert( sizeof( JudyKey ) == JUDY_key_size && "JudyKey *must* be the same size as a pointer!" );
            _judyarray = judy_open( _maxLevels, _depth );
            _buff[0] = 0;
        }

        explicit judyL2Array( const judyL2Array< JudyKey, JudyValue > & other ): _maxLevels( other._maxLevels ),
            _depth( other._depth ), _success( other._success ) {
            _judyarray = judy_clone( other._judyarray );
            _buff[0] = other._buff[0];
            find( *_buff ); //set _lastSlot
        }

        /// calls clear, so should be safe to call at any point
        ~judyL2Array() {
            clear();
            judy_close( _judyarray );
        }

        /// delete all vectors and empty the array
        void clear() {
            JudyKey key = 0;
            while( 0 != ( _lastSlot = ( vector ** ) judy_strt( _judyarray, ( const unsigned char * ) &key, 0 ) ) ) {
                //( * _lastSlot )->~vector(); //TODO: placement new
                delete( * _lastSlot );
                judy_del( _judyarray );
            }
        }

        vector * getLastValue() {
            assert( _lastSlot );
            return &_lastSlot;
        }

        void setLastValue( vector * value ) {
            assert( _lastSlot );
            &_lastSlot = value;
        }

        bool success() {
            return _success;
        }

        /** TODO
         * test for std::vector::shrink_to_fit (C++11), use it once the array is as full as it will be
         * void freeUnused() {...}
         */

        //TODO
        // allocate data memory within judy array for external use.
        // void *judy_data (Judy *judy, unsigned int amt);

        /// insert value into the vector for key.
        bool insert( JudyKey key, JudyValue value ) {
            _lastSlot = ( vector ** ) judy_cell( _judyarray, ( const unsigned char * ) &key, _depth * JUDY_key_size );
            if( _lastSlot ) {
                if( !( * _lastSlot ) ) {
                    * _lastSlot = new vector;
                    /* TODO store vectors inside judy with placement new
                    * vector * n = judy_data( _judyarray, sizeof( std::vector < JudyValue > ) );
                    * new(n) vector;
                    * *_lastSlot = n;
                    * NOTE - memory alloc'd via judy_data will not be freed until the array is freed (judy_close)
                    * also use placement new in the other insert function, below
                    */
                }
                ( * _lastSlot )->push_back( value );
                _success = true;
            } else {
                _success = false;
            }
            return _success;
        }

        /** for a given key, append to or overwrite the vector
         * this never simply re-uses the pointer to the given vector because
         * that would mean that two keys could have the same value (pointer).
         */
        bool insert( JudyKey key, const vector & values, bool overwrite = false ) {
            _lastSlot = ( vector ** ) judy_cell( _judyarray, ( const unsigned char * ) &key, _depth * JUDY_key_size );
            if( _lastSlot ) {
                if( !( * _lastSlot ) ) {
                    * _lastSlot = new vector;
                    /* TODO store vectors inside judy with placement new
                     * (see other insert(), above)
                     */
                } else if( overwrite ) {
                    ( * _lastSlot )->clear();
                }
                std::copy( values.begin(), values.end(), std::back_inserter< vector >( ( ** _lastSlot ) ) );
                _success = true;
            } else {
                _success = false;
            }
            return _success;
        }

        /// retrieve the cell pointer greater than or equal to given key
        /// NOTE what about an atOrBefore function?
        const cpair atOrAfter( JudyKey key ) {
            _lastSlot = ( vector ** ) judy_strt( _judyarray, ( const unsigned char * ) &key, _depth * JUDY_key_size );
            return mostRecentPair();
        }

        /// retrieve the cell pointer, or return NULL for a given key.
        cvector * find( JudyKey key ) {
            _lastSlot = ( vector ** ) judy_slot( _judyarray, ( const unsigned char * ) &key, _depth * JUDY_key_size );
            if( ( _lastSlot ) && ( * _lastSlot ) ) {
                _success = true;
                return * _lastSlot;
            } else {
                _success = false;
                return 0;
            }
        }

        /// retrieve the key-value pair for the most recent judy query.
        inline const cpair & mostRecentPair() {
            judy_key( _judyarray, ( unsigned char * ) _buff, _depth * JUDY_key_size );
            if( _lastSlot ) {
                kv.value = *_lastSlot;
                _success = true;
            } else {
                kv.value = ( JudyValue ) 0;
                _success = false;
            }
            kv.key = _buff[0];
            return kv;
        }

        /// retrieve the first key-value pair in the array
        const cpair & begin() {
            JudyKey key = 0;
            _lastSlot = ( vector ** ) judy_strt( _judyarray, ( const unsigned char * ) &key, 0 );
            return mostRecentPair();
        }

        /// retrieve the last key-value pair in the array
        const cpair & end() {
            _lastSlot = ( vector ** ) judy_end( _judyarray );
            return mostRecentPair();
        }

        /// retrieve the key-value pair for the next string in the array.
        const cpair & next() {
            _lastSlot = ( vector ** ) judy_nxt( _judyarray );
            return mostRecentPair();
        }

        /// retrieve the key-value pair for the prev string in the array.
        const cpair & previous() {
            _lastSlot = ( vector ** ) judy_prv( _judyarray );
            return mostRecentPair();
        }

        /** delete a key-value pair. If the array is not empty,
         * getLastValue() will return the entry before the one that was deleted
         * \sa isEmpty()
         */
        bool removeEntry( JudyKey key ) {
            if( 0 != ( _lastSlot = ( vector ** ) judy_slot( _judyarray, ( const unsigned char * ) &key, _depth * JUDY_key_size ) ) ) {
                // _lastSlot->~vector(); //for use with placement new
                delete _lastSlot;
                _lastSlot = ( vector ** ) judy_del( _judyarray );
                return true;
            } else {
                return false;
            }
        }

        /// true if the array is empty
        bool isEmpty() {
            JudyKey key = 0;
            return ( ( judy_strt( _judyarray, ( const unsigned char * ) &key, _depth * JUDY_key_size ) ) ? false : true );
        }
};
#endif //JUDYL2ARRAY_H
**************FILE************ ./source/0.9.0.0/infra/judy/Judy.cpp
//  Judy arrays 13 DEC 2012 (judy64n.c from http://code.google.com/p/judyarray/ )
//  This code is public domain.

//  Author Karl Malbrain, malbrain AT yahoo.com
//  with assistance from Jan Weiss.
//  modifications (and any bugs) by Mark Pictor, mpictor at gmail

//  Simplified judy arrays for strings and integers
//  Adapted from the ideas of Douglas Baskins of HP.

//  The -D ASKITIS benchmarking option was implemented with
//  assistance from Dr. Nikolas Askitis (www.naskitis.com).

//  Map a set of keys to corresponding memory cells (uints).
//  Each cell must be set to a non-zero value by the caller.

//  STANDALONE is defined to compile into a string sorter.

//  String mappings are denoted by calling judy_open with zero as
//  the second argument.  Integer mappings are denoted by calling
//  judy_open with the Integer depth of the Judy Trie as the second
//  argument.

//#define STANDALONE

//  functions:
//  judy_open:  open a new judy array returning a judy object.
//  judy_close: close an open judy array, freeing all memory.
//  judy_clone: clone an open judy array, duplicating the stack.
//  judy_data:  allocate data memory within judy array for external use.
//  judy_cell:  insert a string into the judy array, return cell pointer.
//  judy_strt:  retrieve the cell pointer greater than or equal to given key
//  judy_slot:  retrieve the cell pointer, or return NULL for a given key.
//  judy_key:   retrieve the string value for the most recent judy query.
//  judy_end:   retrieve the cell pointer for the last string in the array.
//  judy_nxt:   retrieve the cell pointer for the next string in the array.
//  judy_prv:   retrieve the cell pointer for the prev string in the array.
//  judy_del:   delete the key and cell for the current stack entry.

#include <memory.h>
#include <stdlib.h>

#ifdef linux
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define __USE_FILE_OFFSET64
#  include <endian.h>
#else
#  ifdef __BIG_ENDIAN__
#    ifndef BYTE_ORDER
#      define BYTE_ORDER 4321
#    endif
#  else
#    ifndef BYTE_ORDER
#      define BYTE_ORDER 1234
#    endif
#  endif
#  ifndef BIG_ENDIAN
#    define BIG_ENDIAN 4321
#  endif
#endif

#include "Judy.h"

#if defined(STANDALONE) || defined(ASKITIS)
#include <string.h>
#include <stdio.h>

extern unsigned int MaxMem;

// void judy_abort (char *msg) __attribute__ ((noreturn)); // Tell static analyser that this function will not return
void judy_abort( char * msg ) {
    fprintf( stderr, "%s\n", msg );
    exit( 1 );
}
#endif

int JudySize[] = {
    ( JUDY_slot_size * 16 ),                     // JUDY_radix node size
    ( JUDY_slot_size + JUDY_key_size ),          // JUDY_1 node size
    ( 2 * JUDY_slot_size + 2 * JUDY_key_size ),
    ( 4 * JUDY_slot_size + 4 * JUDY_key_size ),
    ( 8 * JUDY_slot_size + 8 * JUDY_key_size ),
    ( 16 * JUDY_slot_size + 16 * JUDY_key_size ),
    ( 32 * JUDY_slot_size + 32 * JUDY_key_size ),
#ifndef ASKITIS
    ( JUDY_span_bytes + JUDY_slot_size )
#else
    ( 64 * JUDY_slot_size + 64 * JUDY_key_size )
#endif
};

judyvalue JudyMask[9] = {
    0, 0xff, 0xffff, 0xffffff, 0xffffffff,
#if JUDY_key_size > 4
    0xffffffffffULL, 0xffffffffffffULL, 0xffffffffffffffULL, 0xffffffffffffffffULL
#endif
};

//    open judy object
//        call with max key size
//        and Integer tree depth.

Judy * judy_open( unsigned int max, unsigned int depth ) {
    JudySeg * seg;
    Judy * judy;
    unsigned int amt;

    max++;        // allow for zero terminator on keys

    if( ( seg = reinterpret_cast<JudySeg *>(new char[JUDY_seg]) ) ) {
        seg->seg = NULL;
        seg->next = JUDY_seg;
    } else {
#if defined(STANDALONE) || defined(ASKITIS)
        judy_abort( "No virtual memory" );
#else
        return NULL;
#endif
    }

    amt = sizeof( Judy ) + max * sizeof( JudyStack );

    if( amt & ( JUDY_cache_line - 1 ) ) {
        amt |= JUDY_cache_line - 1, amt++;
    }

#if defined(STANDALONE) || defined(ASKITIS)
    MaxMem += JUDY_seg;
#endif

    seg->next -= ( JudySlot )seg & ( JUDY_cache_line - 1 );
    seg->next -= amt;

    judy = ( Judy * )( ( unsigned char * )seg + seg->next );
    memset( judy, 0, amt );
    judy->depth = depth;
    judy->seg = seg;
    judy->max = max;
    return judy;
}

void judy_close( Judy * judy ) {
    JudySeg * seg, *nxt = judy->seg;

    while( ( seg = nxt ) ) {
        nxt =  reinterpret_cast<JudySeg *>(seg->seg), free( seg );
    }
}

//    allocate judy node

void * judy_alloc( Judy * judy, unsigned int type ) {
    unsigned int amt, idx, min;
    JudySeg * seg;
    void ** block;
    void ** rtn;

    if( !judy->seg )
#if defined(STANDALONE) || defined(ASKITIS)
        judy_abort( "illegal allocation from judy clone" );
#else
        return NULL;
#endif

    if( type == JUDY_radix ) {
        type = JUDY_radix_equiv;
    }

#ifndef ASKITIS
    if( type == JUDY_span ) {
        type = JUDY_span_equiv;
    }
#endif

    amt = JudySize[type];

    if( amt & 0x07 ) {
        amt |= 0x07, amt += 1;
    }

    //    see if free block is already available

    if( ( block = judy->reuse[type] ) ) {
        judy->reuse[type] = reinterpret_cast<void **>(*block);
        memset( block, 0, amt );
        return ( void * )block;
    }

    //    break down available larger block
    //    for reuse into smaller blocks

    if( type >= JUDY_1 )
        for( idx = type; idx++ < JUDY_max; )
            if( block = judy->reuse[idx] ) {
                judy->reuse[idx] = reinterpret_cast<void **>(*block);
                while( idx-- > type ) {
                    judy->reuse[idx] = block + JudySize[idx] / sizeof( void * );
                    block[JudySize[idx] / sizeof( void * )] = 0;
                }
                memset( block, 0, amt );
                return ( void * )block;
            }

    min = amt < JUDY_cache_line ? JUDY_cache_line : amt;

    if( judy->seg->next < min + sizeof( *seg ) ) {
        if( ( seg = reinterpret_cast<JudySeg *>(new char[JUDY_seg]) ) ) {
            seg->next = JUDY_seg;
            seg->seg = judy->seg;
            judy->seg = seg;
            seg->next -= ( JudySlot )seg & ( JUDY_cache_line - 1 );
        } else {
#if defined(STANDALONE) || defined(ASKITIS)
            judy_abort( "Out of virtual memory" );
#else
            return NULL;
#endif
        }

#if defined(STANDALONE) || defined(ASKITIS)
        MaxMem += JUDY_seg;
#endif
    }

    //    generate additional free blocks
    //    to fill up to cache line size

    rtn = ( void ** )( ( unsigned char * )judy->seg + judy->seg->next - amt );

    for( idx = type; amt & ( JUDY_cache_line - 1 ); amt <<= 1 ) {
        block = ( void ** )( ( unsigned char * )judy->seg + judy->seg->next - 2 * amt );
        judy->reuse[idx++] = block;
        *block = 0;
    }

    judy->seg->next -= amt;
    memset( rtn, 0, JudySize[type] );
    return ( void * )rtn;
}

void * judy_data( Judy * judy, unsigned int amt )

{
    JudySeg * seg;
    void * block;

    if( !judy->seg )
#if defined(STANDALONE) || defined(ASKITIS)
        judy_abort( "illegal allocation from judy clone" );
#else
        return NULL;
#endif

    if( amt & ( JUDY_cache_line - 1 ) ) {
        amt |= ( JUDY_cache_line - 1 ), amt += 1;
    }

    if( judy->seg->next < amt + sizeof( *seg ) ) {
        if( ( seg = reinterpret_cast<JudySeg *>(new char[JUDY_seg]) ) ) {
            seg->next = JUDY_seg;
            seg->seg = judy->seg;
            judy->seg = seg;
            seg->next -= ( JudySlot )seg & ( JUDY_cache_line - 1 );
        } else {
#if defined(STANDALONE) || defined(ASKITIS)
            judy_abort( "Out of virtual memory" );
#else
            return NULL;
#endif
        }

#if defined(STANDALONE) || defined(ASKITIS)
        MaxMem += JUDY_seg;
#endif
    }

    judy->seg->next -= amt;

    block = ( void * )( ( unsigned char * )judy->seg + judy->seg->next );
    memset( block, 0, amt );
    return block;
}

Judy * judy_clone( Judy * judy ) {
    Judy * clone;
    unsigned int amt;

    amt = sizeof( Judy ) + judy->max * sizeof( JudyStack );
    clone = reinterpret_cast<Judy *>(judy_data( judy, amt ));
    memcpy( clone, judy, amt );
    clone->seg = NULL;    // stop allocations from cloned array
    return clone;
}

void judy_free( Judy * judy, void * block, int type ) {
    if( type == JUDY_radix ) {
        type = JUDY_radix_equiv;
    }

#ifndef ASKITIS
    if( type == JUDY_span ) {
        type = JUDY_span_equiv;
    }
#endif

    *( ( void ** )( block ) ) = judy->reuse[type];
    judy->reuse[type] = ( void ** )block;
    return;
}

//    assemble key from current path

unsigned int judy_key( Judy * judy, unsigned char * buff, unsigned int max ) {
    judyvalue * dest = ( judyvalue * )buff;
    unsigned int len = 0, idx = 0, depth;
    int slot, off, type;
    judyvalue value;
    unsigned char * base;
    int keysize;

    if( judy->depth ) {
        max = judy->depth * JUDY_key_size;
    } else {
        max--;    // leave room for zero terminator
    }

    while( len < max && ++idx <= judy->level ) {
        type = judy->stack[idx].next & 0x07;
        slot = judy->stack[idx].slot;
        depth = len / JUDY_key_size;

        if( judy->depth )
            if( !( len & JUDY_key_mask ) ) {
                dest[depth] = 0;
            }

        switch( type ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                keysize = JUDY_key_size - ( judy->stack[idx].off & JUDY_key_mask );
                base = ( unsigned char * )( judy->stack[idx].next & JUDY_mask );

                if( judy->depth ) {
                    value = *( judyvalue * )( base + slot * keysize );
                    value &= JudyMask[keysize];
                    dest[depth++] |= value;
                    len += keysize;

                    if( depth < judy->depth ) {
                        continue;
                    }

                    return len;
                }

#if BYTE_ORDER != BIG_ENDIAN
                off = keysize;

                while( off-- && len < max )
                    if( buff[len] = base[slot * keysize + off] ) {
                        len++;
                    } else {
                        break;
                    }
#else
                for( off = 0; off < keysize && len < max; off++ )
                    if( buff[len] = base[slot * keysize + off] ) {
                        len++;
                    } else {
                        break;
                    }
#endif
                continue;

            case JUDY_radix:
                if( judy->depth ) {
                    dest[depth] |= ( judyvalue )slot << ( JUDY_key_size - ( ++len & JUDY_key_mask ) ) * 8;
                    if( !( len & JUDY_key_mask ) ) {
                        depth++;
                    }
                    if( depth < judy->depth ) {
                        continue;
                    }

                    return len;
                }

                if( !slot ) {
                    break;
                }
                buff[len++] = ( unsigned char )slot;
                continue;

#ifndef ASKITIS
            case JUDY_span:
                base = ( unsigned char * )( judy->stack[idx].next & JUDY_mask );

                for( slot = 0; slot < JUDY_span_bytes && base[slot]; slot++ )
                    if( len < max ) {
                        buff[len++] = base[slot];
                    }
                continue;
#endif
        }
    }
    buff[len] = 0;
    return len;
}

//    find slot & setup cursor

JudySlot * judy_slot( Judy * judy, const unsigned char * buff, unsigned int max ) {
    judyvalue * src = ( judyvalue * )buff;
    int slot, size, keysize, tst, cnt;
    JudySlot next = *judy->root;
    judyvalue value, test = 0;
    JudySlot * table;
    JudySlot * node;
    unsigned int depth = 0;
    unsigned int off = 0;
    unsigned char * base;

#ifndef ASKITIS
    judy->level = 0;
#endif

    while( next ) {
#ifndef ASKITIS
        if( judy->level < judy->max ) {
            judy->level++;
        }

        judy->stack[judy->level].next = next;
        judy->stack[judy->level].off = off;
#endif
        size = JudySize[next & 0x07];

        switch( next & 0x07 ) {

            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                base = ( unsigned char * )( next & JUDY_mask );
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                keysize = JUDY_key_size - ( off & JUDY_key_mask );
                cnt = size / ( sizeof( JudySlot ) + keysize );
                slot = cnt;
                value = 0;

                if( judy->depth ) {
                    value = src[depth++];
                    off |= JUDY_key_mask;
                    off++;
                    value &= JudyMask[keysize];
                } else
                    do {
                        value <<= 8;
                        if( off < max ) {
                            value |= buff[off];
                        }
                    } while( ++off & JUDY_key_mask );

                //  find slot > key

                while( slot-- ) {
                    test = *( judyvalue * )( base + slot * keysize );
#if BYTE_ORDER == BIG_ENDIAN
                    test >>= 8 * ( JUDY_key_size - keysize );
#else
                    test &= JudyMask[keysize];
#endif
                    if( test <= value ) {
                        break;
                    }
                }
#ifndef ASKITIS
                judy->stack[judy->level].slot = slot;
#endif
                if( test == value ) {

                    // is this a leaf?

                    if( !judy->depth && !( value & 0xFF ) || judy->depth && depth == judy->depth ) {
                        return &node[-slot - 1];
                    }

                    next = node[-slot - 1];
                    continue;
                }

                return NULL;

            case JUDY_radix:
                table = ( JudySlot * )( next & JUDY_mask ); // outer radix

                if( judy->depth ) {
                    slot = ( src[depth] >> ( ( JUDY_key_size - ++off & JUDY_key_mask ) * 8 ) ) & 0xff;
                } else if( off < max ) {
                    slot = buff[off++];
                } else {
                    slot = 0;
                }
#ifndef ASKITIS
                //    put radix slot on judy stack

                judy->stack[judy->level].slot = slot;
#endif
                if( ( next = table[slot >> 4] ) ) {
                    table = ( JudySlot * )( next & JUDY_mask );    // inner radix
                } else {
                    return NULL;
                }

                if( judy->depth )
                    if( !( off & JUDY_key_mask ) ) {
                        depth++;
                    }

                if( !judy->depth && !slot || judy->depth && depth == judy->depth )    // leaf?
                    if( table[slot & 0x0F] ) {  // occupied?
                        return &table[slot & 0x0F];
                    } else {
                        return NULL;
                    }

                next = table[slot & 0x0F];
                continue;

#ifndef ASKITIS
            case JUDY_span:
                node = ( JudySlot * )( ( next & JUDY_mask ) + JudySize[JUDY_span] );
                base = ( unsigned char * )( next & JUDY_mask );
                cnt = tst = JUDY_span_bytes;
                if( tst > ( int )( max - off ) ) {
                    tst = max - off;
                }
                value = strncmp( ( const char * )base, ( const char * )( buff + off ), tst );
                if( !value && tst < cnt && !base[tst] ) { // leaf?
                    return &node[-1];
                }

                if( !value && tst == cnt ) {
                    next = node[-1];
                    off += cnt;
                    continue;
                }
                return NULL;
#endif
        }
    }

    return NULL;
}

//    promote full nodes to next larger size

JudySlot * judy_promote( Judy * judy, JudySlot * next, int idx, judyvalue value, int keysize ) {
    unsigned char * base = ( unsigned char * )( *next & JUDY_mask );
    int oldcnt, newcnt, slot;
#if BYTE_ORDER == BIG_ENDIAN
    int i;
#endif
    JudySlot * newnode, *node;
    JudySlot * result;
    unsigned char * newbase;
    unsigned int type;

    type = ( *next & 0x07 ) + 1;
    node = ( JudySlot * )( ( *next & JUDY_mask ) + JudySize[type - 1] );
    oldcnt = JudySize[type - 1] / ( sizeof( JudySlot ) + keysize );
    newcnt = JudySize[type] / ( sizeof( JudySlot ) + keysize );

    // promote node to next larger size

    newbase = reinterpret_cast<unsigned char*>(judy_alloc( judy, type ));
    newnode = ( JudySlot * )( newbase + JudySize[type] );
    *next = ( JudySlot )newbase | type;

    //    open up slot at idx

    memcpy( newbase + ( newcnt - oldcnt - 1 ) * keysize, base, idx * keysize ); // copy keys

    for( slot = 0; slot < idx; slot++ ) {
        newnode[-( slot + newcnt - oldcnt )] = node[-( slot + 1 )];    // copy ptr
    }

    //    fill in new node

#if BYTE_ORDER != BIG_ENDIAN
    memcpy( newbase + ( idx + newcnt - oldcnt - 1 ) * keysize, &value, keysize ); // copy key
#else
    i = keysize;

    while( i-- ) {
        newbase[( idx + newcnt - oldcnt - 1 ) * keysize + i] = value, value >>= 8;
    }
#endif
    result = &newnode[-( idx + newcnt - oldcnt )];

    //    copy rest of old node

    memcpy( newbase + ( idx + newcnt - oldcnt ) * keysize, base + ( idx * keysize ), ( oldcnt - slot ) * keysize ); // copy keys

    for( ; slot < oldcnt; slot++ ) {
        newnode[-( slot + newcnt - oldcnt + 1 )] = node[-( slot + 1 )];    // copy ptr
    }

#ifndef ASKITIS
    judy->stack[judy->level].next = *next;
    judy->stack[judy->level].slot = idx + newcnt - oldcnt - 1;
#endif
    judy_free( judy, ( void ** )base, type - 1 );
    return result;
}

//    construct new node for JUDY_radix entry
//    make node with slot - start entries
//    moving key over one offset

void judy_radix( Judy * judy, JudySlot * radix, unsigned char * old, int start, int slot, int keysize, unsigned char key, unsigned int depth ) {
    int size, idx, cnt = slot - start, newcnt;
    JudySlot * node, *oldnode;
    unsigned int type = JUDY_1 - 1;
    JudySlot * table;
    unsigned char * base;

    //    if necessary, setup inner radix node

    if( !( table = ( JudySlot * )( radix[key >> 4] & JUDY_mask ) ) ) {
        table = reinterpret_cast<JudySlot *>(judy_alloc( judy, JUDY_radix ));
        radix[key >> 4] = ( JudySlot )table | JUDY_radix;
    }

    oldnode = ( JudySlot * )( old + JudySize[JUDY_max] );

    // is this slot a leaf?

    if( !judy->depth && ( !key || !keysize ) || judy->depth && !keysize && depth == judy->depth ) {
        table[key & 0x0F] = oldnode[-start - 1];
        return;
    }

    //    calculate new node big enough to contain slots

    do {
        type++;
        size = JudySize[type];
        newcnt = size / ( sizeof( JudySlot ) + keysize );
    } while( cnt > newcnt && type < JUDY_max );

    //    store new node pointer in inner table

    base = reinterpret_cast<unsigned char*>(judy_alloc( judy, type ));
    node = ( JudySlot * )( base + size );
    table[key & 0x0F] = ( JudySlot )base | type;

    //    allocate node and copy old contents
    //    shorten keys by 1 byte during copy

    for( idx = 0; idx < cnt; idx++ ) {
#if BYTE_ORDER != BIG_ENDIAN
        memcpy( base + ( newcnt - idx - 1 ) * keysize, old + ( start + cnt - idx - 1 ) * ( keysize + 1 ), keysize );
#else
        memcpy( base + ( newcnt - idx - 1 ) * keysize, old + ( start + cnt - idx - 1 ) * ( keysize + 1 ) + 1, keysize );
#endif
        node[-( newcnt - idx )] = oldnode[-( start + cnt - idx )];
    }
}

//    decompose full node to radix nodes

void judy_splitnode( Judy * judy, JudySlot * next, unsigned int size, unsigned int keysize, unsigned int depth ) {
    int cnt, slot, start = 0;
    unsigned int key = 0x0100, nxt;
    JudySlot * newradix;
    unsigned char * base;

    base = ( unsigned char * )( *next & JUDY_mask );
    cnt = size / ( sizeof( JudySlot ) + keysize );

    //    allocate outer judy_radix node

    newradix = reinterpret_cast<JudySlot *>(judy_alloc( judy, JUDY_radix ));
    *next = ( JudySlot )newradix | JUDY_radix;

    for( slot = 0; slot < cnt; slot++ ) {
#if BYTE_ORDER != BIG_ENDIAN
        nxt = base[slot * keysize + keysize - 1];
#else
        nxt = base[slot * keysize];
#endif

        if( key > 0xFF ) {
            key = nxt;
        }
        if( nxt == key ) {
            continue;
        }

        //    decompose portion of old node into radix nodes

        judy_radix( judy, newradix, base, start, slot, keysize - 1, ( unsigned char )key, depth );
        start = slot;
        key = nxt;
    }

    judy_radix( judy, newradix, base, start, slot, keysize - 1, ( unsigned char )key, depth );
    judy_free( judy, ( void ** )base, JUDY_max );
}

//    return first leaf

JudySlot * judy_first( Judy * judy, JudySlot next, unsigned int off, unsigned int depth ) {
    JudySlot * table, *inner;
    unsigned int keysize, size;
    JudySlot * node;
    int slot, cnt;
    unsigned char * base;

    while( next ) {
        if( judy->level < judy->max ) {
            judy->level++;
        }

        judy->stack[judy->level].off = off;
        judy->stack[judy->level].next = next;
        size = JudySize[next & 0x07];

        switch( next & 0x07 ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                keysize = JUDY_key_size - ( off & JUDY_key_mask );
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                base = ( unsigned char * )( next & JUDY_mask );
                cnt = size / ( sizeof( JudySlot ) + keysize );

                for( slot = 0; slot < cnt; slot++ )
                    if( node[-slot - 1] ) {
                        break;
                    }

                judy->stack[judy->level].slot = slot;
#if BYTE_ORDER != BIG_ENDIAN
                if( !judy->depth && !base[slot * keysize] || judy->depth && ++depth == judy->depth ) {
                    return &node[-slot - 1];
                }
#else
                if( !judy->depth && !base[slot * keysize + keysize - 1] || judy->depth && ++depth == judy->depth ) {
                    return &node[-slot - 1];
                }
#endif
                next = node[-slot - 1];
                off = ( off | JUDY_key_mask ) + 1;
                continue;
            case JUDY_radix:
                off++;

                if( judy->depth )
                    if( !( off & JUDY_key_mask ) ) {
                        depth++;
                    }

                table = ( JudySlot * )( next & JUDY_mask );
                for( slot = 0; slot < 256; slot++ )
                    if( ( inner = ( JudySlot * )( table[slot >> 4] & JUDY_mask ) ) ) {
                        if( ( next = inner[slot & 0x0F] ) ) {
                            judy->stack[judy->level].slot = slot;
                            if( !judy->depth && !slot || judy->depth && depth == judy->depth ) {
                                return &inner[slot & 0x0F];
                            } else {
                                break;
                            }
                        }
                    } else {
                        slot |= 0x0F;
                    }
                continue;
#ifndef ASKITIS
            case JUDY_span:
                node = ( JudySlot * )( ( next & JUDY_mask ) + JudySize[JUDY_span] );
                base = ( unsigned char * )( next & JUDY_mask );
                cnt = JUDY_span_bytes;
                if( !base[cnt - 1] ) {  // leaf node?
                    return &node[-1];
                }
                next = node[-1];
                off += cnt;
                continue;
#endif
        }
    }
    return NULL;
}

//    return last leaf cell pointer

JudySlot * judy_last( Judy * judy, JudySlot next, unsigned int off, unsigned int depth ) {
    JudySlot * table, *inner;
    unsigned int keysize, size;
    JudySlot * node;
    int slot, cnt;
    unsigned char * base;

    while( next ) {
        if( judy->level < judy->max ) {
            judy->level++;
        }

        judy->stack[judy->level].next = next;
        judy->stack[judy->level].off = off;
        size = JudySize[next & 0x07];
        switch( next & 0x07 ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                keysize = JUDY_key_size - ( off & JUDY_key_mask );
                slot = size / ( sizeof( JudySlot ) + keysize );
                base = ( unsigned char * )( next & JUDY_mask );
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                judy->stack[judy->level].slot = --slot;

#if BYTE_ORDER != BIG_ENDIAN
                if( !judy->depth && !base[slot * keysize] || judy->depth && ++depth == judy->depth )
#else
                if( !judy->depth && !base[slot * keysize + keysize - 1] || judy->depth && ++depth == judy->depth )
#endif
                    return &node[-slot - 1];

                next = node[-slot - 1];
                off += keysize;
                continue;

            case JUDY_radix:
                table = ( JudySlot * )( next & JUDY_mask );
                off++;

                if( judy->depth )
                    if( !( off & JUDY_key_mask ) ) {
                        depth++;
                    }

                for( slot = 256; slot--; ) {
                    judy->stack[judy->level].slot = slot;
                    if( ( inner = ( JudySlot * )( table[slot >> 4] & JUDY_mask ) ) ) {
                        if( ( next = inner[slot & 0x0F] ) )
                            if( !judy->depth && !slot || judy->depth && depth == judy->depth ) {
                                return &inner[0];
                            } else {
                                break;
                            }
                    } else {
                        slot &= 0xF0;
                    }
                }
                continue;

#ifndef ASKITIS
            case JUDY_span:
                node = ( JudySlot * )( ( next & JUDY_mask ) + JudySize[JUDY_span] );
                base = ( unsigned char * )( next & JUDY_mask );
                cnt = JUDY_span_bytes;
                if( !base[cnt - 1] ) {  // leaf node?
                    return &node[-1];
                }
                next = node[-1];
                off += cnt;
                continue;
#endif
        }
    }
    return NULL;
}

//    judy_end: return last entry

JudySlot * judy_end( Judy * judy ) {
    judy->level = 0;
    return judy_last( judy, *judy->root, 0, 0 );
}

//    judy_nxt: return next entry
JudySlot * judy_nxt( Judy * judy ) {
    JudySlot * table, *inner;
    int slot, size, cnt;
    JudySlot * node;
    JudySlot next;
    unsigned int keysize;
    unsigned char * base;
    unsigned int depth;
    unsigned int off;

    if( !judy->level ) {
        return judy_first( judy, *judy->root, 0, 0 );
    }

    while( judy->level ) {
        next = judy->stack[judy->level].next;
        slot = judy->stack[judy->level].slot;
        off = judy->stack[judy->level].off;
        keysize = JUDY_key_size - ( off & JUDY_key_mask );
        size = JudySize[next & 0x07];
        depth = off / JUDY_key_size;

        switch( next & 0x07 ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                cnt = size / ( sizeof( JudySlot ) + keysize );
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                base = ( unsigned char * )( next & JUDY_mask );
                if( ++slot < cnt )
#if BYTE_ORDER != BIG_ENDIAN
                    if( !judy->depth && !base[slot * keysize] || judy->depth && ++depth == judy->depth )
#else
                    if( !judy->depth && !base[slot * keysize + keysize - 1] || judy->depth && ++depth == judy->depth )
#endif
                    {
                        judy->stack[judy->level].slot = slot;
                        return &node[-slot - 1];
                    } else {
                        judy->stack[judy->level].slot = slot;
                        return judy_first( judy, node[-slot - 1], ( off | JUDY_key_mask ) + 1, depth );
                    }
                judy->level--;
                continue;

            case JUDY_radix:
                table = ( JudySlot * )( next & JUDY_mask );

                if( judy->depth )
                    if( !( ( off + 1 ) & JUDY_key_mask ) ) {
                        depth++;
                    }

                while( ++slot < 256 )
                    if( ( inner = ( JudySlot * )( table[slot >> 4] & JUDY_mask ) ) ) {
                        if( inner[slot & 0x0F] ) {
                            judy->stack[judy->level].slot = slot;
                            if( !judy->depth || depth < judy->depth ) {
                                return judy_first( judy, inner[slot & 0x0F], off + 1, depth );
                            }
                            return &inner[slot & 0x0F];
                        }
                    } else {
                        slot |= 0x0F;
                    }

                judy->level--;
                continue;
#ifndef ASKITIS
            case JUDY_span:
                judy->level--;
                continue;
#endif
        }
    }
    return NULL;
}

//    judy_prv: return ptr to previous entry

JudySlot * judy_prv( Judy * judy ) {
    int slot, size, keysize;
    JudySlot * table, *inner;
    JudySlot * node, next;
    unsigned char * base;
    unsigned int depth;
    unsigned int off;

    if( !judy->level ) {
        return judy_last( judy, *judy->root, 0, 0 );
    }

    while( judy->level ) {
        next = judy->stack[judy->level].next;
        slot = judy->stack[judy->level].slot;
        off = judy->stack[judy->level].off;
        size = JudySize[next & 0x07];
        depth = off / JUDY_key_size;

        switch( next & 0x07 ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                if( !slot || !node[-slot] ) {
                    judy->level--;
                    continue;
                }

                base = ( unsigned char * )( next & JUDY_mask );
                judy->stack[judy->level].slot--;
                keysize = JUDY_key_size - ( off & JUDY_key_mask );

#if BYTE_ORDER != BIG_ENDIAN
                if( !judy->depth && !base[( slot - 1 ) * keysize] || judy->depth && ++depth == judy->depth )
#else
                if( !judy->depth && !base[( slot - 1 ) * keysize + keysize - 1] || judy->depth && ++depth == judy->depth )
#endif
                    return &node[-slot];
                return judy_last( judy, node[-slot], ( off | JUDY_key_mask ) + 1, depth );

            case JUDY_radix:
                table = ( JudySlot * )( next & JUDY_mask );

                if( judy->depth )
                    if( !( ( off + 1 ) & JUDY_key_mask ) ) {
                        depth++;
                    }

                while( slot-- ) {
                    judy->stack[judy->level].slot--;
                    if( ( inner = ( JudySlot * )( table[slot >> 4] & JUDY_mask ) ) )
                        if( inner[slot & 0x0F] )
                            if( !judy->depth && !slot || judy->depth && depth == judy->depth ) {
                                return &inner[0];
                            } else {
                                return judy_last( judy, inner[slot & 0x0F], off + 1, depth );
                            }
                }

                judy->level--;
                continue;

#ifndef ASKITIS
            case JUDY_span:
                judy->level--;
                continue;
#endif
        }
    }
    return NULL;
}

//    judy_del: delete string from judy array
//        returning previous entry.

JudySlot * judy_del( Judy * judy ) {
    int slot, off, size, type, high;
    JudySlot * table, *inner;
    JudySlot next, *node;
    int keysize, cnt;
    unsigned char * base;

    while( judy->level ) {
        next = judy->stack[judy->level].next;
        slot = judy->stack[judy->level].slot;
        off = judy->stack[judy->level].off;
        size = JudySize[next & 0x07];

        switch( type = next & 0x07 ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                keysize = JUDY_key_size - ( off & JUDY_key_mask );
                cnt = size / ( sizeof( JudySlot ) + keysize );
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                base = ( unsigned char * )( next & JUDY_mask );

                //    move deleted slot to first slot

                while( slot ) {
                    node[-slot - 1] = node[-slot];
                    memcpy( base + slot * keysize, base + ( slot - 1 ) * keysize, keysize );
                    slot--;
                }

                //    zero out first slot

                node[-1] = 0;
                memset( base, 0, keysize );

                if( node[-cnt] ) {    // does node have any slots left?
                    judy->stack[judy->level].slot++;
                    return judy_prv( judy );
                }

                judy_free( judy, base, type );
                judy->level--;
                continue;

            case JUDY_radix:
                table = ( JudySlot * )( next & JUDY_mask );
                inner = ( JudySlot * )( table[slot >> 4] & JUDY_mask );
                inner[slot & 0x0F] = 0;
                high = slot & 0xF0;

                for( cnt = 16; cnt--; )
                    if( inner[cnt] ) {
                        return judy_prv( judy );
                    }

                judy_free( judy, inner, JUDY_radix );
                table[slot >> 4] = 0;

                for( cnt = 16; cnt--; )
                    if( table[cnt] ) {
                        return judy_prv( judy );
                    }

                judy_free( judy, table, JUDY_radix );
                judy->level--;
                continue;

#ifndef ASKITIS
            case JUDY_span:
                base = ( unsigned char * )( next & JUDY_mask );
                judy_free( judy, base, type );
                judy->level--;
                continue;
#endif
        }
    }

    //    tree is now empty

    *judy->root = 0;
    return NULL;
}

//    return cell for first key greater than or equal to given key

JudySlot * judy_strt( Judy * judy, const unsigned char * buff, unsigned int max ) {
    JudySlot * cell;

    judy->level = 0;

    if( !max ) {
        return judy_first( judy, *judy->root, 0, 0 );
    }

    if( ( cell = judy_slot( judy, buff, max ) ) ) {
        return cell;
    }

    return judy_nxt( judy );
}

//    split open span node

#ifndef ASKITIS
void judy_splitspan( Judy * judy, JudySlot * next, unsigned char * base ) {
    JudySlot * node = ( JudySlot * )( base + JudySize[JUDY_span] );
    unsigned int cnt = JUDY_span_bytes;
    unsigned char * newbase;
    unsigned int off = 0;
#if BYTE_ORDER != BIG_ENDIAN
    int i;
#endif

    do {
        newbase = reinterpret_cast<unsigned char *>(judy_alloc( judy, JUDY_1 ));
        *next = ( JudySlot )newbase | JUDY_1;

#if BYTE_ORDER != BIG_ENDIAN
        i = JUDY_key_size;
        while( i-- ) {
            *newbase++ = base[off + i];
        }
#else
        memcpy( newbase, base + off, JUDY_key_size );
        newbase += JUDY_key_size;
#endif
        next = ( JudySlot * )newbase;

        off += JUDY_key_size;
        cnt -= JUDY_key_size;
    } while( cnt && base[off - 1] );

    *next = node[-1];
    judy_free( judy, base, JUDY_span );
}
#endif

//    judy_cell: add string to judy array

JudySlot * judy_cell( Judy * judy, const unsigned char * buff, unsigned int max ) {
    judyvalue * src = ( judyvalue * )buff;
    int size, idx, slot, cnt, tst;
    JudySlot * next = judy->root;
    judyvalue test, value;
    unsigned int off = 0, start;
    JudySlot * table;
    JudySlot * node;
    unsigned int depth = 0;
    unsigned int keysize;
    unsigned char * base;

    judy->level = 0;
#ifdef ASKITIS
    Words++;
#endif

    while( *next ) {
#ifndef ASKITIS
        if( judy->level < judy->max ) {
            judy->level++;
        }

        judy->stack[judy->level].next = *next;
        judy->stack[judy->level].off = off;
#endif
        switch( *next & 0x07 ) {
            default:
                size = JudySize[*next & 0x07];
                keysize = JUDY_key_size - ( off & JUDY_key_mask );
                cnt = size / ( sizeof( JudySlot ) + keysize );
                base = ( unsigned char * )( *next & JUDY_mask );
                node = ( JudySlot * )( ( *next & JUDY_mask ) + size );
                start = off;
                slot = cnt;
                value = 0;

                if( judy->depth ) {
                    value = src[depth++];
                    off |= JUDY_key_mask;
                    off++;
                    value &= JudyMask[keysize];
                } else
                    do {
                        value <<= 8;
                        if( off < max ) {
                            value |= buff[off];
                        }
                    } while( ++off & JUDY_key_mask );

                //  find slot > key

                while( slot-- ) {
                    test = *( judyvalue * )( base + slot * keysize );
#if BYTE_ORDER == BIG_ENDIAN
                    test >>= 8 * ( JUDY_key_size - keysize );
#else
                    test &= JudyMask[keysize];
#endif
                    if( test <= value ) {
                        break;
                    }
                }
#ifndef ASKITIS
                judy->stack[judy->level].slot = slot;
#endif
                if( test == value ) {        // new key is equal to slot key
                    next = &node[-slot - 1];

                    // is this a leaf?

                    if( !judy->depth && !( value & 0xFF ) || judy->depth && depth == judy->depth ) {
#ifdef ASKITIS
                        if( *next ) {
                            Found++;
                        } else {
                            Inserts++;
                        }
#endif
                        return next;
                    }

                    continue;
                }

                //    if this node is not full
                //    open up cell after slot

                if( !node[-1] ) {
                    memmove( base, base + keysize, slot * keysize );  // move keys less than new key down one slot
#if BYTE_ORDER != BIG_ENDIAN
                    memcpy( base + slot * keysize, &value, keysize );  // copy new key into slot
#else
                    test = value;
                    idx = keysize;

                    while( idx-- ) {
                        base[slot * keysize + idx] = test, test >>= 8;
                    }
#endif
                    for( idx = 0; idx < slot; idx++ ) {
                        node[-idx - 1] = node[-idx - 2];    // copy tree ptrs/cells down one slot
                    }

                    node[-slot - 1] = 0;          // set new tree ptr/cell
                    next = &node[-slot - 1];

                    if( !judy->depth && !( value & 0xFF ) || judy->depth && depth == judy->depth ) {
#ifdef ASKITIS
                        if( *next ) {
                            Found++;
                        } else {
                            Inserts++;
                        }
#endif
                        return next;
                    }

                    continue;
                }

                if( size < JudySize[JUDY_max] ) {
                    next = judy_promote( judy, next, slot + 1, value, keysize );

                    if( !judy->depth && !( value & 0xFF ) || judy->depth && depth == judy->depth ) {
#ifdef ASKITIS
                        if( *next ) {
                            Found++;
                        } else {
                            Inserts++;
                        }
#endif
                        return next;
                    }

                    continue;
                }

                //    split full maximal node into JUDY_radix nodes
                //  loop to reprocess new insert

                judy_splitnode( judy, next, size, keysize, depth );
#ifndef ASKITIS
                judy->level--;
#endif
                off = start;
                if( judy->depth ) {
                    depth--;
                }
                continue;

            case JUDY_radix:
                table = ( JudySlot * )( *next & JUDY_mask ); // outer radix

                if( judy->depth ) {
                    slot = ( src[depth] >> ( ( JUDY_key_size - ++off & JUDY_key_mask ) * 8 ) ) & 0xff;
                } else if( off < max ) {
                    slot = buff[off++];
                } else {
                    slot = 0, off++;
                }

                if( judy->depth )
                    if( !( off & JUDY_key_mask ) ) {
                        depth++;
                    }

                // allocate inner radix if empty

                if( !table[slot >> 4] ) {
                    table[slot >> 4] = ( JudySlot )judy_alloc( judy, JUDY_radix ) | JUDY_radix;
                }

                table = ( JudySlot * )( table[slot >> 4] & JUDY_mask );
#ifndef ASKITIS
                judy->stack[judy->level].slot = slot;
#endif
                next = &table[slot & 0x0F];

                if( !judy->depth && !slot || judy->depth && depth == judy->depth ) { // leaf?
#ifdef ASKITIS
                    if( *next ) {
                        Found++;
                    } else {
                        Inserts++;
                    }
#endif
                    return next;
                }

                continue;

#ifndef ASKITIS
            case JUDY_span:
                base = ( unsigned char * )( *next & JUDY_mask );
                node = ( JudySlot * )( ( *next & JUDY_mask ) + JudySize[JUDY_span] );
                cnt = JUDY_span_bytes;
                tst = cnt;

                if( tst > ( int )( max - off ) ) {
                    tst = max - off;
                }

                value = strncmp( ( const char * )base, ( const char * )( buff + off ), tst );

                if( !value && tst < cnt && !base[tst] ) { // leaf?
                    return &node[-1];
                }

                if( !value && tst == cnt ) {
                    next = &node[-1];
                    off += cnt;
                    continue;
                }

                //    bust up JUDY_span node and produce JUDY_1 nodes
                //    then loop to reprocess insert

                judy_splitspan( judy, next, base );
                judy->level--;
                continue;
#endif
        }
    }

    // place JUDY_1 node under JUDY_radix node(s)

#ifndef ASKITIS
    if( off & JUDY_key_mask )
        if( judy->depth || off <= max ) {
#else
    while( off <= max ) {
#endif
            base = reinterpret_cast<unsigned char *>(judy_alloc( judy, JUDY_1 ));
            keysize = JUDY_key_size - ( off & JUDY_key_mask );
            node = ( JudySlot * )( base + JudySize[JUDY_1] );
            *next = ( JudySlot )base | JUDY_1;

            //    fill in slot 0 with bytes of key

            if( judy->depth ) {
                value = src[depth];
#if BYTE_ORDER != BIG_ENDIAN
                memcpy( base, &value, keysize );  // copy new key into slot
#else
                while( keysize-- ) {
                    base[keysize] = value, value >>= 8;
                }
#endif
            } else {
#if BYTE_ORDER != BIG_ENDIAN
                while( keysize )
                    if( off + keysize <= max ) {
                        *base++ = buff[off + --keysize];
                    } else {
                        base++, --keysize;
                    }
#else
                tst = keysize;

                if( tst > ( int )( max - off ) ) {
                    tst = max - off;
                }

                memcpy( base, buff + off, tst );
#endif
            }
#ifndef ASKITIS
            if( judy->level < judy->max ) {
                judy->level++;
            }
            judy->stack[judy->level].next = *next;
            judy->stack[judy->level].slot = 0;
            judy->stack[judy->level].off = off;
#endif
            next = &node[-1];

            off |= JUDY_key_mask;
            depth++;
            off++;
        }

    //    produce span nodes to consume rest of key
    //  or judy_1 nodes if not string tree

#ifndef ASKITIS
    if( !judy->depth )
        while( off <= max ) {
            base = reinterpret_cast<unsigned char *>(judy_alloc( judy, JUDY_span ));
            *next = ( JudySlot )base | JUDY_span;
            node = ( JudySlot * )( base + JudySize[JUDY_span] );
            cnt = tst = JUDY_span_bytes;
            if( tst > ( int )( max - off ) ) {
                tst = max - off;
            }
            memcpy( base, buff + off, tst );

            if( judy->level < judy->max ) {
                judy->level++;
            }
            judy->stack[judy->level].next = *next;
            judy->stack[judy->level].slot = 0;
            judy->stack[judy->level].off = off;
            next = &node[-1];
            off += tst;
            depth++;

            if( !base[cnt - 1] ) { // done on leaf
                break;
            }
        }
    else
        while( depth < judy->depth ) {
            base = reinterpret_cast<unsigned char *>(judy_alloc( judy, JUDY_1 ));
            node = ( JudySlot * )( base + JudySize[JUDY_1] );
            *next = ( JudySlot )base | JUDY_1;

            //    fill in slot 0 with bytes of key

            *( judyvalue * )base = src[depth];

            if( judy->level < judy->max ) {
                judy->level++;
            }
            judy->stack[judy->level].next = *next;
            judy->stack[judy->level].slot = 0;
            judy->stack[judy->level].off = off;
            next = &node[-1];
            off |= JUDY_key_mask;
            depth++;
            off++;
        }
#endif

#ifdef ASKITIS
    Inserts++;
#endif
    return next;
}

**************FILE************ ./source/0.9.0.0/infra/judy/JudyCore.cpp
//  Judy arrays 13 DEC 2012 (judy64n.c from http://code.google.com/p/judyarray/ )
//  This code is public domain.

//  Author Karl Malbrain, malbrain AT yahoo.com
//  with assistance from Jan Weiss.
//  modifications (and any bugs) by Mark Pictor, mpictor at gmail

//  Simplified judy arrays for strings and integers
//  Adapted from the ideas of Douglas Baskins of HP.

//  The -D ASKITIS benchmarking option was implemented with
//  assistance from Dr. Nikolas Askitis (www.naskitis.com).

//  Map a set of keys to corresponding memory cells (uints).
//  Each cell must be set to a non-zero value by the caller.

//  STANDALONE is defined to compile into a string sorter.

//  String mappings are denoted by calling judy_open with zero as
//  the second argument.  Integer mappings are denoted by calling
//  judy_open with the Integer depth of the Judy Trie as the second
//  argument.

//#define STANDALONE

//  functions:
//  judy_open:  open a new judy array returning a judy object.
//  judy_close: close an open judy array, freeing all memory.
//  judy_clone: clone an open judy array, duplicating the stack.
//  judy_data:  allocate data memory within judy array for external use.
//  judy_cell:  insert a string into the judy array, return cell pointer.
//  judy_strt:  retrieve the cell pointer greater than or equal to given key
//  judy_slot:  retrieve the cell pointer, or return NULL for a given key.
//  judy_key:   retrieve the string value for the most recent judy query.
//  judy_end:   retrieve the cell pointer for the last string in the array.
//  judy_nxt:   retrieve the cell pointer for the next string in the array.
//  judy_prv:   retrieve the cell pointer for the prev string in the array.
//  judy_del:   delete the key and cell for the current stack entry.

#include <memory.h>
#include <stdlib.h>

#ifdef linux
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define __USE_FILE_OFFSET64
#  include <endian.h>
#else
#  ifdef __BIG_ENDIAN__
#    ifndef BYTE_ORDER
#      define BYTE_ORDER 4321
#    endif
#  else
#    ifndef BYTE_ORDER
#      define BYTE_ORDER 1234
#    endif
#  endif
#  ifndef BIG_ENDIAN
#    define BIG_ENDIAN 4321
#  endif
#endif

#include "Judy.h"

#if defined(STANDALONE) || defined(ASKITIS)
#include <string.h>
#include <stdio.h>

extern unsigned int MaxMem;

// void judy_abort (char *msg) __attribute__ ((noreturn)); // Tell static analyser that this function will not return
void judy_abort( char * msg ) {
    fprintf( stderr, "%s\n", msg );
    exit( 1 );
}
#endif

int JudySize[] = {
    ( JUDY_slot_size * 16 ),                     // JUDY_radix node size
    ( JUDY_slot_size + JUDY_key_size ),          // JUDY_1 node size
    ( 2 * JUDY_slot_size + 2 * JUDY_key_size ),
    ( 4 * JUDY_slot_size + 4 * JUDY_key_size ),
    ( 8 * JUDY_slot_size + 8 * JUDY_key_size ),
    ( 16 * JUDY_slot_size + 16 * JUDY_key_size ),
    ( 32 * JUDY_slot_size + 32 * JUDY_key_size ),
#ifndef ASKITIS
    ( JUDY_span_bytes + JUDY_slot_size )
#else
    ( 64 * JUDY_slot_size + 64 * JUDY_key_size )
#endif
};

judyvalue JudyMask[9] = {
    0, 0xff, 0xffff, 0xffffff, 0xffffffff,
#if JUDY_key_size > 4
    0xffffffffffULL, 0xffffffffffffULL, 0xffffffffffffffULL, 0xffffffffffffffffULL
#endif
};

//    open judy object
//        call with max key size
//        and Integer tree depth.

Judy * judy_open( unsigned int max, unsigned int depth ) {
    JudySeg * seg;
    Judy * judy;
    unsigned int amt;

    max++;        // allow for zero terminator on keys

    if( ( seg = reinterpret_cast<JudySeg *>(new char[JUDY_seg]) ) ) {
        seg->seg = NULL;
        seg->next = JUDY_seg;
    } else {
#if defined(STANDALONE) || defined(ASKITIS)
        judy_abort( "No virtual memory" );
#else
        return NULL;
#endif
    }

    amt = sizeof( Judy ) + max * sizeof( JudyStack );

    if( amt & ( JUDY_cache_line - 1 ) ) {
        amt |= JUDY_cache_line - 1, amt++;
    }

#if defined(STANDALONE) || defined(ASKITIS)
    MaxMem += JUDY_seg;
#endif

    seg->next -= ( JudySlot )seg & ( JUDY_cache_line - 1 );
    seg->next -= amt;

    judy = ( Judy * )( ( unsigned char * )seg + seg->next );
    memset( judy, 0, amt );
    judy->depth = depth;
    judy->seg = seg;
    judy->max = max;
    return judy;
}

void judy_close( Judy * judy ) {
    JudySeg * seg, *nxt = judy->seg;

    while( ( seg = nxt ) ) {
        nxt =  reinterpret_cast<JudySeg *>(seg->seg), free( seg );
    }
}

//    allocate judy node

void * judy_alloc( Judy * judy, unsigned int type ) {
    unsigned int amt, idx, min;
    JudySeg * seg;
    void ** block;
    void ** rtn;

    if( !judy->seg )
#if defined(STANDALONE) || defined(ASKITIS)
        judy_abort( "illegal allocation from judy clone" );
#else
        return NULL;
#endif

    if( type == JUDY_radix ) {
        type = JUDY_radix_equiv;
    }

#ifndef ASKITIS
    if( type == JUDY_span ) {
        type = JUDY_span_equiv;
    }
#endif

    amt = JudySize[type];

    if( amt & 0x07 ) {
        amt |= 0x07, amt += 1;
    }

    //    see if free block is already available

    if( ( block = judy->reuse[type] ) ) {
        judy->reuse[type] = reinterpret_cast<void **>(*block);
        memset( block, 0, amt );
        return ( void * )block;
    }

    //    break down available larger block
    //    for reuse into smaller blocks

    if( type >= JUDY_1 )
        for( idx = type; idx++ < JUDY_max; )
            if( block = judy->reuse[idx] ) {
                judy->reuse[idx] = reinterpret_cast<void **>(*block);
                while( idx-- > type ) {
                    judy->reuse[idx] = block + JudySize[idx] / sizeof( void * );
                    block[JudySize[idx] / sizeof( void * )] = 0;
                }
                memset( block, 0, amt );
                return ( void * )block;
            }

    min = amt < JUDY_cache_line ? JUDY_cache_line : amt;

    if( judy->seg->next < min + sizeof( *seg ) ) {
        if( ( seg = reinterpret_cast<JudySeg *>(new char[JUDY_seg]) ) ) {
            seg->next = JUDY_seg;
            seg->seg = judy->seg;
            judy->seg = seg;
            seg->next -= ( JudySlot )seg & ( JUDY_cache_line - 1 );
        } else {
#if defined(STANDALONE) || defined(ASKITIS)
            judy_abort( "Out of virtual memory" );
#else
            return NULL;
#endif
        }

#if defined(STANDALONE) || defined(ASKITIS)
        MaxMem += JUDY_seg;
#endif
    }

    //    generate additional free blocks
    //    to fill up to cache line size

    rtn = ( void ** )( ( unsigned char * )judy->seg + judy->seg->next - amt );

    for( idx = type; amt & ( JUDY_cache_line - 1 ); amt <<= 1 ) {
        block = ( void ** )( ( unsigned char * )judy->seg + judy->seg->next - 2 * amt );
        judy->reuse[idx++] = block;
        *block = 0;
    }

    judy->seg->next -= amt;
    memset( rtn, 0, JudySize[type] );
    return ( void * )rtn;
}

void * judy_data( Judy * judy, unsigned int amt )

{
    JudySeg * seg;
    void * block;

    if( !judy->seg )
#if defined(STANDALONE) || defined(ASKITIS)
        judy_abort( "illegal allocation from judy clone" );
#else
        return NULL;
#endif

    if( amt & ( JUDY_cache_line - 1 ) ) {
        amt |= ( JUDY_cache_line - 1 ), amt += 1;
    }

    if( judy->seg->next < amt + sizeof( *seg ) ) {
        if( ( seg = reinterpret_cast<JudySeg *>(new char[JUDY_seg]) ) ) {
            seg->next = JUDY_seg;
            seg->seg = judy->seg;
            judy->seg = seg;
            seg->next -= ( JudySlot )seg & ( JUDY_cache_line - 1 );
        } else {
#if defined(STANDALONE) || defined(ASKITIS)
            judy_abort( "Out of virtual memory" );
#else
            return NULL;
#endif
        }

#if defined(STANDALONE) || defined(ASKITIS)
        MaxMem += JUDY_seg;
#endif
    }

    judy->seg->next -= amt;

    block = ( void * )( ( unsigned char * )judy->seg + judy->seg->next );
    memset( block, 0, amt );
    return block;
}

Judy * judy_clone( Judy * judy ) {
    Judy * clone;
    unsigned int amt;

    amt = sizeof( Judy ) + judy->max * sizeof( JudyStack );
    clone = reinterpret_cast<Judy *>(judy_data( judy, amt ));
    memcpy( clone, judy, amt );
    clone->seg = NULL;    // stop allocations from cloned array
    return clone;
}

void judy_free( Judy * judy, void * block, int type ) {
    if( type == JUDY_radix ) {
        type = JUDY_radix_equiv;
    }

#ifndef ASKITIS
    if( type == JUDY_span ) {
        type = JUDY_span_equiv;
    }
#endif

    *( ( void ** )( block ) ) = judy->reuse[type];
    judy->reuse[type] = ( void ** )block;
    return;
}

//    assemble key from current path

unsigned int judy_key( Judy * judy, unsigned char * buff, unsigned int max ) {
    judyvalue * dest = ( judyvalue * )buff;
    unsigned int len = 0, idx = 0, depth;
    int slot, off, type;
    judyvalue value;
    unsigned char * base;
    int keysize;

    if( judy->depth ) {
        max = judy->depth * JUDY_key_size;
    } else {
        max--;    // leave room for zero terminator
    }

    while( len < max && ++idx <= judy->level ) {
        type = judy->stack[idx].next & 0x07;
        slot = judy->stack[idx].slot;
        depth = len / JUDY_key_size;

        if( judy->depth )
            if( !( len & JUDY_key_mask ) ) {
                dest[depth] = 0;
            }

        switch( type ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                keysize = JUDY_key_size - ( judy->stack[idx].off & JUDY_key_mask );
                base = ( unsigned char * )( judy->stack[idx].next & JUDY_mask );

                if( judy->depth ) {
                    value = *( judyvalue * )( base + slot * keysize );
                    value &= JudyMask[keysize];
                    dest[depth++] |= value;
                    len += keysize;

                    if( depth < judy->depth ) {
                        continue;
                    }

                    return len;
                }

#if BYTE_ORDER != BIG_ENDIAN
                off = keysize;

                while( off-- && len < max )
                    if( buff[len] = base[slot * keysize + off] ) {
                        len++;
                    } else {
                        break;
                    }
#else
                for( off = 0; off < keysize && len < max; off++ )
                    if( buff[len] = base[slot * keysize + off] ) {
                        len++;
                    } else {
                        break;
                    }
#endif
                continue;

            case JUDY_radix:
                if( judy->depth ) {
                    dest[depth] |= ( judyvalue )slot << ( JUDY_key_size - ( ++len & JUDY_key_mask ) ) * 8;
                    if( !( len & JUDY_key_mask ) ) {
                        depth++;
                    }
                    if( depth < judy->depth ) {
                        continue;
                    }

                    return len;
                }

                if( !slot ) {
                    break;
                }
                buff[len++] = ( unsigned char )slot;
                continue;

#ifndef ASKITIS
            case JUDY_span:
                base = ( unsigned char * )( judy->stack[idx].next & JUDY_mask );

                for( slot = 0; slot < JUDY_span_bytes && base[slot]; slot++ )
                    if( len < max ) {
                        buff[len++] = base[slot];
                    }
                continue;
#endif
        }
    }
    buff[len] = 0;
    return len;
}

//    find slot & setup cursor

JudySlot * judy_slot( Judy * judy, const unsigned char * buff, unsigned int max ) {
    judyvalue * src = ( judyvalue * )buff;
    int slot, size, keysize, tst, cnt;
    JudySlot next = *judy->root;
    judyvalue value, test = 0;
    JudySlot * table;
    JudySlot * node;
    unsigned int depth = 0;
    unsigned int off = 0;
    unsigned char * base;

#ifndef ASKITIS
    judy->level = 0;
#endif

    while( next ) {
#ifndef ASKITIS
        if( judy->level < judy->max ) {
            judy->level++;
        }

        judy->stack[judy->level].next = next;
        judy->stack[judy->level].off = off;
#endif
        size = JudySize[next & 0x07];

        switch( next & 0x07 ) {

            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                base = ( unsigned char * )( next & JUDY_mask );
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                keysize = JUDY_key_size - ( off & JUDY_key_mask );
                cnt = size / ( sizeof( JudySlot ) + keysize );
                slot = cnt;
                value = 0;

                if( judy->depth ) {
                    value = src[depth++];
                    off |= JUDY_key_mask;
                    off++;
                    value &= JudyMask[keysize];
                } else
                    do {
                        value <<= 8;
                        if( off < max ) {
                            value |= buff[off];
                        }
                    } while( ++off & JUDY_key_mask );

                //  find slot > key

                while( slot-- ) {
                    test = *( judyvalue * )( base + slot * keysize );
#if BYTE_ORDER == BIG_ENDIAN
                    test >>= 8 * ( JUDY_key_size - keysize );
#else
                    test &= JudyMask[keysize];
#endif
                    if( test <= value ) {
                        break;
                    }
                }
#ifndef ASKITIS
                judy->stack[judy->level].slot = slot;
#endif
                if( test == value ) {

                    // is this a leaf?

                    if( !judy->depth && !( value & 0xFF ) || judy->depth && depth == judy->depth ) {
                        return &node[-slot - 1];
                    }

                    next = node[-slot - 1];
                    continue;
                }

                return NULL;

            case JUDY_radix:
                table = ( JudySlot * )( next & JUDY_mask ); // outer radix

                if( judy->depth ) {
                    slot = ( src[depth] >> ( ( JUDY_key_size - ++off & JUDY_key_mask ) * 8 ) ) & 0xff;
                } else if( off < max ) {
                    slot = buff[off++];
                } else {
                    slot = 0;
                }
#ifndef ASKITIS
                //    put radix slot on judy stack

                judy->stack[judy->level].slot = slot;
#endif
                if( ( next = table[slot >> 4] ) ) {
                    table = ( JudySlot * )( next & JUDY_mask );    // inner radix
                } else {
                    return NULL;
                }

                if( judy->depth )
                    if( !( off & JUDY_key_mask ) ) {
                        depth++;
                    }

                if( !judy->depth && !slot || judy->depth && depth == judy->depth )    // leaf?
                    if( table[slot & 0x0F] ) {  // occupied?
                        return &table[slot & 0x0F];
                    } else {
                        return NULL;
                    }

                next = table[slot & 0x0F];
                continue;

#ifndef ASKITIS
            case JUDY_span:
                node = ( JudySlot * )( ( next & JUDY_mask ) + JudySize[JUDY_span] );
                base = ( unsigned char * )( next & JUDY_mask );
                cnt = tst = JUDY_span_bytes;
                if( tst > ( int )( max - off ) ) {
                    tst = max - off;
                }
                value = strncmp( ( const char * )base, ( const char * )( buff + off ), tst );
                if( !value && tst < cnt && !base[tst] ) { // leaf?
                    return &node[-1];
                }

                if( !value && tst == cnt ) {
                    next = node[-1];
                    off += cnt;
                    continue;
                }
                return NULL;
#endif
        }
    }

    return NULL;
}

//    promote full nodes to next larger size

JudySlot * judy_promote( Judy * judy, JudySlot * next, int idx, judyvalue value, int keysize ) {
    unsigned char * base = ( unsigned char * )( *next & JUDY_mask );
    int oldcnt, newcnt, slot;
#if BYTE_ORDER == BIG_ENDIAN
    int i;
#endif
    JudySlot * newnode, *node;
    JudySlot * result;
    unsigned char * newbase;
    unsigned int type;

    type = ( *next & 0x07 ) + 1;
    node = ( JudySlot * )( ( *next & JUDY_mask ) + JudySize[type - 1] );
    oldcnt = JudySize[type - 1] / ( sizeof( JudySlot ) + keysize );
    newcnt = JudySize[type] / ( sizeof( JudySlot ) + keysize );

    // promote node to next larger size

    newbase = reinterpret_cast<unsigned char*>(judy_alloc( judy, type ));
    newnode = ( JudySlot * )( newbase + JudySize[type] );
    *next = ( JudySlot )newbase | type;

    //    open up slot at idx

    memcpy( newbase + ( newcnt - oldcnt - 1 ) * keysize, base, idx * keysize ); // copy keys

    for( slot = 0; slot < idx; slot++ ) {
        newnode[-( slot + newcnt - oldcnt )] = node[-( slot + 1 )];    // copy ptr
    }

    //    fill in new node

#if BYTE_ORDER != BIG_ENDIAN
    memcpy( newbase + ( idx + newcnt - oldcnt - 1 ) * keysize, &value, keysize ); // copy key
#else
    i = keysize;

    while( i-- ) {
        newbase[( idx + newcnt - oldcnt - 1 ) * keysize + i] = value, value >>= 8;
    }
#endif
    result = &newnode[-( idx + newcnt - oldcnt )];

    //    copy rest of old node

    memcpy( newbase + ( idx + newcnt - oldcnt ) * keysize, base + ( idx * keysize ), ( oldcnt - slot ) * keysize ); // copy keys

    for( ; slot < oldcnt; slot++ ) {
        newnode[-( slot + newcnt - oldcnt + 1 )] = node[-( slot + 1 )];    // copy ptr
    }

#ifndef ASKITIS
    judy->stack[judy->level].next = *next;
    judy->stack[judy->level].slot = idx + newcnt - oldcnt - 1;
#endif
    judy_free( judy, ( void ** )base, type - 1 );
    return result;
}

//    construct new node for JUDY_radix entry
//    make node with slot - start entries
//    moving key over one offset

void judy_radix( Judy * judy, JudySlot * radix, unsigned char * old, int start, int slot, int keysize, unsigned char key, unsigned int depth ) {
    int size, idx, cnt = slot - start, newcnt;
    JudySlot * node, *oldnode;
    unsigned int type = JUDY_1 - 1;
    JudySlot * table;
    unsigned char * base;

    //    if necessary, setup inner radix node

    if( !( table = ( JudySlot * )( radix[key >> 4] & JUDY_mask ) ) ) {
        table = reinterpret_cast<JudySlot *>(judy_alloc( judy, JUDY_radix ));
        radix[key >> 4] = ( JudySlot )table | JUDY_radix;
    }

    oldnode = ( JudySlot * )( old + JudySize[JUDY_max] );

    // is this slot a leaf?

    if( !judy->depth && ( !key || !keysize ) || judy->depth && !keysize && depth == judy->depth ) {
        table[key & 0x0F] = oldnode[-start - 1];
        return;
    }

    //    calculate new node big enough to contain slots

    do {
        type++;
        size = JudySize[type];
        newcnt = size / ( sizeof( JudySlot ) + keysize );
    } while( cnt > newcnt && type < JUDY_max );

    //    store new node pointer in inner table

    base = reinterpret_cast<unsigned char*>(judy_alloc( judy, type ));
    node = ( JudySlot * )( base + size );
    table[key & 0x0F] = ( JudySlot )base | type;

    //    allocate node and copy old contents
    //    shorten keys by 1 byte during copy

    for( idx = 0; idx < cnt; idx++ ) {
#if BYTE_ORDER != BIG_ENDIAN
        memcpy( base + ( newcnt - idx - 1 ) * keysize, old + ( start + cnt - idx - 1 ) * ( keysize + 1 ), keysize );
#else
        memcpy( base + ( newcnt - idx - 1 ) * keysize, old + ( start + cnt - idx - 1 ) * ( keysize + 1 ) + 1, keysize );
#endif
        node[-( newcnt - idx )] = oldnode[-( start + cnt - idx )];
    }
}

//    decompose full node to radix nodes

void judy_splitnode( Judy * judy, JudySlot * next, unsigned int size, unsigned int keysize, unsigned int depth ) {
    int cnt, slot, start = 0;
    unsigned int key = 0x0100, nxt;
    JudySlot * newradix;
    unsigned char * base;

    base = ( unsigned char * )( *next & JUDY_mask );
    cnt = size / ( sizeof( JudySlot ) + keysize );

    //    allocate outer judy_radix node

    newradix = reinterpret_cast<JudySlot *>(judy_alloc( judy, JUDY_radix ));
    *next = ( JudySlot )newradix | JUDY_radix;

    for( slot = 0; slot < cnt; slot++ ) {
#if BYTE_ORDER != BIG_ENDIAN
        nxt = base[slot * keysize + keysize - 1];
#else
        nxt = base[slot * keysize];
#endif

        if( key > 0xFF ) {
            key = nxt;
        }
        if( nxt == key ) {
            continue;
        }

        //    decompose portion of old node into radix nodes

        judy_radix( judy, newradix, base, start, slot, keysize - 1, ( unsigned char )key, depth );
        start = slot;
        key = nxt;
    }

    judy_radix( judy, newradix, base, start, slot, keysize - 1, ( unsigned char )key, depth );
    judy_free( judy, ( void ** )base, JUDY_max );
}

//    return first leaf

JudySlot * judy_first( Judy * judy, JudySlot next, unsigned int off, unsigned int depth ) {
    JudySlot * table, *inner;
    unsigned int keysize, size;
    JudySlot * node;
    int slot, cnt;
    unsigned char * base;

    while( next ) {
        if( judy->level < judy->max ) {
            judy->level++;
        }

        judy->stack[judy->level].off = off;
        judy->stack[judy->level].next = next;
        size = JudySize[next & 0x07];

        switch( next & 0x07 ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                keysize = JUDY_key_size - ( off & JUDY_key_mask );
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                base = ( unsigned char * )( next & JUDY_mask );
                cnt = size / ( sizeof( JudySlot ) + keysize );

                for( slot = 0; slot < cnt; slot++ )
                    if( node[-slot - 1] ) {
                        break;
                    }

                judy->stack[judy->level].slot = slot;
#if BYTE_ORDER != BIG_ENDIAN
                if( !judy->depth && !base[slot * keysize] || judy->depth && ++depth == judy->depth ) {
                    return &node[-slot - 1];
                }
#else
                if( !judy->depth && !base[slot * keysize + keysize - 1] || judy->depth && ++depth == judy->depth ) {
                    return &node[-slot - 1];
                }
#endif
                next = node[-slot - 1];
                off = ( off | JUDY_key_mask ) + 1;
                continue;
            case JUDY_radix:
                off++;

                if( judy->depth )
                    if( !( off & JUDY_key_mask ) ) {
                        depth++;
                    }

                table = ( JudySlot * )( next & JUDY_mask );
                for( slot = 0; slot < 256; slot++ )
                    if( ( inner = ( JudySlot * )( table[slot >> 4] & JUDY_mask ) ) ) {
                        if( ( next = inner[slot & 0x0F] ) ) {
                            judy->stack[judy->level].slot = slot;
                            if( !judy->depth && !slot || judy->depth && depth == judy->depth ) {
                                return &inner[slot & 0x0F];
                            } else {
                                break;
                            }
                        }
                    } else {
                        slot |= 0x0F;
                    }
                continue;
#ifndef ASKITIS
            case JUDY_span:
                node = ( JudySlot * )( ( next & JUDY_mask ) + JudySize[JUDY_span] );
                base = ( unsigned char * )( next & JUDY_mask );
                cnt = JUDY_span_bytes;
                if( !base[cnt - 1] ) {  // leaf node?
                    return &node[-1];
                }
                next = node[-1];
                off += cnt;
                continue;
#endif
        }
    }
    return NULL;
}

//    return last leaf cell pointer

JudySlot * judy_last( Judy * judy, JudySlot next, unsigned int off, unsigned int depth ) {
    JudySlot * table, *inner;
    unsigned int keysize, size;
    JudySlot * node;
    int slot, cnt;
    unsigned char * base;

    while( next ) {
        if( judy->level < judy->max ) {
            judy->level++;
        }

        judy->stack[judy->level].next = next;
        judy->stack[judy->level].off = off;
        size = JudySize[next & 0x07];
        switch( next & 0x07 ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                keysize = JUDY_key_size - ( off & JUDY_key_mask );
                slot = size / ( sizeof( JudySlot ) + keysize );
                base = ( unsigned char * )( next & JUDY_mask );
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                judy->stack[judy->level].slot = --slot;

#if BYTE_ORDER != BIG_ENDIAN
                if( !judy->depth && !base[slot * keysize] || judy->depth && ++depth == judy->depth )
#else
                if( !judy->depth && !base[slot * keysize + keysize - 1] || judy->depth && ++depth == judy->depth )
#endif
                    return &node[-slot - 1];

                next = node[-slot - 1];
                off += keysize;
                continue;

            case JUDY_radix:
                table = ( JudySlot * )( next & JUDY_mask );
                off++;

                if( judy->depth )
                    if( !( off & JUDY_key_mask ) ) {
                        depth++;
                    }

                for( slot = 256; slot--; ) {
                    judy->stack[judy->level].slot = slot;
                    if( ( inner = ( JudySlot * )( table[slot >> 4] & JUDY_mask ) ) ) {
                        if( ( next = inner[slot & 0x0F] ) )
                            if( !judy->depth && !slot || judy->depth && depth == judy->depth ) {
                                return &inner[0];
                            } else {
                                break;
                            }
                    } else {
                        slot &= 0xF0;
                    }
                }
                continue;

#ifndef ASKITIS
            case JUDY_span:
                node = ( JudySlot * )( ( next & JUDY_mask ) + JudySize[JUDY_span] );
                base = ( unsigned char * )( next & JUDY_mask );
                cnt = JUDY_span_bytes;
                if( !base[cnt - 1] ) {  // leaf node?
                    return &node[-1];
                }
                next = node[-1];
                off += cnt;
                continue;
#endif
        }
    }
    return NULL;
}

//    judy_end: return last entry

JudySlot * judy_end( Judy * judy ) {
    judy->level = 0;
    return judy_last( judy, *judy->root, 0, 0 );
}

//    judy_nxt: return next entry
JudySlot * judy_nxt( Judy * judy ) {
    JudySlot * table, *inner;
    int slot, size, cnt;
    JudySlot * node;
    JudySlot next;
    unsigned int keysize;
    unsigned char * base;
    unsigned int depth;
    unsigned int off;

    if( !judy->level ) {
        return judy_first( judy, *judy->root, 0, 0 );
    }

    while( judy->level ) {
        next = judy->stack[judy->level].next;
        slot = judy->stack[judy->level].slot;
        off = judy->stack[judy->level].off;
        keysize = JUDY_key_size - ( off & JUDY_key_mask );
        size = JudySize[next & 0x07];
        depth = off / JUDY_key_size;

        switch( next & 0x07 ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                cnt = size / ( sizeof( JudySlot ) + keysize );
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                base = ( unsigned char * )( next & JUDY_mask );
                if( ++slot < cnt )
#if BYTE_ORDER != BIG_ENDIAN
                    if( !judy->depth && !base[slot * keysize] || judy->depth && ++depth == judy->depth )
#else
                    if( !judy->depth && !base[slot * keysize + keysize - 1] || judy->depth && ++depth == judy->depth )
#endif
                    {
                        judy->stack[judy->level].slot = slot;
                        return &node[-slot - 1];
                    } else {
                        judy->stack[judy->level].slot = slot;
                        return judy_first( judy, node[-slot - 1], ( off | JUDY_key_mask ) + 1, depth );
                    }
                judy->level--;
                continue;

            case JUDY_radix:
                table = ( JudySlot * )( next & JUDY_mask );

                if( judy->depth )
                    if( !( ( off + 1 ) & JUDY_key_mask ) ) {
                        depth++;
                    }

                while( ++slot < 256 )
                    if( ( inner = ( JudySlot * )( table[slot >> 4] & JUDY_mask ) ) ) {
                        if( inner[slot & 0x0F] ) {
                            judy->stack[judy->level].slot = slot;
                            if( !judy->depth || depth < judy->depth ) {
                                return judy_first( judy, inner[slot & 0x0F], off + 1, depth );
                            }
                            return &inner[slot & 0x0F];
                        }
                    } else {
                        slot |= 0x0F;
                    }

                judy->level--;
                continue;
#ifndef ASKITIS
            case JUDY_span:
                judy->level--;
                continue;
#endif
        }
    }
    return NULL;
}

//    judy_prv: return ptr to previous entry

JudySlot * judy_prv( Judy * judy ) {
    int slot, size, keysize;
    JudySlot * table, *inner;
    JudySlot * node, next;
    unsigned char * base;
    unsigned int depth;
    unsigned int off;

    if( !judy->level ) {
        return judy_last( judy, *judy->root, 0, 0 );
    }

    while( judy->level ) {
        next = judy->stack[judy->level].next;
        slot = judy->stack[judy->level].slot;
        off = judy->stack[judy->level].off;
        size = JudySize[next & 0x07];
        depth = off / JUDY_key_size;

        switch( next & 0x07 ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                if( !slot || !node[-slot] ) {
                    judy->level--;
                    continue;
                }

                base = ( unsigned char * )( next & JUDY_mask );
                judy->stack[judy->level].slot--;
                keysize = JUDY_key_size - ( off & JUDY_key_mask );

#if BYTE_ORDER != BIG_ENDIAN
                if( !judy->depth && !base[( slot - 1 ) * keysize] || judy->depth && ++depth == judy->depth )
#else
                if( !judy->depth && !base[( slot - 1 ) * keysize + keysize - 1] || judy->depth && ++depth == judy->depth )
#endif
                    return &node[-slot];
                return judy_last( judy, node[-slot], ( off | JUDY_key_mask ) + 1, depth );

            case JUDY_radix:
                table = ( JudySlot * )( next & JUDY_mask );

                if( judy->depth )
                    if( !( ( off + 1 ) & JUDY_key_mask ) ) {
                        depth++;
                    }

                while( slot-- ) {
                    judy->stack[judy->level].slot--;
                    if( ( inner = ( JudySlot * )( table[slot >> 4] & JUDY_mask ) ) )
                        if( inner[slot & 0x0F] )
                            if( !judy->depth && !slot || judy->depth && depth == judy->depth ) {
                                return &inner[0];
                            } else {
                                return judy_last( judy, inner[slot & 0x0F], off + 1, depth );
                            }
                }

                judy->level--;
                continue;

#ifndef ASKITIS
            case JUDY_span:
                judy->level--;
                continue;
#endif
        }
    }
    return NULL;
}

//    judy_del: delete string from judy array
//        returning previous entry.

JudySlot * judy_del( Judy * judy ) {
    int slot, off, size, type, high;
    JudySlot * table, *inner;
    JudySlot next, *node;
    int keysize, cnt;
    unsigned char * base;

    while( judy->level ) {
        next = judy->stack[judy->level].next;
        slot = judy->stack[judy->level].slot;
        off = judy->stack[judy->level].off;
        size = JudySize[next & 0x07];

        switch( type = next & 0x07 ) {
            case JUDY_1:
            case JUDY_2:
            case JUDY_4:
            case JUDY_8:
            case JUDY_16:
            case JUDY_32:
#ifdef ASKITIS
            case JUDY_64:
#endif
                keysize = JUDY_key_size - ( off & JUDY_key_mask );
                cnt = size / ( sizeof( JudySlot ) + keysize );
                node = ( JudySlot * )( ( next & JUDY_mask ) + size );
                base = ( unsigned char * )( next & JUDY_mask );

                //    move deleted slot to first slot

                while( slot ) {
                    node[-slot - 1] = node[-slot];
                    memcpy( base + slot * keysize, base + ( slot - 1 ) * keysize, keysize );
                    slot--;
                }

                //    zero out first slot

                node[-1] = 0;
                memset( base, 0, keysize );

                if( node[-cnt] ) {    // does node have any slots left?
                    judy->stack[judy->level].slot++;
                    return judy_prv( judy );
                }

                judy_free( judy, base, type );
                judy->level--;
                continue;

            case JUDY_radix:
                table = ( JudySlot * )( next & JUDY_mask );
                inner = ( JudySlot * )( table[slot >> 4] & JUDY_mask );
                inner[slot & 0x0F] = 0;
                high = slot & 0xF0;

                for( cnt = 16; cnt--; )
                    if( inner[cnt] ) {
                        return judy_prv( judy );
                    }

                judy_free( judy, inner, JUDY_radix );
                table[slot >> 4] = 0;

                for( cnt = 16; cnt--; )
                    if( table[cnt] ) {
                        return judy_prv( judy );
                    }

                judy_free( judy, table, JUDY_radix );
                judy->level--;
                continue;

#ifndef ASKITIS
            case JUDY_span:
                base = ( unsigned char * )( next & JUDY_mask );
                judy_free( judy, base, type );
                judy->level--;
                continue;
#endif
        }
    }

    //    tree is now empty

    *judy->root = 0;
    return NULL;
}

//    return cell for first key greater than or equal to given key

JudySlot * judy_strt( Judy * judy, const unsigned char * buff, unsigned int max ) {
    JudySlot * cell;

    judy->level = 0;

    if( !max ) {
        return judy_first( judy, *judy->root, 0, 0 );
    }

    if( ( cell = judy_slot( judy, buff, max ) ) ) {
        return cell;
    }

    return judy_nxt( judy );
}

//    split open span node

#ifndef ASKITIS
void judy_splitspan( Judy * judy, JudySlot * next, unsigned char * base ) {
    JudySlot * node = ( JudySlot * )( base + JudySize[JUDY_span] );
    unsigned int cnt = JUDY_span_bytes;
    unsigned char * newbase;
    unsigned int off = 0;
#if BYTE_ORDER != BIG_ENDIAN
    int i;
#endif

    do {
        newbase = reinterpret_cast<unsigned char *>(judy_alloc( judy, JUDY_1 ));
        *next = ( JudySlot )newbase | JUDY_1;

#if BYTE_ORDER != BIG_ENDIAN
        i = JUDY_key_size;
        while( i-- ) {
            *newbase++ = base[off + i];
        }
#else
        memcpy( newbase, base + off, JUDY_key_size );
        newbase += JUDY_key_size;
#endif
        next = ( JudySlot * )newbase;

        off += JUDY_key_size;
        cnt -= JUDY_key_size;
    } while( cnt && base[off - 1] );

    *next = node[-1];
    judy_free( judy, base, JUDY_span );
}
#endif

//    judy_cell: add string to judy array

JudySlot * judy_cell( Judy * judy, const unsigned char * buff, unsigned int max ) {
    judyvalue * src = ( judyvalue * )buff;
    int size, idx, slot, cnt, tst;
    JudySlot * next = judy->root;
    judyvalue test, value;
    unsigned int off = 0, start;
    JudySlot * table;
    JudySlot * node;
    unsigned int depth = 0;
    unsigned int keysize;
    unsigned char * base;

    judy->level = 0;
#ifdef ASKITIS
    Words++;
#endif

    while( *next ) {
#ifndef ASKITIS
        if( judy->level < judy->max ) {
            judy->level++;
        }

        judy->stack[judy->level].next = *next;
        judy->stack[judy->level].off = off;
#endif
        switch( *next & 0x07 ) {
            default:
                size = JudySize[*next & 0x07];
                keysize = JUDY_key_size - ( off & JUDY_key_mask );
                cnt = size / ( sizeof( JudySlot ) + keysize );
                base = ( unsigned char * )( *next & JUDY_mask );
                node = ( JudySlot * )( ( *next & JUDY_mask ) + size );
                start = off;
                slot = cnt;
                value = 0;

                if( judy->depth ) {
                    value = src[depth++];
                    off |= JUDY_key_mask;
                    off++;
                    value &= JudyMask[keysize];
                } else
                    do {
                        value <<= 8;
                        if( off < max ) {
                            value |= buff[off];
                        }
                    } while( ++off & JUDY_key_mask );

                //  find slot > key

                while( slot-- ) {
                    test = *( judyvalue * )( base + slot * keysize );
#if BYTE_ORDER == BIG_ENDIAN
                    test >>= 8 * ( JUDY_key_size - keysize );
#else
                    test &= JudyMask[keysize];
#endif
                    if( test <= value ) {
                        break;
                    }
                }
#ifndef ASKITIS
                judy->stack[judy->level].slot = slot;
#endif
                if( test == value ) {        // new key is equal to slot key
                    next = &node[-slot - 1];

                    // is this a leaf?

                    if( !judy->depth && !( value & 0xFF ) || judy->depth && depth == judy->depth ) {
#ifdef ASKITIS
                        if( *next ) {
                            Found++;
                        } else {
                            Inserts++;
                        }
#endif
                        return next;
                    }

                    continue;
                }

                //    if this node is not full
                //    open up cell after slot

                if( !node[-1] ) {
                    memmove( base, base + keysize, slot * keysize );  // move keys less than new key down one slot
#if BYTE_ORDER != BIG_ENDIAN
                    memcpy( base + slot * keysize, &value, keysize );  // copy new key into slot
#else
                    test = value;
                    idx = keysize;

                    while( idx-- ) {
                        base[slot * keysize + idx] = test, test >>= 8;
                    }
#endif
                    for( idx = 0; idx < slot; idx++ ) {
                        node[-idx - 1] = node[-idx - 2];    // copy tree ptrs/cells down one slot
                    }

                    node[-slot - 1] = 0;          // set new tree ptr/cell
                    next = &node[-slot - 1];

                    if( !judy->depth && !( value & 0xFF ) || judy->depth && depth == judy->depth ) {
#ifdef ASKITIS
                        if( *next ) {
                            Found++;
                        } else {
                            Inserts++;
                        }
#endif
                        return next;
                    }

                    continue;
                }

                if( size < JudySize[JUDY_max] ) {
                    next = judy_promote( judy, next, slot + 1, value, keysize );

                    if( !judy->depth && !( value & 0xFF ) || judy->depth && depth == judy->depth ) {
#ifdef ASKITIS
                        if( *next ) {
                            Found++;
                        } else {
                            Inserts++;
                        }
#endif
                        return next;
                    }

                    continue;
                }

                //    split full maximal node into JUDY_radix nodes
                //  loop to reprocess new insert

                judy_splitnode( judy, next, size, keysize, depth );
#ifndef ASKITIS
                judy->level--;
#endif
                off = start;
                if( judy->depth ) {
                    depth--;
                }
                continue;

            case JUDY_radix:
                table = ( JudySlot * )( *next & JUDY_mask ); // outer radix

                if( judy->depth ) {
                    slot = ( src[depth] >> ( ( JUDY_key_size - ++off & JUDY_key_mask ) * 8 ) ) & 0xff;
                } else if( off < max ) {
                    slot = buff[off++];
                } else {
                    slot = 0, off++;
                }

                if( judy->depth )
                    if( !( off & JUDY_key_mask ) ) {
                        depth++;
                    }

                // allocate inner radix if empty

                if( !table[slot >> 4] ) {
                    table[slot >> 4] = ( JudySlot )judy_alloc( judy, JUDY_radix ) | JUDY_radix;
                }

                table = ( JudySlot * )( table[slot >> 4] & JUDY_mask );
#ifndef ASKITIS
                judy->stack[judy->level].slot = slot;
#endif
                next = &table[slot & 0x0F];

                if( !judy->depth && !slot || judy->depth && depth == judy->depth ) { // leaf?
#ifdef ASKITIS
                    if( *next ) {
                        Found++;
                    } else {
                        Inserts++;
                    }
#endif
                    return next;
                }

                continue;

#ifndef ASKITIS
            case JUDY_span:
                base = ( unsigned char * )( *next & JUDY_mask );
                node = ( JudySlot * )( ( *next & JUDY_mask ) + JudySize[JUDY_span] );
                cnt = JUDY_span_bytes;
                tst = cnt;

                if( tst > ( int )( max - off ) ) {
                    tst = max - off;
                }

                value = strncmp( ( const char * )base, ( const char * )( buff + off ), tst );

                if( !value && tst < cnt && !base[tst] ) { // leaf?
                    return &node[-1];
                }

                if( !value && tst == cnt ) {
                    next = &node[-1];
                    off += cnt;
                    continue;
                }

                //    bust up JUDY_span node and produce JUDY_1 nodes
                //    then loop to reprocess insert

                judy_splitspan( judy, next, base );
                judy->level--;
                continue;
#endif
        }
    }

    // place JUDY_1 node under JUDY_radix node(s)

#ifndef ASKITIS
    if( off & JUDY_key_mask )
        if( judy->depth || off <= max ) {
#else
    while( off <= max ) {
#endif
            base = reinterpret_cast<unsigned char *>(judy_alloc( judy, JUDY_1 ));
            keysize = JUDY_key_size - ( off & JUDY_key_mask );
            node = ( JudySlot * )( base + JudySize[JUDY_1] );
            *next = ( JudySlot )base | JUDY_1;

            //    fill in slot 0 with bytes of key

            if( judy->depth ) {
                value = src[depth];
#if BYTE_ORDER != BIG_ENDIAN
                memcpy( base, &value, keysize );  // copy new key into slot
#else
                while( keysize-- ) {
                    base[keysize] = value, value >>= 8;
                }
#endif
            } else {
#if BYTE_ORDER != BIG_ENDIAN
                while( keysize )
                    if( off + keysize <= max ) {
                        *base++ = buff[off + --keysize];
                    } else {
                        base++, --keysize;
                    }
#else
                tst = keysize;

                if( tst > ( int )( max - off ) ) {
                    tst = max - off;
                }

                memcpy( base, buff + off, tst );
#endif
            }
#ifndef ASKITIS
            if( judy->level < judy->max ) {
                judy->level++;
            }
            judy->stack[judy->level].next = *next;
            judy->stack[judy->level].slot = 0;
            judy->stack[judy->level].off = off;
#endif
            next = &node[-1];

            off |= JUDY_key_mask;
            depth++;
            off++;
        }

    //    produce span nodes to consume rest of key
    //  or judy_1 nodes if not string tree

#ifndef ASKITIS
    if( !judy->depth )
        while( off <= max ) {
            base = reinterpret_cast<unsigned char *>(judy_alloc( judy, JUDY_span ));
            *next = ( JudySlot )base | JUDY_span;
            node = ( JudySlot * )( base + JudySize[JUDY_span] );
            cnt = tst = JUDY_span_bytes;
            if( tst > ( int )( max - off ) ) {
                tst = max - off;
            }
            memcpy( base, buff + off, tst );

            if( judy->level < judy->max ) {
                judy->level++;
            }
            judy->stack[judy->level].next = *next;
            judy->stack[judy->level].slot = 0;
            judy->stack[judy->level].off = off;
            next = &node[-1];
            off += tst;
            depth++;

            if( !base[cnt - 1] ) { // done on leaf
                break;
            }
        }
    else
        while( depth < judy->depth ) {
            base = reinterpret_cast<unsigned char *>(judy_alloc( judy, JUDY_1 ));
            node = ( JudySlot * )( base + JudySize[JUDY_1] );
            *next = ( JudySlot )base | JUDY_1;

            //    fill in slot 0 with bytes of key

            *( judyvalue * )base = src[depth];

            if( judy->level < judy->max ) {
                judy->level++;
            }
            judy->stack[judy->level].next = *next;
            judy->stack[judy->level].slot = 0;
            judy->stack[judy->level].off = off;
            next = &node[-1];
            off |= JUDY_key_mask;
            depth++;
            off++;
        }
#endif

#ifdef ASKITIS
    Inserts++;
#endif
    return next;
}

**************FILE************ ./source/0.9.0.0/infra/utils
**************FILE************ ./source/0.9.0.0/infra/utils/StringUtils.cpp
#include <boost/tokenizer.hpp>
#include "infra/utils/StringUtils.h"

using namespace infra;
/**
 * Used by
 * saperating playback files in FeedHandler.cpp
 */
extern "C" std::vector<std::string> tokenize(std::string str, const char *delimeters)
{
	std::vector<std::string> result;
	typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
	boost::char_separator<char> sep(delimeters);
	tokenizer tokens(str, sep);
	auto tok_iter = tokens.begin();
	while(tok_iter != tokens.end())
	{
		result.push_back(*tok_iter);
		++tok_iter;
	}
	return result;
}
**************FILE************ ./source/0.9.0.0/infra/utils/StringUtils.h
#ifndef __STRING_UTILS_H__
#define __STRING_UTILS_H__

#include <vector>
#include <string>

namespace infra 
{
	extern "C" std::vector<std::string> tokenize(std::string , const char *);
}
#endif//__STRING_UTILS_H__
**************FILE************ ./source/0.9.0.0/infra/gzstream
**************FILE************ ./source/0.9.0.0/infra/gzstream/read.txt
love you too much Sonal. You are mine kitten ... thanks for making my life beautiful
**************FILE************ ./source/0.9.0.0/infra/gzstream/gzstream.cpp
// ============================================================================
// gzstream, C++ iostream classes wrapping the zlib compression library.
// Copyright (C) 2001  Deepak Bandyopadhyay, Lutz Kettner
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// ============================================================================
//
// File          : gzstream.C
// Revision      : $Revision: 1.7 $
// Revision_date : $Date: 2003/01/08 14:41:27 $
// Author(s)     : Deepak Bandyopadhyay, Lutz Kettner
// 
// Standard streambuf implementation following Nicolai Josuttis, "The 
// Standard C++ Library".
// ============================================================================

#include "infra/gzstream/gzstream.h"
#include <iostream>
#include <string.h>  // for memcpy

namespace infra {

// ----------------------------------------------------------------------------
// Internal classes to implement gzstream. See header file for user classes.
// ----------------------------------------------------------------------------

// --------------------------------------
// class gzstreambuf:
// --------------------------------------

gzstreambuf* gzstreambuf::open( const char* name, int open_mode) {
    if ( is_open())
        return (gzstreambuf*)0;
    mode = open_mode;
    // no append nor read/write mode
    if ((mode & std::ios::ate) || (mode & std::ios::app)
        || ((mode & std::ios::in) && (mode & std::ios::out)))
        return (gzstreambuf*)0;
    char  fmode[10];
    char* fmodeptr = fmode;
    if ( mode & std::ios::in)
        *fmodeptr++ = 'r';
    else if ( mode & std::ios::out)
        *fmodeptr++ = 'w';
    *fmodeptr++ = 'b';
    *fmodeptr = '\0';
    file = gzopen( name, fmode);
    if (file == 0)
        return (gzstreambuf*)0;
    opened = 1;
    return this;
}

gzstreambuf * gzstreambuf::close() {
    if ( is_open()) {
        sync();
        opened = 0;
        if ( gzclose( file) == Z_OK)
            return this;
    }
    return (gzstreambuf*)0;
}

int gzstreambuf::underflow() { // used for input buffer only
    if ( gptr() && ( gptr() < egptr()))
        return * reinterpret_cast<unsigned char *>( gptr());

    if ( ! (mode & std::ios::in) || ! opened)
        return EOF;
    // Josuttis' implementation of inbuf
    int n_putback = gptr() - eback();
    if ( n_putback > 4)
        n_putback = 4;
    memcpy( buffer + (4 - n_putback), gptr() - n_putback, n_putback);

    int num = gzread( file, buffer+4, bufferSize-4);
    if (num <= 0) // ERROR or EOF
        return EOF;

    // reset buffer pointers
    setg( buffer + (4 - n_putback),   // beginning of putback area
          buffer + 4,                 // read position
          buffer + 4 + num);          // end of buffer

    // return next character
    return * reinterpret_cast<unsigned char *>( gptr());    
}

int gzstreambuf::flush_buffer() {
    // Separate the writing of the buffer from overflow() and
    // sync() operation.
    int w = pptr() - pbase();
    if ( gzwrite( file, pbase(), w) != w)
        return EOF;
    pbump( -w);
    return w;
}

int gzstreambuf::overflow( int c) { // used for output buffer only
    if ( ! ( mode & std::ios::out) || ! opened)
        return EOF;
    if (c != EOF) {
        *pptr() = c;
        pbump(1);
    }
    if ( flush_buffer() == EOF)
        return EOF;
    return c;
}

int gzstreambuf::sync() {
    // Changed to use flush_buffer() instead of overflow( EOF)
    // which caused improper behavior with std::endl and flush(),
    // bug reported by Vincent Ricard.
    if ( pptr() && pptr() > pbase()) {
        if ( flush_buffer() == EOF)
            return -1;
    }
    return 0;
}

// --------------------------------------
// class gzstreambase:
// --------------------------------------

gzstreambase::gzstreambase( const char* name, int mode) {
    init( &buf);
    open( name, mode);
}

gzstreambase::~gzstreambase() {
    buf.close();
}

void gzstreambase::open( const char* name, int open_mode) {
    if ( ! buf.open( name, open_mode))
        clear( rdstate() | std::ios::badbit);
}

void gzstreambase::close() {
    if ( buf.is_open())
        if ( ! buf.close())
            clear( rdstate() | std::ios::badbit);
}

} // namespace infra 

// ============================================================================
// EOF //
**************FILE************ ./source/0.9.0.0/infra/gzstream/README

                              gzstream
      C++ iostream classes wrapping the zlib compression library.
===========================================================================

    See index.html for documentation and installation instructions.
**************FILE************ ./source/0.9.0.0/infra/gzstream/gzstream.tgz
 8> }\Yu۬9vagPgFJBQ/hWkN}Z^QK$8`ĩ:.L@`_F.&[$|pX\I1Zis{^RDkL/-gK'კÇG?;0>z?h@ċp.$	d}_(܊-.-LqX+'gK疊.320c91-Qۋ:bv]1:_'bhr?1KjERL%0MNJޥ-eՐbUdN,Dќ8	>]btؾB,\Q\Q'cђQOYI(* @~2,/}"\IlRTJ)$'`Խ5'8}&k4uYͻO._RbՏDD!_Sx饘q,#10_;H gە
#_2@93ˠ"]zBeX)\8<:drCAevUX	>!S_w>\:#w6NɄ*8vxȋz+3kzyTyKZLb޷4ҸzCpH4
PƢ')29žj5z)ݸ%+>QX-r 
kй!~CzbB*clv+^>B&uH HRk кĕK 'aTXьP9	3 j!nnȭx2l[/m00@ⴋ. wd=_!`+2[aMM60ϹȺ@Dͷ;ڸmX֘,ҴDK0Ő"	p
*[JgcɊpvTtx5(ԃ1p֣8Fd
< B`, 3:܊Z5c4l
7e5J5z$)
qDVbR1U -FVYa_uB2 #x)H3z
"$sy\$^ܽTJBFh-/?Y:ҩ+D=)Kj ImU/E5\f'ip"00*aZQE0scpد~X^Yǧ`eRSĄ"9>4P":]zv3^ 5^0v#ٽ`4-.7
wyj m
  tPsICd\iEr0g3fH kfI%=z/NdK4PQ146gR1v*.qh?WA)uzݯc>Y.YA1Y٤'͹҃-F$%IDZ_fO	@c#Tt	 bd	4DC
;وYxUFڍ*nhdX`ׁW&S̷.kܻbXNXY8Os$(`b&gY`Da]A@+Q"NζH+Ľ	[IX^#A7*U[lQj/G`$|в PFAF{ƃJ^D=l4f
:TKVP4ژ]5)شbf	,@d]AO	jjXAѮV
S-T	,>Ud<uugjO{VSiA,BB'r&`*kubBNf4 _u_
c0ؗ/R3E`WJd(mh 3q@eIM8 i	0ٓL<H@pyDa#2Rlt{U  ,]8+?Jg+ Y_Z^/Dt"<VEVmJȢE8hW)(ˊ[p8QR1Z4(P=}dP.
5HVp1E *zT	SEܓɍ%AK
(~jD#)ާQD}	@FtX&!]&DBz)bAHP7u풂ʆNJ}΀YþU&: Xjl01|I֫  xvM`G0yÓQk()=QUȐXDa}<%V.;!iPCѱvc!5wSD'dYc Q
 ʲ^6VU`6+L"Gp-2(wQZ/HZMmakx;HPEA:o$%)e!Y?h_9#ڵOϝĘapjKK2 <f{W$wc~][$
]u$B]sP"0IQ;`WK
1uw`Ҷx C00! Li9*F[!+Ƃٳ	Zh(pmmT(h.pQgB	Oe;Vv)JQ2fFMJmٶJqHe?v4o.. %QsSܒ_*	S*M&hmIM`kZD62
P b@9Y:7ja^۷&=aI%+Ւ:UEc LȪؙ8bZ LݢGNU$7u<Afr1h)=l(UVhTHU/ eEfR>D#eI(2bt?N1"GfEZnt2VYaAŻ98 <Ne(Pa{ӝRDB-4B+)E5ZRUtU=
#}p>y^ldDF8 Հ*!6XAS ) SL foQ>FP_Š`~tp)*ϨMX4c|4c*ܕ+[4x&fǕi%Wotnz}!{qtN
U8;4O+'<Ja!8&Gp|4GM
9V*vz*!jc $̧GZk'1f\ȃ٥rE*c"]צYAYjfavQO('Rup-F23+pHP~2'G]#4j1j3Cg:Fu196Ís]+vg2*(/TN)~5fULt؎(lEHIT\STAZ,ԪMM6u eD~L93$؀?YlTyXqon:u=VL\;m# L`UQQxQCGyR|2bmZU"r uJ'*MSƢURRIMm5BgJB(qnV*]KjwcW">NӔJ.biG] 3吱YmB6VoepHy13pcQDIsPHDN
iURE`Tpgk:WE*
B6ǩ"F&zBu3Y@^s4Yf1iJ%ЂSmI`.L"OSpl4AT"Y(M)ZxL#:8aƄ.W)`9FȹBO-4ڡ9-e,
{*ra4 QiGd\4YVuC8u<ڬHڇT:0=XQf!82>2j(ЭUAټR3óaR
:3dcSMX1_Jl-`Gu~msUAS J3C:4bUv4M4SV@!!3S=NaIq*&zy-I`vò0"uѝC `	RsMƊilItHːk}bÀQ⮥ho7 *ʹCNf`NE],{XVCZrӔs
㰐s-SʠM&@RzabCu4\*XsV9BJcǐȲEpɸ3yF(C{IyL1Tבy.xGtCUBCkY+X@aOXjOA>=A! `X&'A?SRdAǮ? Ԯ)F,L˶>JcʉSSr*0/a4͛wk̎+tdW.\ b0huR\p.1e([9M5hV[~X)lnP*SXd~ڛ*ZeE@n+#s&hhZ؋ )R)5VMJgSLT;-9Z,qm(+Qj'ckf|OYfhͬݔ*-]%srwsb1Fsv*22|%014>UR?_DZz@yg)lzbuYaзѦh%w5A~ƪhqA<y
5ALfbLNIdEdďW}6kƇ]tI^VJk$-$(dIݤ%&h3=B^*	*#(8Q3O:bxw.WaC]u0LjIL*Ί躎A[40wkӯ*ƈÜ:pNTʧ׫+lͻZtT&;1o7ڝbQI;>izTOЅouJXjB>c۲A82ܝ!On}ݢW[@>Uh/M6<:e+\b1y(L;G4<\O	hJ^6UxZr<+(>Q&4L+I:NUwnT"nRëDal} !t3*UԒq3Av%&4@VZ}Ŕj24@,ڢK;jqܣ8C5 "sǽXxoNٖwʻr-8Nm$jy䎢*(
fq{4@I)Y-X*k|݋J	~eJb`o#isV49r^JO0:=.&Vzt!n#uhc8`3,ktͮ7E(4*Mdj}pDݜ7\lDQ1neRaI"Arm߈)`uTx2'nvDy}A&uSA"mjW&-wҔDAY'w2{g눱NЍu6Pm[0LY^1X,,냂BtT+ݺ̠g<֥Ia;51A[eWUFw	9)Hv	L*ӕJ")4ͅ<l1;ih6hPacElZV2nlhJ܄735&jL4f9ցx)NcJmسߔ*d7s9`Ců
GDC$tC$cz;IKMj2]D̃A4N͏UnJ#iP0K,1)ǥgz8ݾ,W-Ny,`q'[PSF:@*	N0jV
	WF:Mvs29ξ) %nYPpok)b
t9Xx2BTqG5(H''"^ѣ 
V$[ϛMKleNq&K	FM54n$Y$kykcTeR97C4## n {cCXwJ	rESޣ	: 0.Uߩ.\1tI
S?dfkV6Ï32nmPMf.c܏P@2AlWhf=Hu޵.Y p+Uxp!c<O݈.~alidFYp:l撌!}>.
5;
8TؔbmOkq!wz1)mU&BO5|Rmm8ht)Qu=j)Po(gR=Ȝ[j?SꞦk4I黌7gvPCNfwRovIw&ou ԃ׾bÏȄlaopK{9r
(RNLdir4n *ֳ7:)h$g PV3^!$ak^}EdymL諘xxe{A4ZJ	 -l7r@ -;gD !#mJ
 &ByD5|h|U|>f0iY%!JS{5,{d!<OIܓ4=oe?1AUӇB'[Tp"HtRU۪a% CZ*_WgGtClwUv].!'wʩ`l2~],?u>zpד+;AĬ6^//2"or3l3ЎPt9AvW](8`NW(nT%f*:/ܨ4qTW+ccyr_ɯ۪@i8߮ȘV-w"p`e.!t˃b ۖpεrńK$!.wTt 7w+ڢƟ%xȭx]v!5>Ϧ]]MiTѪk乬LMA"P`D^zzLeQzTM۰G%ݷRUӕNC(-5Kx$
CB@%L@ߒzD:o$eT5$JLyY<3kt;ee}rV.[1%נҹb͆˺5R.oTLTB4}}JhJaoj[*Y}B݄JrxxuLy,,֩tͶ7XǺQ5\@Bi"mMVK[Q^Jxk^DTe_\WS;.ϡf&@X[eUhSF}e.Эӑj0UC<: :3=T) SĠ҆,)YF%YJP\%2AqVYG<m?JwF5Jغ{wsu;"r'MMу*2:NzTAWUr
wMb U|~fJk*Ăl%$HLPSǗ7(e"%G;vyY&ͪ	?!0pĕ&2 b7UWGU.J5Rsy*xٶ$aųHt<
zU--w)Ȅ L`5x@7tA7r
+Qu70=62dr~UIQaxviػ*[-Y]JӪe`hPk5`.u8L<Юm+P`r#.h,Y瞷'[7<^Wxɢ"R M}=o4l~kQZA{ϥ<5{%| Fu'?dV[fḩ~2N0z30ϰc4lJd	Ǧ.{4WSX08X),e:`[iFI*Qx[TyRj3<7//,.ϒ8;'X>UųbLbQOSřb-qܼ0j~/>\[ӥeYQXX'gax[|`,?U8% giKsrinSTqt/X(,.KbaqLi*@=(/-_Y6xκ/MDDXX>!S6V:  9	3/1<OqX=;..'K%X{L`	B]!\-,+KE abivzJLȅ9N&
q
&(`߳S b8]\.Ӆ^Z&Ί$O-ϔ&	ŅBiQPwEe~5<\6^~QbCd£>K8P"=@Ft,d92ygK* )qN#N q
3%hiF&'%|g=๓D)jQ ڜX[9Ρt^KDlS E. _NɕE`-O 4K+l9>$ b'ĳ;](ͮ,j38%Zz Kр(MK+8Ya3%<^xap#5O}Z3?1l(
rvl,J90|fu&PR5PBߚW-UV)P'n-6֣~T+yOtIr=vMcmrg&5*IO3Uqvtk0HMy*AeV07}{l`nrĨP%Lե@Bd1T4j]))1BX90yyRgx-bCҔn!Lce UǵȏsyMZy];f.eHMu{tކHW JE1wL4?KV`sm(b׊Ǆ0U>auΉc\n6.Pj㘩W(LWMKuN-lg&LXcugzXa Mun<D)fa X=nN~	Io+cѫUU*uVT*$^ ݬ[ԫdq!\ar2äk\CrXrh4֮%(O~EEX|Ά=(
r,=S HI*R=8廀R
p]x"b6)rAFDt\>; xNzfUwľpH{^rih].I_c?'8>4zxt聃C?zgO[k݉O"9
Ĉy'g&g.L)S{_ŧ<D}lǉk1Elif8^_8n	YeJ3*r`#:b
A#SO~D=!?xwGy?1Ydǝc^Sm(3=s	.YMtJjہ;!o$LM4BoVt7 $ R|w yoT0Qߟ= >"	ߐĈ\)07wo^0S,XL/]n66{+#Փutdd}}=_aTǿ>*B%2yD3]`Zq-¾3:[S`\lϧ3]G~eSR$hNcpF(	̶K+?7S,WEyk2l\tĐ*Qn+sbUCC:ECD=\n93MKBŐ;by6mrҎETe/nm;=&^;AO3PX~,?.*e7cLxQ{e{d;7pu.q`+mvט5R)C}Q="	lxM9jj OՎ(ӗ2G8@&Xد<h_̉EY=du_{XI»e8~cc(EE 8%ت4Ώ$bGfo""􅪉$9$Xq*u,.YNQMlyϛ+Gs>9#/#<pA5ZT/\_nsL*x4yqРws~\&_cZBi[xZQ/Mwoxaɲu3-՛ԉ+Q6J~nmNs{hQP
Mw&S,XlT!݀nhgTa_ad귎PcxP%.̃Kˋ7N
E1),#N	s3KO%=ۑk]EVr]}rv(3eS:O*d0kfL?K/Iyk*H'iMx9mӫhn, mP{שl6L^'kNb"8Vwom,`H .@2n8uZ[G	'+5qT7C%׳u#@H?]סd
"HW̅ 9WcMCG0#M24:']<nFL92~ܴ]eD\) &eRmIǀ;02(CE22N43_]AAھz_9GL1	ԡVj@WR[CdJe6`WઙA5\Q>ڋ/}YU$c:=7~uv\f&ӯ	d	ˠ`ɸ3@Mı~ u}+@HhįVГĥjONvj?@u@W>P:-jk
&3ro*!Zˍrwmx9%-'Ib$+
|cCVkӬ%"&1p1^£`oWB|Q^U-n;~i4۽KBqg#~ܬWp?S<}_~7=_dēφ
n*R1=bH[MB=)c?c?:Z<sgt|и3zx(Ё~?3#w8?gyܞK@<ܺ7rHg8͗;#O9]Nx©'8gsזˎsD{wm:ο+_3;/pNԁ'7vomll9~gNgįtܾDp˦lp6~ܭOn:ם?ys	g#|s;~qĭl:/rqN8έ.;weƹ?{8l8Wv98΋\ݹlm9λ:sۖםƹ|ʹu۝~7_iCsagcksbos\Εo;vpٹl8xعv8O9nBӸ\{zlgm䶍'xm:/rbjc`9Oͫ[[[<wskϖ/ޫS|9ysysbnUgV.㎳qv]qNhΚHǉXw6#gw6*kbkKnl\;@(
޼Ysz->UOwx4ݺHrˉ7qΓ@X3=ܺm8S.P?93pݹe>zdܗ>ϿN/;^:~kb//}#''?g+}ϼH?N<{SKOGfk'xA/S~?'_=1;|U/07''ϼv|v_Zk;w<x%~ϼ+-O}o:/}gn-wykw\?ͿGO>w8]wS7_?|~uw}+|ׯչ[>s3̝Ͼ>җ~+$܋ϼ?IO?>}~~7~^ȁ;^|Ok3oR}KG7>޷=w|γ{W{~wbU[_z\W?;_~/kW?ӯȻϜ_Z}r󣏭]ai|aڨ>HL$A4bL&tB c~m|~Ӣ]S,~	sw[RJ}w$d@ixs=s={߽{瑇Gyo3O>|0xËأ߷-;׼ps]??ZBc_)?zZO^Sk-8m9=elWu<Q}ԓeߚ~٦_tTRb>mmß߹߼,,+<z!>~(ske/|'},M,eO[^\u_uO9,<񋆜^<+=x>_>wQ՟6\q:{4|SG:?;ho߫lc떼'Cڱm}UOoi7RqWn=|wC3gߴTڭ|}]g!1KK?%%8+xQR8sA_m!>rAH?dHV>Ut "?]9s39ol)7Ιn5NcRI4I>2Ny;Ep_|* i-~XjȒrysFrTGZjS)S>ϕ%Y(&ۖSZl
\@ٲ-YZ%mZ}E]dvEX{B3֨9M6\%i\ctY\Ņd~%䘖v,AcyW:)|.|S@?j)JqFUcD-fr_9Hn@
7pdg?NEjjg]5:Зh;̔YPLrv1;gO*rE'aj*Ig[!H7ۘ9nAHF#%ɍZ"udC΅-3T$w~0HOiڽH^O2A0;]훜dKoR?b#A	MHULb`AZBRlQhÝOx66ϰ/ζ!ө '3=w4~^A0
*$NDUQdN2(YI8&}F׬7knTⰤc1&7W*d)E$M#jIenԬk@,?5g%1OiS^x1O1?\=dLTnv0+EZ7ɘnfDw"0E^<z7`c_^ZV?//N8.KMX\ȓI8{R^@OZI:=(qi'+s@ :o`[-O +($	OS/r=n5}9=Z3TiW	?Z㣺$P X< ӅGM``?nlp;]HRM'HDTGOil,Dq]VB[?7uz"j͍+5$~/.9Uwx\WFɄ9?A]ooeIn[\n^F|̅YvZZP(@-"[C-EI%]' )տuFU7d-=0-TDRTNrmşiEL0H"
iLqjU֩P5e][j4|ܢ̔RL_C~YֈӞcϏd/\*KsLSߔ7e%r)Ｐ¢3bg1ϟ7)j>(uP矅Erz8e =glIyc0+3eMSߔge	;12*2J,Qe2b?6S?7K/;}WMuMk.P&2U#'!6# Ж`vjU'pX$/'	gt'4[ICyDxi+0R\)噈K4j8
]i0ބL|{w#AۂI6ovٸ=~~QFH2h_Lt~
\!3>4]sje 0&-\hÅ;KmE#2Fvi(pQX"6+V8"4*uQdE$[c#{,Gc&%Z_A5jC
Tz!JE
)bW	8&V<(䦫)KG(IRP7󍫯7_YW~3M&e#DVr2ǎ[ꌒAebߕjW<o*nfZc[4w'j -e[\^`S!*P0`F(jsSVT(ZB5&/vZfd-bN0..|Uu@wY s1 o=[cbYJ6o	"R%=ʁxp6CHԥF+AowvH`$N@ASM.D?(oB+)PR6:T45vD,[9,w 8'9,)ECo ϰi?jaruӅJ\U ̩Mb{t^7t	OA`GKZɵlA#yL(UuhsIVE%̔`W}js7t6KyystRstzs*;\6j)Nz )=S?#!v>1t=9uQHLRb4p&C&cgRBy34_6S.0|ր5b.Y)ΨrQKcvBknjind1,-CɬIs"'SQ2(KIߐhxz*__M}uN)w;yLoXߒbOYqbWy	µㅼF%n'lx3%	26nv"Ӌ5;}!xĠmZFgW}+ 38?6| 耩/)_V4FBqIkMjF<dNx(}{-!
>s&$#T0Ɖ9 ϬТl4JGZ:Gmf3zBgz8(+WS'eNZq>& `c<&/hH$nK*(I!Xj"_U	}L8׬]#0B	6u55w &N4m!~]º4~Yyjr?Ѵ6sSY䟭<#Hn%l~\pt.a-0X	TYا,Qd%A0Ջ"-vZ 5,a Cb~W!dVL߁^Mxt^ᰝE8Į1]֗Gf^)zu+lI^gEAl0Rൟd'g6Y#fe;L
 =\R~UKeZ/$eIPNK%F|ې+G\4x*)lYIJ
2 G;JhZ-jԪ'^77Vs
R`/r`r_iY^1;?զ4Ŧ	͡2K)Txm8kpg]"ZO_ǟ~<CE_x#Kz#{잙N CKy+2XiLfRz)CKӔXMFԞ\[GFFjBd`GsZht݆Ä;q1[tnȚl
@CH/#qm$C
t`@q^j4	P~wm_#٣cAu SFuX\G>У|* v.ȊvgGƮ/ӋxHOp#zd#( FfWbz28baj9[[1+Lwߔ5DHw#֐qvZaRI$\7pjDsĖޙ=,7Ee={tsm!eP[px 06P?X#2#[s"v=jڇQ&õ(zx9+CQe6~fјlK_*}җ} ˸ՖAXڥ
qh/Q*WL,h3dFke$e3E®^ %c֣Z0h6-M27VXMfCXl䢂Aby9kh2Qn\3w|	e g";vAJ|8@P,z
z
z
z
z
zNF=. J=HR]\8$aM|dDwX	;
;v0¦C8`ALUpIHMvZ3Cc340T3LЯ48msk98p|0Q9q 9TkN蕱Ǫ29BdlO^N/f rxc!㋧FFSrIE0X(xX$"0l㭽(OgzjK-$M7d.w@h
y 3"aW;R(^6m68be'2FrU1?ҔgיOI#fm&^{V"1G梴0d`%٥x8鉞zJȬ=V`بE5D\(tVEơY4OHYZZߚ:%mcfwȧo)%0˱{gN#ƀa\`Xm
m6^{lvzeNHmQ; k%%AlI"XP ѷAiҜ~)&HnH~`:ޏLY@$౜2trfAh/JtMBy3eyb" ,	]z	b~ +ԍI($`]]>NѶ7<ֻ"uoߢ55[f+(B4n-lmF QΞ"9wkE_-i\e5[ǉhAuR dL5L@G+coĞ	"2!+1H{dIb\Zb%eB:!iAg35Ҵ`-ʯBs 6NRa8eL23@ghXu3&M&8|/-<J87XI_K(cD4޵=@R92,^އ%zk^&.S$z7Q"';!ѻ'
]f߃t.K4/)[.nҤ:v![OH/Ku.'/x~UYw@/@o7diJP3|%<W}e'-M ߮{W?U/f\f3k6s~#GjC$z 6ӫBEu6d'> `3 <_5`"tݐxP.xal0l<٥RxvHaΐ³H82)%/R)|+/WHaU
WS"<9Jb")VcntŰ1u)b~RJFS ͜^f혾B1$w	69GRx<ЗcRE\).ذioJXE ~J
I#l 0xО<$	ޡ-/v8_͚ǩeagJ/&3Yx	Q%t	-RxH
3v)-)|L
$gå,<7[ea/U:${YxIDSyﵑ:7= YE5ݤdmۻk.ݜER 
Ɂo	xq3ߙ^ET0wfv7ߙݨOAP)ua{LIuyI$cLI~֔@$ԃ7M4+?%=E╗JݽaȚ$@pU ! sEDm`ʮiRBs|N/˘	BJ ӵwvdb/8!#+\U2a#293ru}Fߐ"_=wM|d'TpaxCmP-2+ƢKy!u2t^>L53"fͳ8#fmX8
Xl U<8|hЀ:888jUyCV񍠘lՁpk@K%-+Jsorseی;=bLw{zڂ.wͨK[Sap1.xvFjW|6mR`uw÷`gx(b;^5߹[#Kx!jwZ̎hB_t]'kH')VxD}\qQ|a_KO+]1ֿ<41R[ϑ:EH,rQ^Fo*ub?LR%MsWLR?D:ԉ:EϥH\_HVC~N+^_c64s&4_J6ݷU5l ;'&H*\sJ;AW`~D_L3=C{YW/_=5O\˰֓tz޳@qJkxV,)L>Ba?GUXo`vL=?Fp.(QxӌǱ>|K,2or+#'P"?A>:}0qhi)+10>_2Ha0m?`ߐ&|{_aϯ'83N.k?Ό_>XfRi^:%/K@ @ @ @ b @ **************FILE************ ./source/0.9.0.0/infra/gzstream/gzstream.h
// ============================================================================
// gzstream, C++ iostream classes wrapping the zlib compression library.
// Copyright (C) 2001  Deepak Bandyopadhyay, Lutz Kettner
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// ============================================================================
//
// File          : gzstream.h
// Revision      : $Revision: 1.5 $
// Revision_date : $Date: 2002/04/26 23:30:15 $
// Author(s)     : Deepak Bandyopadhyay, Lutz Kettner
// 
// Standard streambuf implementation following Nicolai Josuttis, "The 
// Standard C++ Library".
// ============================================================================

#ifndef GZSTREAM_H
#define GZSTREAM_H 1

// standard C++ with new header file names and std:: namespace
#include <iostream>
#include <fstream>
#include <zlib.h>

namespace infra {

// ----------------------------------------------------------------------------
// Internal classes to implement gzstream. See below for user classes.
// ----------------------------------------------------------------------------

class gzstreambuf : public std::streambuf {
private:
    static const int bufferSize = 47+256;    // size of data buff
    // totals 512 bytes under g++ for igzstream at the end.

    gzFile           file;               // file handle for compressed file
    char             buffer[bufferSize]; // data buffer
    char             opened;             // open/close state of stream
    int              mode;               // I/O mode

    int flush_buffer();
public:
    gzstreambuf() : opened(0) {
        setp( buffer, buffer + (bufferSize-1));
        setg( buffer + 4,     // beginning of putback area
              buffer + 4,     // read position
              buffer + 4);    // end position      
        // ASSERT: both input & output capabilities will not be used together
    }
    int is_open() { return opened; }
    gzstreambuf* open( const char* name, int open_mode);
    gzstreambuf* close();
    ~gzstreambuf() { close(); }
    
    virtual int     overflow( int c = EOF);
    virtual int     underflow();
    virtual int     sync();
};

class gzstreambase : virtual public std::ios {
protected:
    gzstreambuf buf;
public:
    gzstreambase() { init(&buf); }
    gzstreambase( const char* name, int open_mode);
    ~gzstreambase();
    void open( const char* name, int open_mode);
    void close();
    gzstreambuf* rdbuf() { return &buf; }
};

// ----------------------------------------------------------------------------
// User classes. Use igzstream and ogzstream analogously to ifstream and
// ofstream respectively. They read and write files based on the gz* 
// function interface of the zlib. Files are compatible with gzip compression.
// ----------------------------------------------------------------------------

class igzstream : public gzstreambase, public std::istream {
public:
    igzstream() : std::istream( &buf) {} 
    igzstream( const char* name, int open_mode = std::ios::in)
        : gzstreambase( name, open_mode), std::istream( &buf) {}  
    gzstreambuf* rdbuf() { return gzstreambase::rdbuf(); }
    void open( const char* name, int open_mode = std::ios::in) {
        gzstreambase::open( name, open_mode);
    }
};

class ogzstream : public gzstreambase, public std::ostream {
public:
    ogzstream() : std::ostream( &buf) {}
    ogzstream( const char* name, int mode = std::ios::out)
        : gzstreambase( name, mode), std::ostream( &buf) {}  
    gzstreambuf* rdbuf() { return gzstreambase::rdbuf(); }
    void open( const char* name, int open_mode = std::ios::out) {
        gzstreambase::open( name, open_mode);
    }
};

} // namespace infra 

#endif // GZSTREAM_H
// ============================================================================
// EOF //

**************FILE************ ./source/0.9.0.0/infra/gzstream/version
1.5 (08 Jan 2003)
**************FILE************ ./source/0.9.0.0/infra/gzstream/Makefile
# ============================================================================
# gzstream, C++ iostream classes wrapping the zlib compression library.
# Copyright (C) 2001  Deepak Bandyopadhyay, Lutz Kettner
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
# ============================================================================
# 
# File          : Makefile
# Revision      : $Revision: 1.3 $
# Revision_date : $Date: 2001/10/04 15:09:28 $
# Author(s)     : Deepak Bandyopadhyay, Lutz Kettner
# 
# ============================================================================

# ----------------------------------------------------------------------------
# adapt these settings to your need:
# add '-DGZSTREAM_NAMESPACE=name' to CPPFLAGS to place the classes
# in its own namespace. Note, this macro needs to be set while creating
# the library as well while compiling applications based on it.
# As an alternative, gzstream.cpp and gzstream.h can be edited.
# ----------------------------------------------------------------------------

# CXX      = CC -n32 -LANG:std   # for SGI Irix 6.5, MIPSpro CC version 7.30
CXX      = g++   # for Linux RedHat 6.1, g++ version 2.95.2

CPPFLAGS = -I. 
LDFLAGS  = -g -L. -lgzstream -lz
AR       = ar cr

# ----------------------------------------------------------------------------
# plain simple rules to make and cleanup the library:
# make default;   compiles the library
# make test;      compiles and executes test. O.K. message marks success.
# make clean;     removes temporary files
# make cleanall;  removes temporary files, the library, and programs
# ----------------------------------------------------------------------------

default: libgzstream.a

test:    test_gzip test_gunzip
	./test_gzip COPYING.LIB gz.tmp.gz
	gunzip gz.tmp.gz
	diff COPYING.LIB gz.tmp
	gzip gz.tmp
	./test_gunzip gz.tmp.gz gz.tmp
	diff COPYING.LIB gz.tmp
	rm gz.tmp.gz gz.tmp
	# *** O.K. Test finished successfully. ***

gzstream.o : gzstream.cpp gzstream.h
	${CXX} ${CPPFLAGS} -c -o gzstream.o gzstream.cpp

test_gzip.o : test_gzip.C gzstream.h
	${CXX} ${CPPFLAGS} -c -o test_gzip.o test_gzip.C

clariceFmt.o : clariceFmt.cpp gzstream.h
	${CXX} ${CPPFLAGS} -c -g -o clariceFmt.o clariceFmt.cpp

test_gunzip.o : test_gunzip.C gzstream.h
	${CXX} ${CPPFLAGS} -c -o test_gunzip.o test_gunzip.C

libgzstream.a : gzstream.o
	${AR} libgzstream.a gzstream.o

test_gzip : test_gzip.o libgzstream.a
	${CXX} -o test_gzip test_gzip.o ${LDFLAGS}

clariceFmt : clariceFmt.o libgzstream.a
	${CXX} -g -o clariceFmt clariceFmt.o ${LDFLAGS}

test_gunzip : test_gunzip.o libgzstream.a
	${CXX} -o test_gunzip test_gunzip.o ${LDFLAGS}

clean :
	rm *.o

cleanall :
	rm *.o libgzstream.a clariceFmt test_gzip test_gunzip

# ============================================================================
# EOF

**************FILE************ ./source/0.9.0.0/sources
INFRA_SOURCES= infra/logger/Logger.cpp\
	infra/thread/Thread.cpp\
	infra/lock/Lock.cpp\
	infra/judy/Judy.cpp\
	infra/pugixml/pugixml.cpp\
	infra/gzstream/gzstream.cpp\
	infra/socket/Socket.cpp\
	infra/utils/StringUtils.cpp

BASE_SOURCES= base/Book.cpp\
	base/PriceLevel.cpp\
	base/Order.cpp\
	base/MarketDataApplication.cpp\
	base/NetworkReader.cpp\
	base/Packet.cpp\
	base/FeedHandler.cpp\
	base/LineGroup.cpp\
	base/Line.cpp\
	base/API.cpp\
	base/BaseCommon.cpp\
	base/Trade.cpp\
	base/Status.cpp\
	base/Subscription.cpp\
	base/ProductInfo.cpp\
	base/Recorder.cpp

MILLENIUM_SOURCES= feeds/millenium/MilleniumFeedHandler.cpp\
	feeds/millenium/MilleniumLineGroup.cpp\
	feeds/millenium/MilleniumLine.cpp

OMXNORDIC_SOURCES= feeds/omxnordic/OMXNordicFeedHandler.cpp\
	feeds/omxnordic/OMXNordicLineGroup.cpp\
	feeds/omxnordic/OMXNordicLine.cpp\
	feeds/omxnordic/OMXNordicUtils.cpp

MDAPP_SOURCES= test/MDApp.cpp


**************FILE************ ./source/0.9.0.0/Makefile
.SUFFIXES: .o .cpp
include main.mk
include sources

INFRA_OBJECTS = ${INFRA_SOURCES:.cpp=.o}
INFRA_DEBUG_OBJECTS = ${INFRA_OBJECTS:%.o=${DEBUG_OBJ_DIR}/%.o}
INFRA_RELEASE_OBJECTS = ${INFRA_OBJECTS:%.o=${RELEASE_OBJ_DIR}/%.o}

CORE_OBJECTS = ${CORE_SOURCES:.cpp=.o}
CORE_DEBUG_OBJECTS = ${CORE_OBJECTS:%.o=${DEBUG_OBJ_DIR}/%.o}
CORE_RELEASE_OBJECTS = ${CORE_OBJECTS:%.o=${RELEASE_OBJ_DIR}/%.o}

BASE_OBJECTS = ${BASE_SOURCES:.cpp=.o}
BASE_DEBUG_OBJECTS = ${BASE_OBJECTS:%.o=${DEBUG_OBJ_DIR}/%.o}
BASE_RELEASE_OBJECTS = ${BASE_OBJECTS:%.o=${RELEASE_OBJ_DIR}/%.o}

MDAPP_OBJECTS = ${MDAPP_SOURCES:.cpp=.o}
MDAPP_DEBUG_OBJECTS = ${MDAPP_OBJECTS:%.o=${DEBUG_OBJ_DIR}/%.o}
MDAPP_RELEASE_OBJECTS= ${MDAPP_OBJECTS:%.o=${DEBUG_OBJ_DIR}/%.o}


MILLENIUM_OBJECTS = ${MILLENIUM_SOURCES:.cpp=.o}
MILLENIUM_DEBUG_OBJECTS = ${MILLENIUM_OBJECTS:%.o=${DEBUG_OBJ_DIR}/%.o}
MILLENIUM_RELEASE_OBJECTS = ${MILLENIUM_OBJECTS:%.o=${RELEASE_OBJ_DIR}/%.o}

OMXNORDIC_OBJECTS = ${OMXNORDIC_SOURCES:.cpp=.o}
OMXNORDIC_DEBUG_OBJECTS = ${OMXNORDIC_OBJECTS:%.o=${DEBUG_OBJ_DIR}/%.o}
OMXNORDIC_RELEASE_OBJECTS = ${OMXNORDIC_OBJECTS:%.o=${RELEASE_OBJ_DIR}/%.o}

$(DEBUG_OBJ_DIR)/%.o : %.cpp
	test -d $(dir $@) || mkdir -p $(dir $@)
	${CC} ${CFLAGS} ${CORE_USER_FLAGS} ${CORE_C_DEBUG_FLAGS} ${CD_INC_DIR} $< -o $@

$(RELEASE_OBJ_DIR)/%.o : %.cpp
	test -d $(dir $@) || mkdir -p $(dir $@)
	${CC} ${CFLAGS} ${CORE_USER_FLAGS} ${CORE_C_RELEASE_FLAGS} ${CD_INC_DIR} $< -o $@

infra-debug: ${INFRA_DEBUG_OBJECTS}
	${CC} -m${HOSTBITS} ${CORE_C_DEBUG_FLAGS} -shared -o ${DEBUG_OBJ_DIR}/libcd-infra-dbg.so ${INFRA_DEBUG_OBJECTS} ${CD_STD_LIBS}
	mkdir -p ${CD_LIB_DIR}
	mv ${DEBUG_OBJ_DIR}/*.so ${CD_LIB_DIR}
	ln -sf ${CD_LIB_DIR}/libcd-infra-dbg.so ${CD_LIB_DIR}/libcd-infra.so
    
infra-release: ${INFRA_RELEASE_OBJECTS}
	${CC}  -m${HOSTBITS} ${CORE_C_RELEASE_FLAGS} -shared -o ${RELEASE_OBJ_DIR}/libcd-infra-release.so ${INFRA_RELEASE_OBJECTS} ${CD_STD_LIBS} 
	mkdir -p ${CD_LIB_DIR}
	mv ${RELEASE_OBJ_DIR}/libcd-infra-release.so ${CD_LIB_DIR}
	ln -sf ${CD_LIB_DIR}/libcd-infra-release.so ${CD_LIB_DIR}/libcd-infra.so

base-debug: ${BASE_DEBUG_OBJECTS}
	${CC} -m${HOSTBITS} ${CORE_C_DEBUG_FLAGS} -shared -o ${DEBUG_OBJ_DIR}/libcd-base-dbg.so ${BASE_DEBUG_OBJECTS} ${CD_STD_LIBS} ${CD_BOOST_LIBS}
	mkdir -p ${CD_LIB_DIR}
	mv ${DEBUG_OBJ_DIR}/*.so ${CD_LIB_DIR}
	ln -sf ${CD_LIB_DIR}/libcd-base-dbg.so ${CD_LIB_DIR}/libcd-base.so
    
base-release: ${BASE_RELEASE_OBJECTS}
	${CC}  -m${HOSTBITS} ${CORE_C_RELEASE_FLAGS} -shared -o ${RELEASE_OBJ_DIR}/libcd-base-release.so ${BASE_RELEASE_OBJECTS} ${CD_STD_LIBS} ${CD_BOOST_LIBS} 
	mkdir -p ${CD_LIB_DIR}
	mv ${RELEASE_OBJ_DIR}/libcd-base-release.so ${CD_LIB_DIR}
	ln -sf ${CD_LIB_DIR}/libcd-base-release.so ${CD_LIB_DIR}/libcd-base.so

millenium-debug: ${MILLENIUM_DEBUG_OBJECTS}
	${CC} -m${HOSTBITS} ${CORE_C_DEBUG_FLAGS} -shared -o ${DEBUG_OBJ_DIR}/libcd-millenium-dbg.so ${MILLENIUM_DEBUG_OBJECTS} ${CD_STD_LIBS} 
	mkdir -p ${CD_LIB_DIR}
	mv ${DEBUG_OBJ_DIR}/*.so ${CD_LIB_DIR}
	ln -sf ${CD_LIB_DIR}/libcd-millenium-dbg.so ${CD_LIB_DIR}/libcd-millenium.so

millenium-release: ${MILLENIUM_RELEASE_OBJECTS}
	${CC}  -m${HOSTBITS} ${CORE_C_RELEASE_FLAGS} -shared -o ${RELEASE_OBJ_DIR}/libcd-millenium-release.so ${MILLENIUM_RELEASE_OBJECTS} ${CD_STD_LIBS} 
	mkdir -p ${CD_LIB_DIR}
	mv ${RELEASE_OBJ_DIR}/libcd-millenium-release.so ${CD_LIB_DIR}
	ln -sf ${CD_LIB_DIR}/libcd-millenium-release.so ${CD_LIB_DIR}/libcd-millenium.so

omxnordic-debug: ${OMXNORDIC_DEBUG_OBJECTS}
	${CC} -m${HOSTBITS} ${CORE_C_DEBUG_FLAGS} -shared -o ${DEBUG_OBJ_DIR}/libcd-omxnordic-dbg.so ${OMXNORDIC_DEBUG_OBJECTS} ${CD_STD_LIBS} 
	mkdir -p ${CD_LIB_DIR}
	mv ${DEBUG_OBJ_DIR}/*.so ${CD_LIB_DIR}
	ln -sf ${CD_LIB_DIR}/libcd-omxnordic-dbg.so ${CD_LIB_DIR}/libcd-omxnordic.so

omxnordic-release: ${OMXNORDIC_RELEASE_OBJECTS}
	${CC}  -m${HOSTBITS} ${CORE_C_RELEASE_FLAGS} -shared -o ${RELEASE_OBJ_DIR}/libcd-omxnordic-release.so ${OMXNORDIC_RELEASE_OBJECTS} ${CD_STD_LIBS} 
	mkdir -p ${CD_LIB_DIR}
	mv ${RELEASE_OBJ_DIR}/libcd-omxnordic-release.so ${CD_LIB_DIR}
	ln -sf ${CD_LIB_DIR}/libcd-omxnordic-release.so ${CD_LIB_DIR}/libcd-omxnordic.so

mdapp-debug:${MDAPP_DEBUG_OBJECTS}
	${CC} -m${HOSTBITS} -o $@ ${MDAPP_DEBUG_OBJECTS} -L${CD_LIB_DIR} ${CD_CORE_LIBS} ${CD_STD_LIBS} ${CD_BOOST_LIBS}
	mkdir -p ${CD_BIN_DIR}
	mv $@ ${CD_BIN_DIR}/

test:
	mdapp-debug mdapp-release

mdapp-release:${MDAPP_RELEASE_OBJECTS}
	${CC} -m${HOSTBITS} ${CORE_C_RELEASE_FLAGS} -o $@ ${MDAPP_RELEASE_OBJECTS} -L${CD_LIB_DIR} ${CD_CORE_LIBS} ${CD_STD_LIBS} ${CD_BOOST_LIBS} 
	mkdir -p ${CD_BIN_DIR}
	mv $@ ${CD_BIN_DIR}/

infra-clean:
	rm -rf ${INFRA_DEBUG_OBJECTS} ${INFRA_RELEASE_OBJECTS}

base-clean:
	rm -rf ${BASE_DEBUG_OBJECTS} ${BASE_RELEASE_OBJECTS}

millenium-clean:
	rm -rf ${MILLENIUM_DEBUG_OBJECTS} ${MILLENIUM_RELEASE_OBJECTS}

mdapp-clean:
	rm -rf ${CD_BIN_DIR}/mdapp

clean:
	rm -rf ${DEBUG_OBJ_DIR} ${RELEASE_OBJ_DIR} 

all-debug: clean infra-release  base-release millenium-release omxnordic-release mdapp-release 

all-release: clean infra-release  base-release millenium-release omxnordic-release mdapp-release 


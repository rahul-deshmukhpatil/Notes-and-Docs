move symantics
	possible to have uniq_ptr vector now
	uniq_ptr does not allow implicite move like auto_ptr, may be its move constr is explicit

rvalue ref
	int x = 1
	int& xl = x;
	int&& xr = x; // error, cant bind rvalue ref to lvalue
	int&& xr = int{2};

	void f(int& x)
	void f(int&& x)

	f(xl): int& x: 1
	f(xr): int& x: 2
	f(3): int&& x: 3
	f(std::move(x)): int&& x: 1


perfect fw or universal fw
	template<typename T>
	void f(T& );
	T& & becomes T&
	T& && becomes T&

	void f(T&& );
	T&& & becomes T&
	T&& && becomes T&&

	you cant bind rvalue ref to the lvalue:
		rvalue ref is permission to utilize the passed on object
	you cant bind the lvalue ref to the temp
		temp is going to automatically destroyed, 
			so if you bind it to lvalue 
				and return it to parent func or pass it on to further functions
			copy use its interval allocated resources
				they are going to automatically going to be destroyed

	int&& z = 0; // NOTE: `z` is an lvalue with type `int&&`.
	f(z); // T is int&, deduces as f(int& &&) => f(int&)
	f(std::move(z)); // T is int, deduces as f(int &&) => f(int&&)


inititalizer list
	int iter_and_sum(const std::initializer_list<int>& list)
	{
		return std::accumulate(list.begin(), list.end(), 0);
	}
	
	std::initializer_list<int> list = {1, 2, 3, 4, 5};
	iter_and_sum(list);


Variadic templates
	template<typename... Args>
	class A{
		public:
		static void size()
		{
			std::cout << sizeof...(Args) << std::endl;
		}
	};

	template<typename F, typename... Args>
	auto foo(const F f, const Args... args) -> decltype(f)
	{
		const auto list = std::initializer_list<F>{f, args...};
		return std::accumulate(list.begin(), list.end(), F{0});
	}

Static assertions
	with constexpr var or expresions

auto
	auto&& ir = i; // int &
	auto&& irr = 5; // int &&

	auto add(X x, Y y) -> decltype(x + y);


lambda
	its a implicit unnamed class object with
	1. ref capture : 
			are always non-cost ref
			but can be declared std::as_const
	2. value capture:
			are const data memebers
			unless lamda is mutable making all value capture non-const


	auto add10 = [i,&j = std::as_const(j)] () mutable -> decltype(i) {
		i += 10; // allowed because labmda is mutable
		j += 10; // Error: because j is a const-ref
		return j;
	}

decltype: with cv and ref qualification
	int i = 1;
	int& ilr = i;
	decltype(ilr) ir = ilr; // int&

	int&& j = 1;
	decltype(j) jrr = j; // int&&

type aliases
	template<typename T>
	using cache = std::map<int, T>;

nullptr:
	of type nullptr_t
	is not implicitely convertible to bool unlike 

	f(int)
	f(char *)
	
	f(NULL) // ambiguous
	f(nullptr); // calls f(int*)

Strongly-typed enums
	enum class Color : int32_t
	{
		INVALID = 0,
		RED = 1,
		MAX = std::numeric_limits<std::underlying_type<Color>>::max(),
	};


